/*
Binance Spot API

OpenAPI specification for Binance exchange - Spot API

API version: 0.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// StakingAPIService StakingAPI service
type StakingAPIService service

type ApiCreateEthStakingEthRedeemV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	amount *string
	timestamp *int64
	asset *string
	recvWindow *int64
}

func (r ApiCreateEthStakingEthRedeemV1Request) Amount(amount string) ApiCreateEthStakingEthRedeemV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateEthStakingEthRedeemV1Request) Timestamp(timestamp int64) ApiCreateEthStakingEthRedeemV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateEthStakingEthRedeemV1Request) Asset(asset string) ApiCreateEthStakingEthRedeemV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateEthStakingEthRedeemV1Request) RecvWindow(recvWindow int64) ApiCreateEthStakingEthRedeemV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateEthStakingEthRedeemV1Request) Execute() (*CreateEthStakingEthRedeemV1Resp, *http.Response, error) {
	return r.ApiService.CreateEthStakingEthRedeemV1Execute(r)
}

/*
CreateEthStakingEthRedeemV1 Redeem ETH(TRADE)

Redeem WBETH or BETH and get ETH

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEthStakingEthRedeemV1Request
*/
func (a *StakingAPIService) CreateEthStakingEthRedeemV1(ctx context.Context) ApiCreateEthStakingEthRedeemV1Request {
	return ApiCreateEthStakingEthRedeemV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateEthStakingEthRedeemV1Resp
func (a *StakingAPIService) CreateEthStakingEthRedeemV1Execute(r ApiCreateEthStakingEthRedeemV1Request) (*CreateEthStakingEthRedeemV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateEthStakingEthRedeemV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.CreateEthStakingEthRedeemV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/eth-staking/eth/redeem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEthStakingEthStakeV2Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	amount *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateEthStakingEthStakeV2Request) Amount(amount string) ApiCreateEthStakingEthStakeV2Request {
	r.amount = &amount
	return r
}

func (r ApiCreateEthStakingEthStakeV2Request) Timestamp(timestamp int64) ApiCreateEthStakingEthStakeV2Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateEthStakingEthStakeV2Request) RecvWindow(recvWindow int64) ApiCreateEthStakingEthStakeV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateEthStakingEthStakeV2Request) Execute() (*CreateEthStakingEthStakeV2Resp, *http.Response, error) {
	return r.ApiService.CreateEthStakingEthStakeV2Execute(r)
}

/*
CreateEthStakingEthStakeV2 Subscribe ETH Staking(TRADE)

Subscribe ETH Staking

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEthStakingEthStakeV2Request
*/
func (a *StakingAPIService) CreateEthStakingEthStakeV2(ctx context.Context) ApiCreateEthStakingEthStakeV2Request {
	return ApiCreateEthStakingEthStakeV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateEthStakingEthStakeV2Resp
func (a *StakingAPIService) CreateEthStakingEthStakeV2Execute(r ApiCreateEthStakingEthStakeV2Request) (*CreateEthStakingEthStakeV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateEthStakingEthStakeV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.CreateEthStakingEthStakeV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/eth-staking/eth/stake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEthStakingWbethWrapV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	amount *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateEthStakingWbethWrapV1Request) Amount(amount string) ApiCreateEthStakingWbethWrapV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateEthStakingWbethWrapV1Request) Timestamp(timestamp int64) ApiCreateEthStakingWbethWrapV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateEthStakingWbethWrapV1Request) RecvWindow(recvWindow int64) ApiCreateEthStakingWbethWrapV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateEthStakingWbethWrapV1Request) Execute() (*CreateEthStakingWbethWrapV1Resp, *http.Response, error) {
	return r.ApiService.CreateEthStakingWbethWrapV1Execute(r)
}

/*
CreateEthStakingWbethWrapV1 Wrap BETH(TRADE)

Wrap BETH

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEthStakingWbethWrapV1Request
*/
func (a *StakingAPIService) CreateEthStakingWbethWrapV1(ctx context.Context) ApiCreateEthStakingWbethWrapV1Request {
	return ApiCreateEthStakingWbethWrapV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateEthStakingWbethWrapV1Resp
func (a *StakingAPIService) CreateEthStakingWbethWrapV1Execute(r ApiCreateEthStakingWbethWrapV1Request) (*CreateEthStakingWbethWrapV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateEthStakingWbethWrapV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.CreateEthStakingWbethWrapV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/eth-staking/wbeth/wrap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSolStakingSolClaimV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSolStakingSolClaimV1Request) Timestamp(timestamp int64) ApiCreateSolStakingSolClaimV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSolStakingSolClaimV1Request) RecvWindow(recvWindow int64) ApiCreateSolStakingSolClaimV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSolStakingSolClaimV1Request) Execute() (*CreateSolStakingSolClaimV1Resp, *http.Response, error) {
	return r.ApiService.CreateSolStakingSolClaimV1Execute(r)
}

/*
CreateSolStakingSolClaimV1 Claim Boost Rewards(TRADE)

Claim Boost APR Airdrop Rewards

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSolStakingSolClaimV1Request
*/
func (a *StakingAPIService) CreateSolStakingSolClaimV1(ctx context.Context) ApiCreateSolStakingSolClaimV1Request {
	return ApiCreateSolStakingSolClaimV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSolStakingSolClaimV1Resp
func (a *StakingAPIService) CreateSolStakingSolClaimV1Execute(r ApiCreateSolStakingSolClaimV1Request) (*CreateSolStakingSolClaimV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSolStakingSolClaimV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.CreateSolStakingSolClaimV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/sol/claim"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSolStakingSolRedeemV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	amount *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSolStakingSolRedeemV1Request) Amount(amount string) ApiCreateSolStakingSolRedeemV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSolStakingSolRedeemV1Request) Timestamp(timestamp int64) ApiCreateSolStakingSolRedeemV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSolStakingSolRedeemV1Request) RecvWindow(recvWindow int64) ApiCreateSolStakingSolRedeemV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSolStakingSolRedeemV1Request) Execute() (*CreateSolStakingSolRedeemV1Resp, *http.Response, error) {
	return r.ApiService.CreateSolStakingSolRedeemV1Execute(r)
}

/*
CreateSolStakingSolRedeemV1 Redeem SOL(TRADE)

Redeem BNSOL get SOL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSolStakingSolRedeemV1Request
*/
func (a *StakingAPIService) CreateSolStakingSolRedeemV1(ctx context.Context) ApiCreateSolStakingSolRedeemV1Request {
	return ApiCreateSolStakingSolRedeemV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSolStakingSolRedeemV1Resp
func (a *StakingAPIService) CreateSolStakingSolRedeemV1Execute(r ApiCreateSolStakingSolRedeemV1Request) (*CreateSolStakingSolRedeemV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSolStakingSolRedeemV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.CreateSolStakingSolRedeemV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/sol/redeem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSolStakingSolStakeV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	amount *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSolStakingSolStakeV1Request) Amount(amount string) ApiCreateSolStakingSolStakeV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSolStakingSolStakeV1Request) Timestamp(timestamp int64) ApiCreateSolStakingSolStakeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSolStakingSolStakeV1Request) RecvWindow(recvWindow int64) ApiCreateSolStakingSolStakeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSolStakingSolStakeV1Request) Execute() (*CreateSolStakingSolStakeV1Resp, *http.Response, error) {
	return r.ApiService.CreateSolStakingSolStakeV1Execute(r)
}

/*
CreateSolStakingSolStakeV1 Subscribe SOL Staking(TRADE)

Subscribe SOL Staking

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSolStakingSolStakeV1Request
*/
func (a *StakingAPIService) CreateSolStakingSolStakeV1(ctx context.Context) ApiCreateSolStakingSolStakeV1Request {
	return ApiCreateSolStakingSolStakeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSolStakingSolStakeV1Resp
func (a *StakingAPIService) CreateSolStakingSolStakeV1Execute(r ApiCreateSolStakingSolStakeV1Request) (*CreateSolStakingSolStakeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSolStakingSolStakeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.CreateSolStakingSolStakeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/sol/stake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthStakingAccountV2Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetEthStakingAccountV2Request) Timestamp(timestamp int64) ApiGetEthStakingAccountV2Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetEthStakingAccountV2Request) RecvWindow(recvWindow int64) ApiGetEthStakingAccountV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetEthStakingAccountV2Request) Execute() (*GetEthStakingAccountV2Resp, *http.Response, error) {
	return r.ApiService.GetEthStakingAccountV2Execute(r)
}

/*
GetEthStakingAccountV2 ETH Staking account(USER_DATA)

ETH Staking account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthStakingAccountV2Request
*/
func (a *StakingAPIService) GetEthStakingAccountV2(ctx context.Context) ApiGetEthStakingAccountV2Request {
	return ApiGetEthStakingAccountV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEthStakingAccountV2Resp
func (a *StakingAPIService) GetEthStakingAccountV2Execute(r ApiGetEthStakingAccountV2Request) (*GetEthStakingAccountV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEthStakingAccountV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetEthStakingAccountV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/eth-staking/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthStakingEthHistoryRateHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetEthStakingEthHistoryRateHistoryV1Request) Timestamp(timestamp int64) ApiGetEthStakingEthHistoryRateHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetEthStakingEthHistoryRateHistoryV1Request) StartTime(startTime int64) ApiGetEthStakingEthHistoryRateHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetEthStakingEthHistoryRateHistoryV1Request) EndTime(endTime int64) ApiGetEthStakingEthHistoryRateHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiGetEthStakingEthHistoryRateHistoryV1Request) Current(current int64) ApiGetEthStakingEthHistoryRateHistoryV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetEthStakingEthHistoryRateHistoryV1Request) Size(size int64) ApiGetEthStakingEthHistoryRateHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetEthStakingEthHistoryRateHistoryV1Request) RecvWindow(recvWindow int64) ApiGetEthStakingEthHistoryRateHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetEthStakingEthHistoryRateHistoryV1Request) Execute() (*GetEthStakingEthHistoryRateHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetEthStakingEthHistoryRateHistoryV1Execute(r)
}

/*
GetEthStakingEthHistoryRateHistoryV1 Get WBETH Rate History(USER_DATA)

Get WBETH Rate History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthStakingEthHistoryRateHistoryV1Request
*/
func (a *StakingAPIService) GetEthStakingEthHistoryRateHistoryV1(ctx context.Context) ApiGetEthStakingEthHistoryRateHistoryV1Request {
	return ApiGetEthStakingEthHistoryRateHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEthStakingEthHistoryRateHistoryV1Resp
func (a *StakingAPIService) GetEthStakingEthHistoryRateHistoryV1Execute(r ApiGetEthStakingEthHistoryRateHistoryV1Request) (*GetEthStakingEthHistoryRateHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEthStakingEthHistoryRateHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetEthStakingEthHistoryRateHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/eth-staking/eth/history/rateHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthStakingEthHistoryRedemptionHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetEthStakingEthHistoryRedemptionHistoryV1Request) Timestamp(timestamp int64) ApiGetEthStakingEthHistoryRedemptionHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetEthStakingEthHistoryRedemptionHistoryV1Request) StartTime(startTime int64) ApiGetEthStakingEthHistoryRedemptionHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetEthStakingEthHistoryRedemptionHistoryV1Request) EndTime(endTime int64) ApiGetEthStakingEthHistoryRedemptionHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default: 1
func (r ApiGetEthStakingEthHistoryRedemptionHistoryV1Request) Current(current int64) ApiGetEthStakingEthHistoryRedemptionHistoryV1Request {
	r.current = &current
	return r
}

// Default: 10, Max: 100
func (r ApiGetEthStakingEthHistoryRedemptionHistoryV1Request) Size(size int64) ApiGetEthStakingEthHistoryRedemptionHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetEthStakingEthHistoryRedemptionHistoryV1Request) RecvWindow(recvWindow int64) ApiGetEthStakingEthHistoryRedemptionHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetEthStakingEthHistoryRedemptionHistoryV1Request) Execute() (*GetEthStakingEthHistoryRedemptionHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetEthStakingEthHistoryRedemptionHistoryV1Execute(r)
}

/*
GetEthStakingEthHistoryRedemptionHistoryV1 Get ETH redemption history(USER_DATA)

Get ETH redemption history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthStakingEthHistoryRedemptionHistoryV1Request
*/
func (a *StakingAPIService) GetEthStakingEthHistoryRedemptionHistoryV1(ctx context.Context) ApiGetEthStakingEthHistoryRedemptionHistoryV1Request {
	return ApiGetEthStakingEthHistoryRedemptionHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEthStakingEthHistoryRedemptionHistoryV1Resp
func (a *StakingAPIService) GetEthStakingEthHistoryRedemptionHistoryV1Execute(r ApiGetEthStakingEthHistoryRedemptionHistoryV1Request) (*GetEthStakingEthHistoryRedemptionHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEthStakingEthHistoryRedemptionHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetEthStakingEthHistoryRedemptionHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/eth-staking/eth/history/redemptionHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int64 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthStakingEthHistoryRewardsHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetEthStakingEthHistoryRewardsHistoryV1Request) Timestamp(timestamp int64) ApiGetEthStakingEthHistoryRewardsHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetEthStakingEthHistoryRewardsHistoryV1Request) StartTime(startTime int64) ApiGetEthStakingEthHistoryRewardsHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetEthStakingEthHistoryRewardsHistoryV1Request) EndTime(endTime int64) ApiGetEthStakingEthHistoryRewardsHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default: 1
func (r ApiGetEthStakingEthHistoryRewardsHistoryV1Request) Current(current int64) ApiGetEthStakingEthHistoryRewardsHistoryV1Request {
	r.current = &current
	return r
}

// Default: 10, Max: 100
func (r ApiGetEthStakingEthHistoryRewardsHistoryV1Request) Size(size int64) ApiGetEthStakingEthHistoryRewardsHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetEthStakingEthHistoryRewardsHistoryV1Request) RecvWindow(recvWindow int64) ApiGetEthStakingEthHistoryRewardsHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetEthStakingEthHistoryRewardsHistoryV1Request) Execute() (*GetEthStakingEthHistoryRewardsHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetEthStakingEthHistoryRewardsHistoryV1Execute(r)
}

/*
GetEthStakingEthHistoryRewardsHistoryV1 Get BETH rewards distribution history(USER_DATA)

Get BETH rewards distribution history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthStakingEthHistoryRewardsHistoryV1Request
*/
func (a *StakingAPIService) GetEthStakingEthHistoryRewardsHistoryV1(ctx context.Context) ApiGetEthStakingEthHistoryRewardsHistoryV1Request {
	return ApiGetEthStakingEthHistoryRewardsHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEthStakingEthHistoryRewardsHistoryV1Resp
func (a *StakingAPIService) GetEthStakingEthHistoryRewardsHistoryV1Execute(r ApiGetEthStakingEthHistoryRewardsHistoryV1Request) (*GetEthStakingEthHistoryRewardsHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEthStakingEthHistoryRewardsHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetEthStakingEthHistoryRewardsHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/eth-staking/eth/history/rewardsHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int64 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthStakingEthHistoryStakingHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetEthStakingEthHistoryStakingHistoryV1Request) Timestamp(timestamp int64) ApiGetEthStakingEthHistoryStakingHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetEthStakingEthHistoryStakingHistoryV1Request) StartTime(startTime int64) ApiGetEthStakingEthHistoryStakingHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetEthStakingEthHistoryStakingHistoryV1Request) EndTime(endTime int64) ApiGetEthStakingEthHistoryStakingHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default: 1
func (r ApiGetEthStakingEthHistoryStakingHistoryV1Request) Current(current int64) ApiGetEthStakingEthHistoryStakingHistoryV1Request {
	r.current = &current
	return r
}

// Default: 10, Max: 100
func (r ApiGetEthStakingEthHistoryStakingHistoryV1Request) Size(size int64) ApiGetEthStakingEthHistoryStakingHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetEthStakingEthHistoryStakingHistoryV1Request) RecvWindow(recvWindow int64) ApiGetEthStakingEthHistoryStakingHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetEthStakingEthHistoryStakingHistoryV1Request) Execute() (*GetEthStakingEthHistoryStakingHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetEthStakingEthHistoryStakingHistoryV1Execute(r)
}

/*
GetEthStakingEthHistoryStakingHistoryV1 Get ETH staking history(USER_DATA)

Get ETH staking history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthStakingEthHistoryStakingHistoryV1Request
*/
func (a *StakingAPIService) GetEthStakingEthHistoryStakingHistoryV1(ctx context.Context) ApiGetEthStakingEthHistoryStakingHistoryV1Request {
	return ApiGetEthStakingEthHistoryStakingHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEthStakingEthHistoryStakingHistoryV1Resp
func (a *StakingAPIService) GetEthStakingEthHistoryStakingHistoryV1Execute(r ApiGetEthStakingEthHistoryStakingHistoryV1Request) (*GetEthStakingEthHistoryStakingHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEthStakingEthHistoryStakingHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetEthStakingEthHistoryStakingHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/eth-staking/eth/history/stakingHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int64 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request) Timestamp(timestamp int64) ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request) StartTime(startTime int64) ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request) EndTime(endTime int64) ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default: 1
func (r ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request) Current(current int64) ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request {
	r.current = &current
	return r
}

// Default: 10, Max: 100
func (r ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request) Size(size int64) ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request) RecvWindow(recvWindow int64) ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request) Execute() (*GetEthStakingEthHistoryWbethRewardsHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetEthStakingEthHistoryWbethRewardsHistoryV1Execute(r)
}

/*
GetEthStakingEthHistoryWbethRewardsHistoryV1 Get WBETH rewards history(USER_DATA)

Get WBETH rewards history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request
*/
func (a *StakingAPIService) GetEthStakingEthHistoryWbethRewardsHistoryV1(ctx context.Context) ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request {
	return ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEthStakingEthHistoryWbethRewardsHistoryV1Resp
func (a *StakingAPIService) GetEthStakingEthHistoryWbethRewardsHistoryV1Execute(r ApiGetEthStakingEthHistoryWbethRewardsHistoryV1Request) (*GetEthStakingEthHistoryWbethRewardsHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEthStakingEthHistoryWbethRewardsHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetEthStakingEthHistoryWbethRewardsHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/eth-staking/eth/history/wbethRewardsHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int64 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthStakingEthQuotaV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetEthStakingEthQuotaV1Request) Timestamp(timestamp int64) ApiGetEthStakingEthQuotaV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetEthStakingEthQuotaV1Request) RecvWindow(recvWindow int64) ApiGetEthStakingEthQuotaV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetEthStakingEthQuotaV1Request) Execute() (*GetEthStakingEthQuotaV1Resp, *http.Response, error) {
	return r.ApiService.GetEthStakingEthQuotaV1Execute(r)
}

/*
GetEthStakingEthQuotaV1 Get current ETH staking quota(USER_DATA)

Get current ETH staking quota

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthStakingEthQuotaV1Request
*/
func (a *StakingAPIService) GetEthStakingEthQuotaV1(ctx context.Context) ApiGetEthStakingEthQuotaV1Request {
	return ApiGetEthStakingEthQuotaV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEthStakingEthQuotaV1Resp
func (a *StakingAPIService) GetEthStakingEthQuotaV1Execute(r ApiGetEthStakingEthQuotaV1Request) (*GetEthStakingEthQuotaV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEthStakingEthQuotaV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetEthStakingEthQuotaV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/eth-staking/eth/quota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request) Timestamp(timestamp int64) ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request) StartTime(startTime int64) ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request) EndTime(endTime int64) ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request) Current(current int64) ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request) Size(size int64) ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request) RecvWindow(recvWindow int64) ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request) Execute() (*GetEthStakingWbethHistoryUnwrapHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetEthStakingWbethHistoryUnwrapHistoryV1Execute(r)
}

/*
GetEthStakingWbethHistoryUnwrapHistoryV1 Get WBETH unwrap history(USER_DATA)

Get WBETH unwrap history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request
*/
func (a *StakingAPIService) GetEthStakingWbethHistoryUnwrapHistoryV1(ctx context.Context) ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request {
	return ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEthStakingWbethHistoryUnwrapHistoryV1Resp
func (a *StakingAPIService) GetEthStakingWbethHistoryUnwrapHistoryV1Execute(r ApiGetEthStakingWbethHistoryUnwrapHistoryV1Request) (*GetEthStakingWbethHistoryUnwrapHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEthStakingWbethHistoryUnwrapHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetEthStakingWbethHistoryUnwrapHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/eth-staking/wbeth/history/unwrapHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEthStakingWbethHistoryWrapHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetEthStakingWbethHistoryWrapHistoryV1Request) Timestamp(timestamp int64) ApiGetEthStakingWbethHistoryWrapHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetEthStakingWbethHistoryWrapHistoryV1Request) StartTime(startTime int64) ApiGetEthStakingWbethHistoryWrapHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetEthStakingWbethHistoryWrapHistoryV1Request) EndTime(endTime int64) ApiGetEthStakingWbethHistoryWrapHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiGetEthStakingWbethHistoryWrapHistoryV1Request) Current(current int64) ApiGetEthStakingWbethHistoryWrapHistoryV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetEthStakingWbethHistoryWrapHistoryV1Request) Size(size int64) ApiGetEthStakingWbethHistoryWrapHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetEthStakingWbethHistoryWrapHistoryV1Request) RecvWindow(recvWindow int64) ApiGetEthStakingWbethHistoryWrapHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetEthStakingWbethHistoryWrapHistoryV1Request) Execute() (*GetEthStakingWbethHistoryWrapHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetEthStakingWbethHistoryWrapHistoryV1Execute(r)
}

/*
GetEthStakingWbethHistoryWrapHistoryV1 Get WBETH wrap history(USER_DATA)

Get WBETH wrap history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthStakingWbethHistoryWrapHistoryV1Request
*/
func (a *StakingAPIService) GetEthStakingWbethHistoryWrapHistoryV1(ctx context.Context) ApiGetEthStakingWbethHistoryWrapHistoryV1Request {
	return ApiGetEthStakingWbethHistoryWrapHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEthStakingWbethHistoryWrapHistoryV1Resp
func (a *StakingAPIService) GetEthStakingWbethHistoryWrapHistoryV1Execute(r ApiGetEthStakingWbethHistoryWrapHistoryV1Request) (*GetEthStakingWbethHistoryWrapHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEthStakingWbethHistoryWrapHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetEthStakingWbethHistoryWrapHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/eth-staking/wbeth/history/wrapHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSolStakingAccountV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetSolStakingAccountV1Request) Timestamp(timestamp int64) ApiGetSolStakingAccountV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than 60000
func (r ApiGetSolStakingAccountV1Request) RecvWindow(recvWindow int64) ApiGetSolStakingAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSolStakingAccountV1Request) Execute() (*GetSolStakingAccountV1Resp, *http.Response, error) {
	return r.ApiService.GetSolStakingAccountV1Execute(r)
}

/*
GetSolStakingAccountV1 SOL Staking account(USER_DATA)

SOL Staking account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolStakingAccountV1Request
*/
func (a *StakingAPIService) GetSolStakingAccountV1(ctx context.Context) ApiGetSolStakingAccountV1Request {
	return ApiGetSolStakingAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSolStakingAccountV1Resp
func (a *StakingAPIService) GetSolStakingAccountV1Execute(r ApiGetSolStakingAccountV1Request) (*GetSolStakingAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSolStakingAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetSolStakingAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request) Timestamp(timestamp int64) ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request) StartTime(startTime int64) ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request) EndTime(endTime int64) ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default: 1
func (r ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request) Current(current int64) ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request {
	r.current = &current
	return r
}

// Default: 10, Max: 100
func (r ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request) Size(size int64) ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request) RecvWindow(recvWindow int64) ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request) Execute() (*GetSolStakingSolHistoryBnsolRewardsHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetSolStakingSolHistoryBnsolRewardsHistoryV1Execute(r)
}

/*
GetSolStakingSolHistoryBnsolRewardsHistoryV1 Get BNSOL rewards history(USER_DATA)

Get BNSOL rewards history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request
*/
func (a *StakingAPIService) GetSolStakingSolHistoryBnsolRewardsHistoryV1(ctx context.Context) ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request {
	return ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSolStakingSolHistoryBnsolRewardsHistoryV1Resp
func (a *StakingAPIService) GetSolStakingSolHistoryBnsolRewardsHistoryV1Execute(r ApiGetSolStakingSolHistoryBnsolRewardsHistoryV1Request) (*GetSolStakingSolHistoryBnsolRewardsHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSolStakingSolHistoryBnsolRewardsHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetSolStakingSolHistoryBnsolRewardsHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/sol/history/bnsolRewardsHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int64 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	type_ *string
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

// &amp;#34;CLAIM&amp;#34;, &amp;#34;DISTRIBUTE&amp;#34;, default &amp;#34;CLAIM&amp;#34;
func (r ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request) Type_(type_ string) ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request) Timestamp(timestamp int64) ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request) StartTime(startTime int64) ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request) EndTime(endTime int64) ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default: 1
func (r ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request) Current(current int64) ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request {
	r.current = &current
	return r
}

// Default: 10, Max: 100
func (r ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request) Size(size int64) ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request) RecvWindow(recvWindow int64) ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request) Execute() (*GetSolStakingSolHistoryBoostRewardsHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetSolStakingSolHistoryBoostRewardsHistoryV1Execute(r)
}

/*
GetSolStakingSolHistoryBoostRewardsHistoryV1 Get Boost Rewards History(USER_DATA)

Get Boost rewards history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request
*/
func (a *StakingAPIService) GetSolStakingSolHistoryBoostRewardsHistoryV1(ctx context.Context) ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request {
	return ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSolStakingSolHistoryBoostRewardsHistoryV1Resp
func (a *StakingAPIService) GetSolStakingSolHistoryBoostRewardsHistoryV1Execute(r ApiGetSolStakingSolHistoryBoostRewardsHistoryV1Request) (*GetSolStakingSolHistoryBoostRewardsHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSolStakingSolHistoryBoostRewardsHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetSolStakingSolHistoryBoostRewardsHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/sol/history/boostRewardsHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int64 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSolStakingSolHistoryRateHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSolStakingSolHistoryRateHistoryV1Request) Timestamp(timestamp int64) ApiGetSolStakingSolHistoryRateHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSolStakingSolHistoryRateHistoryV1Request) StartTime(startTime int64) ApiGetSolStakingSolHistoryRateHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSolStakingSolHistoryRateHistoryV1Request) EndTime(endTime int64) ApiGetSolStakingSolHistoryRateHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiGetSolStakingSolHistoryRateHistoryV1Request) Current(current int64) ApiGetSolStakingSolHistoryRateHistoryV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSolStakingSolHistoryRateHistoryV1Request) Size(size int64) ApiGetSolStakingSolHistoryRateHistoryV1Request {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiGetSolStakingSolHistoryRateHistoryV1Request) RecvWindow(recvWindow int64) ApiGetSolStakingSolHistoryRateHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSolStakingSolHistoryRateHistoryV1Request) Execute() (*GetSolStakingSolHistoryRateHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetSolStakingSolHistoryRateHistoryV1Execute(r)
}

/*
GetSolStakingSolHistoryRateHistoryV1 Get BNSOL Rate History(USER_DATA)

Get BNSOL Rate History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolStakingSolHistoryRateHistoryV1Request
*/
func (a *StakingAPIService) GetSolStakingSolHistoryRateHistoryV1(ctx context.Context) ApiGetSolStakingSolHistoryRateHistoryV1Request {
	return ApiGetSolStakingSolHistoryRateHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSolStakingSolHistoryRateHistoryV1Resp
func (a *StakingAPIService) GetSolStakingSolHistoryRateHistoryV1Execute(r ApiGetSolStakingSolHistoryRateHistoryV1Request) (*GetSolStakingSolHistoryRateHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSolStakingSolHistoryRateHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetSolStakingSolHistoryRateHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/sol/history/rateHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSolStakingSolHistoryRedemptionHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSolStakingSolHistoryRedemptionHistoryV1Request) Timestamp(timestamp int64) ApiGetSolStakingSolHistoryRedemptionHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSolStakingSolHistoryRedemptionHistoryV1Request) StartTime(startTime int64) ApiGetSolStakingSolHistoryRedemptionHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSolStakingSolHistoryRedemptionHistoryV1Request) EndTime(endTime int64) ApiGetSolStakingSolHistoryRedemptionHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default: 1
func (r ApiGetSolStakingSolHistoryRedemptionHistoryV1Request) Current(current int64) ApiGetSolStakingSolHistoryRedemptionHistoryV1Request {
	r.current = &current
	return r
}

// Default: 10, Max: 100
func (r ApiGetSolStakingSolHistoryRedemptionHistoryV1Request) Size(size int64) ApiGetSolStakingSolHistoryRedemptionHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetSolStakingSolHistoryRedemptionHistoryV1Request) RecvWindow(recvWindow int64) ApiGetSolStakingSolHistoryRedemptionHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSolStakingSolHistoryRedemptionHistoryV1Request) Execute() (*GetSolStakingSolHistoryRedemptionHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetSolStakingSolHistoryRedemptionHistoryV1Execute(r)
}

/*
GetSolStakingSolHistoryRedemptionHistoryV1 Get SOL redemption history(USER_DATA)

Get SOL redemption history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolStakingSolHistoryRedemptionHistoryV1Request
*/
func (a *StakingAPIService) GetSolStakingSolHistoryRedemptionHistoryV1(ctx context.Context) ApiGetSolStakingSolHistoryRedemptionHistoryV1Request {
	return ApiGetSolStakingSolHistoryRedemptionHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSolStakingSolHistoryRedemptionHistoryV1Resp
func (a *StakingAPIService) GetSolStakingSolHistoryRedemptionHistoryV1Execute(r ApiGetSolStakingSolHistoryRedemptionHistoryV1Request) (*GetSolStakingSolHistoryRedemptionHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSolStakingSolHistoryRedemptionHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetSolStakingSolHistoryRedemptionHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/sol/history/redemptionHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int64 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSolStakingSolHistoryStakingHistoryV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSolStakingSolHistoryStakingHistoryV1Request) Timestamp(timestamp int64) ApiGetSolStakingSolHistoryStakingHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSolStakingSolHistoryStakingHistoryV1Request) StartTime(startTime int64) ApiGetSolStakingSolHistoryStakingHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSolStakingSolHistoryStakingHistoryV1Request) EndTime(endTime int64) ApiGetSolStakingSolHistoryStakingHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default: 1
func (r ApiGetSolStakingSolHistoryStakingHistoryV1Request) Current(current int64) ApiGetSolStakingSolHistoryStakingHistoryV1Request {
	r.current = &current
	return r
}

// Default: 10, Max: 100
func (r ApiGetSolStakingSolHistoryStakingHistoryV1Request) Size(size int64) ApiGetSolStakingSolHistoryStakingHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetSolStakingSolHistoryStakingHistoryV1Request) RecvWindow(recvWindow int64) ApiGetSolStakingSolHistoryStakingHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSolStakingSolHistoryStakingHistoryV1Request) Execute() (*GetSolStakingSolHistoryStakingHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetSolStakingSolHistoryStakingHistoryV1Execute(r)
}

/*
GetSolStakingSolHistoryStakingHistoryV1 Get SOL staking history(USER_DATA)

Get SOL staking history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolStakingSolHistoryStakingHistoryV1Request
*/
func (a *StakingAPIService) GetSolStakingSolHistoryStakingHistoryV1(ctx context.Context) ApiGetSolStakingSolHistoryStakingHistoryV1Request {
	return ApiGetSolStakingSolHistoryStakingHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSolStakingSolHistoryStakingHistoryV1Resp
func (a *StakingAPIService) GetSolStakingSolHistoryStakingHistoryV1Execute(r ApiGetSolStakingSolHistoryStakingHistoryV1Request) (*GetSolStakingSolHistoryStakingHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSolStakingSolHistoryStakingHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetSolStakingSolHistoryStakingHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/sol/history/stakingHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int64 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSolStakingSolHistoryUnclaimedRewardsV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetSolStakingSolHistoryUnclaimedRewardsV1Request) Timestamp(timestamp int64) ApiGetSolStakingSolHistoryUnclaimedRewardsV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSolStakingSolHistoryUnclaimedRewardsV1Request) RecvWindow(recvWindow int64) ApiGetSolStakingSolHistoryUnclaimedRewardsV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSolStakingSolHistoryUnclaimedRewardsV1Request) Execute() ([]GetSolStakingSolHistoryUnclaimedRewardsV1RespItem, *http.Response, error) {
	return r.ApiService.GetSolStakingSolHistoryUnclaimedRewardsV1Execute(r)
}

/*
GetSolStakingSolHistoryUnclaimedRewardsV1 Get Unclaimed Rewards(USER_DATA)

Get Unclaimed rewards

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolStakingSolHistoryUnclaimedRewardsV1Request
*/
func (a *StakingAPIService) GetSolStakingSolHistoryUnclaimedRewardsV1(ctx context.Context) ApiGetSolStakingSolHistoryUnclaimedRewardsV1Request {
	return ApiGetSolStakingSolHistoryUnclaimedRewardsV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetSolStakingSolHistoryUnclaimedRewardsV1RespItem
func (a *StakingAPIService) GetSolStakingSolHistoryUnclaimedRewardsV1Execute(r ApiGetSolStakingSolHistoryUnclaimedRewardsV1Request) ([]GetSolStakingSolHistoryUnclaimedRewardsV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetSolStakingSolHistoryUnclaimedRewardsV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetSolStakingSolHistoryUnclaimedRewardsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/sol/history/unclaimedRewards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSolStakingSolQuotaV1Request struct {
	ctx context.Context
	ApiService *StakingAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetSolStakingSolQuotaV1Request) Timestamp(timestamp int64) ApiGetSolStakingSolQuotaV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than 60000
func (r ApiGetSolStakingSolQuotaV1Request) RecvWindow(recvWindow int64) ApiGetSolStakingSolQuotaV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSolStakingSolQuotaV1Request) Execute() (*GetSolStakingSolQuotaV1Resp, *http.Response, error) {
	return r.ApiService.GetSolStakingSolQuotaV1Execute(r)
}

/*
GetSolStakingSolQuotaV1 Get SOL staking quota details(USER_DATA)

Get SOL staking quota

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolStakingSolQuotaV1Request
*/
func (a *StakingAPIService) GetSolStakingSolQuotaV1(ctx context.Context) ApiGetSolStakingSolQuotaV1Request {
	return ApiGetSolStakingSolQuotaV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSolStakingSolQuotaV1Resp
func (a *StakingAPIService) GetSolStakingSolQuotaV1Execute(r ApiGetSolStakingSolQuotaV1Request) (*GetSolStakingSolQuotaV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSolStakingSolQuotaV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StakingAPIService.GetSolStakingSolQuotaV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sol-staking/sol/quota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Binance Spot API

OpenAPI specification for Binance exchange - Spot API

API version: 0.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// DualInvestmentAPIService DualInvestmentAPI service
type DualInvestmentAPIService service

type ApiCreateDciProductAutoCompoundEditStatusV1Request struct {
	ctx context.Context
	ApiService *DualInvestmentAPIService
	positionId *string
	timestamp *int64
	autoCompoundPlan *string
	recvWindow *int64
}

func (r ApiCreateDciProductAutoCompoundEditStatusV1Request) PositionId(positionId string) ApiCreateDciProductAutoCompoundEditStatusV1Request {
	r.positionId = &positionId
	return r
}

func (r ApiCreateDciProductAutoCompoundEditStatusV1Request) Timestamp(timestamp int64) ApiCreateDciProductAutoCompoundEditStatusV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateDciProductAutoCompoundEditStatusV1Request) AutoCompoundPlan(autoCompoundPlan string) ApiCreateDciProductAutoCompoundEditStatusV1Request {
	r.autoCompoundPlan = &autoCompoundPlan
	return r
}

func (r ApiCreateDciProductAutoCompoundEditStatusV1Request) RecvWindow(recvWindow int64) ApiCreateDciProductAutoCompoundEditStatusV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateDciProductAutoCompoundEditStatusV1Request) Execute() (*CreateDciProductAutoCompoundEditStatusV1Resp, *http.Response, error) {
	return r.ApiService.CreateDciProductAutoCompoundEditStatusV1Execute(r)
}

/*
CreateDciProductAutoCompoundEditStatusV1 Change Auto-Compound status(USER_DATA)

Change Auto-Compound status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDciProductAutoCompoundEditStatusV1Request
*/
func (a *DualInvestmentAPIService) CreateDciProductAutoCompoundEditStatusV1(ctx context.Context) ApiCreateDciProductAutoCompoundEditStatusV1Request {
	return ApiCreateDciProductAutoCompoundEditStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateDciProductAutoCompoundEditStatusV1Resp
func (a *DualInvestmentAPIService) CreateDciProductAutoCompoundEditStatusV1Execute(r ApiCreateDciProductAutoCompoundEditStatusV1Request) (*CreateDciProductAutoCompoundEditStatusV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateDciProductAutoCompoundEditStatusV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DualInvestmentAPIService.CreateDciProductAutoCompoundEditStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/dci/product/auto_compound/edit-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.positionId == nil {
		return localVarReturnValue, nil, reportError("positionId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoCompoundPlan != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "AutoCompoundPlan", r.autoCompoundPlan, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "positionId", r.positionId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDciProductSubscribeV1Request struct {
	ctx context.Context
	ApiService *DualInvestmentAPIService
	autoCompoundPlan *string
	depositAmount *string
	id *string
	orderId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateDciProductSubscribeV1Request) AutoCompoundPlan(autoCompoundPlan string) ApiCreateDciProductSubscribeV1Request {
	r.autoCompoundPlan = &autoCompoundPlan
	return r
}

func (r ApiCreateDciProductSubscribeV1Request) DepositAmount(depositAmount string) ApiCreateDciProductSubscribeV1Request {
	r.depositAmount = &depositAmount
	return r
}

func (r ApiCreateDciProductSubscribeV1Request) Id(id string) ApiCreateDciProductSubscribeV1Request {
	r.id = &id
	return r
}

func (r ApiCreateDciProductSubscribeV1Request) OrderId(orderId string) ApiCreateDciProductSubscribeV1Request {
	r.orderId = &orderId
	return r
}

func (r ApiCreateDciProductSubscribeV1Request) Timestamp(timestamp int64) ApiCreateDciProductSubscribeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateDciProductSubscribeV1Request) RecvWindow(recvWindow int64) ApiCreateDciProductSubscribeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateDciProductSubscribeV1Request) Execute() (*CreateDciProductSubscribeV1Resp, *http.Response, error) {
	return r.ApiService.CreateDciProductSubscribeV1Execute(r)
}

/*
CreateDciProductSubscribeV1 Subscribe Dual Investment products(USER_DATA)

Subscribe Dual Investment products

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDciProductSubscribeV1Request
*/
func (a *DualInvestmentAPIService) CreateDciProductSubscribeV1(ctx context.Context) ApiCreateDciProductSubscribeV1Request {
	return ApiCreateDciProductSubscribeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateDciProductSubscribeV1Resp
func (a *DualInvestmentAPIService) CreateDciProductSubscribeV1Execute(r ApiCreateDciProductSubscribeV1Request) (*CreateDciProductSubscribeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateDciProductSubscribeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DualInvestmentAPIService.CreateDciProductSubscribeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/dci/product/subscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.autoCompoundPlan == nil {
		return localVarReturnValue, nil, reportError("autoCompoundPlan is required and must be specified")
	}
	if r.depositAmount == nil {
		return localVarReturnValue, nil, reportError("depositAmount is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.orderId == nil {
		return localVarReturnValue, nil, reportError("orderId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "autoCompoundPlan", r.autoCompoundPlan, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "depositAmount", r.depositAmount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "orderId", r.orderId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDciProductAccountsV1Request struct {
	ctx context.Context
	ApiService *DualInvestmentAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetDciProductAccountsV1Request) Timestamp(timestamp int64) ApiGetDciProductAccountsV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than 60000
func (r ApiGetDciProductAccountsV1Request) RecvWindow(recvWindow int64) ApiGetDciProductAccountsV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetDciProductAccountsV1Request) Execute() (*GetDciProductAccountsV1Resp, *http.Response, error) {
	return r.ApiService.GetDciProductAccountsV1Execute(r)
}

/*
GetDciProductAccountsV1 Check Dual Investment accounts(USER_DATA)

Check Dual Investment accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDciProductAccountsV1Request
*/
func (a *DualInvestmentAPIService) GetDciProductAccountsV1(ctx context.Context) ApiGetDciProductAccountsV1Request {
	return ApiGetDciProductAccountsV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDciProductAccountsV1Resp
func (a *DualInvestmentAPIService) GetDciProductAccountsV1Execute(r ApiGetDciProductAccountsV1Request) (*GetDciProductAccountsV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDciProductAccountsV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DualInvestmentAPIService.GetDciProductAccountsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/dci/product/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDciProductListV1Request struct {
	ctx context.Context
	ApiService *DualInvestmentAPIService
	optionType *string
	exercisedCoin *string
	investCoin *string
	timestamp *int64
	pageSize *int64
	pageIndex *int32
	recvWindow *int64
}

// Input CALL or PUT
func (r ApiGetDciProductListV1Request) OptionType(optionType string) ApiGetDciProductListV1Request {
	r.optionType = &optionType
	return r
}

// Target exercised asset, e.g.: if you subscribe to a high sell product (call option), you should input: &#x60;optionType&#x60;:CALL,&#x60;exercisedCoin&#x60;:USDT,&#x60;investCoin&#x60;:BNB; if you subscribe to a low buy product (put option), you should input: &#x60;optionType&#x60;:PUT,&#x60;exercisedCoin&#x60;:BNB,&#x60;investCoin&#x60;:USDT
func (r ApiGetDciProductListV1Request) ExercisedCoin(exercisedCoin string) ApiGetDciProductListV1Request {
	r.exercisedCoin = &exercisedCoin
	return r
}

// Asset used for subscribing, e.g.: if you subscribe to a high sell product (call option), you should input: &#x60;optionType&#x60;:CALL,&#x60;exercisedCoin&#x60;:USDT,&#x60;investCoin&#x60;:BNB; if you subscribe to a low buy product (put option), you should input: &#x60;optionType&#x60;:PUT,&#x60;exercisedCoin&#x60;:BNB,&#x60;investCoin&#x60;:USDT
func (r ApiGetDciProductListV1Request) InvestCoin(investCoin string) ApiGetDciProductListV1Request {
	r.investCoin = &investCoin
	return r
}

func (r ApiGetDciProductListV1Request) Timestamp(timestamp int64) ApiGetDciProductListV1Request {
	r.timestamp = &timestamp
	return r
}

// Default: 10, Maximum: 100
func (r ApiGetDciProductListV1Request) PageSize(pageSize int64) ApiGetDciProductListV1Request {
	r.pageSize = &pageSize
	return r
}

// Default: 1
func (r ApiGetDciProductListV1Request) PageIndex(pageIndex int32) ApiGetDciProductListV1Request {
	r.pageIndex = &pageIndex
	return r
}

// The value cannot be greater than 60000
func (r ApiGetDciProductListV1Request) RecvWindow(recvWindow int64) ApiGetDciProductListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetDciProductListV1Request) Execute() (*GetDciProductListV1Resp, *http.Response, error) {
	return r.ApiService.GetDciProductListV1Execute(r)
}

/*
GetDciProductListV1 Get Dual Investment product list

Get Dual Investment product list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDciProductListV1Request
*/
func (a *DualInvestmentAPIService) GetDciProductListV1(ctx context.Context) ApiGetDciProductListV1Request {
	return ApiGetDciProductListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDciProductListV1Resp
func (a *DualInvestmentAPIService) GetDciProductListV1Execute(r ApiGetDciProductListV1Request) (*GetDciProductListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDciProductListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DualInvestmentAPIService.GetDciProductListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/dci/product/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.optionType == nil {
		return localVarReturnValue, nil, reportError("optionType is required and must be specified")
	}
	if r.exercisedCoin == nil {
		return localVarReturnValue, nil, reportError("exercisedCoin is required and must be specified")
	}
	if r.investCoin == nil {
		return localVarReturnValue, nil, reportError("investCoin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "optionType", r.optionType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "exercisedCoin", r.exercisedCoin, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "investCoin", r.investCoin, "form", "")
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int64 = 10
		r.pageSize = &defaultValue
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageIndex = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDciProductPositionsV1Request struct {
	ctx context.Context
	ApiService *DualInvestmentAPIService
	timestamp *int64
	status *string
	pageSize *int64
	pageIndex *int32
	recvWindow *int64
}

func (r ApiGetDciProductPositionsV1Request) Timestamp(timestamp int64) ApiGetDciProductPositionsV1Request {
	r.timestamp = &timestamp
	return r
}

// &#x60;PENDING&#x60;:Products are purchasing, will give results later;&#x60;PURCHASE_SUCCESS&#x60;:purchase successfully;&#x60;SETTLED&#x60;: Products are finish settling;&#x60;PURCHASE_FAIL&#x60;:fail to purchase;&#x60;REFUNDING&#x60;:refund ongoing;&#x60;REFUND_SUCCESS&#x60;:refund to spot account successfully; &#x60;SETTLING&#x60;:Products are settling. If don&amp;#39;t fill this field, will response all the position status.
func (r ApiGetDciProductPositionsV1Request) Status(status string) ApiGetDciProductPositionsV1Request {
	r.status = &status
	return r
}

// Default: 10, Max:100
func (r ApiGetDciProductPositionsV1Request) PageSize(pageSize int64) ApiGetDciProductPositionsV1Request {
	r.pageSize = &pageSize
	return r
}

// Default:1
func (r ApiGetDciProductPositionsV1Request) PageIndex(pageIndex int32) ApiGetDciProductPositionsV1Request {
	r.pageIndex = &pageIndex
	return r
}

// The value cannot be greater than 60000
func (r ApiGetDciProductPositionsV1Request) RecvWindow(recvWindow int64) ApiGetDciProductPositionsV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetDciProductPositionsV1Request) Execute() (*GetDciProductPositionsV1Resp, *http.Response, error) {
	return r.ApiService.GetDciProductPositionsV1Execute(r)
}

/*
GetDciProductPositionsV1 Get Dual Investment positions(USER_DATA)

Get Dual Investment positions (batch)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDciProductPositionsV1Request
*/
func (a *DualInvestmentAPIService) GetDciProductPositionsV1(ctx context.Context) ApiGetDciProductPositionsV1Request {
	return ApiGetDciProductPositionsV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDciProductPositionsV1Resp
func (a *DualInvestmentAPIService) GetDciProductPositionsV1Execute(r ApiGetDciProductPositionsV1Request) (*GetDciProductPositionsV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDciProductPositionsV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DualInvestmentAPIService.GetDciProductPositionsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/dci/product/positions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = ""
		r.status = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int64 = 10
		r.pageSize = &defaultValue
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

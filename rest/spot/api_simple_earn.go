/*
Binance Spot API

OpenAPI specification for Binance exchange - Spot API

API version: 0.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SimpleEarnAPIService SimpleEarnAPI service
type SimpleEarnAPIService service

type ApiCreateSimpleEarnFlexibleRedeemV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	productId *string
	timestamp *int64
	amount *string
	destAccount *string
	recvWindow *int64
	redeemAll *bool
}

func (r ApiCreateSimpleEarnFlexibleRedeemV1Request) ProductId(productId string) ApiCreateSimpleEarnFlexibleRedeemV1Request {
	r.productId = &productId
	return r
}

func (r ApiCreateSimpleEarnFlexibleRedeemV1Request) Timestamp(timestamp int64) ApiCreateSimpleEarnFlexibleRedeemV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSimpleEarnFlexibleRedeemV1Request) Amount(amount string) ApiCreateSimpleEarnFlexibleRedeemV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSimpleEarnFlexibleRedeemV1Request) DestAccount(destAccount string) ApiCreateSimpleEarnFlexibleRedeemV1Request {
	r.destAccount = &destAccount
	return r
}

func (r ApiCreateSimpleEarnFlexibleRedeemV1Request) RecvWindow(recvWindow int64) ApiCreateSimpleEarnFlexibleRedeemV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSimpleEarnFlexibleRedeemV1Request) RedeemAll(redeemAll bool) ApiCreateSimpleEarnFlexibleRedeemV1Request {
	r.redeemAll = &redeemAll
	return r
}

func (r ApiCreateSimpleEarnFlexibleRedeemV1Request) Execute() (*CreateSimpleEarnFlexibleRedeemV1Resp, *http.Response, error) {
	return r.ApiService.CreateSimpleEarnFlexibleRedeemV1Execute(r)
}

/*
CreateSimpleEarnFlexibleRedeemV1 Redeem Flexible Product(TRADE)

Redeem Flexible Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSimpleEarnFlexibleRedeemV1Request
*/
func (a *SimpleEarnAPIService) CreateSimpleEarnFlexibleRedeemV1(ctx context.Context) ApiCreateSimpleEarnFlexibleRedeemV1Request {
	return ApiCreateSimpleEarnFlexibleRedeemV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSimpleEarnFlexibleRedeemV1Resp
func (a *SimpleEarnAPIService) CreateSimpleEarnFlexibleRedeemV1Execute(r ApiCreateSimpleEarnFlexibleRedeemV1Request) (*CreateSimpleEarnFlexibleRedeemV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSimpleEarnFlexibleRedeemV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.CreateSimpleEarnFlexibleRedeemV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/redeem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	}
	if r.destAccount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "destAccount", r.destAccount, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "productId", r.productId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.redeemAll != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "redeemAll", r.redeemAll, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	autoSubscribe *bool
	productId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request) AutoSubscribe(autoSubscribe bool) ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request {
	r.autoSubscribe = &autoSubscribe
	return r
}

func (r ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request) ProductId(productId string) ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request {
	r.productId = &productId
	return r
}

func (r ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request) Timestamp(timestamp int64) ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request) RecvWindow(recvWindow int64) ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request) Execute() (*CreateSimpleEarnFlexibleSetAutoSubscribeV1Resp, *http.Response, error) {
	return r.ApiService.CreateSimpleEarnFlexibleSetAutoSubscribeV1Execute(r)
}

/*
CreateSimpleEarnFlexibleSetAutoSubscribeV1 Set Flexible Auto Subscribe(USER_DATA)

Set Flexible Auto Subscribe

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request
*/
func (a *SimpleEarnAPIService) CreateSimpleEarnFlexibleSetAutoSubscribeV1(ctx context.Context) ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request {
	return ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSimpleEarnFlexibleSetAutoSubscribeV1Resp
func (a *SimpleEarnAPIService) CreateSimpleEarnFlexibleSetAutoSubscribeV1Execute(r ApiCreateSimpleEarnFlexibleSetAutoSubscribeV1Request) (*CreateSimpleEarnFlexibleSetAutoSubscribeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSimpleEarnFlexibleSetAutoSubscribeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.CreateSimpleEarnFlexibleSetAutoSubscribeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/setAutoSubscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.autoSubscribe == nil {
		return localVarReturnValue, nil, reportError("autoSubscribe is required and must be specified")
	}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "autoSubscribe", r.autoSubscribe, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "productId", r.productId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSimpleEarnFlexibleSubscribeV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	amount *string
	productId *string
	timestamp *int64
	autoSubscribe *bool
	recvWindow *int64
	sourceAccount *string
}

func (r ApiCreateSimpleEarnFlexibleSubscribeV1Request) Amount(amount string) ApiCreateSimpleEarnFlexibleSubscribeV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSimpleEarnFlexibleSubscribeV1Request) ProductId(productId string) ApiCreateSimpleEarnFlexibleSubscribeV1Request {
	r.productId = &productId
	return r
}

func (r ApiCreateSimpleEarnFlexibleSubscribeV1Request) Timestamp(timestamp int64) ApiCreateSimpleEarnFlexibleSubscribeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSimpleEarnFlexibleSubscribeV1Request) AutoSubscribe(autoSubscribe bool) ApiCreateSimpleEarnFlexibleSubscribeV1Request {
	r.autoSubscribe = &autoSubscribe
	return r
}

func (r ApiCreateSimpleEarnFlexibleSubscribeV1Request) RecvWindow(recvWindow int64) ApiCreateSimpleEarnFlexibleSubscribeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSimpleEarnFlexibleSubscribeV1Request) SourceAccount(sourceAccount string) ApiCreateSimpleEarnFlexibleSubscribeV1Request {
	r.sourceAccount = &sourceAccount
	return r
}

func (r ApiCreateSimpleEarnFlexibleSubscribeV1Request) Execute() (*CreateSimpleEarnFlexibleSubscribeV1Resp, *http.Response, error) {
	return r.ApiService.CreateSimpleEarnFlexibleSubscribeV1Execute(r)
}

/*
CreateSimpleEarnFlexibleSubscribeV1 Subscribe Flexible Product(TRADE)

Subscribe Flexible Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSimpleEarnFlexibleSubscribeV1Request
*/
func (a *SimpleEarnAPIService) CreateSimpleEarnFlexibleSubscribeV1(ctx context.Context) ApiCreateSimpleEarnFlexibleSubscribeV1Request {
	return ApiCreateSimpleEarnFlexibleSubscribeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSimpleEarnFlexibleSubscribeV1Resp
func (a *SimpleEarnAPIService) CreateSimpleEarnFlexibleSubscribeV1Execute(r ApiCreateSimpleEarnFlexibleSubscribeV1Request) (*CreateSimpleEarnFlexibleSubscribeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSimpleEarnFlexibleSubscribeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.CreateSimpleEarnFlexibleSubscribeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/subscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.autoSubscribe != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoSubscribe", r.autoSubscribe, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "productId", r.productId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.sourceAccount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sourceAccount", r.sourceAccount, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSimpleEarnLockedRedeemV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	positionId *int32
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSimpleEarnLockedRedeemV1Request) PositionId(positionId int32) ApiCreateSimpleEarnLockedRedeemV1Request {
	r.positionId = &positionId
	return r
}

func (r ApiCreateSimpleEarnLockedRedeemV1Request) Timestamp(timestamp int64) ApiCreateSimpleEarnLockedRedeemV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSimpleEarnLockedRedeemV1Request) RecvWindow(recvWindow int64) ApiCreateSimpleEarnLockedRedeemV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSimpleEarnLockedRedeemV1Request) Execute() (*CreateSimpleEarnLockedRedeemV1Resp, *http.Response, error) {
	return r.ApiService.CreateSimpleEarnLockedRedeemV1Execute(r)
}

/*
CreateSimpleEarnLockedRedeemV1 Redeem Locked Product(TRADE)

Redeem Locked Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSimpleEarnLockedRedeemV1Request
*/
func (a *SimpleEarnAPIService) CreateSimpleEarnLockedRedeemV1(ctx context.Context) ApiCreateSimpleEarnLockedRedeemV1Request {
	return ApiCreateSimpleEarnLockedRedeemV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSimpleEarnLockedRedeemV1Resp
func (a *SimpleEarnAPIService) CreateSimpleEarnLockedRedeemV1Execute(r ApiCreateSimpleEarnLockedRedeemV1Request) (*CreateSimpleEarnLockedRedeemV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSimpleEarnLockedRedeemV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.CreateSimpleEarnLockedRedeemV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/redeem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.positionId == nil {
		return localVarReturnValue, nil, reportError("positionId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "positionId", r.positionId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	autoSubscribe *bool
	positionId *int32
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request) AutoSubscribe(autoSubscribe bool) ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request {
	r.autoSubscribe = &autoSubscribe
	return r
}

func (r ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request) PositionId(positionId int32) ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request {
	r.positionId = &positionId
	return r
}

func (r ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request) Timestamp(timestamp int64) ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request) RecvWindow(recvWindow int64) ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request) Execute() (*CreateSimpleEarnLockedSetAutoSubscribeV1Resp, *http.Response, error) {
	return r.ApiService.CreateSimpleEarnLockedSetAutoSubscribeV1Execute(r)
}

/*
CreateSimpleEarnLockedSetAutoSubscribeV1 Set Locked Auto Subscribe(USER_DATA)

Set locked auto subscribe

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request
*/
func (a *SimpleEarnAPIService) CreateSimpleEarnLockedSetAutoSubscribeV1(ctx context.Context) ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request {
	return ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSimpleEarnLockedSetAutoSubscribeV1Resp
func (a *SimpleEarnAPIService) CreateSimpleEarnLockedSetAutoSubscribeV1Execute(r ApiCreateSimpleEarnLockedSetAutoSubscribeV1Request) (*CreateSimpleEarnLockedSetAutoSubscribeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSimpleEarnLockedSetAutoSubscribeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.CreateSimpleEarnLockedSetAutoSubscribeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/setAutoSubscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.autoSubscribe == nil {
		return localVarReturnValue, nil, reportError("autoSubscribe is required and must be specified")
	}
	if r.positionId == nil {
		return localVarReturnValue, nil, reportError("positionId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "autoSubscribe", r.autoSubscribe, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "positionId", r.positionId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSimpleEarnLockedSetRedeemOptionV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	positionId *string
	redeemTo *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSimpleEarnLockedSetRedeemOptionV1Request) PositionId(positionId string) ApiCreateSimpleEarnLockedSetRedeemOptionV1Request {
	r.positionId = &positionId
	return r
}

func (r ApiCreateSimpleEarnLockedSetRedeemOptionV1Request) RedeemTo(redeemTo string) ApiCreateSimpleEarnLockedSetRedeemOptionV1Request {
	r.redeemTo = &redeemTo
	return r
}

func (r ApiCreateSimpleEarnLockedSetRedeemOptionV1Request) Timestamp(timestamp int64) ApiCreateSimpleEarnLockedSetRedeemOptionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSimpleEarnLockedSetRedeemOptionV1Request) RecvWindow(recvWindow int64) ApiCreateSimpleEarnLockedSetRedeemOptionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSimpleEarnLockedSetRedeemOptionV1Request) Execute() (*CreateSimpleEarnLockedSetRedeemOptionV1Resp, *http.Response, error) {
	return r.ApiService.CreateSimpleEarnLockedSetRedeemOptionV1Execute(r)
}

/*
CreateSimpleEarnLockedSetRedeemOptionV1 Set Locked Product Redeem Option(USER_DATA)

Set redeem option for Locked product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSimpleEarnLockedSetRedeemOptionV1Request
*/
func (a *SimpleEarnAPIService) CreateSimpleEarnLockedSetRedeemOptionV1(ctx context.Context) ApiCreateSimpleEarnLockedSetRedeemOptionV1Request {
	return ApiCreateSimpleEarnLockedSetRedeemOptionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSimpleEarnLockedSetRedeemOptionV1Resp
func (a *SimpleEarnAPIService) CreateSimpleEarnLockedSetRedeemOptionV1Execute(r ApiCreateSimpleEarnLockedSetRedeemOptionV1Request) (*CreateSimpleEarnLockedSetRedeemOptionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSimpleEarnLockedSetRedeemOptionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.CreateSimpleEarnLockedSetRedeemOptionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/setRedeemOption"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.positionId == nil {
		return localVarReturnValue, nil, reportError("positionId is required and must be specified")
	}
	if r.redeemTo == nil {
		return localVarReturnValue, nil, reportError("redeemTo is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "positionId", r.positionId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "redeemTo", r.redeemTo, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSimpleEarnLockedSubscribeV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	amount *string
	projectId *string
	timestamp *int64
	autoSubscribe *bool
	recvWindow *int64
	redeemTo *string
	sourceAccount *string
}

func (r ApiCreateSimpleEarnLockedSubscribeV1Request) Amount(amount string) ApiCreateSimpleEarnLockedSubscribeV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSimpleEarnLockedSubscribeV1Request) ProjectId(projectId string) ApiCreateSimpleEarnLockedSubscribeV1Request {
	r.projectId = &projectId
	return r
}

func (r ApiCreateSimpleEarnLockedSubscribeV1Request) Timestamp(timestamp int64) ApiCreateSimpleEarnLockedSubscribeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSimpleEarnLockedSubscribeV1Request) AutoSubscribe(autoSubscribe bool) ApiCreateSimpleEarnLockedSubscribeV1Request {
	r.autoSubscribe = &autoSubscribe
	return r
}

func (r ApiCreateSimpleEarnLockedSubscribeV1Request) RecvWindow(recvWindow int64) ApiCreateSimpleEarnLockedSubscribeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSimpleEarnLockedSubscribeV1Request) RedeemTo(redeemTo string) ApiCreateSimpleEarnLockedSubscribeV1Request {
	r.redeemTo = &redeemTo
	return r
}

func (r ApiCreateSimpleEarnLockedSubscribeV1Request) SourceAccount(sourceAccount string) ApiCreateSimpleEarnLockedSubscribeV1Request {
	r.sourceAccount = &sourceAccount
	return r
}

func (r ApiCreateSimpleEarnLockedSubscribeV1Request) Execute() (*CreateSimpleEarnLockedSubscribeV1Resp, *http.Response, error) {
	return r.ApiService.CreateSimpleEarnLockedSubscribeV1Execute(r)
}

/*
CreateSimpleEarnLockedSubscribeV1 Subscribe Locked Product(TRADE)

Subscribe Locked Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSimpleEarnLockedSubscribeV1Request
*/
func (a *SimpleEarnAPIService) CreateSimpleEarnLockedSubscribeV1(ctx context.Context) ApiCreateSimpleEarnLockedSubscribeV1Request {
	return ApiCreateSimpleEarnLockedSubscribeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSimpleEarnLockedSubscribeV1Resp
func (a *SimpleEarnAPIService) CreateSimpleEarnLockedSubscribeV1Execute(r ApiCreateSimpleEarnLockedSubscribeV1Request) (*CreateSimpleEarnLockedSubscribeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSimpleEarnLockedSubscribeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.CreateSimpleEarnLockedSubscribeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/subscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.autoSubscribe != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoSubscribe", r.autoSubscribe, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "projectId", r.projectId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.redeemTo != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "redeemTo", r.redeemTo, "", "")
	}
	if r.sourceAccount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sourceAccount", r.sourceAccount, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnAccountV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnAccountV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnAccountV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetSimpleEarnAccountV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnAccountV1Request) Execute() (*GetSimpleEarnAccountV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnAccountV1Execute(r)
}

/*
GetSimpleEarnAccountV1 Simple Account(USER_DATA)

Simple Account query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnAccountV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnAccountV1(ctx context.Context) ApiGetSimpleEarnAccountV1Request {
	return ApiGetSimpleEarnAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnAccountV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnAccountV1Execute(r ApiGetSimpleEarnAccountV1Request) (*GetSimpleEarnAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	timestamp *int64
	productId *string
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request) ProductId(productId string) ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request {
	r.productId = &productId
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request) StartTime(startTime int64) ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request) EndTime(endTime int64) ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request) Current(current int64) ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request) Size(size int64) ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request) Execute() (*GetSimpleEarnFlexibleHistoryCollateralRecordV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnFlexibleHistoryCollateralRecordV1Execute(r)
}

/*
GetSimpleEarnFlexibleHistoryCollateralRecordV1 Get Collateral Record(USER_DATA)

Get Collateral Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleHistoryCollateralRecordV1(ctx context.Context) ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request {
	return ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnFlexibleHistoryCollateralRecordV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleHistoryCollateralRecordV1Execute(r ApiGetSimpleEarnFlexibleHistoryCollateralRecordV1Request) (*GetSimpleEarnFlexibleHistoryCollateralRecordV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnFlexibleHistoryCollateralRecordV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnFlexibleHistoryCollateralRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/history/collateralRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "form", "")
	} else {
		var defaultValue string = ""
		r.productId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	productId *string
	timestamp *int64
	aprPeriod *string
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request) ProductId(productId string) ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request {
	r.productId = &productId
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// &amp;#34;DAY&amp;#34;,&amp;#34;YEAR&amp;#34;,default&amp;#34;DAY&amp;#34;
func (r ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request) AprPeriod(aprPeriod string) ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request {
	r.aprPeriod = &aprPeriod
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request) StartTime(startTime int64) ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request) EndTime(endTime int64) ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request) Current(current int64) ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request) Size(size int64) ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request) Execute() (*GetSimpleEarnFlexibleHistoryRateHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnFlexibleHistoryRateHistoryV1Execute(r)
}

/*
GetSimpleEarnFlexibleHistoryRateHistoryV1 Get Rate History(USER_DATA)

Get Rate History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleHistoryRateHistoryV1(ctx context.Context) ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request {
	return ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnFlexibleHistoryRateHistoryV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleHistoryRateHistoryV1Execute(r ApiGetSimpleEarnFlexibleHistoryRateHistoryV1Request) (*GetSimpleEarnFlexibleHistoryRateHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnFlexibleHistoryRateHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnFlexibleHistoryRateHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/history/rateHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "form", "")
	if r.aprPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aprPeriod", r.aprPeriod, "form", "")
	} else {
		var defaultValue string = ""
		r.aprPeriod = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	productId *string
	redeemId *string
	asset *string
	startTime *int64
	endTime *int64
	current *int64
	size *int64
}

func (r ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request) ProductId(productId string) ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request {
	r.productId = &productId
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request) RedeemId(redeemId string) ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request {
	r.redeemId = &redeemId
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request) Asset(asset string) ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request {
	r.asset = &asset
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request) StartTime(startTime int64) ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request) EndTime(endTime int64) ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying the page. Start from 1. Default:1
func (r ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request) Current(current int64) ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request) Size(size int64) ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request {
	r.size = &size
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request) Execute() (*GetSimpleEarnFlexibleHistoryRedemptionRecordV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnFlexibleHistoryRedemptionRecordV1Execute(r)
}

/*
GetSimpleEarnFlexibleHistoryRedemptionRecordV1 Get Flexible Redemption Record(USER_DATA)

Get Flexible Redemption Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleHistoryRedemptionRecordV1(ctx context.Context) ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request {
	return ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnFlexibleHistoryRedemptionRecordV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleHistoryRedemptionRecordV1Execute(r ApiGetSimpleEarnFlexibleHistoryRedemptionRecordV1Request) (*GetSimpleEarnFlexibleHistoryRedemptionRecordV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnFlexibleHistoryRedemptionRecordV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnFlexibleHistoryRedemptionRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/history/redemptionRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "form", "")
	} else {
		var defaultValue string = ""
		r.productId = &defaultValue
	}
	if r.redeemId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemId", r.redeemId, "form", "")
	} else {
		var defaultValue string = ""
		r.redeemId = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	type_ *string
	timestamp *int64
	productId *string
	asset *string
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

// &#x60;Bonus&#x60; - Bonus tiered APR, &#x60;REALTIME&#x60; Real-time APR, &#x60;REWARDS&#x60; Historical rewards,&#x60;ALL&#x60;(set to default)
func (r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) Type_(type_ string) ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request {
	r.type_ = &type_
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) ProductId(productId string) ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request {
	r.productId = &productId
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) Asset(asset string) ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request {
	r.asset = &asset
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) StartTime(startTime int64) ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) EndTime(endTime int64) ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying the page. Start from 1. Default:1
func (r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) Current(current int64) ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) Size(size int64) ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request {
	r.size = &size
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) Execute() (*GetSimpleEarnFlexibleHistoryRewardsRecordV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnFlexibleHistoryRewardsRecordV1Execute(r)
}

/*
GetSimpleEarnFlexibleHistoryRewardsRecordV1 Get Flexible Rewards History(USER_DATA)

Get Flexible Rewards History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleHistoryRewardsRecordV1(ctx context.Context) ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request {
	return ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnFlexibleHistoryRewardsRecordV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleHistoryRewardsRecordV1Execute(r ApiGetSimpleEarnFlexibleHistoryRewardsRecordV1Request) (*GetSimpleEarnFlexibleHistoryRewardsRecordV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnFlexibleHistoryRewardsRecordV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnFlexibleHistoryRewardsRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/history/rewardsRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "form", "")
	} else {
		var defaultValue string = ""
		r.productId = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	timestamp *int64
	productId *string
	purchaseId *string
	asset *string
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) ProductId(productId string) ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request {
	r.productId = &productId
	return r
}

func (r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) PurchaseId(purchaseId string) ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request {
	r.purchaseId = &purchaseId
	return r
}

func (r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) Asset(asset string) ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request {
	r.asset = &asset
	return r
}

func (r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) StartTime(startTime int64) ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) EndTime(endTime int64) ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying the page. Start from 1. Default:1
func (r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) Current(current int64) ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) Size(size int64) ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request {
	r.size = &size
	return r
}

func (r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) Execute() (*GetSimpleEarnFlexibleHistorySubscriptionRecordV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnFlexibleHistorySubscriptionRecordV1Execute(r)
}

/*
GetSimpleEarnFlexibleHistorySubscriptionRecordV1 Get Flexible Subscription Record(USER_DATA)

Get Flexible Subscription Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleHistorySubscriptionRecordV1(ctx context.Context) ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request {
	return ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnFlexibleHistorySubscriptionRecordV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleHistorySubscriptionRecordV1Execute(r ApiGetSimpleEarnFlexibleHistorySubscriptionRecordV1Request) (*GetSimpleEarnFlexibleHistorySubscriptionRecordV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnFlexibleHistorySubscriptionRecordV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnFlexibleHistorySubscriptionRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/history/subscriptionRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "form", "")
	} else {
		var defaultValue string = ""
		r.productId = &defaultValue
	}
	if r.purchaseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseId", r.purchaseId, "form", "")
	} else {
		var defaultValue string = ""
		r.purchaseId = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnFlexibleListV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	timestamp *int64
	asset *string
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnFlexibleListV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnFlexibleListV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnFlexibleListV1Request) Asset(asset string) ApiGetSimpleEarnFlexibleListV1Request {
	r.asset = &asset
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiGetSimpleEarnFlexibleListV1Request) Current(current int64) ApiGetSimpleEarnFlexibleListV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnFlexibleListV1Request) Size(size int64) ApiGetSimpleEarnFlexibleListV1Request {
	r.size = &size
	return r
}

func (r ApiGetSimpleEarnFlexibleListV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnFlexibleListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnFlexibleListV1Request) Execute() (*GetSimpleEarnFlexibleListV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnFlexibleListV1Execute(r)
}

/*
GetSimpleEarnFlexibleListV1 Get Simple Earn Flexible Product List(USER_DATA)

Get available Simple Earn flexible product list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnFlexibleListV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleListV1(ctx context.Context) ApiGetSimpleEarnFlexibleListV1Request {
	return ApiGetSimpleEarnFlexibleListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnFlexibleListV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleListV1Execute(r ApiGetSimpleEarnFlexibleListV1Request) (*GetSimpleEarnFlexibleListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnFlexibleListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnFlexibleListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	productId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request) ProductId(productId string) ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request {
	r.productId = &productId
	return r
}

func (r ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request) Execute() (*GetSimpleEarnFlexiblePersonalLeftQuotaV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnFlexiblePersonalLeftQuotaV1Execute(r)
}

/*
GetSimpleEarnFlexiblePersonalLeftQuotaV1 Get Flexible Personal Left Quota(USER_DATA)

Get Flexible Personal Left Quota

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnFlexiblePersonalLeftQuotaV1(ctx context.Context) ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request {
	return ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnFlexiblePersonalLeftQuotaV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnFlexiblePersonalLeftQuotaV1Execute(r ApiGetSimpleEarnFlexiblePersonalLeftQuotaV1Request) (*GetSimpleEarnFlexiblePersonalLeftQuotaV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnFlexiblePersonalLeftQuotaV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnFlexiblePersonalLeftQuotaV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/personalLeftQuota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnFlexiblePositionV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	timestamp *int64
	asset *string
	productId *string
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnFlexiblePositionV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnFlexiblePositionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnFlexiblePositionV1Request) Asset(asset string) ApiGetSimpleEarnFlexiblePositionV1Request {
	r.asset = &asset
	return r
}

func (r ApiGetSimpleEarnFlexiblePositionV1Request) ProductId(productId string) ApiGetSimpleEarnFlexiblePositionV1Request {
	r.productId = &productId
	return r
}

// Currently querying the page. Start from 1. Default:1
func (r ApiGetSimpleEarnFlexiblePositionV1Request) Current(current int64) ApiGetSimpleEarnFlexiblePositionV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnFlexiblePositionV1Request) Size(size int64) ApiGetSimpleEarnFlexiblePositionV1Request {
	r.size = &size
	return r
}

func (r ApiGetSimpleEarnFlexiblePositionV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnFlexiblePositionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnFlexiblePositionV1Request) Execute() (*GetSimpleEarnFlexiblePositionV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnFlexiblePositionV1Execute(r)
}

/*
GetSimpleEarnFlexiblePositionV1 Get Flexible Product Position(USER_DATA)

Get Flexible Product Position

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnFlexiblePositionV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnFlexiblePositionV1(ctx context.Context) ApiGetSimpleEarnFlexiblePositionV1Request {
	return ApiGetSimpleEarnFlexiblePositionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnFlexiblePositionV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnFlexiblePositionV1Execute(r ApiGetSimpleEarnFlexiblePositionV1Request) (*GetSimpleEarnFlexiblePositionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnFlexiblePositionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnFlexiblePositionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "form", "")
	} else {
		var defaultValue string = ""
		r.productId = &defaultValue
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	productId *string
	amount *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request) ProductId(productId string) ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request {
	r.productId = &productId
	return r
}

func (r ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request) Amount(amount string) ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request {
	r.amount = &amount
	return r
}

func (r ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request) Execute() (*GetSimpleEarnFlexibleSubscriptionPreviewV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnFlexibleSubscriptionPreviewV1Execute(r)
}

/*
GetSimpleEarnFlexibleSubscriptionPreviewV1 Get Flexible Subscription Preview(USER_DATA)

Get Flexible Subscription Preview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleSubscriptionPreviewV1(ctx context.Context) ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request {
	return ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnFlexibleSubscriptionPreviewV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnFlexibleSubscriptionPreviewV1Execute(r ApiGetSimpleEarnFlexibleSubscriptionPreviewV1Request) (*GetSimpleEarnFlexibleSubscriptionPreviewV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnFlexibleSubscriptionPreviewV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnFlexibleSubscriptionPreviewV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/flexible/subscriptionPreview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	timestamp *int64
	positionId *int32
	redeemId *string
	asset *string
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) PositionId(positionId int32) ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request {
	r.positionId = &positionId
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) RedeemId(redeemId string) ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request {
	r.redeemId = &redeemId
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) Asset(asset string) ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request {
	r.asset = &asset
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) StartTime(startTime int64) ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) EndTime(endTime int64) ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying the page. Start from 1. Default:1
func (r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) Current(current int64) ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) Size(size int64) ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request {
	r.size = &size
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) Execute() (*GetSimpleEarnLockedHistoryRedemptionRecordV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnLockedHistoryRedemptionRecordV1Execute(r)
}

/*
GetSimpleEarnLockedHistoryRedemptionRecordV1 Get Locked Redemption Record(USER_DATA)

Get Locked Redemption Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnLockedHistoryRedemptionRecordV1(ctx context.Context) ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request {
	return ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnLockedHistoryRedemptionRecordV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnLockedHistoryRedemptionRecordV1Execute(r ApiGetSimpleEarnLockedHistoryRedemptionRecordV1Request) (*GetSimpleEarnLockedHistoryRedemptionRecordV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnLockedHistoryRedemptionRecordV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnLockedHistoryRedemptionRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/history/redemptionRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.positionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positionId", r.positionId, "form", "")
	}
	if r.redeemId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "redeemId", r.redeemId, "form", "")
	} else {
		var defaultValue string = ""
		r.redeemId = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	timestamp *int64
	positionId *int32
	asset *string
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request) PositionId(positionId int32) ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request {
	r.positionId = &positionId
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request) Asset(asset string) ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request {
	r.asset = &asset
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request) StartTime(startTime int64) ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request) EndTime(endTime int64) ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying the page. Start from 1, Default:1, Max: 1,000
func (r ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request) Current(current int64) ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request) Size(size int64) ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request {
	r.size = &size
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request) Execute() (*GetSimpleEarnLockedHistoryRewardsRecordV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnLockedHistoryRewardsRecordV1Execute(r)
}

/*
GetSimpleEarnLockedHistoryRewardsRecordV1 Get Locked Rewards History(USER_DATA)

Get Locked Rewards History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnLockedHistoryRewardsRecordV1(ctx context.Context) ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request {
	return ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnLockedHistoryRewardsRecordV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnLockedHistoryRewardsRecordV1Execute(r ApiGetSimpleEarnLockedHistoryRewardsRecordV1Request) (*GetSimpleEarnLockedHistoryRewardsRecordV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnLockedHistoryRewardsRecordV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnLockedHistoryRewardsRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/history/rewardsRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.positionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positionId", r.positionId, "form", "")
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	timestamp *int64
	purchaseId *string
	asset *string
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request) PurchaseId(purchaseId string) ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request {
	r.purchaseId = &purchaseId
	return r
}

func (r ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request) Asset(asset string) ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request {
	r.asset = &asset
	return r
}

func (r ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request) StartTime(startTime int64) ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request) EndTime(endTime int64) ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying the page. Start from 1. Default:1
func (r ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request) Current(current int64) ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request) Size(size int64) ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request {
	r.size = &size
	return r
}

func (r ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request) Execute() (*GetSimpleEarnLockedHistorySubscriptionRecordV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnLockedHistorySubscriptionRecordV1Execute(r)
}

/*
GetSimpleEarnLockedHistorySubscriptionRecordV1 Get Locked Subscription Record(USER_DATA)

Get Locked Subscription Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnLockedHistorySubscriptionRecordV1(ctx context.Context) ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request {
	return ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnLockedHistorySubscriptionRecordV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnLockedHistorySubscriptionRecordV1Execute(r ApiGetSimpleEarnLockedHistorySubscriptionRecordV1Request) (*GetSimpleEarnLockedHistorySubscriptionRecordV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnLockedHistorySubscriptionRecordV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnLockedHistorySubscriptionRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/history/subscriptionRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.purchaseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purchaseId", r.purchaseId, "form", "")
	} else {
		var defaultValue string = ""
		r.purchaseId = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnLockedListV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	timestamp *int64
	asset *string
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnLockedListV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnLockedListV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnLockedListV1Request) Asset(asset string) ApiGetSimpleEarnLockedListV1Request {
	r.asset = &asset
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiGetSimpleEarnLockedListV1Request) Current(current int64) ApiGetSimpleEarnLockedListV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnLockedListV1Request) Size(size int64) ApiGetSimpleEarnLockedListV1Request {
	r.size = &size
	return r
}

func (r ApiGetSimpleEarnLockedListV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnLockedListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnLockedListV1Request) Execute() (*GetSimpleEarnLockedListV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnLockedListV1Execute(r)
}

/*
GetSimpleEarnLockedListV1 Get Simple Earn Locked Product List(USER_DATA)

Get Simple Earn Locked Product List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnLockedListV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnLockedListV1(ctx context.Context) ApiGetSimpleEarnLockedListV1Request {
	return ApiGetSimpleEarnLockedListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnLockedListV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnLockedListV1Execute(r ApiGetSimpleEarnLockedListV1Request) (*GetSimpleEarnLockedListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnLockedListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnLockedListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	projectId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request) ProjectId(projectId string) ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request {
	r.projectId = &projectId
	return r
}

func (r ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request) Execute() (*GetSimpleEarnLockedPersonalLeftQuotaV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnLockedPersonalLeftQuotaV1Execute(r)
}

/*
GetSimpleEarnLockedPersonalLeftQuotaV1 Get Locked Personal Left Quota(USER_DATA)

Get Locked Personal Left Quota

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnLockedPersonalLeftQuotaV1(ctx context.Context) ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request {
	return ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnLockedPersonalLeftQuotaV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnLockedPersonalLeftQuotaV1Execute(r ApiGetSimpleEarnLockedPersonalLeftQuotaV1Request) (*GetSimpleEarnLockedPersonalLeftQuotaV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnLockedPersonalLeftQuotaV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnLockedPersonalLeftQuotaV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/personalLeftQuota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", r.projectId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnLockedPositionV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	timestamp *int64
	asset *string
	positionId *int32
	projectId *string
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSimpleEarnLockedPositionV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnLockedPositionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSimpleEarnLockedPositionV1Request) Asset(asset string) ApiGetSimpleEarnLockedPositionV1Request {
	r.asset = &asset
	return r
}

func (r ApiGetSimpleEarnLockedPositionV1Request) PositionId(positionId int32) ApiGetSimpleEarnLockedPositionV1Request {
	r.positionId = &positionId
	return r
}

func (r ApiGetSimpleEarnLockedPositionV1Request) ProjectId(projectId string) ApiGetSimpleEarnLockedPositionV1Request {
	r.projectId = &projectId
	return r
}

// Currently querying the page. Start from 1. Default:1
func (r ApiGetSimpleEarnLockedPositionV1Request) Current(current int64) ApiGetSimpleEarnLockedPositionV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiGetSimpleEarnLockedPositionV1Request) Size(size int64) ApiGetSimpleEarnLockedPositionV1Request {
	r.size = &size
	return r
}

func (r ApiGetSimpleEarnLockedPositionV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnLockedPositionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnLockedPositionV1Request) Execute() (*GetSimpleEarnLockedPositionV1Resp, *http.Response, error) {
	return r.ApiService.GetSimpleEarnLockedPositionV1Execute(r)
}

/*
GetSimpleEarnLockedPositionV1 Get Locked Product Position

Get Locked Product Position

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnLockedPositionV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnLockedPositionV1(ctx context.Context) ApiGetSimpleEarnLockedPositionV1Request {
	return ApiGetSimpleEarnLockedPositionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSimpleEarnLockedPositionV1Resp
func (a *SimpleEarnAPIService) GetSimpleEarnLockedPositionV1Execute(r ApiGetSimpleEarnLockedPositionV1Request) (*GetSimpleEarnLockedPositionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSimpleEarnLockedPositionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnLockedPositionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.positionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "positionId", r.positionId, "form", "")
	}
	if r.projectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", r.projectId, "form", "")
	} else {
		var defaultValue string = ""
		r.projectId = &defaultValue
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleEarnLockedSubscriptionPreviewV1Request struct {
	ctx context.Context
	ApiService *SimpleEarnAPIService
	projectId *string
	amount *string
	timestamp *int64
	autoSubscribe *bool
	recvWindow *int64
}

func (r ApiGetSimpleEarnLockedSubscriptionPreviewV1Request) ProjectId(projectId string) ApiGetSimpleEarnLockedSubscriptionPreviewV1Request {
	r.projectId = &projectId
	return r
}

func (r ApiGetSimpleEarnLockedSubscriptionPreviewV1Request) Amount(amount string) ApiGetSimpleEarnLockedSubscriptionPreviewV1Request {
	r.amount = &amount
	return r
}

func (r ApiGetSimpleEarnLockedSubscriptionPreviewV1Request) Timestamp(timestamp int64) ApiGetSimpleEarnLockedSubscriptionPreviewV1Request {
	r.timestamp = &timestamp
	return r
}

// true or false, default true.
func (r ApiGetSimpleEarnLockedSubscriptionPreviewV1Request) AutoSubscribe(autoSubscribe bool) ApiGetSimpleEarnLockedSubscriptionPreviewV1Request {
	r.autoSubscribe = &autoSubscribe
	return r
}

func (r ApiGetSimpleEarnLockedSubscriptionPreviewV1Request) RecvWindow(recvWindow int64) ApiGetSimpleEarnLockedSubscriptionPreviewV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSimpleEarnLockedSubscriptionPreviewV1Request) Execute() ([]GetSimpleEarnLockedSubscriptionPreviewV1RespItem, *http.Response, error) {
	return r.ApiService.GetSimpleEarnLockedSubscriptionPreviewV1Execute(r)
}

/*
GetSimpleEarnLockedSubscriptionPreviewV1 Get Locked Subscription Preview(USER_DATA)

Get Locked Subscription Preview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSimpleEarnLockedSubscriptionPreviewV1Request
*/
func (a *SimpleEarnAPIService) GetSimpleEarnLockedSubscriptionPreviewV1(ctx context.Context) ApiGetSimpleEarnLockedSubscriptionPreviewV1Request {
	return ApiGetSimpleEarnLockedSubscriptionPreviewV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetSimpleEarnLockedSubscriptionPreviewV1RespItem
func (a *SimpleEarnAPIService) GetSimpleEarnLockedSubscriptionPreviewV1Execute(r ApiGetSimpleEarnLockedSubscriptionPreviewV1Request) ([]GetSimpleEarnLockedSubscriptionPreviewV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetSimpleEarnLockedSubscriptionPreviewV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimpleEarnAPIService.GetSimpleEarnLockedSubscriptionPreviewV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/simple-earn/locked/subscriptionPreview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", r.projectId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	if r.autoSubscribe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoSubscribe", r.autoSubscribe, "form", "")
	} else {
		var defaultValue bool = true
		r.autoSubscribe = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Binance Spot API

OpenAPI specification for Binance exchange - Spot API

API version: 0.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// GiftCardAPIService GiftCardAPI service
type GiftCardAPIService service

type ApiCreateGiftcardBuyCodeV1Request struct {
	ctx context.Context
	ApiService *GiftCardAPIService
	baseToken *string
	baseTokenAmount *float32
	faceToken *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateGiftcardBuyCodeV1Request) BaseToken(baseToken string) ApiCreateGiftcardBuyCodeV1Request {
	r.baseToken = &baseToken
	return r
}

func (r ApiCreateGiftcardBuyCodeV1Request) BaseTokenAmount(baseTokenAmount float32) ApiCreateGiftcardBuyCodeV1Request {
	r.baseTokenAmount = &baseTokenAmount
	return r
}

func (r ApiCreateGiftcardBuyCodeV1Request) FaceToken(faceToken string) ApiCreateGiftcardBuyCodeV1Request {
	r.faceToken = &faceToken
	return r
}

func (r ApiCreateGiftcardBuyCodeV1Request) Timestamp(timestamp int64) ApiCreateGiftcardBuyCodeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateGiftcardBuyCodeV1Request) RecvWindow(recvWindow int64) ApiCreateGiftcardBuyCodeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateGiftcardBuyCodeV1Request) Execute() (*CreateGiftcardBuyCodeV1Resp, *http.Response, error) {
	return r.ApiService.CreateGiftcardBuyCodeV1Execute(r)
}

/*
CreateGiftcardBuyCodeV1 Create a dual-token gift card(fixed value, discount feature)(TRADE)

This API is for creating a dual-token ( stablecoin-denominated) Binance Gift Card. You may create a gift card using USDT as baseToken, that is redeemable to another designated token (faceToken). For example, you can create a fixed-value BTC gift card and pay with 100 USDT plus 1 USDT fee. This gift card can keep the value fixed at 100 USDT before redemption, and will be redeemable to BTC equivalent to 100 USDT upon redemption.


Once successfully created, the amount of baseToken (e.g. USDT) in the fixed-value gift card along with the fee would be deducted from your funding wallet.


To get started with, please make sure:

You have a Binance account
You have passed KYB
You have a sufﬁcient balance(Gift Card amount and fee amount) in your Binance funding wallet
You need Enable Withdrawals for the API Key which requests this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGiftcardBuyCodeV1Request
*/
func (a *GiftCardAPIService) CreateGiftcardBuyCodeV1(ctx context.Context) ApiCreateGiftcardBuyCodeV1Request {
	return ApiCreateGiftcardBuyCodeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGiftcardBuyCodeV1Resp
func (a *GiftCardAPIService) CreateGiftcardBuyCodeV1Execute(r ApiCreateGiftcardBuyCodeV1Request) (*CreateGiftcardBuyCodeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGiftcardBuyCodeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GiftCardAPIService.CreateGiftcardBuyCodeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/giftcard/buyCode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.baseToken == nil {
		return localVarReturnValue, nil, reportError("baseToken is required and must be specified")
	}
	if r.baseTokenAmount == nil {
		return localVarReturnValue, nil, reportError("baseTokenAmount is required and must be specified")
	}
	if r.faceToken == nil {
		return localVarReturnValue, nil, reportError("faceToken is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "baseToken", r.baseToken, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "baseTokenAmount", r.baseTokenAmount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "faceToken", r.faceToken, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGiftcardCreateCodeV1Request struct {
	ctx context.Context
	ApiService *GiftCardAPIService
	amount *float32
	timestamp *int64
	token *string
	recvWindow *int64
}

func (r ApiCreateGiftcardCreateCodeV1Request) Amount(amount float32) ApiCreateGiftcardCreateCodeV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateGiftcardCreateCodeV1Request) Timestamp(timestamp int64) ApiCreateGiftcardCreateCodeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateGiftcardCreateCodeV1Request) Token(token string) ApiCreateGiftcardCreateCodeV1Request {
	r.token = &token
	return r
}

func (r ApiCreateGiftcardCreateCodeV1Request) RecvWindow(recvWindow int64) ApiCreateGiftcardCreateCodeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateGiftcardCreateCodeV1Request) Execute() (*CreateGiftcardCreateCodeV1Resp, *http.Response, error) {
	return r.ApiService.CreateGiftcardCreateCodeV1Execute(r)
}

/*
CreateGiftcardCreateCodeV1 Create a single-token gift card (USER_DATA)

This API is for creating a Binance Gift Card.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGiftcardCreateCodeV1Request
*/
func (a *GiftCardAPIService) CreateGiftcardCreateCodeV1(ctx context.Context) ApiCreateGiftcardCreateCodeV1Request {
	return ApiCreateGiftcardCreateCodeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGiftcardCreateCodeV1Resp
func (a *GiftCardAPIService) CreateGiftcardCreateCodeV1Execute(r ApiCreateGiftcardCreateCodeV1Request) (*CreateGiftcardCreateCodeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGiftcardCreateCodeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GiftCardAPIService.CreateGiftcardCreateCodeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/giftcard/createCode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.token == nil {
		return localVarReturnValue, nil, reportError("token is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "token", r.token, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGiftcardRedeemCodeV1Request struct {
	ctx context.Context
	ApiService *GiftCardAPIService
	code *string
	timestamp *int64
	externalUid *string
	recvWindow *int64
}

func (r ApiCreateGiftcardRedeemCodeV1Request) Code(code string) ApiCreateGiftcardRedeemCodeV1Request {
	r.code = &code
	return r
}

func (r ApiCreateGiftcardRedeemCodeV1Request) Timestamp(timestamp int64) ApiCreateGiftcardRedeemCodeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateGiftcardRedeemCodeV1Request) ExternalUid(externalUid string) ApiCreateGiftcardRedeemCodeV1Request {
	r.externalUid = &externalUid
	return r
}

func (r ApiCreateGiftcardRedeemCodeV1Request) RecvWindow(recvWindow int64) ApiCreateGiftcardRedeemCodeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateGiftcardRedeemCodeV1Request) Execute() (*CreateGiftcardRedeemCodeV1Resp, *http.Response, error) {
	return r.ApiService.CreateGiftcardRedeemCodeV1Execute(r)
}

/*
CreateGiftcardRedeemCodeV1 Redeem a Binance Gift Card(USER_DATA)

This API is for redeeming a Binance Gift Card
Once redeemed, the coins will be deposited in your funding wallet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGiftcardRedeemCodeV1Request
*/
func (a *GiftCardAPIService) CreateGiftcardRedeemCodeV1(ctx context.Context) ApiCreateGiftcardRedeemCodeV1Request {
	return ApiCreateGiftcardRedeemCodeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateGiftcardRedeemCodeV1Resp
func (a *GiftCardAPIService) CreateGiftcardRedeemCodeV1Execute(r ApiCreateGiftcardRedeemCodeV1Request) (*CreateGiftcardRedeemCodeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateGiftcardRedeemCodeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GiftCardAPIService.CreateGiftcardRedeemCodeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/giftcard/redeemCode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.code == nil {
		return localVarReturnValue, nil, reportError("code is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	parameterAddToHeaderOrQuery(localVarFormParams, "code", r.code, "", "")
	if r.externalUid != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "externalUid", r.externalUid, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGiftcardBuyCodeTokenLimitV1Request struct {
	ctx context.Context
	ApiService *GiftCardAPIService
	baseToken *string
	timestamp *int64
	recvWindow *int64
}

// The token you want to pay, example: BUSD
func (r ApiGetGiftcardBuyCodeTokenLimitV1Request) BaseToken(baseToken string) ApiGetGiftcardBuyCodeTokenLimitV1Request {
	r.baseToken = &baseToken
	return r
}

func (r ApiGetGiftcardBuyCodeTokenLimitV1Request) Timestamp(timestamp int64) ApiGetGiftcardBuyCodeTokenLimitV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetGiftcardBuyCodeTokenLimitV1Request) RecvWindow(recvWindow int64) ApiGetGiftcardBuyCodeTokenLimitV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetGiftcardBuyCodeTokenLimitV1Request) Execute() (*GetGiftcardBuyCodeTokenLimitV1Resp, *http.Response, error) {
	return r.ApiService.GetGiftcardBuyCodeTokenLimitV1Execute(r)
}

/*
GetGiftcardBuyCodeTokenLimitV1 Fetch Token Limit(USER_DATA)

This API is to help you verify which tokens are available for you to create Stablecoin-Denominated gift cards as mentioned in section 2 and its’ limitation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGiftcardBuyCodeTokenLimitV1Request
*/
func (a *GiftCardAPIService) GetGiftcardBuyCodeTokenLimitV1(ctx context.Context) ApiGetGiftcardBuyCodeTokenLimitV1Request {
	return ApiGetGiftcardBuyCodeTokenLimitV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGiftcardBuyCodeTokenLimitV1Resp
func (a *GiftCardAPIService) GetGiftcardBuyCodeTokenLimitV1Execute(r ApiGetGiftcardBuyCodeTokenLimitV1Request) (*GetGiftcardBuyCodeTokenLimitV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGiftcardBuyCodeTokenLimitV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GiftCardAPIService.GetGiftcardBuyCodeTokenLimitV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/giftcard/buyCode/token-limit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.baseToken == nil {
		return localVarReturnValue, nil, reportError("baseToken is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "baseToken", r.baseToken, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGiftcardCryptographyRsaPublicKeyV1Request struct {
	ctx context.Context
	ApiService *GiftCardAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetGiftcardCryptographyRsaPublicKeyV1Request) Timestamp(timestamp int64) ApiGetGiftcardCryptographyRsaPublicKeyV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetGiftcardCryptographyRsaPublicKeyV1Request) RecvWindow(recvWindow int64) ApiGetGiftcardCryptographyRsaPublicKeyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetGiftcardCryptographyRsaPublicKeyV1Request) Execute() (*GetGiftcardCryptographyRsaPublicKeyV1Resp, *http.Response, error) {
	return r.ApiService.GetGiftcardCryptographyRsaPublicKeyV1Execute(r)
}

/*
GetGiftcardCryptographyRsaPublicKeyV1 Fetch RSA Public Key(USER_DATA)

This API is for fetching the RSA Public Key.
This RSA Public key will be used to encrypt the card code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGiftcardCryptographyRsaPublicKeyV1Request
*/
func (a *GiftCardAPIService) GetGiftcardCryptographyRsaPublicKeyV1(ctx context.Context) ApiGetGiftcardCryptographyRsaPublicKeyV1Request {
	return ApiGetGiftcardCryptographyRsaPublicKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGiftcardCryptographyRsaPublicKeyV1Resp
func (a *GiftCardAPIService) GetGiftcardCryptographyRsaPublicKeyV1Execute(r ApiGetGiftcardCryptographyRsaPublicKeyV1Request) (*GetGiftcardCryptographyRsaPublicKeyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGiftcardCryptographyRsaPublicKeyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GiftCardAPIService.GetGiftcardCryptographyRsaPublicKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/giftcard/cryptography/rsa-public-key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGiftcardVerifyV1Request struct {
	ctx context.Context
	ApiService *GiftCardAPIService
	referenceNo *string
	timestamp *int64
	recvWindow *int64
}

// Enter the Gift Card Number
func (r ApiGetGiftcardVerifyV1Request) ReferenceNo(referenceNo string) ApiGetGiftcardVerifyV1Request {
	r.referenceNo = &referenceNo
	return r
}

func (r ApiGetGiftcardVerifyV1Request) Timestamp(timestamp int64) ApiGetGiftcardVerifyV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetGiftcardVerifyV1Request) RecvWindow(recvWindow int64) ApiGetGiftcardVerifyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetGiftcardVerifyV1Request) Execute() (*GetGiftcardVerifyV1Resp, *http.Response, error) {
	return r.ApiService.GetGiftcardVerifyV1Execute(r)
}

/*
GetGiftcardVerifyV1 Verify Binance Gift Card by Gift Card Number(USER_DATA)

This API is for verifying whether the Binance Gift Card is valid or not by entering Gift Card Number.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGiftcardVerifyV1Request
*/
func (a *GiftCardAPIService) GetGiftcardVerifyV1(ctx context.Context) ApiGetGiftcardVerifyV1Request {
	return ApiGetGiftcardVerifyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGiftcardVerifyV1Resp
func (a *GiftCardAPIService) GetGiftcardVerifyV1Execute(r ApiGetGiftcardVerifyV1Request) (*GetGiftcardVerifyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGiftcardVerifyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GiftCardAPIService.GetGiftcardVerifyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/giftcard/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.referenceNo == nil {
		return localVarReturnValue, nil, reportError("referenceNo is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "referenceNo", r.referenceNo, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// Prepare raw parameters for signature if needed
	var rawParams map[string]string
	// Add raw parameters to context if any
	if len(rawParams) > 0 {
		r.ctx = context.WithValue(r.ctx, ContextRawParams, rawParams)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Binance Sub Account API

OpenAPI specification for Binance exchange - Subaccount API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package subaccount

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// V1APIService V1API service
type V1APIService service

type V1APISubaccountCreateManagedSubaccountDepositV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	asset *string
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r V1APISubaccountCreateManagedSubaccountDepositV1Request) Amount(amount string) V1APISubaccountCreateManagedSubaccountDepositV1Request {
	r.amount = &amount
	return r
}

func (r V1APISubaccountCreateManagedSubaccountDepositV1Request) Asset(asset string) V1APISubaccountCreateManagedSubaccountDepositV1Request {
	r.asset = &asset
	return r
}

func (r V1APISubaccountCreateManagedSubaccountDepositV1Request) Timestamp(timestamp int64) V1APISubaccountCreateManagedSubaccountDepositV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateManagedSubaccountDepositV1Request) ToEmail(toEmail string) V1APISubaccountCreateManagedSubaccountDepositV1Request {
	r.toEmail = &toEmail
	return r
}

func (r V1APISubaccountCreateManagedSubaccountDepositV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateManagedSubaccountDepositV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateManagedSubaccountDepositV1Request) Execute() (*SubaccountCreateManagedSubaccountDepositV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateManagedSubaccountDepositV1Execute(r)
}

/*
SubaccountCreateManagedSubaccountDepositV1 Deposit Assets Into The Managed Sub-account(For Investor Master Account)

Deposit Assets Into The Managed Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateManagedSubaccountDepositV1Request
*/
func (a *V1APIService) SubaccountCreateManagedSubaccountDepositV1(ctx context.Context) V1APISubaccountCreateManagedSubaccountDepositV1Request {
	return V1APISubaccountCreateManagedSubaccountDepositV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateManagedSubaccountDepositV1Resp
func (a *V1APIService) SubaccountCreateManagedSubaccountDepositV1Execute(r V1APISubaccountCreateManagedSubaccountDepositV1Request) (*SubaccountCreateManagedSubaccountDepositV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateManagedSubaccountDepositV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateManagedSubaccountDepositV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/deposit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateManagedSubaccountWithdrawV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	asset *string
	fromEmail *string
	timestamp *int64
	recvWindow *int64
	transferDate *int64
}

func (r V1APISubaccountCreateManagedSubaccountWithdrawV1Request) Amount(amount string) V1APISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.amount = &amount
	return r
}

func (r V1APISubaccountCreateManagedSubaccountWithdrawV1Request) Asset(asset string) V1APISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.asset = &asset
	return r
}

func (r V1APISubaccountCreateManagedSubaccountWithdrawV1Request) FromEmail(fromEmail string) V1APISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r V1APISubaccountCreateManagedSubaccountWithdrawV1Request) Timestamp(timestamp int64) V1APISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateManagedSubaccountWithdrawV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateManagedSubaccountWithdrawV1Request) TransferDate(transferDate int64) V1APISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.transferDate = &transferDate
	return r
}

func (r V1APISubaccountCreateManagedSubaccountWithdrawV1Request) Execute() (*SubaccountCreateManagedSubaccountWithdrawV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateManagedSubaccountWithdrawV1Execute(r)
}

/*
SubaccountCreateManagedSubaccountWithdrawV1 Withdrawl Assets From The Managed Sub-account(For Investor Master Account)

Withdrawl Assets From The Managed Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateManagedSubaccountWithdrawV1Request
*/
func (a *V1APIService) SubaccountCreateManagedSubaccountWithdrawV1(ctx context.Context) V1APISubaccountCreateManagedSubaccountWithdrawV1Request {
	return V1APISubaccountCreateManagedSubaccountWithdrawV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateManagedSubaccountWithdrawV1Resp
func (a *V1APIService) SubaccountCreateManagedSubaccountWithdrawV1Execute(r V1APISubaccountCreateManagedSubaccountWithdrawV1Request) (*SubaccountCreateManagedSubaccountWithdrawV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateManagedSubaccountWithdrawV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateManagedSubaccountWithdrawV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/withdraw"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.transferDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transferDate", r.transferDate, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountBlvtEnableV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	enableBlvt *bool
	timestamp *int64
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountBlvtEnableV1Request) Email(email string) V1APISubaccountCreateSubAccountBlvtEnableV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountCreateSubAccountBlvtEnableV1Request) EnableBlvt(enableBlvt bool) V1APISubaccountCreateSubAccountBlvtEnableV1Request {
	r.enableBlvt = &enableBlvt
	return r
}

func (r V1APISubaccountCreateSubAccountBlvtEnableV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountBlvtEnableV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountBlvtEnableV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountBlvtEnableV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountBlvtEnableV1Request) Execute() (*SubaccountCreateSubAccountBlvtEnableV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountBlvtEnableV1Execute(r)
}

/*
SubaccountCreateSubAccountBlvtEnableV1 Enable Leverage Token for Sub-account(For Master Account)

Enable Leverage Token for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountBlvtEnableV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountBlvtEnableV1(ctx context.Context) V1APISubaccountCreateSubAccountBlvtEnableV1Request {
	return V1APISubaccountCreateSubAccountBlvtEnableV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountBlvtEnableV1Resp
func (a *V1APIService) SubaccountCreateSubAccountBlvtEnableV1Execute(r V1APISubaccountCreateSubAccountBlvtEnableV1Request) (*SubaccountCreateSubAccountBlvtEnableV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountBlvtEnableV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountBlvtEnableV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/blvt/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.enableBlvt == nil {
		return localVarReturnValue, nil, reportError("enableBlvt is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "enableBlvt", r.enableBlvt, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountEoptionsEnableV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountEoptionsEnableV1Request) Email(email string) V1APISubaccountCreateSubAccountEoptionsEnableV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountCreateSubAccountEoptionsEnableV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountEoptionsEnableV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountEoptionsEnableV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountEoptionsEnableV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountEoptionsEnableV1Request) Execute() (*SubaccountCreateSubAccountEoptionsEnableV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountEoptionsEnableV1Execute(r)
}

/*
SubaccountCreateSubAccountEoptionsEnableV1 Enable Options for Sub-account(For Master Account)(USER_DATA)

Enable Options for Sub-account (For Master Account).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountEoptionsEnableV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountEoptionsEnableV1(ctx context.Context) V1APISubaccountCreateSubAccountEoptionsEnableV1Request {
	return V1APISubaccountCreateSubAccountEoptionsEnableV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountEoptionsEnableV1Resp
func (a *V1APIService) SubaccountCreateSubAccountEoptionsEnableV1Execute(r V1APISubaccountCreateSubAccountEoptionsEnableV1Request) (*SubaccountCreateSubAccountEoptionsEnableV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountEoptionsEnableV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountEoptionsEnableV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/eoptions/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountFuturesEnableV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountFuturesEnableV1Request) Email(email string) V1APISubaccountCreateSubAccountFuturesEnableV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesEnableV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountFuturesEnableV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesEnableV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountFuturesEnableV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesEnableV1Request) Execute() (*SubaccountCreateSubAccountFuturesEnableV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountFuturesEnableV1Execute(r)
}

/*
SubaccountCreateSubAccountFuturesEnableV1 Enable Futures for Sub-account(For Master Account)

Enable Futures for Sub-account for Master Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountFuturesEnableV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountFuturesEnableV1(ctx context.Context) V1APISubaccountCreateSubAccountFuturesEnableV1Request {
	return V1APISubaccountCreateSubAccountFuturesEnableV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountFuturesEnableV1Resp
func (a *V1APIService) SubaccountCreateSubAccountFuturesEnableV1Execute(r V1APISubaccountCreateSubAccountFuturesEnableV1Request) (*SubaccountCreateSubAccountFuturesEnableV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountFuturesEnableV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountFuturesEnableV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	asset *string
	fromEmail *string
	futuresType *int64
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request) Amount(amount string) V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.amount = &amount
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request) Asset(asset string) V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.asset = &asset
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request) FromEmail(fromEmail string) V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request) FuturesType(futuresType int64) V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.futuresType = &futuresType
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request) ToEmail(toEmail string) V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request) Execute() (*SubaccountCreateSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountFuturesInternalTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountFuturesInternalTransferV1 Sub-account Futures Asset Transfer(For Master Account)

Sub-account Futures Asset Transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountFuturesInternalTransferV1(ctx context.Context) V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	return V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountFuturesInternalTransferV1Resp
func (a *V1APIService) SubaccountCreateSubAccountFuturesInternalTransferV1Execute(r V1APISubaccountCreateSubAccountFuturesInternalTransferV1Request) (*SubaccountCreateSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountFuturesInternalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountFuturesInternalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "futuresType", r.futuresType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountFuturesMovePositionV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	fromUserEmail *string
	orderArgs *[]map[string]interface{}
	productType *string
	timestamp *int64
	toUserEmail *string
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountFuturesMovePositionV1Request) FromUserEmail(fromUserEmail string) V1APISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.fromUserEmail = &fromUserEmail
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesMovePositionV1Request) OrderArgs(orderArgs []map[string]interface{}) V1APISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.orderArgs = &orderArgs
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesMovePositionV1Request) ProductType(productType string) V1APISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.productType = &productType
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesMovePositionV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesMovePositionV1Request) ToUserEmail(toUserEmail string) V1APISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.toUserEmail = &toUserEmail
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesMovePositionV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesMovePositionV1Request) Execute() (*SubaccountCreateSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountFuturesMovePositionV1Execute(r)
}

/*
SubaccountCreateSubAccountFuturesMovePositionV1 Move Position for Sub-account (For Master Account)

Move position between sub-master, master-sub, or sub-sub accounts when necessary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountFuturesMovePositionV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountFuturesMovePositionV1(ctx context.Context) V1APISubaccountCreateSubAccountFuturesMovePositionV1Request {
	return V1APISubaccountCreateSubAccountFuturesMovePositionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountFuturesMovePositionV1Resp
func (a *V1APIService) SubaccountCreateSubAccountFuturesMovePositionV1Execute(r V1APISubaccountCreateSubAccountFuturesMovePositionV1Request) (*SubaccountCreateSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountFuturesMovePositionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountFuturesMovePositionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/move-position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromUserEmail == nil {
		return localVarReturnValue, nil, reportError("fromUserEmail is required and must be specified")
	}
	if r.orderArgs == nil {
		return localVarReturnValue, nil, reportError("orderArgs is required and must be specified")
	}
	if r.productType == nil {
		return localVarReturnValue, nil, reportError("productType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toUserEmail == nil {
		return localVarReturnValue, nil, reportError("toUserEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "fromUserEmail", r.fromUserEmail, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "orderArgs", r.orderArgs, "", "csv")
	parameterAddToHeaderOrQuery(localVarFormParams, "productType", r.productType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toUserEmail", r.toUserEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountFuturesTransferV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	asset *string
	email *string
	timestamp *int64
	type_ *int32
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountFuturesTransferV1Request) Amount(amount string) V1APISubaccountCreateSubAccountFuturesTransferV1Request {
	r.amount = &amount
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesTransferV1Request) Asset(asset string) V1APISubaccountCreateSubAccountFuturesTransferV1Request {
	r.asset = &asset
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesTransferV1Request) Email(email string) V1APISubaccountCreateSubAccountFuturesTransferV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesTransferV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountFuturesTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesTransferV1Request) Type_(type_ int32) V1APISubaccountCreateSubAccountFuturesTransferV1Request {
	r.type_ = &type_
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesTransferV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountFuturesTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountFuturesTransferV1Request) Execute() (*SubaccountCreateSubAccountFuturesTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountFuturesTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountFuturesTransferV1 Futures Transfer for Sub-account(For Master Account)

Futures Transfer for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountFuturesTransferV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountFuturesTransferV1(ctx context.Context) V1APISubaccountCreateSubAccountFuturesTransferV1Request {
	return V1APISubaccountCreateSubAccountFuturesTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountFuturesTransferV1Resp
func (a *V1APIService) SubaccountCreateSubAccountFuturesTransferV1Execute(r V1APISubaccountCreateSubAccountFuturesTransferV1Request) (*SubaccountCreateSubAccountFuturesTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountFuturesTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountFuturesTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountMarginEnableV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountMarginEnableV1Request) Email(email string) V1APISubaccountCreateSubAccountMarginEnableV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountCreateSubAccountMarginEnableV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountMarginEnableV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountMarginEnableV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountMarginEnableV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountMarginEnableV1Request) Execute() (*SubaccountCreateSubAccountMarginEnableV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountMarginEnableV1Execute(r)
}

/*
SubaccountCreateSubAccountMarginEnableV1 Enable Margin for Sub-account(For Master Account)

Enable Margin for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountMarginEnableV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountMarginEnableV1(ctx context.Context) V1APISubaccountCreateSubAccountMarginEnableV1Request {
	return V1APISubaccountCreateSubAccountMarginEnableV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountMarginEnableV1Resp
func (a *V1APIService) SubaccountCreateSubAccountMarginEnableV1Execute(r V1APISubaccountCreateSubAccountMarginEnableV1Request) (*SubaccountCreateSubAccountMarginEnableV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountMarginEnableV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountMarginEnableV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountMarginTransferV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	asset *string
	email *string
	timestamp *int64
	type_ *int32
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountMarginTransferV1Request) Amount(amount string) V1APISubaccountCreateSubAccountMarginTransferV1Request {
	r.amount = &amount
	return r
}

func (r V1APISubaccountCreateSubAccountMarginTransferV1Request) Asset(asset string) V1APISubaccountCreateSubAccountMarginTransferV1Request {
	r.asset = &asset
	return r
}

func (r V1APISubaccountCreateSubAccountMarginTransferV1Request) Email(email string) V1APISubaccountCreateSubAccountMarginTransferV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountCreateSubAccountMarginTransferV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountMarginTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountMarginTransferV1Request) Type_(type_ int32) V1APISubaccountCreateSubAccountMarginTransferV1Request {
	r.type_ = &type_
	return r
}

func (r V1APISubaccountCreateSubAccountMarginTransferV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountMarginTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountMarginTransferV1Request) Execute() (*SubaccountCreateSubAccountMarginTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountMarginTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountMarginTransferV1 Margin Transfer for Sub-account(For Master Account)

Margin Transfer for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountMarginTransferV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountMarginTransferV1(ctx context.Context) V1APISubaccountCreateSubAccountMarginTransferV1Request {
	return V1APISubaccountCreateSubAccountMarginTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountMarginTransferV1Resp
func (a *V1APIService) SubaccountCreateSubAccountMarginTransferV1Execute(r V1APISubaccountCreateSubAccountMarginTransferV1Request) (*SubaccountCreateSubAccountMarginTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountMarginTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountMarginTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountTransferSubToMasterV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountTransferSubToMasterV1Request) Amount(amount string) V1APISubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.amount = &amount
	return r
}

func (r V1APISubaccountCreateSubAccountTransferSubToMasterV1Request) Asset(asset string) V1APISubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.asset = &asset
	return r
}

func (r V1APISubaccountCreateSubAccountTransferSubToMasterV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountTransferSubToMasterV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountTransferSubToMasterV1Request) Execute() (*SubaccountCreateSubAccountTransferSubToMasterV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountTransferSubToMasterV1Execute(r)
}

/*
SubaccountCreateSubAccountTransferSubToMasterV1 Transfer to Master(For Sub-account)

Transfer to Master

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountTransferSubToMasterV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountTransferSubToMasterV1(ctx context.Context) V1APISubaccountCreateSubAccountTransferSubToMasterV1Request {
	return V1APISubaccountCreateSubAccountTransferSubToMasterV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountTransferSubToMasterV1Resp
func (a *V1APIService) SubaccountCreateSubAccountTransferSubToMasterV1Execute(r V1APISubaccountCreateSubAccountTransferSubToMasterV1Request) (*SubaccountCreateSubAccountTransferSubToMasterV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountTransferSubToMasterV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountTransferSubToMasterV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToMaster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountTransferSubToSubV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	asset *string
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountTransferSubToSubV1Request) Amount(amount string) V1APISubaccountCreateSubAccountTransferSubToSubV1Request {
	r.amount = &amount
	return r
}

func (r V1APISubaccountCreateSubAccountTransferSubToSubV1Request) Asset(asset string) V1APISubaccountCreateSubAccountTransferSubToSubV1Request {
	r.asset = &asset
	return r
}

func (r V1APISubaccountCreateSubAccountTransferSubToSubV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountTransferSubToSubV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountTransferSubToSubV1Request) ToEmail(toEmail string) V1APISubaccountCreateSubAccountTransferSubToSubV1Request {
	r.toEmail = &toEmail
	return r
}

func (r V1APISubaccountCreateSubAccountTransferSubToSubV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountTransferSubToSubV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountTransferSubToSubV1Request) Execute() (*SubaccountCreateSubAccountTransferSubToSubV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountTransferSubToSubV1Execute(r)
}

/*
SubaccountCreateSubAccountTransferSubToSubV1 Transfer to Sub-account of Same Master(For Sub-account)

Transfer to Sub-account of Same Master

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountTransferSubToSubV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountTransferSubToSubV1(ctx context.Context) V1APISubaccountCreateSubAccountTransferSubToSubV1Request {
	return V1APISubaccountCreateSubAccountTransferSubToSubV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountTransferSubToSubV1Resp
func (a *V1APIService) SubaccountCreateSubAccountTransferSubToSubV1Execute(r V1APISubaccountCreateSubAccountTransferSubToSubV1Request) (*SubaccountCreateSubAccountTransferSubToSubV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountTransferSubToSubV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountTransferSubToSubV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToSub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	asset *string
	fromAccountType *string
	timestamp *int64
	toAccountType *string
	clientTranId *string
	fromEmail *string
	recvWindow *int64
	symbol *string
	toEmail *string
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) Amount(amount string) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	r.amount = &amount
	return r
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) Asset(asset string) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	r.asset = &asset
	return r
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) FromAccountType(fromAccountType string) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	r.fromAccountType = &fromAccountType
	return r
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) ToAccountType(toAccountType string) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	r.toAccountType = &toAccountType
	return r
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) ClientTranId(clientTranId string) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) FromEmail(fromEmail string) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) Symbol(symbol string) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) ToEmail(toEmail string) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r V1APISubaccountCreateSubAccountUniversalTransferV1Request) Execute() (*SubaccountCreateSubAccountUniversalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountUniversalTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountUniversalTransferV1 Universal Transfer(For Master Account)

Universal Transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountUniversalTransferV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountUniversalTransferV1(ctx context.Context) V1APISubaccountCreateSubAccountUniversalTransferV1Request {
	return V1APISubaccountCreateSubAccountUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountUniversalTransferV1Resp
func (a *V1APIService) SubaccountCreateSubAccountUniversalTransferV1Execute(r V1APISubaccountCreateSubAccountUniversalTransferV1Request) (*SubaccountCreateSubAccountUniversalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountUniversalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromAccountType == nil {
		return localVarReturnValue, nil, reportError("fromAccountType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toAccountType == nil {
		return localVarReturnValue, nil, reportError("toAccountType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "clientTranId", r.clientTranId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "fromAccountType", r.fromAccountType, "", "")
	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toAccountType", r.toAccountType, "", "")
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountCreateSubAccountVirtualSubAccountV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	subAccountString *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APISubaccountCreateSubAccountVirtualSubAccountV1Request) SubAccountString(subAccountString string) V1APISubaccountCreateSubAccountVirtualSubAccountV1Request {
	r.subAccountString = &subAccountString
	return r
}

func (r V1APISubaccountCreateSubAccountVirtualSubAccountV1Request) Timestamp(timestamp int64) V1APISubaccountCreateSubAccountVirtualSubAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountCreateSubAccountVirtualSubAccountV1Request) RecvWindow(recvWindow int64) V1APISubaccountCreateSubAccountVirtualSubAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountCreateSubAccountVirtualSubAccountV1Request) Execute() (*SubaccountCreateSubAccountVirtualSubAccountV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountVirtualSubAccountV1Execute(r)
}

/*
SubaccountCreateSubAccountVirtualSubAccountV1 Create a Virtual Sub-account(For Master Account)

Create a Virtual Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountCreateSubAccountVirtualSubAccountV1Request
*/
func (a *V1APIService) SubaccountCreateSubAccountVirtualSubAccountV1(ctx context.Context) V1APISubaccountCreateSubAccountVirtualSubAccountV1Request {
	return V1APISubaccountCreateSubAccountVirtualSubAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountVirtualSubAccountV1Resp
func (a *V1APIService) SubaccountCreateSubAccountVirtualSubAccountV1Execute(r V1APISubaccountCreateSubAccountVirtualSubAccountV1Request) (*SubaccountCreateSubAccountVirtualSubAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountVirtualSubAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountCreateSubAccountVirtualSubAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/virtualSubAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountString == nil {
		return localVarReturnValue, nil, reportError("subAccountString is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountString", r.subAccountString, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	subAccountApiKey *string
	timestamp *int64
	ipAddress *string
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/api-management/Delete-IP-List-For-a-Sub-account-API-Key#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) Email(email string) V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) SubAccountApiKey(subAccountApiKey string) V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) Timestamp(timestamp int64) V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	r.timestamp = &timestamp
	return r
}

// Can be added in batches, separated by commas
func (r V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) IpAddress(ipAddress string) V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	r.ipAddress = &ipAddress
	return r
}

func (r V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) RecvWindow(recvWindow int64) V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) Execute() (*SubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Execute(r)
}

/*
SubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1 Delete IP List For a Sub-account API Key(For Master Account)

Delete IP List For a Sub-account API Key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request
*/
func (a *V1APIService) SubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1(ctx context.Context) V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	return V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Resp
func (a *V1APIService) SubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Execute(r V1APISubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) (*SubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountDeleteSubAccountSubAccountApiIpRestrictionIpListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/subAccountApi/ipRestriction/ipList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountApiKey", r.subAccountApiKey, "form", "")
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipAddress", r.ipAddress, "form", "")
	} else {
		var defaultValue string = ""
		r.ipAddress = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetCapitalDepositSubAddressV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	coin *string
	timestamp *int64
	network *string
	amount *string
	recvWindow *int64
}

// Sub account email
func (r V1APISubaccountGetCapitalDepositSubAddressV1Request) Email(email string) V1APISubaccountGetCapitalDepositSubAddressV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountGetCapitalDepositSubAddressV1Request) Coin(coin string) V1APISubaccountGetCapitalDepositSubAddressV1Request {
	r.coin = &coin
	return r
}

func (r V1APISubaccountGetCapitalDepositSubAddressV1Request) Timestamp(timestamp int64) V1APISubaccountGetCapitalDepositSubAddressV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetCapitalDepositSubAddressV1Request) Network(network string) V1APISubaccountGetCapitalDepositSubAddressV1Request {
	r.network = &network
	return r
}

func (r V1APISubaccountGetCapitalDepositSubAddressV1Request) Amount(amount string) V1APISubaccountGetCapitalDepositSubAddressV1Request {
	r.amount = &amount
	return r
}

func (r V1APISubaccountGetCapitalDepositSubAddressV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetCapitalDepositSubAddressV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetCapitalDepositSubAddressV1Request) Execute() (*SubaccountGetCapitalDepositSubAddressV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetCapitalDepositSubAddressV1Execute(r)
}

/*
SubaccountGetCapitalDepositSubAddressV1 Get Sub-account Deposit Address(For Master Account)

Fetch sub-account deposit address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetCapitalDepositSubAddressV1Request
*/
func (a *V1APIService) SubaccountGetCapitalDepositSubAddressV1(ctx context.Context) V1APISubaccountGetCapitalDepositSubAddressV1Request {
	return V1APISubaccountGetCapitalDepositSubAddressV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetCapitalDepositSubAddressV1Resp
func (a *V1APIService) SubaccountGetCapitalDepositSubAddressV1Execute(r V1APISubaccountGetCapitalDepositSubAddressV1Request) (*SubaccountGetCapitalDepositSubAddressV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetCapitalDepositSubAddressV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetCapitalDepositSubAddressV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	} else {
		var defaultValue string = ""
		r.amount = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetCapitalDepositSubHisrecV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	timestamp *int64
	coin *string
	status *int32
	startTime *int64
	endTime *int64
	limit *int32
	offset *int32
	recvWindow *int64
	txId *string
}

// Sub account email
func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) Email(email string) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) Timestamp(timestamp int64) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) Coin(coin string) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	r.coin = &coin
	return r
}

// 0(0:pending,6: credited but cannot withdraw,7:Wrong Deposit,8:Waiting User confirm,1:success)
func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) Status(status int32) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	r.status = &status
	return r
}

func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) StartTime(startTime int64) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) EndTime(endTime int64) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) Limit(limit int32) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	r.limit = &limit
	return r
}

// default:0
func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) Offset(offset int32) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	r.offset = &offset
	return r
}

func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) TxId(txId string) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	r.txId = &txId
	return r
}

func (r V1APISubaccountGetCapitalDepositSubHisrecV1Request) Execute() ([]SubaccountGetCapitalDepositSubHisrecV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetCapitalDepositSubHisrecV1Execute(r)
}

/*
SubaccountGetCapitalDepositSubHisrecV1 Get Sub-account Deposit History(For Master Account)

Fetch sub-account deposit history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetCapitalDepositSubHisrecV1Request
*/
func (a *V1APIService) SubaccountGetCapitalDepositSubHisrecV1(ctx context.Context) V1APISubaccountGetCapitalDepositSubHisrecV1Request {
	return V1APISubaccountGetCapitalDepositSubHisrecV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetCapitalDepositSubHisrecV1RespItem
func (a *V1APIService) SubaccountGetCapitalDepositSubHisrecV1Execute(r V1APISubaccountGetCapitalDepositSubHisrecV1Request) ([]SubaccountGetCapitalDepositSubHisrecV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetCapitalDepositSubHisrecV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetCapitalDepositSubHisrecV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subHisrec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	type_ *string
	timestamp *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request) Email(email string) V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.email = &email
	return r
}

// &amp;#34;SPOT&amp;#34;, &amp;#34;MARGIN&amp;#34;（cross）, &amp;#34;FUTURES&amp;#34;（UM）
func (r V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request) Type_(type_ string) V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.type_ = &type_
	return r
}

func (r V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request) Timestamp(timestamp int64) V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request) StartTime(startTime int64) V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request) EndTime(endTime int64) V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.endTime = &endTime
	return r
}

// min 7, max 30, default 7
func (r V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request) Limit(limit int32) V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.limit = &limit
	return r
}

func (r V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request) Execute() (*SubaccountGetManagedSubaccountAccountSnapshotV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountAccountSnapshotV1Execute(r)
}

/*
SubaccountGetManagedSubaccountAccountSnapshotV1 Query Managed Sub-account Snapshot(For Investor Master Account)

Query Managed Sub-account Snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request
*/
func (a *V1APIService) SubaccountGetManagedSubaccountAccountSnapshotV1(ctx context.Context) V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	return V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountAccountSnapshotV1Resp
func (a *V1APIService) SubaccountGetManagedSubaccountAccountSnapshotV1Execute(r V1APISubaccountGetManagedSubaccountAccountSnapshotV1Request) (*SubaccountGetManagedSubaccountAccountSnapshotV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountAccountSnapshotV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetManagedSubaccountAccountSnapshotV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/accountSnapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 7
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetManagedSubaccountAssetV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APISubaccountGetManagedSubaccountAssetV1Request) Email(email string) V1APISubaccountGetManagedSubaccountAssetV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountGetManagedSubaccountAssetV1Request) Timestamp(timestamp int64) V1APISubaccountGetManagedSubaccountAssetV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetManagedSubaccountAssetV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetManagedSubaccountAssetV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetManagedSubaccountAssetV1Request) Execute() ([]SubaccountGetManagedSubaccountAssetV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountAssetV1Execute(r)
}

/*
SubaccountGetManagedSubaccountAssetV1 Query Managed Sub-account Asset Details(For Investor Master Account)

Query Managed Sub-account Asset Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetManagedSubaccountAssetV1Request
*/
func (a *V1APIService) SubaccountGetManagedSubaccountAssetV1(ctx context.Context) V1APISubaccountGetManagedSubaccountAssetV1Request {
	return V1APISubaccountGetManagedSubaccountAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetManagedSubaccountAssetV1RespItem
func (a *V1APIService) SubaccountGetManagedSubaccountAssetV1Execute(r V1APISubaccountGetManagedSubaccountAssetV1Request) ([]SubaccountGetManagedSubaccountAssetV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetManagedSubaccountAssetV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetManagedSubaccountAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetManagedSubaccountDepositAddressV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	coin *string
	timestamp *int64
	network *string
	amount *string
	recvWindow *int64
}

// Sub user email
func (r V1APISubaccountGetManagedSubaccountDepositAddressV1Request) Email(email string) V1APISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountGetManagedSubaccountDepositAddressV1Request) Coin(coin string) V1APISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.coin = &coin
	return r
}

func (r V1APISubaccountGetManagedSubaccountDepositAddressV1Request) Timestamp(timestamp int64) V1APISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.timestamp = &timestamp
	return r
}

// networks can be found in &#x60;GET /sapi/v1/capital/deposit/address&#x60;
func (r V1APISubaccountGetManagedSubaccountDepositAddressV1Request) Network(network string) V1APISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.network = &network
	return r
}

func (r V1APISubaccountGetManagedSubaccountDepositAddressV1Request) Amount(amount string) V1APISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.amount = &amount
	return r
}

func (r V1APISubaccountGetManagedSubaccountDepositAddressV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetManagedSubaccountDepositAddressV1Request) Execute() (*SubaccountGetManagedSubaccountDepositAddressV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountDepositAddressV1Execute(r)
}

/*
SubaccountGetManagedSubaccountDepositAddressV1 Get Managed Sub-account Deposit Address (For Investor Master Account)(USER_DATA)

Get investor's managed sub-account deposit address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetManagedSubaccountDepositAddressV1Request
*/
func (a *V1APIService) SubaccountGetManagedSubaccountDepositAddressV1(ctx context.Context) V1APISubaccountGetManagedSubaccountDepositAddressV1Request {
	return V1APISubaccountGetManagedSubaccountDepositAddressV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountDepositAddressV1Resp
func (a *V1APIService) SubaccountGetManagedSubaccountDepositAddressV1Execute(r V1APISubaccountGetManagedSubaccountDepositAddressV1Request) (*SubaccountGetManagedSubaccountDepositAddressV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountDepositAddressV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetManagedSubaccountDepositAddressV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/deposit/address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	} else {
		var defaultValue string = ""
		r.amount = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetManagedSubaccountFetchFutureAssetV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	accountType *string
}

// Managed Sub Account Email
func (r V1APISubaccountGetManagedSubaccountFetchFutureAssetV1Request) Email(email string) V1APISubaccountGetManagedSubaccountFetchFutureAssetV1Request {
	r.email = &email
	return r
}

// No input or input &amp;#34;USDT_FUTURE&amp;#34; to get UM Futures account details. Input &amp;#34;COIN_FUTURE&amp;#34; to get CM Futures account details.
func (r V1APISubaccountGetManagedSubaccountFetchFutureAssetV1Request) AccountType(accountType string) V1APISubaccountGetManagedSubaccountFetchFutureAssetV1Request {
	r.accountType = &accountType
	return r
}

func (r V1APISubaccountGetManagedSubaccountFetchFutureAssetV1Request) Execute() (*SubaccountGetManagedSubaccountFetchFutureAssetV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountFetchFutureAssetV1Execute(r)
}

/*
SubaccountGetManagedSubaccountFetchFutureAssetV1 Query Managed Sub-account Futures Asset Details(For Investor Master Account)(USER_DATA)

Investor can use this api to query managed sub account futures asset details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetManagedSubaccountFetchFutureAssetV1Request
*/
func (a *V1APIService) SubaccountGetManagedSubaccountFetchFutureAssetV1(ctx context.Context) V1APISubaccountGetManagedSubaccountFetchFutureAssetV1Request {
	return V1APISubaccountGetManagedSubaccountFetchFutureAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountFetchFutureAssetV1Resp
func (a *V1APIService) SubaccountGetManagedSubaccountFetchFutureAssetV1Execute(r V1APISubaccountGetManagedSubaccountFetchFutureAssetV1Request) (*SubaccountGetManagedSubaccountFetchFutureAssetV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountFetchFutureAssetV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetManagedSubaccountFetchFutureAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/fetch-future-asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "form", "")
	} else {
		var defaultValue string = ""
		r.accountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetManagedSubaccountInfoV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	email *string
	page *int32
	limit *int32
	recvWindow *int64
}

func (r V1APISubaccountGetManagedSubaccountInfoV1Request) Timestamp(timestamp int64) V1APISubaccountGetManagedSubaccountInfoV1Request {
	r.timestamp = &timestamp
	return r
}

// Managed sub-account email
func (r V1APISubaccountGetManagedSubaccountInfoV1Request) Email(email string) V1APISubaccountGetManagedSubaccountInfoV1Request {
	r.email = &email
	return r
}

// Default value: 1
func (r V1APISubaccountGetManagedSubaccountInfoV1Request) Page(page int32) V1APISubaccountGetManagedSubaccountInfoV1Request {
	r.page = &page
	return r
}

// Default value: 20, Max value: 20
func (r V1APISubaccountGetManagedSubaccountInfoV1Request) Limit(limit int32) V1APISubaccountGetManagedSubaccountInfoV1Request {
	r.limit = &limit
	return r
}

func (r V1APISubaccountGetManagedSubaccountInfoV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetManagedSubaccountInfoV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetManagedSubaccountInfoV1Request) Execute() (*SubaccountGetManagedSubaccountInfoV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountInfoV1Execute(r)
}

/*
SubaccountGetManagedSubaccountInfoV1 Query Managed Sub-account List(For Investor)(USER_DATA)

Get investor's managed sub-account list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetManagedSubaccountInfoV1Request
*/
func (a *V1APIService) SubaccountGetManagedSubaccountInfoV1(ctx context.Context) V1APISubaccountGetManagedSubaccountInfoV1Request {
	return V1APISubaccountGetManagedSubaccountInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountInfoV1Resp
func (a *V1APIService) SubaccountGetManagedSubaccountInfoV1Execute(r V1APISubaccountGetManagedSubaccountInfoV1Request) (*SubaccountGetManagedSubaccountInfoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountInfoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetManagedSubaccountInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetManagedSubaccountMarginAssetV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	accountType *string
}

// Managed Sub Account Email
func (r V1APISubaccountGetManagedSubaccountMarginAssetV1Request) Email(email string) V1APISubaccountGetManagedSubaccountMarginAssetV1Request {
	r.email = &email
	return r
}

// No input or input &amp;#34;MARGIN&amp;#34; to get Cross Margin account details. Input &amp;#34;ISOLATED_MARGIN&amp;#34; to get Isolated Margin account details.
func (r V1APISubaccountGetManagedSubaccountMarginAssetV1Request) AccountType(accountType string) V1APISubaccountGetManagedSubaccountMarginAssetV1Request {
	r.accountType = &accountType
	return r
}

func (r V1APISubaccountGetManagedSubaccountMarginAssetV1Request) Execute() (*SubaccountGetManagedSubaccountMarginAssetV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountMarginAssetV1Execute(r)
}

/*
SubaccountGetManagedSubaccountMarginAssetV1 Query Managed Sub-account Margin Asset Details(For Investor Master Account)(USER_DATA)

Investor can use this api to query managed sub account margin asset details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetManagedSubaccountMarginAssetV1Request
*/
func (a *V1APIService) SubaccountGetManagedSubaccountMarginAssetV1(ctx context.Context) V1APISubaccountGetManagedSubaccountMarginAssetV1Request {
	return V1APISubaccountGetManagedSubaccountMarginAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountMarginAssetV1Resp
func (a *V1APIService) SubaccountGetManagedSubaccountMarginAssetV1Execute(r V1APISubaccountGetManagedSubaccountMarginAssetV1Request) (*SubaccountGetManagedSubaccountMarginAssetV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountMarginAssetV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetManagedSubaccountMarginAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/marginAsset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "form", "")
	} else {
		var defaultValue string = ""
		r.accountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	transfers *string
	transferFunctionAccountType *string
}

// Managed Sub Account Email
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) Email(email string) V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.email = &email
	return r
}

// Start Time
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) StartTime(startTime int64) V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.startTime = &startTime
	return r
}

// End Time (The start time and end time interval cannot exceed half a year)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) EndTime(endTime int64) V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.endTime = &endTime
	return r
}

// Page
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) Page(page int32) V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.page = &page
	return r
}

// Limit (Max: 500)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) Limit(limit int32) V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.limit = &limit
	return r
}

// Transfer Direction (FROM/TO)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) Transfers(transfers string) V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.transfers = &transfers
	return r
}

// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) TransferFunctionAccountType(transferFunctionAccountType string) V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.transferFunctionAccountType = &transferFunctionAccountType
	return r
}

func (r V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) Execute() (*SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Execute(r)
}

/*
SubaccountGetManagedSubaccountQueryTransLogForInvestorV1 Query Managed Sub Account Transfer Log(For Investor Master Account)(USER_DATA)

Investor can use this api to query managed sub account transfer log. This endpoint is available for investor of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team.
Please refer to link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request
*/
func (a *V1APIService) SubaccountGetManagedSubaccountQueryTransLogForInvestorV1(ctx context.Context) V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	return V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp
func (a *V1APIService) SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Execute(r V1APISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) (*SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetManagedSubaccountQueryTransLogForInvestorV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/queryTransLogForInvestor"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.transfers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transfers", r.transfers, "form", "")
	} else {
		var defaultValue string = ""
		r.transfers = &defaultValue
	}
	if r.transferFunctionAccountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferFunctionAccountType", r.transferFunctionAccountType, "form", "")
	} else {
		var defaultValue string = ""
		r.transferFunctionAccountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	transfers *string
	transferFunctionAccountType *string
}

// Managed Sub Account Email
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) Email(email string) V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.email = &email
	return r
}

// Start Time
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) StartTime(startTime int64) V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.startTime = &startTime
	return r
}

// End Time (The start time and end time interval cannot exceed half a year)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) EndTime(endTime int64) V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.endTime = &endTime
	return r
}

// Page
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) Page(page int32) V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.page = &page
	return r
}

// Limit (Max: 500)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) Limit(limit int32) V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.limit = &limit
	return r
}

// Transfer Direction (FROM/TO)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) Transfers(transfers string) V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.transfers = &transfers
	return r
}

// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) TransferFunctionAccountType(transferFunctionAccountType string) V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.transferFunctionAccountType = &transferFunctionAccountType
	return r
}

func (r V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) Execute() (*SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Execute(r)
}

/*
SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1 Query Managed Sub Account Transfer Log(For Trading Team Master Account)(USER_DATA)

Trading team can use this api to query managed sub account transfer log. This endpoint is available for trading team of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team.
Please refer to link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request
*/
func (a *V1APIService) SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1(ctx context.Context) V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	return V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp
func (a *V1APIService) SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Execute(r V1APISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) (*SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/queryTransLogForTradeParent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.transfers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transfers", r.transfers, "form", "")
	} else {
		var defaultValue string = ""
		r.transfers = &defaultValue
	}
	if r.transferFunctionAccountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferFunctionAccountType", r.transferFunctionAccountType, "form", "")
	} else {
		var defaultValue string = ""
		r.transferFunctionAccountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetManagedSubaccountQueryTransLogV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	timestamp *int64
	transfers *string
	transferFunctionAccountType *string
	recvWindow *int64
}

// Start Time
func (r V1APISubaccountGetManagedSubaccountQueryTransLogV1Request) StartTime(startTime int64) V1APISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.startTime = &startTime
	return r
}

// End Time (The start time and end time interval cannot exceed half a year)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogV1Request) EndTime(endTime int64) V1APISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.endTime = &endTime
	return r
}

// Page
func (r V1APISubaccountGetManagedSubaccountQueryTransLogV1Request) Page(page int32) V1APISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.page = &page
	return r
}

// Limit (Max: 500)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogV1Request) Limit(limit int32) V1APISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.limit = &limit
	return r
}

func (r V1APISubaccountGetManagedSubaccountQueryTransLogV1Request) Timestamp(timestamp int64) V1APISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.timestamp = &timestamp
	return r
}

// Transfer Direction (FROM/TO)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogV1Request) Transfers(transfers string) V1APISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.transfers = &transfers
	return r
}

// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
func (r V1APISubaccountGetManagedSubaccountQueryTransLogV1Request) TransferFunctionAccountType(transferFunctionAccountType string) V1APISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.transferFunctionAccountType = &transferFunctionAccountType
	return r
}

func (r V1APISubaccountGetManagedSubaccountQueryTransLogV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetManagedSubaccountQueryTransLogV1Request) Execute() (*SubaccountGetManagedSubaccountQueryTransLogV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountQueryTransLogV1Execute(r)
}

/*
SubaccountGetManagedSubaccountQueryTransLogV1 Query Managed Sub Account Transfer Log (For Trading Team Sub Account)(USER_DATA)

Query Managed Sub Account Transfer Log (For Trading Team Sub Account)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetManagedSubaccountQueryTransLogV1Request
*/
func (a *V1APIService) SubaccountGetManagedSubaccountQueryTransLogV1(ctx context.Context) V1APISubaccountGetManagedSubaccountQueryTransLogV1Request {
	return V1APISubaccountGetManagedSubaccountQueryTransLogV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountQueryTransLogV1Resp
func (a *V1APIService) SubaccountGetManagedSubaccountQueryTransLogV1Execute(r V1APISubaccountGetManagedSubaccountQueryTransLogV1Request) (*SubaccountGetManagedSubaccountQueryTransLogV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountQueryTransLogV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetManagedSubaccountQueryTransLogV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/query-trans-log"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.transfers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transfers", r.transfers, "form", "")
	} else {
		var defaultValue string = ""
		r.transfers = &defaultValue
	}
	if r.transferFunctionAccountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferFunctionAccountType", r.transferFunctionAccountType, "form", "")
	} else {
		var defaultValue string = ""
		r.transferFunctionAccountType = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountFuturesAccountSummaryV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APISubaccountGetSubAccountFuturesAccountSummaryV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountFuturesAccountSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetSubAccountFuturesAccountSummaryV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountFuturesAccountSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountFuturesAccountSummaryV1Request) Execute() (*SubaccountGetSubAccountFuturesAccountSummaryV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesAccountSummaryV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesAccountSummaryV1 Get Summary of Sub-account's Futures Account(For Master Account)

Get Summary of Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountFuturesAccountSummaryV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountFuturesAccountSummaryV1(ctx context.Context) V1APISubaccountGetSubAccountFuturesAccountSummaryV1Request {
	return V1APISubaccountGetSubAccountFuturesAccountSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesAccountSummaryV1Resp
func (a *V1APIService) SubaccountGetSubAccountFuturesAccountSummaryV1Execute(r V1APISubaccountGetSubAccountFuturesAccountSummaryV1Request) (*SubaccountGetSubAccountFuturesAccountSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesAccountSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountFuturesAccountSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountFuturesAccountV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Futures-Account#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r V1APISubaccountGetSubAccountFuturesAccountV1Request) Email(email string) V1APISubaccountGetSubAccountFuturesAccountV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountGetSubAccountFuturesAccountV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountFuturesAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetSubAccountFuturesAccountV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountFuturesAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountFuturesAccountV1Request) Execute() (*SubaccountGetSubAccountFuturesAccountV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesAccountV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesAccountV1 Get Detail on Sub-account's Futures Account(For Master Account)

Get Detail on Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountFuturesAccountV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountFuturesAccountV1(ctx context.Context) V1APISubaccountGetSubAccountFuturesAccountV1Request {
	return V1APISubaccountGetSubAccountFuturesAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesAccountV1Resp
func (a *V1APIService) SubaccountGetSubAccountFuturesAccountV1Execute(r V1APISubaccountGetSubAccountFuturesAccountV1Request) (*SubaccountGetSubAccountFuturesAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountFuturesAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountFuturesInternalTransferV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	futuresType *int64
	timestamp *int64
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Query-Sub-account-Futures-Asset-Transfer-History#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r V1APISubaccountGetSubAccountFuturesInternalTransferV1Request) Email(email string) V1APISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.email = &email
	return r
}

// 1:USDT-margined Futures，2: Coin-margined Futures
func (r V1APISubaccountGetSubAccountFuturesInternalTransferV1Request) FuturesType(futuresType int64) V1APISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.futuresType = &futuresType
	return r
}

func (r V1APISubaccountGetSubAccountFuturesInternalTransferV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

// Cannot be earlier than 1 month ago
func (r V1APISubaccountGetSubAccountFuturesInternalTransferV1Request) StartTime(startTime int64) V1APISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APISubaccountGetSubAccountFuturesInternalTransferV1Request) EndTime(endTime int64) V1APISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default value: 1
func (r V1APISubaccountGetSubAccountFuturesInternalTransferV1Request) Page(page int32) V1APISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.page = &page
	return r
}

// Default value: 50, Max value: 500
func (r V1APISubaccountGetSubAccountFuturesInternalTransferV1Request) Limit(limit int32) V1APISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.limit = &limit
	return r
}

func (r V1APISubaccountGetSubAccountFuturesInternalTransferV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountFuturesInternalTransferV1Request) Execute() (*SubaccountGetSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesInternalTransferV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesInternalTransferV1 Query Sub-account Futures Asset Transfer History(For Master Account)

Query Sub-account Futures Asset Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountFuturesInternalTransferV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountFuturesInternalTransferV1(ctx context.Context) V1APISubaccountGetSubAccountFuturesInternalTransferV1Request {
	return V1APISubaccountGetSubAccountFuturesInternalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesInternalTransferV1Resp
func (a *V1APIService) SubaccountGetSubAccountFuturesInternalTransferV1Execute(r V1APISubaccountGetSubAccountFuturesInternalTransferV1Request) (*SubaccountGetSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesInternalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountFuturesInternalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountFuturesMovePositionV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	page *int32
	row *int32
	timestamp *int64
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r V1APISubaccountGetSubAccountFuturesMovePositionV1Request) Symbol(symbol string) V1APISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APISubaccountGetSubAccountFuturesMovePositionV1Request) Page(page int32) V1APISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.page = &page
	return r
}

func (r V1APISubaccountGetSubAccountFuturesMovePositionV1Request) Row(row int32) V1APISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.row = &row
	return r
}

func (r V1APISubaccountGetSubAccountFuturesMovePositionV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetSubAccountFuturesMovePositionV1Request) StartTime(startTime int64) V1APISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APISubaccountGetSubAccountFuturesMovePositionV1Request) EndTime(endTime int64) V1APISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APISubaccountGetSubAccountFuturesMovePositionV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountFuturesMovePositionV1Request) Execute() (*SubaccountGetSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesMovePositionV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesMovePositionV1 Get Move Position History for Sub-account (For Master Account)

Query move position history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountFuturesMovePositionV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountFuturesMovePositionV1(ctx context.Context) V1APISubaccountGetSubAccountFuturesMovePositionV1Request {
	return V1APISubaccountGetSubAccountFuturesMovePositionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesMovePositionV1Resp
func (a *V1APIService) SubaccountGetSubAccountFuturesMovePositionV1Execute(r V1APISubaccountGetSubAccountFuturesMovePositionV1Request) (*SubaccountGetSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesMovePositionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountFuturesMovePositionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/move-position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.row == nil {
		return localVarReturnValue, nil, reportError("row is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "row", r.row, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountFuturesPositionRiskV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/account-management/Get-Futures-Position-Risk-of-Sub-account#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r V1APISubaccountGetSubAccountFuturesPositionRiskV1Request) Email(email string) V1APISubaccountGetSubAccountFuturesPositionRiskV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountGetSubAccountFuturesPositionRiskV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountFuturesPositionRiskV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetSubAccountFuturesPositionRiskV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountFuturesPositionRiskV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountFuturesPositionRiskV1Request) Execute() ([]SubaccountGetSubAccountFuturesPositionRiskV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesPositionRiskV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesPositionRiskV1 Get Futures Position-Risk of Sub-account(For Master Account)

Get Futures Position-Risk of Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountFuturesPositionRiskV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountFuturesPositionRiskV1(ctx context.Context) V1APISubaccountGetSubAccountFuturesPositionRiskV1Request {
	return V1APISubaccountGetSubAccountFuturesPositionRiskV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetSubAccountFuturesPositionRiskV1RespItem
func (a *V1APIService) SubaccountGetSubAccountFuturesPositionRiskV1Execute(r V1APISubaccountGetSubAccountFuturesPositionRiskV1Request) ([]SubaccountGetSubAccountFuturesPositionRiskV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetSubAccountFuturesPositionRiskV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountFuturesPositionRiskV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountListV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	email *string
	isFreeze *string
	page *int32
	limit *int32
	recvWindow *int64
}

func (r V1APISubaccountGetSubAccountListV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountListV1Request {
	r.timestamp = &timestamp
	return r
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/account-management/Query-Sub-account-List#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r V1APISubaccountGetSubAccountListV1Request) Email(email string) V1APISubaccountGetSubAccountListV1Request {
	r.email = &email
	return r
}

// true or false
func (r V1APISubaccountGetSubAccountListV1Request) IsFreeze(isFreeze string) V1APISubaccountGetSubAccountListV1Request {
	r.isFreeze = &isFreeze
	return r
}

// Default value: 1
func (r V1APISubaccountGetSubAccountListV1Request) Page(page int32) V1APISubaccountGetSubAccountListV1Request {
	r.page = &page
	return r
}

// Default value: 1, Max value: 200
func (r V1APISubaccountGetSubAccountListV1Request) Limit(limit int32) V1APISubaccountGetSubAccountListV1Request {
	r.limit = &limit
	return r
}

func (r V1APISubaccountGetSubAccountListV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountListV1Request) Execute() (*SubaccountGetSubAccountListV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountListV1Execute(r)
}

/*
SubaccountGetSubAccountListV1 Query Sub-account List(For Master Account)

Query Sub-account List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountListV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountListV1(ctx context.Context) V1APISubaccountGetSubAccountListV1Request {
	return V1APISubaccountGetSubAccountListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountListV1Resp
func (a *V1APIService) SubaccountGetSubAccountListV1Execute(r V1APISubaccountGetSubAccountListV1Request) (*SubaccountGetSubAccountListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.isFreeze != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isFreeze", r.isFreeze, "form", "")
	} else {
		var defaultValue string = ""
		r.isFreeze = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountMarginAccountSummaryV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APISubaccountGetSubAccountMarginAccountSummaryV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountMarginAccountSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetSubAccountMarginAccountSummaryV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountMarginAccountSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountMarginAccountSummaryV1Request) Execute() (*SubaccountGetSubAccountMarginAccountSummaryV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountMarginAccountSummaryV1Execute(r)
}

/*
SubaccountGetSubAccountMarginAccountSummaryV1 Get Summary of Sub-account's Margin Account(For Master Account)

Get Summary of Sub-account's Margin Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountMarginAccountSummaryV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountMarginAccountSummaryV1(ctx context.Context) V1APISubaccountGetSubAccountMarginAccountSummaryV1Request {
	return V1APISubaccountGetSubAccountMarginAccountSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountMarginAccountSummaryV1Resp
func (a *V1APIService) SubaccountGetSubAccountMarginAccountSummaryV1Execute(r V1APISubaccountGetSubAccountMarginAccountSummaryV1Request) (*SubaccountGetSubAccountMarginAccountSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountMarginAccountSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountMarginAccountSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountMarginAccountV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Margin-Account#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r V1APISubaccountGetSubAccountMarginAccountV1Request) Email(email string) V1APISubaccountGetSubAccountMarginAccountV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountGetSubAccountMarginAccountV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountMarginAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetSubAccountMarginAccountV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountMarginAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountMarginAccountV1Request) Execute() (*SubaccountGetSubAccountMarginAccountV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountMarginAccountV1Execute(r)
}

/*
SubaccountGetSubAccountMarginAccountV1 Get Detail on Sub-account's Margin Account(For Master Account)

Get Detail on Sub-account's Margin Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountMarginAccountV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountMarginAccountV1(ctx context.Context) V1APISubaccountGetSubAccountMarginAccountV1Request {
	return V1APISubaccountGetSubAccountMarginAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountMarginAccountV1Resp
func (a *V1APIService) SubaccountGetSubAccountMarginAccountV1Execute(r V1APISubaccountGetSubAccountMarginAccountV1Request) (*SubaccountGetSubAccountMarginAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountMarginAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountMarginAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountSpotSummaryV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	email *string
	page *int64
	size *int64
	recvWindow *int64
}

func (r V1APISubaccountGetSubAccountSpotSummaryV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountSpotSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

// Sub account email
func (r V1APISubaccountGetSubAccountSpotSummaryV1Request) Email(email string) V1APISubaccountGetSubAccountSpotSummaryV1Request {
	r.email = &email
	return r
}

// default 1
func (r V1APISubaccountGetSubAccountSpotSummaryV1Request) Page(page int64) V1APISubaccountGetSubAccountSpotSummaryV1Request {
	r.page = &page
	return r
}

// default 10, max 20
func (r V1APISubaccountGetSubAccountSpotSummaryV1Request) Size(size int64) V1APISubaccountGetSubAccountSpotSummaryV1Request {
	r.size = &size
	return r
}

func (r V1APISubaccountGetSubAccountSpotSummaryV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountSpotSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountSpotSummaryV1Request) Execute() (*SubaccountGetSubAccountSpotSummaryV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountSpotSummaryV1Execute(r)
}

/*
SubaccountGetSubAccountSpotSummaryV1 Query Sub-account Spot Assets Summary(For Master Account)

Get BTC valued asset summary of subaccounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountSpotSummaryV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountSpotSummaryV1(ctx context.Context) V1APISubaccountGetSubAccountSpotSummaryV1Request {
	return V1APISubaccountGetSubAccountSpotSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountSpotSummaryV1Resp
func (a *V1APIService) SubaccountGetSubAccountSpotSummaryV1Execute(r V1APISubaccountGetSubAccountSpotSummaryV1Request) (*SubaccountGetSubAccountSpotSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountSpotSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountSpotSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/spotSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountStatusV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	email *string
	recvWindow *int64
}

func (r V1APISubaccountGetSubAccountStatusV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountStatusV1Request {
	r.timestamp = &timestamp
	return r
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/account-management/Get-Sub-accounts-Status-on-Margin-Or-Futures#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r V1APISubaccountGetSubAccountStatusV1Request) Email(email string) V1APISubaccountGetSubAccountStatusV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountGetSubAccountStatusV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountStatusV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountStatusV1Request) Execute() ([]SubaccountGetSubAccountStatusV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountStatusV1Execute(r)
}

/*
SubaccountGetSubAccountStatusV1 Get Sub-account's Status on Margin Or Futures(For Master Account)

Get Sub-account's Status on Margin Or Futures

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountStatusV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountStatusV1(ctx context.Context) V1APISubaccountGetSubAccountStatusV1Request {
	return V1APISubaccountGetSubAccountStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetSubAccountStatusV1RespItem
func (a *V1APIService) SubaccountGetSubAccountStatusV1Execute(r V1APISubaccountGetSubAccountStatusV1Request) ([]SubaccountGetSubAccountStatusV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetSubAccountStatusV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	subAccountApiKey *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/api-management#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request) Email(email string) V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request) SubAccountApiKey(subAccountApiKey string) V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request) Execute() (*SubaccountGetSubAccountSubAccountApiIpRestrictionV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountSubAccountApiIpRestrictionV1Execute(r)
}

/*
SubaccountGetSubAccountSubAccountApiIpRestrictionV1 Get IP Restriction for a Sub-account API Key(For Master Account)

Get IP Restriction for a Sub-account API Key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountSubAccountApiIpRestrictionV1(ctx context.Context) V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request {
	return V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountSubAccountApiIpRestrictionV1Resp
func (a *V1APIService) SubaccountGetSubAccountSubAccountApiIpRestrictionV1Execute(r V1APISubaccountGetSubAccountSubAccountApiIpRestrictionV1Request) (*SubaccountGetSubAccountSubAccountApiIpRestrictionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountSubAccountApiIpRestrictionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountSubAccountApiIpRestrictionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/subAccountApi/ipRestriction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountApiKey", r.subAccountApiKey, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountSubTransferHistoryV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	fromEmail *string
	toEmail *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r V1APISubaccountGetSubAccountSubTransferHistoryV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetSubAccountSubTransferHistoryV1Request) FromEmail(fromEmail string) V1APISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r V1APISubaccountGetSubAccountSubTransferHistoryV1Request) ToEmail(toEmail string) V1APISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.toEmail = &toEmail
	return r
}

func (r V1APISubaccountGetSubAccountSubTransferHistoryV1Request) StartTime(startTime int64) V1APISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APISubaccountGetSubAccountSubTransferHistoryV1Request) EndTime(endTime int64) V1APISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default value: 1
func (r V1APISubaccountGetSubAccountSubTransferHistoryV1Request) Page(page int32) V1APISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.page = &page
	return r
}

// Default value: 500
func (r V1APISubaccountGetSubAccountSubTransferHistoryV1Request) Limit(limit int32) V1APISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.limit = &limit
	return r
}

func (r V1APISubaccountGetSubAccountSubTransferHistoryV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountSubTransferHistoryV1Request) Execute() ([]SubaccountGetSubAccountSubTransferHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountSubTransferHistoryV1Execute(r)
}

/*
SubaccountGetSubAccountSubTransferHistoryV1 Query Sub-account Spot Asset Transfer History(For Master Account)

Query Sub-account Spot Asset Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountSubTransferHistoryV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountSubTransferHistoryV1(ctx context.Context) V1APISubaccountGetSubAccountSubTransferHistoryV1Request {
	return V1APISubaccountGetSubAccountSubTransferHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetSubAccountSubTransferHistoryV1RespItem
func (a *V1APIService) SubaccountGetSubAccountSubTransferHistoryV1Execute(r V1APISubaccountGetSubAccountSubTransferHistoryV1Request) ([]SubaccountGetSubAccountSubTransferHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetSubAccountSubTransferHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountSubTransferHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/sub/transfer/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromEmail", r.fromEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.fromEmail = &defaultValue
	}
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toEmail", r.toEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.toEmail = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountTransactionStatisticsV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// Sub user email
func (r V1APISubaccountGetSubAccountTransactionStatisticsV1Request) Email(email string) V1APISubaccountGetSubAccountTransactionStatisticsV1Request {
	r.email = &email
	return r
}

func (r V1APISubaccountGetSubAccountTransactionStatisticsV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountTransactionStatisticsV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetSubAccountTransactionStatisticsV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountTransactionStatisticsV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountTransactionStatisticsV1Request) Execute() (*SubaccountGetSubAccountTransactionStatisticsV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountTransactionStatisticsV1Execute(r)
}

/*
SubaccountGetSubAccountTransactionStatisticsV1 Query Sub-account Transaction Statistics(For Master Account)(USER_DATA)

Query Sub-account Transaction statistics (For Master Account).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountTransactionStatisticsV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountTransactionStatisticsV1(ctx context.Context) V1APISubaccountGetSubAccountTransactionStatisticsV1Request {
	return V1APISubaccountGetSubAccountTransactionStatisticsV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountTransactionStatisticsV1Resp
func (a *V1APIService) SubaccountGetSubAccountTransactionStatisticsV1Execute(r V1APISubaccountGetSubAccountTransactionStatisticsV1Request) (*SubaccountGetSubAccountTransactionStatisticsV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountTransactionStatisticsV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountTransactionStatisticsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transaction-statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	asset *string
	type_ *int32
	startTime *int64
	endTime *int64
	limit *int32
	returnFailHistory *bool
	recvWindow *int64
}

func (r V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// If not sent, result of all assets will be returned
func (r V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request) Asset(asset string) V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.asset = &asset
	return r
}

// 1: transfer in, 2: transfer out
func (r V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request) Type_(type_ int32) V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request) StartTime(startTime int64) V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request) EndTime(endTime int64) V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default 500
func (r V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request) Limit(limit int32) V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.limit = &limit
	return r
}

// Default &#x60;False&#x60;, return PROCESS and SUCCESS status history; If &#x60;True&#x60;,return PROCESS and SUCCESS and FAILURE status history
func (r V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request) ReturnFailHistory(returnFailHistory bool) V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.returnFailHistory = &returnFailHistory
	return r
}

func (r V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request) Execute() ([]SubaccountGetSubAccountTransferSubUserHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountTransferSubUserHistoryV1Execute(r)
}

/*
SubaccountGetSubAccountTransferSubUserHistoryV1 Sub-account Transfer History(For Sub-account)

Sub-account Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountTransferSubUserHistoryV1(ctx context.Context) V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	return V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetSubAccountTransferSubUserHistoryV1RespItem
func (a *V1APIService) SubaccountGetSubAccountTransferSubUserHistoryV1Execute(r V1APISubaccountGetSubAccountTransferSubUserHistoryV1Request) ([]SubaccountGetSubAccountTransferSubUserHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetSubAccountTransferSubUserHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountTransferSubUserHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subUserHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.returnFailHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFailHistory", r.returnFailHistory, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APISubaccountGetSubAccountUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	fromEmail *string
	toEmail *string
	clientTranId *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r V1APISubaccountGetSubAccountUniversalTransferV1Request) Timestamp(timestamp int64) V1APISubaccountGetSubAccountUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APISubaccountGetSubAccountUniversalTransferV1Request) FromEmail(fromEmail string) V1APISubaccountGetSubAccountUniversalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r V1APISubaccountGetSubAccountUniversalTransferV1Request) ToEmail(toEmail string) V1APISubaccountGetSubAccountUniversalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r V1APISubaccountGetSubAccountUniversalTransferV1Request) ClientTranId(clientTranId string) V1APISubaccountGetSubAccountUniversalTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r V1APISubaccountGetSubAccountUniversalTransferV1Request) StartTime(startTime int64) V1APISubaccountGetSubAccountUniversalTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APISubaccountGetSubAccountUniversalTransferV1Request) EndTime(endTime int64) V1APISubaccountGetSubAccountUniversalTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default 1
func (r V1APISubaccountGetSubAccountUniversalTransferV1Request) Page(page int32) V1APISubaccountGetSubAccountUniversalTransferV1Request {
	r.page = &page
	return r
}

// Default 500, Max 500
func (r V1APISubaccountGetSubAccountUniversalTransferV1Request) Limit(limit int32) V1APISubaccountGetSubAccountUniversalTransferV1Request {
	r.limit = &limit
	return r
}

func (r V1APISubaccountGetSubAccountUniversalTransferV1Request) RecvWindow(recvWindow int64) V1APISubaccountGetSubAccountUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APISubaccountGetSubAccountUniversalTransferV1Request) Execute() (*SubaccountGetSubAccountUniversalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountUniversalTransferV1Execute(r)
}

/*
SubaccountGetSubAccountUniversalTransferV1 Query Universal Transfer History(For Master Account)

Query Universal Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APISubaccountGetSubAccountUniversalTransferV1Request
*/
func (a *V1APIService) SubaccountGetSubAccountUniversalTransferV1(ctx context.Context) V1APISubaccountGetSubAccountUniversalTransferV1Request {
	return V1APISubaccountGetSubAccountUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountUniversalTransferV1Resp
func (a *V1APIService) SubaccountGetSubAccountUniversalTransferV1Execute(r V1APISubaccountGetSubAccountUniversalTransferV1Request) (*SubaccountGetSubAccountUniversalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountUniversalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.SubaccountGetSubAccountUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromEmail", r.fromEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.fromEmail = &defaultValue
	}
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toEmail", r.toEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.toEmail = &defaultValue
	}
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientTranId", r.clientTranId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientTranId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

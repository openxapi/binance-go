/*
Binance Sub Account API

OpenAPI specification for Binance exchange - Subaccount API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package subaccount

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AssetManagementAPIService AssetManagementAPI service
type AssetManagementAPIService service

type AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	fromEmail *string
	futuresType *int64
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request) Amount(amount string) AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.amount = &amount
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request) Asset(asset string) AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.asset = &asset
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request) FromEmail(fromEmail string) AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request) FuturesType(futuresType int64) AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.futuresType = &futuresType
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request) ToEmail(toEmail string) AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request) Execute() (*SubaccountCreateSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountFuturesInternalTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountFuturesInternalTransferV1 Sub-account Futures Asset Transfer(For Master Account)

Sub-account Futures Asset Transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesInternalTransferV1(ctx context.Context) AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request {
	return AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountFuturesInternalTransferV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesInternalTransferV1Execute(r AssetManagementAPISubaccountCreateSubAccountFuturesInternalTransferV1Request) (*SubaccountCreateSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountFuturesInternalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountFuturesInternalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "futuresType", r.futuresType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	fromUserEmail *string
	orderArgs *[]map[string]interface{}
	productType *string
	timestamp *int64
	toUserEmail *string
	recvWindow *int64
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request) FromUserEmail(fromUserEmail string) AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.fromUserEmail = &fromUserEmail
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request) OrderArgs(orderArgs []map[string]interface{}) AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.orderArgs = &orderArgs
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request) ProductType(productType string) AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.productType = &productType
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request) ToUserEmail(toUserEmail string) AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.toUserEmail = &toUserEmail
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request) Execute() (*SubaccountCreateSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountFuturesMovePositionV1Execute(r)
}

/*
SubaccountCreateSubAccountFuturesMovePositionV1 Move Position for Sub-account (For Master Account)

Move position between sub-master, master-sub, or sub-sub accounts when necessary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesMovePositionV1(ctx context.Context) AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request {
	return AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountFuturesMovePositionV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesMovePositionV1Execute(r AssetManagementAPISubaccountCreateSubAccountFuturesMovePositionV1Request) (*SubaccountCreateSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountFuturesMovePositionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountFuturesMovePositionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/move-position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromUserEmail == nil {
		return localVarReturnValue, nil, reportError("fromUserEmail is required and must be specified")
	}
	if r.orderArgs == nil {
		return localVarReturnValue, nil, reportError("orderArgs is required and must be specified")
	}
	if r.productType == nil {
		return localVarReturnValue, nil, reportError("productType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toUserEmail == nil {
		return localVarReturnValue, nil, reportError("toUserEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "fromUserEmail", r.fromUserEmail, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "orderArgs", r.orderArgs, "", "csv")
	parameterAddToHeaderOrQuery(localVarFormParams, "productType", r.productType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toUserEmail", r.toUserEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	email *string
	timestamp *int64
	type_ *int32
	recvWindow *int64
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request) Amount(amount string) AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request {
	r.amount = &amount
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request) Asset(asset string) AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request {
	r.asset = &asset
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request) Email(email string) AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request {
	r.email = &email
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request) Type_(type_ int32) AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request {
	r.type_ = &type_
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request) Execute() (*SubaccountCreateSubAccountFuturesTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountFuturesTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountFuturesTransferV1 Futures Transfer for Sub-account(For Master Account)

Futures Transfer for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesTransferV1(ctx context.Context) AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request {
	return AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountFuturesTransferV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesTransferV1Execute(r AssetManagementAPISubaccountCreateSubAccountFuturesTransferV1Request) (*SubaccountCreateSubAccountFuturesTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountFuturesTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountFuturesTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	email *string
	timestamp *int64
	type_ *int32
	recvWindow *int64
}

func (r AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request) Amount(amount string) AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request {
	r.amount = &amount
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request) Asset(asset string) AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request {
	r.asset = &asset
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request) Email(email string) AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request {
	r.email = &email
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request) Type_(type_ int32) AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request {
	r.type_ = &type_
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request) Execute() (*SubaccountCreateSubAccountMarginTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountMarginTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountMarginTransferV1 Margin Transfer for Sub-account(For Master Account)

Margin Transfer for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountMarginTransferV1(ctx context.Context) AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request {
	return AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountMarginTransferV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountMarginTransferV1Execute(r AssetManagementAPISubaccountCreateSubAccountMarginTransferV1Request) (*SubaccountCreateSubAccountMarginTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountMarginTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountMarginTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request) Amount(amount string) AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.amount = &amount
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request) Asset(asset string) AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.asset = &asset
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request) Execute() (*SubaccountCreateSubAccountTransferSubToMasterV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountTransferSubToMasterV1Execute(r)
}

/*
SubaccountCreateSubAccountTransferSubToMasterV1 Transfer to Master(For Sub-account)

Transfer to Master

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountTransferSubToMasterV1(ctx context.Context) AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request {
	return AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountTransferSubToMasterV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountTransferSubToMasterV1Execute(r AssetManagementAPISubaccountCreateSubAccountTransferSubToMasterV1Request) (*SubaccountCreateSubAccountTransferSubToMasterV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountTransferSubToMasterV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountTransferSubToMasterV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToMaster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request) Amount(amount string) AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request {
	r.amount = &amount
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request) Asset(asset string) AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request {
	r.asset = &asset
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request) ToEmail(toEmail string) AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request {
	r.toEmail = &toEmail
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request) Execute() (*SubaccountCreateSubAccountTransferSubToSubV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountTransferSubToSubV1Execute(r)
}

/*
SubaccountCreateSubAccountTransferSubToSubV1 Transfer to Sub-account of Same Master(For Sub-account)

Transfer to Sub-account of Same Master

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountTransferSubToSubV1(ctx context.Context) AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request {
	return AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountTransferSubToSubV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountTransferSubToSubV1Execute(r AssetManagementAPISubaccountCreateSubAccountTransferSubToSubV1Request) (*SubaccountCreateSubAccountTransferSubToSubV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountTransferSubToSubV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountTransferSubToSubV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToSub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	fromAccountType *string
	timestamp *int64
	toAccountType *string
	clientTranId *string
	fromEmail *string
	recvWindow *int64
	symbol *string
	toEmail *string
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) Amount(amount string) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	r.amount = &amount
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) Asset(asset string) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	r.asset = &asset
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) FromAccountType(fromAccountType string) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	r.fromAccountType = &fromAccountType
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) ToAccountType(toAccountType string) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	r.toAccountType = &toAccountType
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) ClientTranId(clientTranId string) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) FromEmail(fromEmail string) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) Symbol(symbol string) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	r.symbol = &symbol
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) ToEmail(toEmail string) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) Execute() (*SubaccountCreateSubAccountUniversalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountUniversalTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountUniversalTransferV1 Universal Transfer(For Master Account)

Universal Transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountUniversalTransferV1(ctx context.Context) AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request {
	return AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountUniversalTransferV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountUniversalTransferV1Execute(r AssetManagementAPISubaccountCreateSubAccountUniversalTransferV1Request) (*SubaccountCreateSubAccountUniversalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountUniversalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromAccountType == nil {
		return localVarReturnValue, nil, reportError("fromAccountType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toAccountType == nil {
		return localVarReturnValue, nil, reportError("toAccountType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "clientTranId", r.clientTranId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "fromAccountType", r.fromAccountType, "", "")
	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toAccountType", r.toAccountType, "", "")
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	coin *string
	timestamp *int64
	network *string
	amount *string
	recvWindow *int64
}

// Sub account email
func (r AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request) Email(email string) AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request {
	r.email = &email
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request) Coin(coin string) AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request {
	r.coin = &coin
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request) Network(network string) AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request {
	r.network = &network
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request) Amount(amount string) AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request {
	r.amount = &amount
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request) Execute() (*SubaccountGetCapitalDepositSubAddressV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetCapitalDepositSubAddressV1Execute(r)
}

/*
SubaccountGetCapitalDepositSubAddressV1 Get Sub-account Deposit Address(For Master Account)

Fetch sub-account deposit address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetCapitalDepositSubAddressV1(ctx context.Context) AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request {
	return AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetCapitalDepositSubAddressV1Resp
func (a *AssetManagementAPIService) SubaccountGetCapitalDepositSubAddressV1Execute(r AssetManagementAPISubaccountGetCapitalDepositSubAddressV1Request) (*SubaccountGetCapitalDepositSubAddressV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetCapitalDepositSubAddressV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetCapitalDepositSubAddressV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	} else {
		var defaultValue string = ""
		r.amount = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	timestamp *int64
	coin *string
	status *int32
	startTime *int64
	endTime *int64
	limit *int32
	offset *int32
	recvWindow *int64
	txId *string
}

// Sub account email
func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) Email(email string) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	r.email = &email
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) Coin(coin string) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	r.coin = &coin
	return r
}

// 0(0:pending,6: credited but cannot withdraw,7:Wrong Deposit,8:Waiting User confirm,1:success)
func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) Status(status int32) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	r.status = &status
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) StartTime(startTime int64) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	r.startTime = &startTime
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) EndTime(endTime int64) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	r.endTime = &endTime
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) Limit(limit int32) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	r.limit = &limit
	return r
}

// default:0
func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) Offset(offset int32) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	r.offset = &offset
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) TxId(txId string) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	r.txId = &txId
	return r
}

func (r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) Execute() ([]SubaccountGetCapitalDepositSubHisrecV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetCapitalDepositSubHisrecV1Execute(r)
}

/*
SubaccountGetCapitalDepositSubHisrecV1 Get Sub-account Deposit History(For Master Account)

Fetch sub-account deposit history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetCapitalDepositSubHisrecV1(ctx context.Context) AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request {
	return AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetCapitalDepositSubHisrecV1RespItem
func (a *AssetManagementAPIService) SubaccountGetCapitalDepositSubHisrecV1Execute(r AssetManagementAPISubaccountGetCapitalDepositSubHisrecV1Request) ([]SubaccountGetCapitalDepositSubHisrecV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetCapitalDepositSubHisrecV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetCapitalDepositSubHisrecV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subHisrec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountAssetsV3Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// Sub account email
func (r AssetManagementAPISubaccountGetSubAccountAssetsV3Request) Email(email string) AssetManagementAPISubaccountGetSubAccountAssetsV3Request {
	r.email = &email
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountAssetsV3Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountAssetsV3Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountAssetsV3Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountAssetsV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountAssetsV3Request) Execute() (*SubaccountGetSubAccountAssetsV3Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountAssetsV3Execute(r)
}

/*
SubaccountGetSubAccountAssetsV3 Query Sub-account Assets(For Master Account)

Fetch sub-account assets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountAssetsV3Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountAssetsV3(ctx context.Context) AssetManagementAPISubaccountGetSubAccountAssetsV3Request {
	return AssetManagementAPISubaccountGetSubAccountAssetsV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountAssetsV3Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountAssetsV3Execute(r AssetManagementAPISubaccountGetSubAccountAssetsV3Request) (*SubaccountGetSubAccountAssetsV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountAssetsV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountAssetsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v3/sub-account/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountAssetsV4Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// Sub Account Email
func (r AssetManagementAPISubaccountGetSubAccountAssetsV4Request) Email(email string) AssetManagementAPISubaccountGetSubAccountAssetsV4Request {
	r.email = &email
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountAssetsV4Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountAssetsV4Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountAssetsV4Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountAssetsV4Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountAssetsV4Request) Execute() (*SubaccountGetSubAccountAssetsV4Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountAssetsV4Execute(r)
}

/*
SubaccountGetSubAccountAssetsV4 Query Sub-account Assets (For Master Account)(USER_DATA)

Fetch sub-account assets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountAssetsV4Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountAssetsV4(ctx context.Context) AssetManagementAPISubaccountGetSubAccountAssetsV4Request {
	return AssetManagementAPISubaccountGetSubAccountAssetsV4Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountAssetsV4Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountAssetsV4Execute(r AssetManagementAPISubaccountGetSubAccountAssetsV4Request) (*SubaccountGetSubAccountAssetsV4Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountAssetsV4Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountAssetsV4")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v4/sub-account/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	recvWindow *int64
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV1Request) Execute() (*SubaccountGetSubAccountFuturesAccountSummaryV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesAccountSummaryV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesAccountSummaryV1 Get Summary of Sub-account's Futures Account(For Master Account)

Get Summary of Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountSummaryV1(ctx context.Context) AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV1Request {
	return AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesAccountSummaryV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountSummaryV1Execute(r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV1Request) (*SubaccountGetSubAccountFuturesAccountSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesAccountSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesAccountSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	futuresType *int32
	timestamp *int64
	page *int32
	limit *int32
	recvWindow *int64
}

// 1:USDT Margined Futures, 2:COIN Margined Futures
func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request) FuturesType(futuresType int32) AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request {
	r.futuresType = &futuresType
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request {
	r.timestamp = &timestamp
	return r
}

// default:1
func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request) Page(page int32) AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request {
	r.page = &page
	return r
}

// default:10, max:20
func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request) Limit(limit int32) AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request {
	r.limit = &limit
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request) Execute() (*SubaccountGetSubAccountFuturesAccountSummaryV2Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesAccountSummaryV2Execute(r)
}

/*
SubaccountGetSubAccountFuturesAccountSummaryV2 Get Summary of Sub-account's Futures Account V2(For Master Account)

Get Summary of Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountSummaryV2(ctx context.Context) AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request {
	return AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesAccountSummaryV2Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountSummaryV2Execute(r AssetManagementAPISubaccountGetSubAccountFuturesAccountSummaryV2Request) (*SubaccountGetSubAccountFuturesAccountSummaryV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesAccountSummaryV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesAccountSummaryV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Futures-Account#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request) Email(email string) AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request {
	r.email = &email
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request) Execute() (*SubaccountGetSubAccountFuturesAccountV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesAccountV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesAccountV1 Get Detail on Sub-account's Futures Account(For Master Account)

Get Detail on Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountV1(ctx context.Context) AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request {
	return AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesAccountV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountV1Execute(r AssetManagementAPISubaccountGetSubAccountFuturesAccountV1Request) (*SubaccountGetSubAccountFuturesAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	futuresType *int32
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Futures-Account-V2#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request) Email(email string) AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request {
	r.email = &email
	return r
}

// 1:USDT Margined Futures, 2:COIN Margined Futures
func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request) FuturesType(futuresType int32) AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request {
	r.futuresType = &futuresType
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request) Execute() (*SubaccountGetSubAccountFuturesAccountV2Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesAccountV2Execute(r)
}

/*
SubaccountGetSubAccountFuturesAccountV2 Get Detail on Sub-account's Futures Account V2(For Master Account)

Get Detail on Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountV2(ctx context.Context) AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request {
	return AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesAccountV2Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountV2Execute(r AssetManagementAPISubaccountGetSubAccountFuturesAccountV2Request) (*SubaccountGetSubAccountFuturesAccountV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesAccountV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesAccountV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	futuresType *int64
	timestamp *int64
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Query-Sub-account-Futures-Asset-Transfer-History#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request) Email(email string) AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.email = &email
	return r
}

// 1:USDT-margined Futures2: Coin-margined Futures
func (r AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request) FuturesType(futuresType int64) AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.futuresType = &futuresType
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

// Cannot be earlier than 1 month ago
func (r AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request) StartTime(startTime int64) AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request) EndTime(endTime int64) AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default value: 1
func (r AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request) Page(page int32) AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.page = &page
	return r
}

// Default value: 50, Max value: 500
func (r AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request) Limit(limit int32) AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.limit = &limit
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request) Execute() (*SubaccountGetSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesInternalTransferV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesInternalTransferV1 Query Sub-account Futures Asset Transfer History(For Master Account)

Query Sub-account Futures Asset Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesInternalTransferV1(ctx context.Context) AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request {
	return AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesInternalTransferV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesInternalTransferV1Execute(r AssetManagementAPISubaccountGetSubAccountFuturesInternalTransferV1Request) (*SubaccountGetSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesInternalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesInternalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	symbol *string
	page *int32
	row *int32
	timestamp *int64
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request) Symbol(symbol string) AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.symbol = &symbol
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request) Page(page int32) AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.page = &page
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request) Row(row int32) AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.row = &row
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request) StartTime(startTime int64) AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.startTime = &startTime
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request) EndTime(endTime int64) AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.endTime = &endTime
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request) Execute() (*SubaccountGetSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesMovePositionV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesMovePositionV1 Get Move Position History for Sub-account (For Master Account)

Query move position history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesMovePositionV1(ctx context.Context) AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request {
	return AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesMovePositionV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesMovePositionV1Execute(r AssetManagementAPISubaccountGetSubAccountFuturesMovePositionV1Request) (*SubaccountGetSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesMovePositionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesMovePositionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/move-position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.row == nil {
		return localVarReturnValue, nil, reportError("row is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "row", r.row, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountMarginAccountSummaryV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	recvWindow *int64
}

func (r AssetManagementAPISubaccountGetSubAccountMarginAccountSummaryV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountMarginAccountSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountMarginAccountSummaryV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountMarginAccountSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountMarginAccountSummaryV1Request) Execute() (*SubaccountGetSubAccountMarginAccountSummaryV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountMarginAccountSummaryV1Execute(r)
}

/*
SubaccountGetSubAccountMarginAccountSummaryV1 Get Summary of Sub-account's Margin Account(For Master Account)

Get Summary of Sub-account's Margin Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountMarginAccountSummaryV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountMarginAccountSummaryV1(ctx context.Context) AssetManagementAPISubaccountGetSubAccountMarginAccountSummaryV1Request {
	return AssetManagementAPISubaccountGetSubAccountMarginAccountSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountMarginAccountSummaryV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountMarginAccountSummaryV1Execute(r AssetManagementAPISubaccountGetSubAccountMarginAccountSummaryV1Request) (*SubaccountGetSubAccountMarginAccountSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountMarginAccountSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountMarginAccountSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Margin-Account#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request) Email(email string) AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request {
	r.email = &email
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request) Execute() (*SubaccountGetSubAccountMarginAccountV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountMarginAccountV1Execute(r)
}

/*
SubaccountGetSubAccountMarginAccountV1 Get Detail on Sub-account's Margin Account(For Master Account)

Get Detail on Sub-account's Margin Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountMarginAccountV1(ctx context.Context) AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request {
	return AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountMarginAccountV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountMarginAccountV1Execute(r AssetManagementAPISubaccountGetSubAccountMarginAccountV1Request) (*SubaccountGetSubAccountMarginAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountMarginAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountMarginAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	email *string
	page *int64
	size *int64
	recvWindow *int64
}

func (r AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

// Sub account email
func (r AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request) Email(email string) AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request {
	r.email = &email
	return r
}

// default 1
func (r AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request) Page(page int64) AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request {
	r.page = &page
	return r
}

// default 10, max 20
func (r AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request) Size(size int64) AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request {
	r.size = &size
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request) Execute() (*SubaccountGetSubAccountSpotSummaryV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountSpotSummaryV1Execute(r)
}

/*
SubaccountGetSubAccountSpotSummaryV1 Query Sub-account Spot Assets Summary(For Master Account)

Get BTC valued asset summary of subaccounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountSpotSummaryV1(ctx context.Context) AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request {
	return AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountSpotSummaryV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountSpotSummaryV1Execute(r AssetManagementAPISubaccountGetSubAccountSpotSummaryV1Request) (*SubaccountGetSubAccountSpotSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountSpotSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountSpotSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/spotSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	fromEmail *string
	toEmail *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request) FromEmail(fromEmail string) AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request) ToEmail(toEmail string) AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.toEmail = &toEmail
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request) StartTime(startTime int64) AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request) EndTime(endTime int64) AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default value: 1
func (r AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request) Page(page int32) AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.page = &page
	return r
}

// Default value: 500
func (r AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request) Limit(limit int32) AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.limit = &limit
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request) Execute() ([]SubaccountGetSubAccountSubTransferHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountSubTransferHistoryV1Execute(r)
}

/*
SubaccountGetSubAccountSubTransferHistoryV1 Query Sub-account Spot Asset Transfer History(For Master Account)

Query Sub-account Spot Asset Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountSubTransferHistoryV1(ctx context.Context) AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request {
	return AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetSubAccountSubTransferHistoryV1RespItem
func (a *AssetManagementAPIService) SubaccountGetSubAccountSubTransferHistoryV1Execute(r AssetManagementAPISubaccountGetSubAccountSubTransferHistoryV1Request) ([]SubaccountGetSubAccountSubTransferHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetSubAccountSubTransferHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountSubTransferHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/sub/transfer/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromEmail", r.fromEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.fromEmail = &defaultValue
	}
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toEmail", r.toEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.toEmail = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	asset *string
	type_ *int32
	startTime *int64
	endTime *int64
	limit *int32
	returnFailHistory *bool
	recvWindow *int64
}

func (r AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// If not sent, result of all assets will be returned
func (r AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request) Asset(asset string) AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.asset = &asset
	return r
}

// 1: transfer in, 2: transfer out
func (r AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request) Type_(type_ int32) AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request) StartTime(startTime int64) AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request) EndTime(endTime int64) AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default 500
func (r AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request) Limit(limit int32) AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.limit = &limit
	return r
}

// Default &#x60;False&#x60;, return PROCESS and SUCCESS status history; If &#x60;True&#x60;,return PROCESS and SUCCESS and FAILURE status history
func (r AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request) ReturnFailHistory(returnFailHistory bool) AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.returnFailHistory = &returnFailHistory
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request) Execute() ([]SubaccountGetSubAccountTransferSubUserHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountTransferSubUserHistoryV1Execute(r)
}

/*
SubaccountGetSubAccountTransferSubUserHistoryV1 Sub-account Transfer History(For Sub-account)

Sub-account Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountTransferSubUserHistoryV1(ctx context.Context) AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request {
	return AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetSubAccountTransferSubUserHistoryV1RespItem
func (a *AssetManagementAPIService) SubaccountGetSubAccountTransferSubUserHistoryV1Execute(r AssetManagementAPISubaccountGetSubAccountTransferSubUserHistoryV1Request) ([]SubaccountGetSubAccountTransferSubUserHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetSubAccountTransferSubUserHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountTransferSubUserHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subUserHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.returnFailHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFailHistory", r.returnFailHistory, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	fromEmail *string
	toEmail *string
	clientTranId *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) Timestamp(timestamp int64) AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) FromEmail(fromEmail string) AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) ToEmail(toEmail string) AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) ClientTranId(clientTranId string) AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) StartTime(startTime int64) AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) EndTime(endTime int64) AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default 1
func (r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) Page(page int32) AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request {
	r.page = &page
	return r
}

// Default 500, Max 500
func (r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) Limit(limit int32) AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request {
	r.limit = &limit
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) RecvWindow(recvWindow int64) AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) Execute() (*SubaccountGetSubAccountUniversalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountUniversalTransferV1Execute(r)
}

/*
SubaccountGetSubAccountUniversalTransferV1 Query Universal Transfer History(For Master Account)

Query Universal Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountUniversalTransferV1(ctx context.Context) AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request {
	return AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountUniversalTransferV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountUniversalTransferV1Execute(r AssetManagementAPISubaccountGetSubAccountUniversalTransferV1Request) (*SubaccountGetSubAccountUniversalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountUniversalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromEmail", r.fromEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.fromEmail = &defaultValue
	}
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toEmail", r.toEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.toEmail = &defaultValue
	}
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientTranId", r.clientTranId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientTranId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

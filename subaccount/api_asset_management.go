/*
Binance Sub Account API

OpenAPI specification for Binance exchange - Subaccount API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package subaccount

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AssetManagementAPIService AssetManagementAPI service
type AssetManagementAPIService service

type ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	fromEmail *string
	futuresType *int64
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request) Amount(amount string) ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request) Asset(asset string) ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request) FromEmail(fromEmail string) ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request) FuturesType(futuresType int64) ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request) Timestamp(timestamp int64) ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request) ToEmail(toEmail string) ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request) RecvWindow(recvWindow int64) ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request) Execute() (*SubaccountCreateSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountFuturesInternalTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountFuturesInternalTransferV1 Sub-account Futures Asset Transfer(For Master Account)

Sub-account Futures Asset Transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesInternalTransferV1(ctx context.Context) ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request {
	return ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountFuturesInternalTransferV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesInternalTransferV1Execute(r ApiSubaccountCreateSubAccountFuturesInternalTransferV1Request) (*SubaccountCreateSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountFuturesInternalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountFuturesInternalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "futuresType", r.futuresType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountCreateSubAccountFuturesMovePositionV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	fromUserEmail *string
	orderArgs *[]map[string]interface{}
	productType *string
	timestamp *int64
	toUserEmail *string
	recvWindow *int64
}

func (r ApiSubaccountCreateSubAccountFuturesMovePositionV1Request) FromUserEmail(fromUserEmail string) ApiSubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.fromUserEmail = &fromUserEmail
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesMovePositionV1Request) OrderArgs(orderArgs []map[string]interface{}) ApiSubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.orderArgs = &orderArgs
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesMovePositionV1Request) ProductType(productType string) ApiSubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.productType = &productType
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesMovePositionV1Request) Timestamp(timestamp int64) ApiSubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesMovePositionV1Request) ToUserEmail(toUserEmail string) ApiSubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.toUserEmail = &toUserEmail
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesMovePositionV1Request) RecvWindow(recvWindow int64) ApiSubaccountCreateSubAccountFuturesMovePositionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesMovePositionV1Request) Execute() (*SubaccountCreateSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountFuturesMovePositionV1Execute(r)
}

/*
SubaccountCreateSubAccountFuturesMovePositionV1 Move Position for Sub-account (For Master Account)

Move position between sub-master, master-sub, or sub-sub accounts when necessary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountCreateSubAccountFuturesMovePositionV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesMovePositionV1(ctx context.Context) ApiSubaccountCreateSubAccountFuturesMovePositionV1Request {
	return ApiSubaccountCreateSubAccountFuturesMovePositionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountFuturesMovePositionV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesMovePositionV1Execute(r ApiSubaccountCreateSubAccountFuturesMovePositionV1Request) (*SubaccountCreateSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountFuturesMovePositionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountFuturesMovePositionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/move-position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromUserEmail == nil {
		return localVarReturnValue, nil, reportError("fromUserEmail is required and must be specified")
	}
	if r.orderArgs == nil {
		return localVarReturnValue, nil, reportError("orderArgs is required and must be specified")
	}
	if r.productType == nil {
		return localVarReturnValue, nil, reportError("productType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toUserEmail == nil {
		return localVarReturnValue, nil, reportError("toUserEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "fromUserEmail", r.fromUserEmail, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "orderArgs", r.orderArgs, "", "csv")
	parameterAddToHeaderOrQuery(localVarFormParams, "productType", r.productType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toUserEmail", r.toUserEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountCreateSubAccountFuturesTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	email *string
	timestamp *int64
	type_ *int32
	recvWindow *int64
}

func (r ApiSubaccountCreateSubAccountFuturesTransferV1Request) Amount(amount string) ApiSubaccountCreateSubAccountFuturesTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesTransferV1Request) Asset(asset string) ApiSubaccountCreateSubAccountFuturesTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesTransferV1Request) Email(email string) ApiSubaccountCreateSubAccountFuturesTransferV1Request {
	r.email = &email
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesTransferV1Request) Timestamp(timestamp int64) ApiSubaccountCreateSubAccountFuturesTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesTransferV1Request) Type_(type_ int32) ApiSubaccountCreateSubAccountFuturesTransferV1Request {
	r.type_ = &type_
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesTransferV1Request) RecvWindow(recvWindow int64) ApiSubaccountCreateSubAccountFuturesTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountCreateSubAccountFuturesTransferV1Request) Execute() (*SubaccountCreateSubAccountFuturesTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountFuturesTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountFuturesTransferV1 Futures Transfer for Sub-account(For Master Account)

Futures Transfer for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountCreateSubAccountFuturesTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesTransferV1(ctx context.Context) ApiSubaccountCreateSubAccountFuturesTransferV1Request {
	return ApiSubaccountCreateSubAccountFuturesTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountFuturesTransferV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountFuturesTransferV1Execute(r ApiSubaccountCreateSubAccountFuturesTransferV1Request) (*SubaccountCreateSubAccountFuturesTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountFuturesTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountFuturesTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountCreateSubAccountMarginTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	email *string
	timestamp *int64
	type_ *int32
	recvWindow *int64
}

func (r ApiSubaccountCreateSubAccountMarginTransferV1Request) Amount(amount string) ApiSubaccountCreateSubAccountMarginTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiSubaccountCreateSubAccountMarginTransferV1Request) Asset(asset string) ApiSubaccountCreateSubAccountMarginTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiSubaccountCreateSubAccountMarginTransferV1Request) Email(email string) ApiSubaccountCreateSubAccountMarginTransferV1Request {
	r.email = &email
	return r
}

func (r ApiSubaccountCreateSubAccountMarginTransferV1Request) Timestamp(timestamp int64) ApiSubaccountCreateSubAccountMarginTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountCreateSubAccountMarginTransferV1Request) Type_(type_ int32) ApiSubaccountCreateSubAccountMarginTransferV1Request {
	r.type_ = &type_
	return r
}

func (r ApiSubaccountCreateSubAccountMarginTransferV1Request) RecvWindow(recvWindow int64) ApiSubaccountCreateSubAccountMarginTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountCreateSubAccountMarginTransferV1Request) Execute() (*SubaccountCreateSubAccountMarginTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountMarginTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountMarginTransferV1 Margin Transfer for Sub-account(For Master Account)

Margin Transfer for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountCreateSubAccountMarginTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountMarginTransferV1(ctx context.Context) ApiSubaccountCreateSubAccountMarginTransferV1Request {
	return ApiSubaccountCreateSubAccountMarginTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountMarginTransferV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountMarginTransferV1Execute(r ApiSubaccountCreateSubAccountMarginTransferV1Request) (*SubaccountCreateSubAccountMarginTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountMarginTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountMarginTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountCreateSubAccountTransferSubToMasterV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiSubaccountCreateSubAccountTransferSubToMasterV1Request) Amount(amount string) ApiSubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.amount = &amount
	return r
}

func (r ApiSubaccountCreateSubAccountTransferSubToMasterV1Request) Asset(asset string) ApiSubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.asset = &asset
	return r
}

func (r ApiSubaccountCreateSubAccountTransferSubToMasterV1Request) Timestamp(timestamp int64) ApiSubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountCreateSubAccountTransferSubToMasterV1Request) RecvWindow(recvWindow int64) ApiSubaccountCreateSubAccountTransferSubToMasterV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountCreateSubAccountTransferSubToMasterV1Request) Execute() (*SubaccountCreateSubAccountTransferSubToMasterV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountTransferSubToMasterV1Execute(r)
}

/*
SubaccountCreateSubAccountTransferSubToMasterV1 Transfer to Master(For Sub-account)

Transfer to Master

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountCreateSubAccountTransferSubToMasterV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountTransferSubToMasterV1(ctx context.Context) ApiSubaccountCreateSubAccountTransferSubToMasterV1Request {
	return ApiSubaccountCreateSubAccountTransferSubToMasterV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountTransferSubToMasterV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountTransferSubToMasterV1Execute(r ApiSubaccountCreateSubAccountTransferSubToMasterV1Request) (*SubaccountCreateSubAccountTransferSubToMasterV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountTransferSubToMasterV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountTransferSubToMasterV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToMaster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountCreateSubAccountTransferSubToSubV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r ApiSubaccountCreateSubAccountTransferSubToSubV1Request) Amount(amount string) ApiSubaccountCreateSubAccountTransferSubToSubV1Request {
	r.amount = &amount
	return r
}

func (r ApiSubaccountCreateSubAccountTransferSubToSubV1Request) Asset(asset string) ApiSubaccountCreateSubAccountTransferSubToSubV1Request {
	r.asset = &asset
	return r
}

func (r ApiSubaccountCreateSubAccountTransferSubToSubV1Request) Timestamp(timestamp int64) ApiSubaccountCreateSubAccountTransferSubToSubV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountCreateSubAccountTransferSubToSubV1Request) ToEmail(toEmail string) ApiSubaccountCreateSubAccountTransferSubToSubV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiSubaccountCreateSubAccountTransferSubToSubV1Request) RecvWindow(recvWindow int64) ApiSubaccountCreateSubAccountTransferSubToSubV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountCreateSubAccountTransferSubToSubV1Request) Execute() (*SubaccountCreateSubAccountTransferSubToSubV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountTransferSubToSubV1Execute(r)
}

/*
SubaccountCreateSubAccountTransferSubToSubV1 Transfer to Sub-account of Same Master(For Sub-account)

Transfer to Sub-account of Same Master

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountCreateSubAccountTransferSubToSubV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountTransferSubToSubV1(ctx context.Context) ApiSubaccountCreateSubAccountTransferSubToSubV1Request {
	return ApiSubaccountCreateSubAccountTransferSubToSubV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountTransferSubToSubV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountTransferSubToSubV1Execute(r ApiSubaccountCreateSubAccountTransferSubToSubV1Request) (*SubaccountCreateSubAccountTransferSubToSubV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountTransferSubToSubV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountTransferSubToSubV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToSub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountCreateSubAccountUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	amount *string
	asset *string
	fromAccountType *string
	timestamp *int64
	toAccountType *string
	clientTranId *string
	fromEmail *string
	recvWindow *int64
	symbol *string
	toEmail *string
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) Amount(amount string) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) Asset(asset string) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) FromAccountType(fromAccountType string) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	r.fromAccountType = &fromAccountType
	return r
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) Timestamp(timestamp int64) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) ToAccountType(toAccountType string) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	r.toAccountType = &toAccountType
	return r
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) ClientTranId(clientTranId string) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) FromEmail(fromEmail string) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) RecvWindow(recvWindow int64) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) Symbol(symbol string) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) ToEmail(toEmail string) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiSubaccountCreateSubAccountUniversalTransferV1Request) Execute() (*SubaccountCreateSubAccountUniversalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateSubAccountUniversalTransferV1Execute(r)
}

/*
SubaccountCreateSubAccountUniversalTransferV1 Universal Transfer(For Master Account)

Universal Transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountCreateSubAccountUniversalTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountCreateSubAccountUniversalTransferV1(ctx context.Context) ApiSubaccountCreateSubAccountUniversalTransferV1Request {
	return ApiSubaccountCreateSubAccountUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateSubAccountUniversalTransferV1Resp
func (a *AssetManagementAPIService) SubaccountCreateSubAccountUniversalTransferV1Execute(r ApiSubaccountCreateSubAccountUniversalTransferV1Request) (*SubaccountCreateSubAccountUniversalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateSubAccountUniversalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountCreateSubAccountUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromAccountType == nil {
		return localVarReturnValue, nil, reportError("fromAccountType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toAccountType == nil {
		return localVarReturnValue, nil, reportError("toAccountType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "clientTranId", r.clientTranId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "fromAccountType", r.fromAccountType, "", "")
	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toAccountType", r.toAccountType, "", "")
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetCapitalDepositSubAddressV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	coin *string
	timestamp *int64
	network *string
	amount *string
	recvWindow *int64
}

// Sub account email
func (r ApiSubaccountGetCapitalDepositSubAddressV1Request) Email(email string) ApiSubaccountGetCapitalDepositSubAddressV1Request {
	r.email = &email
	return r
}

func (r ApiSubaccountGetCapitalDepositSubAddressV1Request) Coin(coin string) ApiSubaccountGetCapitalDepositSubAddressV1Request {
	r.coin = &coin
	return r
}

func (r ApiSubaccountGetCapitalDepositSubAddressV1Request) Timestamp(timestamp int64) ApiSubaccountGetCapitalDepositSubAddressV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetCapitalDepositSubAddressV1Request) Network(network string) ApiSubaccountGetCapitalDepositSubAddressV1Request {
	r.network = &network
	return r
}

func (r ApiSubaccountGetCapitalDepositSubAddressV1Request) Amount(amount string) ApiSubaccountGetCapitalDepositSubAddressV1Request {
	r.amount = &amount
	return r
}

func (r ApiSubaccountGetCapitalDepositSubAddressV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetCapitalDepositSubAddressV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetCapitalDepositSubAddressV1Request) Execute() (*SubaccountGetCapitalDepositSubAddressV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetCapitalDepositSubAddressV1Execute(r)
}

/*
SubaccountGetCapitalDepositSubAddressV1 Get Sub-account Deposit Address(For Master Account)

Fetch sub-account deposit address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetCapitalDepositSubAddressV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetCapitalDepositSubAddressV1(ctx context.Context) ApiSubaccountGetCapitalDepositSubAddressV1Request {
	return ApiSubaccountGetCapitalDepositSubAddressV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetCapitalDepositSubAddressV1Resp
func (a *AssetManagementAPIService) SubaccountGetCapitalDepositSubAddressV1Execute(r ApiSubaccountGetCapitalDepositSubAddressV1Request) (*SubaccountGetCapitalDepositSubAddressV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetCapitalDepositSubAddressV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetCapitalDepositSubAddressV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	} else {
		var defaultValue string = ""
		r.amount = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetCapitalDepositSubHisrecV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	timestamp *int64
	coin *string
	status *int32
	startTime *int64
	endTime *int64
	limit *int32
	offset *int32
	recvWindow *int64
	txId *string
}

// Sub account email
func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) Email(email string) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	r.email = &email
	return r
}

func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) Timestamp(timestamp int64) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) Coin(coin string) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	r.coin = &coin
	return r
}

// 0(0:pending,6: credited but cannot withdraw,7:Wrong Deposit,8:Waiting User confirm,1:success)
func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) Status(status int32) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	r.status = &status
	return r
}

func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) StartTime(startTime int64) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) EndTime(endTime int64) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) Limit(limit int32) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	r.limit = &limit
	return r
}

// default:0
func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) Offset(offset int32) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	r.offset = &offset
	return r
}

func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) TxId(txId string) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	r.txId = &txId
	return r
}

func (r ApiSubaccountGetCapitalDepositSubHisrecV1Request) Execute() ([]SubaccountGetCapitalDepositSubHisrecV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetCapitalDepositSubHisrecV1Execute(r)
}

/*
SubaccountGetCapitalDepositSubHisrecV1 Get Sub-account Deposit History(For Master Account)

Fetch sub-account deposit history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetCapitalDepositSubHisrecV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetCapitalDepositSubHisrecV1(ctx context.Context) ApiSubaccountGetCapitalDepositSubHisrecV1Request {
	return ApiSubaccountGetCapitalDepositSubHisrecV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetCapitalDepositSubHisrecV1RespItem
func (a *AssetManagementAPIService) SubaccountGetCapitalDepositSubHisrecV1Execute(r ApiSubaccountGetCapitalDepositSubHisrecV1Request) ([]SubaccountGetCapitalDepositSubHisrecV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetCapitalDepositSubHisrecV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetCapitalDepositSubHisrecV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subHisrec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountAssetsV3Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// Sub account email
func (r ApiSubaccountGetSubAccountAssetsV3Request) Email(email string) ApiSubaccountGetSubAccountAssetsV3Request {
	r.email = &email
	return r
}

func (r ApiSubaccountGetSubAccountAssetsV3Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountAssetsV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetSubAccountAssetsV3Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountAssetsV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountAssetsV3Request) Execute() (*SubaccountGetSubAccountAssetsV3Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountAssetsV3Execute(r)
}

/*
SubaccountGetSubAccountAssetsV3 Query Sub-account Assets(For Master Account)

Fetch sub-account assets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountAssetsV3Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountAssetsV3(ctx context.Context) ApiSubaccountGetSubAccountAssetsV3Request {
	return ApiSubaccountGetSubAccountAssetsV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountAssetsV3Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountAssetsV3Execute(r ApiSubaccountGetSubAccountAssetsV3Request) (*SubaccountGetSubAccountAssetsV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountAssetsV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountAssetsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v3/sub-account/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountAssetsV4Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// Sub Account Email
func (r ApiSubaccountGetSubAccountAssetsV4Request) Email(email string) ApiSubaccountGetSubAccountAssetsV4Request {
	r.email = &email
	return r
}

func (r ApiSubaccountGetSubAccountAssetsV4Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountAssetsV4Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetSubAccountAssetsV4Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountAssetsV4Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountAssetsV4Request) Execute() (*SubaccountGetSubAccountAssetsV4Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountAssetsV4Execute(r)
}

/*
SubaccountGetSubAccountAssetsV4 Query Sub-account Assets (For Master Account)(USER_DATA)

Fetch sub-account assets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountAssetsV4Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountAssetsV4(ctx context.Context) ApiSubaccountGetSubAccountAssetsV4Request {
	return ApiSubaccountGetSubAccountAssetsV4Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountAssetsV4Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountAssetsV4Execute(r ApiSubaccountGetSubAccountAssetsV4Request) (*SubaccountGetSubAccountAssetsV4Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountAssetsV4Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountAssetsV4")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v4/sub-account/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountFuturesAccountSummaryV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiSubaccountGetSubAccountFuturesAccountSummaryV1Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountFuturesAccountSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountSummaryV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountFuturesAccountSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountSummaryV1Request) Execute() (*SubaccountGetSubAccountFuturesAccountSummaryV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesAccountSummaryV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesAccountSummaryV1 Get Summary of Sub-account's Futures Account(For Master Account)

Get Summary of Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountFuturesAccountSummaryV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountSummaryV1(ctx context.Context) ApiSubaccountGetSubAccountFuturesAccountSummaryV1Request {
	return ApiSubaccountGetSubAccountFuturesAccountSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesAccountSummaryV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountSummaryV1Execute(r ApiSubaccountGetSubAccountFuturesAccountSummaryV1Request) (*SubaccountGetSubAccountFuturesAccountSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesAccountSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesAccountSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	futuresType *int32
	timestamp *int64
	page *int32
	limit *int32
	recvWindow *int64
}

// 1:USDT Margined Futures, 2:COIN Margined Futures
func (r ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request) FuturesType(futuresType int32) ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request {
	r.timestamp = &timestamp
	return r
}

// default:1
func (r ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request) Page(page int32) ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request {
	r.page = &page
	return r
}

// default:10, max:20
func (r ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request) Limit(limit int32) ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request {
	r.limit = &limit
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request) Execute() (*SubaccountGetSubAccountFuturesAccountSummaryV2Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesAccountSummaryV2Execute(r)
}

/*
SubaccountGetSubAccountFuturesAccountSummaryV2 Get Summary of Sub-account's Futures Account V2(For Master Account)

Get Summary of Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountSummaryV2(ctx context.Context) ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request {
	return ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesAccountSummaryV2Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountSummaryV2Execute(r ApiSubaccountGetSubAccountFuturesAccountSummaryV2Request) (*SubaccountGetSubAccountFuturesAccountSummaryV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesAccountSummaryV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesAccountSummaryV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountFuturesAccountV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Futures-Account#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiSubaccountGetSubAccountFuturesAccountV1Request) Email(email string) ApiSubaccountGetSubAccountFuturesAccountV1Request {
	r.email = &email
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountV1Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountFuturesAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountFuturesAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountV1Request) Execute() (*SubaccountGetSubAccountFuturesAccountV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesAccountV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesAccountV1 Get Detail on Sub-account's Futures Account(For Master Account)

Get Detail on Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountFuturesAccountV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountV1(ctx context.Context) ApiSubaccountGetSubAccountFuturesAccountV1Request {
	return ApiSubaccountGetSubAccountFuturesAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesAccountV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountV1Execute(r ApiSubaccountGetSubAccountFuturesAccountV1Request) (*SubaccountGetSubAccountFuturesAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountFuturesAccountV2Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	futuresType *int32
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Futures-Account-V2#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiSubaccountGetSubAccountFuturesAccountV2Request) Email(email string) ApiSubaccountGetSubAccountFuturesAccountV2Request {
	r.email = &email
	return r
}

// 1:USDT Margined Futures, 2:COIN Margined Futures
func (r ApiSubaccountGetSubAccountFuturesAccountV2Request) FuturesType(futuresType int32) ApiSubaccountGetSubAccountFuturesAccountV2Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountV2Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountFuturesAccountV2Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountV2Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountFuturesAccountV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountFuturesAccountV2Request) Execute() (*SubaccountGetSubAccountFuturesAccountV2Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesAccountV2Execute(r)
}

/*
SubaccountGetSubAccountFuturesAccountV2 Get Detail on Sub-account's Futures Account V2(For Master Account)

Get Detail on Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountFuturesAccountV2Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountV2(ctx context.Context) ApiSubaccountGetSubAccountFuturesAccountV2Request {
	return ApiSubaccountGetSubAccountFuturesAccountV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesAccountV2Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesAccountV2Execute(r ApiSubaccountGetSubAccountFuturesAccountV2Request) (*SubaccountGetSubAccountFuturesAccountV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesAccountV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesAccountV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountFuturesInternalTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	futuresType *int64
	timestamp *int64
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Query-Sub-account-Futures-Asset-Transfer-History#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiSubaccountGetSubAccountFuturesInternalTransferV1Request) Email(email string) ApiSubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.email = &email
	return r
}

// 1:USDT-margined Futures，2: Coin-margined Futures
func (r ApiSubaccountGetSubAccountFuturesInternalTransferV1Request) FuturesType(futuresType int64) ApiSubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiSubaccountGetSubAccountFuturesInternalTransferV1Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

// Cannot be earlier than 1 month ago
func (r ApiSubaccountGetSubAccountFuturesInternalTransferV1Request) StartTime(startTime int64) ApiSubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiSubaccountGetSubAccountFuturesInternalTransferV1Request) EndTime(endTime int64) ApiSubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default value: 1
func (r ApiSubaccountGetSubAccountFuturesInternalTransferV1Request) Page(page int32) ApiSubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.page = &page
	return r
}

// Default value: 50, Max value: 500
func (r ApiSubaccountGetSubAccountFuturesInternalTransferV1Request) Limit(limit int32) ApiSubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.limit = &limit
	return r
}

func (r ApiSubaccountGetSubAccountFuturesInternalTransferV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountFuturesInternalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountFuturesInternalTransferV1Request) Execute() (*SubaccountGetSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesInternalTransferV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesInternalTransferV1 Query Sub-account Futures Asset Transfer History(For Master Account)

Query Sub-account Futures Asset Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountFuturesInternalTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesInternalTransferV1(ctx context.Context) ApiSubaccountGetSubAccountFuturesInternalTransferV1Request {
	return ApiSubaccountGetSubAccountFuturesInternalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesInternalTransferV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesInternalTransferV1Execute(r ApiSubaccountGetSubAccountFuturesInternalTransferV1Request) (*SubaccountGetSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesInternalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesInternalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountFuturesMovePositionV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	symbol *string
	page *int32
	row *int32
	timestamp *int64
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r ApiSubaccountGetSubAccountFuturesMovePositionV1Request) Symbol(symbol string) ApiSubaccountGetSubAccountFuturesMovePositionV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiSubaccountGetSubAccountFuturesMovePositionV1Request) Page(page int32) ApiSubaccountGetSubAccountFuturesMovePositionV1Request {
	r.page = &page
	return r
}

func (r ApiSubaccountGetSubAccountFuturesMovePositionV1Request) Row(row int32) ApiSubaccountGetSubAccountFuturesMovePositionV1Request {
	r.row = &row
	return r
}

func (r ApiSubaccountGetSubAccountFuturesMovePositionV1Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountFuturesMovePositionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetSubAccountFuturesMovePositionV1Request) StartTime(startTime int64) ApiSubaccountGetSubAccountFuturesMovePositionV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiSubaccountGetSubAccountFuturesMovePositionV1Request) EndTime(endTime int64) ApiSubaccountGetSubAccountFuturesMovePositionV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiSubaccountGetSubAccountFuturesMovePositionV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountFuturesMovePositionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountFuturesMovePositionV1Request) Execute() (*SubaccountGetSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountFuturesMovePositionV1Execute(r)
}

/*
SubaccountGetSubAccountFuturesMovePositionV1 Get Move Position History for Sub-account (For Master Account)

Query move position history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountFuturesMovePositionV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesMovePositionV1(ctx context.Context) ApiSubaccountGetSubAccountFuturesMovePositionV1Request {
	return ApiSubaccountGetSubAccountFuturesMovePositionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountFuturesMovePositionV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountFuturesMovePositionV1Execute(r ApiSubaccountGetSubAccountFuturesMovePositionV1Request) (*SubaccountGetSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountFuturesMovePositionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountFuturesMovePositionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/move-position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.row == nil {
		return localVarReturnValue, nil, reportError("row is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "row", r.row, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountMarginAccountSummaryV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiSubaccountGetSubAccountMarginAccountSummaryV1Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountMarginAccountSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetSubAccountMarginAccountSummaryV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountMarginAccountSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountMarginAccountSummaryV1Request) Execute() (*SubaccountGetSubAccountMarginAccountSummaryV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountMarginAccountSummaryV1Execute(r)
}

/*
SubaccountGetSubAccountMarginAccountSummaryV1 Get Summary of Sub-account's Margin Account(For Master Account)

Get Summary of Sub-account's Margin Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountMarginAccountSummaryV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountMarginAccountSummaryV1(ctx context.Context) ApiSubaccountGetSubAccountMarginAccountSummaryV1Request {
	return ApiSubaccountGetSubAccountMarginAccountSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountMarginAccountSummaryV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountMarginAccountSummaryV1Execute(r ApiSubaccountGetSubAccountMarginAccountSummaryV1Request) (*SubaccountGetSubAccountMarginAccountSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountMarginAccountSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountMarginAccountSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountMarginAccountV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Margin-Account#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiSubaccountGetSubAccountMarginAccountV1Request) Email(email string) ApiSubaccountGetSubAccountMarginAccountV1Request {
	r.email = &email
	return r
}

func (r ApiSubaccountGetSubAccountMarginAccountV1Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountMarginAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetSubAccountMarginAccountV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountMarginAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountMarginAccountV1Request) Execute() (*SubaccountGetSubAccountMarginAccountV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountMarginAccountV1Execute(r)
}

/*
SubaccountGetSubAccountMarginAccountV1 Get Detail on Sub-account's Margin Account(For Master Account)

Get Detail on Sub-account's Margin Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountMarginAccountV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountMarginAccountV1(ctx context.Context) ApiSubaccountGetSubAccountMarginAccountV1Request {
	return ApiSubaccountGetSubAccountMarginAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountMarginAccountV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountMarginAccountV1Execute(r ApiSubaccountGetSubAccountMarginAccountV1Request) (*SubaccountGetSubAccountMarginAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountMarginAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountMarginAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountSpotSummaryV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	email *string
	page *int64
	size *int64
	recvWindow *int64
}

func (r ApiSubaccountGetSubAccountSpotSummaryV1Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountSpotSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

// Sub account email
func (r ApiSubaccountGetSubAccountSpotSummaryV1Request) Email(email string) ApiSubaccountGetSubAccountSpotSummaryV1Request {
	r.email = &email
	return r
}

// default 1
func (r ApiSubaccountGetSubAccountSpotSummaryV1Request) Page(page int64) ApiSubaccountGetSubAccountSpotSummaryV1Request {
	r.page = &page
	return r
}

// default 10, max 20
func (r ApiSubaccountGetSubAccountSpotSummaryV1Request) Size(size int64) ApiSubaccountGetSubAccountSpotSummaryV1Request {
	r.size = &size
	return r
}

func (r ApiSubaccountGetSubAccountSpotSummaryV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountSpotSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountSpotSummaryV1Request) Execute() (*SubaccountGetSubAccountSpotSummaryV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountSpotSummaryV1Execute(r)
}

/*
SubaccountGetSubAccountSpotSummaryV1 Query Sub-account Spot Assets Summary(For Master Account)

Get BTC valued asset summary of subaccounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountSpotSummaryV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountSpotSummaryV1(ctx context.Context) ApiSubaccountGetSubAccountSpotSummaryV1Request {
	return ApiSubaccountGetSubAccountSpotSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountSpotSummaryV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountSpotSummaryV1Execute(r ApiSubaccountGetSubAccountSpotSummaryV1Request) (*SubaccountGetSubAccountSpotSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountSpotSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountSpotSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/spotSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountSubTransferHistoryV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	fromEmail *string
	toEmail *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ApiSubaccountGetSubAccountSubTransferHistoryV1Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountSubTransferHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetSubAccountSubTransferHistoryV1Request) FromEmail(fromEmail string) ApiSubaccountGetSubAccountSubTransferHistoryV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r ApiSubaccountGetSubAccountSubTransferHistoryV1Request) ToEmail(toEmail string) ApiSubaccountGetSubAccountSubTransferHistoryV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiSubaccountGetSubAccountSubTransferHistoryV1Request) StartTime(startTime int64) ApiSubaccountGetSubAccountSubTransferHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiSubaccountGetSubAccountSubTransferHistoryV1Request) EndTime(endTime int64) ApiSubaccountGetSubAccountSubTransferHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default value: 1
func (r ApiSubaccountGetSubAccountSubTransferHistoryV1Request) Page(page int32) ApiSubaccountGetSubAccountSubTransferHistoryV1Request {
	r.page = &page
	return r
}

// Default value: 500
func (r ApiSubaccountGetSubAccountSubTransferHistoryV1Request) Limit(limit int32) ApiSubaccountGetSubAccountSubTransferHistoryV1Request {
	r.limit = &limit
	return r
}

func (r ApiSubaccountGetSubAccountSubTransferHistoryV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountSubTransferHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountSubTransferHistoryV1Request) Execute() ([]SubaccountGetSubAccountSubTransferHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountSubTransferHistoryV1Execute(r)
}

/*
SubaccountGetSubAccountSubTransferHistoryV1 Query Sub-account Spot Asset Transfer History(For Master Account)

Query Sub-account Spot Asset Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountSubTransferHistoryV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountSubTransferHistoryV1(ctx context.Context) ApiSubaccountGetSubAccountSubTransferHistoryV1Request {
	return ApiSubaccountGetSubAccountSubTransferHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetSubAccountSubTransferHistoryV1RespItem
func (a *AssetManagementAPIService) SubaccountGetSubAccountSubTransferHistoryV1Execute(r ApiSubaccountGetSubAccountSubTransferHistoryV1Request) ([]SubaccountGetSubAccountSubTransferHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetSubAccountSubTransferHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountSubTransferHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/sub/transfer/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromEmail", r.fromEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.fromEmail = &defaultValue
	}
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toEmail", r.toEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.toEmail = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	asset *string
	type_ *int32
	startTime *int64
	endTime *int64
	limit *int32
	returnFailHistory *bool
	recvWindow *int64
}

func (r ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// If not sent, result of all assets will be returned
func (r ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request) Asset(asset string) ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.asset = &asset
	return r
}

// 1: transfer in, 2: transfer out
func (r ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request) Type_(type_ int32) ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request) StartTime(startTime int64) ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request) EndTime(endTime int64) ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default 500
func (r ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request) Limit(limit int32) ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.limit = &limit
	return r
}

// Default &#x60;False&#x60;, return PROCESS and SUCCESS status history; If &#x60;True&#x60;,return PROCESS and SUCCESS and FAILURE status history
func (r ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request) ReturnFailHistory(returnFailHistory bool) ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.returnFailHistory = &returnFailHistory
	return r
}

func (r ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request) Execute() ([]SubaccountGetSubAccountTransferSubUserHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountTransferSubUserHistoryV1Execute(r)
}

/*
SubaccountGetSubAccountTransferSubUserHistoryV1 Sub-account Transfer History(For Sub-account)

Sub-account Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountTransferSubUserHistoryV1(ctx context.Context) ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request {
	return ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetSubAccountTransferSubUserHistoryV1RespItem
func (a *AssetManagementAPIService) SubaccountGetSubAccountTransferSubUserHistoryV1Execute(r ApiSubaccountGetSubAccountTransferSubUserHistoryV1Request) ([]SubaccountGetSubAccountTransferSubUserHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetSubAccountTransferSubUserHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountTransferSubUserHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subUserHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.returnFailHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFailHistory", r.returnFailHistory, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSubAccountUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *AssetManagementAPIService
	timestamp *int64
	fromEmail *string
	toEmail *string
	clientTranId *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ApiSubaccountGetSubAccountUniversalTransferV1Request) Timestamp(timestamp int64) ApiSubaccountGetSubAccountUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSubaccountGetSubAccountUniversalTransferV1Request) FromEmail(fromEmail string) ApiSubaccountGetSubAccountUniversalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r ApiSubaccountGetSubAccountUniversalTransferV1Request) ToEmail(toEmail string) ApiSubaccountGetSubAccountUniversalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiSubaccountGetSubAccountUniversalTransferV1Request) ClientTranId(clientTranId string) ApiSubaccountGetSubAccountUniversalTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r ApiSubaccountGetSubAccountUniversalTransferV1Request) StartTime(startTime int64) ApiSubaccountGetSubAccountUniversalTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiSubaccountGetSubAccountUniversalTransferV1Request) EndTime(endTime int64) ApiSubaccountGetSubAccountUniversalTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default 1
func (r ApiSubaccountGetSubAccountUniversalTransferV1Request) Page(page int32) ApiSubaccountGetSubAccountUniversalTransferV1Request {
	r.page = &page
	return r
}

// Default 500, Max 500
func (r ApiSubaccountGetSubAccountUniversalTransferV1Request) Limit(limit int32) ApiSubaccountGetSubAccountUniversalTransferV1Request {
	r.limit = &limit
	return r
}

func (r ApiSubaccountGetSubAccountUniversalTransferV1Request) RecvWindow(recvWindow int64) ApiSubaccountGetSubAccountUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSubAccountUniversalTransferV1Request) Execute() (*SubaccountGetSubAccountUniversalTransferV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetSubAccountUniversalTransferV1Execute(r)
}

/*
SubaccountGetSubAccountUniversalTransferV1 Query Universal Transfer History(For Master Account)

Query Universal Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSubAccountUniversalTransferV1Request
*/
func (a *AssetManagementAPIService) SubaccountGetSubAccountUniversalTransferV1(ctx context.Context) ApiSubaccountGetSubAccountUniversalTransferV1Request {
	return ApiSubaccountGetSubAccountUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountUniversalTransferV1Resp
func (a *AssetManagementAPIService) SubaccountGetSubAccountUniversalTransferV1Execute(r ApiSubaccountGetSubAccountUniversalTransferV1Request) (*SubaccountGetSubAccountUniversalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountUniversalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetManagementAPIService.SubaccountGetSubAccountUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromEmail", r.fromEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.fromEmail = &defaultValue
	}
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toEmail", r.toEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.toEmail = &defaultValue
	}
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientTranId", r.clientTranId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientTranId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

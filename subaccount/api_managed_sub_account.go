/*
Binance Sub Account API

OpenAPI specification for Binance exchange - Subaccount API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package subaccount

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ManagedSubAccountAPIService ManagedSubAccountAPI service
type ManagedSubAccountAPIService service

type ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	amount *string
	asset *string
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request) Amount(amount string) ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request {
	r.amount = &amount
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request) Asset(asset string) ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request {
	r.asset = &asset
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request) Timestamp(timestamp int64) ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request) ToEmail(toEmail string) ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request) RecvWindow(recvWindow int64) ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request) Execute() (*SubaccountCreateManagedSubaccountDepositV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateManagedSubaccountDepositV1Execute(r)
}

/*
SubaccountCreateManagedSubaccountDepositV1 Deposit Assets Into The Managed Sub-account(For Investor Master Account)

Deposit Assets Into The Managed Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountCreateManagedSubaccountDepositV1(ctx context.Context) ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request {
	return ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateManagedSubaccountDepositV1Resp
func (a *ManagedSubAccountAPIService) SubaccountCreateManagedSubaccountDepositV1Execute(r ManagedSubAccountAPISubaccountCreateManagedSubaccountDepositV1Request) (*SubaccountCreateManagedSubaccountDepositV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateManagedSubaccountDepositV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountCreateManagedSubaccountDepositV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/deposit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	amount *string
	asset *string
	fromEmail *string
	timestamp *int64
	recvWindow *int64
	transferDate *int64
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request) Amount(amount string) ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.amount = &amount
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request) Asset(asset string) ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.asset = &asset
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request) FromEmail(fromEmail string) ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request) Timestamp(timestamp int64) ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request) RecvWindow(recvWindow int64) ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request) TransferDate(transferDate int64) ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request {
	r.transferDate = &transferDate
	return r
}

func (r ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request) Execute() (*SubaccountCreateManagedSubaccountWithdrawV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountCreateManagedSubaccountWithdrawV1Execute(r)
}

/*
SubaccountCreateManagedSubaccountWithdrawV1 Withdrawl Assets From The Managed Sub-account(For Investor Master Account)

Withdrawl Assets From The Managed Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountCreateManagedSubaccountWithdrawV1(ctx context.Context) ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request {
	return ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountCreateManagedSubaccountWithdrawV1Resp
func (a *ManagedSubAccountAPIService) SubaccountCreateManagedSubaccountWithdrawV1Execute(r ManagedSubAccountAPISubaccountCreateManagedSubaccountWithdrawV1Request) (*SubaccountCreateManagedSubaccountWithdrawV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountCreateManagedSubaccountWithdrawV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountCreateManagedSubaccountWithdrawV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/withdraw"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.transferDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transferDate", r.transferDate, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	email *string
	type_ *string
	timestamp *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request) Email(email string) ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.email = &email
	return r
}

// &amp;#34;SPOT&amp;#34;, &amp;#34;MARGIN&amp;#34;（cross）, &amp;#34;FUTURES&amp;#34;（UM）
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request) Type_(type_ string) ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.type_ = &type_
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request) Timestamp(timestamp int64) ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request) StartTime(startTime int64) ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.startTime = &startTime
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request) EndTime(endTime int64) ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.endTime = &endTime
	return r
}

// min 7, max 30, default 7
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request) Limit(limit int32) ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.limit = &limit
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request) RecvWindow(recvWindow int64) ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request) Execute() (*SubaccountGetManagedSubaccountAccountSnapshotV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountAccountSnapshotV1Execute(r)
}

/*
SubaccountGetManagedSubaccountAccountSnapshotV1 Query Managed Sub-account Snapshot(For Investor Master Account)

Query Managed Sub-account Snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountAccountSnapshotV1(ctx context.Context) ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request {
	return ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountAccountSnapshotV1Resp
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountAccountSnapshotV1Execute(r ManagedSubAccountAPISubaccountGetManagedSubaccountAccountSnapshotV1Request) (*SubaccountGetManagedSubaccountAccountSnapshotV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountAccountSnapshotV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountGetManagedSubaccountAccountSnapshotV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/accountSnapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 7
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request) Email(email string) ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request {
	r.email = &email
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request) Timestamp(timestamp int64) ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request) RecvWindow(recvWindow int64) ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request) Execute() ([]SubaccountGetManagedSubaccountAssetV1RespItem, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountAssetV1Execute(r)
}

/*
SubaccountGetManagedSubaccountAssetV1 Query Managed Sub-account Asset Details(For Investor Master Account)

Query Managed Sub-account Asset Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountAssetV1(ctx context.Context) ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request {
	return ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SubaccountGetManagedSubaccountAssetV1RespItem
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountAssetV1Execute(r ManagedSubAccountAPISubaccountGetManagedSubaccountAssetV1Request) ([]SubaccountGetManagedSubaccountAssetV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SubaccountGetManagedSubaccountAssetV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountGetManagedSubaccountAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	email *string
	coin *string
	timestamp *int64
	network *string
	amount *string
	recvWindow *int64
}

// Sub user email
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request) Email(email string) ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.email = &email
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request) Coin(coin string) ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.coin = &coin
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request) Timestamp(timestamp int64) ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.timestamp = &timestamp
	return r
}

// networks can be found in &#x60;GET /sapi/v1/capital/deposit/address&#x60;
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request) Network(network string) ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.network = &network
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request) Amount(amount string) ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.amount = &amount
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request) RecvWindow(recvWindow int64) ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request) Execute() (*SubaccountGetManagedSubaccountDepositAddressV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountDepositAddressV1Execute(r)
}

/*
SubaccountGetManagedSubaccountDepositAddressV1 Get Managed Sub-account Deposit Address (For Investor Master Account)(USER_DATA)

Get investor's managed sub-account deposit address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountDepositAddressV1(ctx context.Context) ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request {
	return ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountDepositAddressV1Resp
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountDepositAddressV1Execute(r ManagedSubAccountAPISubaccountGetManagedSubaccountDepositAddressV1Request) (*SubaccountGetManagedSubaccountDepositAddressV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountDepositAddressV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountGetManagedSubaccountDepositAddressV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/deposit/address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	} else {
		var defaultValue string = ""
		r.amount = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSubAccountAPISubaccountGetManagedSubaccountFetchFutureAssetV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	email *string
	accountType *string
}

// Managed Sub Account Email
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountFetchFutureAssetV1Request) Email(email string) ManagedSubAccountAPISubaccountGetManagedSubaccountFetchFutureAssetV1Request {
	r.email = &email
	return r
}

// No input or input &amp;#34;USDT_FUTURE&amp;#34; to get UM Futures account details. Input &amp;#34;COIN_FUTURE&amp;#34; to get CM Futures account details.
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountFetchFutureAssetV1Request) AccountType(accountType string) ManagedSubAccountAPISubaccountGetManagedSubaccountFetchFutureAssetV1Request {
	r.accountType = &accountType
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountFetchFutureAssetV1Request) Execute() (*SubaccountGetManagedSubaccountFetchFutureAssetV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountFetchFutureAssetV1Execute(r)
}

/*
SubaccountGetManagedSubaccountFetchFutureAssetV1 Query Managed Sub-account Futures Asset Details(For Investor Master Account)(USER_DATA)

Investor can use this api to query managed sub account futures asset details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountGetManagedSubaccountFetchFutureAssetV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountFetchFutureAssetV1(ctx context.Context) ManagedSubAccountAPISubaccountGetManagedSubaccountFetchFutureAssetV1Request {
	return ManagedSubAccountAPISubaccountGetManagedSubaccountFetchFutureAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountFetchFutureAssetV1Resp
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountFetchFutureAssetV1Execute(r ManagedSubAccountAPISubaccountGetManagedSubaccountFetchFutureAssetV1Request) (*SubaccountGetManagedSubaccountFetchFutureAssetV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountFetchFutureAssetV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountGetManagedSubaccountFetchFutureAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/fetch-future-asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "form", "")
	} else {
		var defaultValue string = ""
		r.accountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	timestamp *int64
	email *string
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request) Timestamp(timestamp int64) ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request {
	r.timestamp = &timestamp
	return r
}

// Managed sub-account email
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request) Email(email string) ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request {
	r.email = &email
	return r
}

// Default value: 1
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request) Page(page int32) ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request {
	r.page = &page
	return r
}

// Default value: 20, Max value: 20
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request) Limit(limit int32) ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request {
	r.limit = &limit
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request) RecvWindow(recvWindow int64) ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request) Execute() (*SubaccountGetManagedSubaccountInfoV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountInfoV1Execute(r)
}

/*
SubaccountGetManagedSubaccountInfoV1 Query Managed Sub-account List(For Investor)(USER_DATA)

Get investor's managed sub-account list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountInfoV1(ctx context.Context) ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request {
	return ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountInfoV1Resp
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountInfoV1Execute(r ManagedSubAccountAPISubaccountGetManagedSubaccountInfoV1Request) (*SubaccountGetManagedSubaccountInfoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountInfoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountGetManagedSubaccountInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSubAccountAPISubaccountGetManagedSubaccountMarginAssetV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	email *string
	accountType *string
}

// Managed Sub Account Email
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountMarginAssetV1Request) Email(email string) ManagedSubAccountAPISubaccountGetManagedSubaccountMarginAssetV1Request {
	r.email = &email
	return r
}

// No input or input &amp;#34;MARGIN&amp;#34; to get Cross Margin account details. Input &amp;#34;ISOLATED_MARGIN&amp;#34; to get Isolated Margin account details.
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountMarginAssetV1Request) AccountType(accountType string) ManagedSubAccountAPISubaccountGetManagedSubaccountMarginAssetV1Request {
	r.accountType = &accountType
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountMarginAssetV1Request) Execute() (*SubaccountGetManagedSubaccountMarginAssetV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountMarginAssetV1Execute(r)
}

/*
SubaccountGetManagedSubaccountMarginAssetV1 Query Managed Sub-account Margin Asset Details(For Investor Master Account)(USER_DATA)

Investor can use this api to query managed sub account margin asset details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountGetManagedSubaccountMarginAssetV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountMarginAssetV1(ctx context.Context) ManagedSubAccountAPISubaccountGetManagedSubaccountMarginAssetV1Request {
	return ManagedSubAccountAPISubaccountGetManagedSubaccountMarginAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountMarginAssetV1Resp
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountMarginAssetV1Execute(r ManagedSubAccountAPISubaccountGetManagedSubaccountMarginAssetV1Request) (*SubaccountGetManagedSubaccountMarginAssetV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountMarginAssetV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountGetManagedSubaccountMarginAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/marginAsset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "form", "")
	} else {
		var defaultValue string = ""
		r.accountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	email *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	transfers *string
	transferFunctionAccountType *string
}

// Managed Sub Account Email
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) Email(email string) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.email = &email
	return r
}

// Start Time
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) StartTime(startTime int64) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.startTime = &startTime
	return r
}

// End Time (The start time and end time interval cannot exceed half a year)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) EndTime(endTime int64) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.endTime = &endTime
	return r
}

// Page
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) Page(page int32) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.page = &page
	return r
}

// Limit (Max: 500)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) Limit(limit int32) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.limit = &limit
	return r
}

// Transfer Direction (FROM/TO)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) Transfers(transfers string) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.transfers = &transfers
	return r
}

// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) TransferFunctionAccountType(transferFunctionAccountType string) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.transferFunctionAccountType = &transferFunctionAccountType
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) Execute() (*SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Execute(r)
}

/*
SubaccountGetManagedSubaccountQueryTransLogForInvestorV1 Query Managed Sub Account Transfer Log(For Investor Master Account)(USER_DATA)

Investor can use this api to query managed sub account transfer log. This endpoint is available for investor of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team.
Please refer to link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountQueryTransLogForInvestorV1(ctx context.Context) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request {
	return ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Execute(r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForInvestorV1Request) (*SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountGetManagedSubaccountQueryTransLogForInvestorV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/queryTransLogForInvestor"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.transfers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transfers", r.transfers, "form", "")
	} else {
		var defaultValue string = ""
		r.transfers = &defaultValue
	}
	if r.transferFunctionAccountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferFunctionAccountType", r.transferFunctionAccountType, "form", "")
	} else {
		var defaultValue string = ""
		r.transferFunctionAccountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	email *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	transfers *string
	transferFunctionAccountType *string
}

// Managed Sub Account Email
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) Email(email string) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.email = &email
	return r
}

// Start Time
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) StartTime(startTime int64) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.startTime = &startTime
	return r
}

// End Time (The start time and end time interval cannot exceed half a year)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) EndTime(endTime int64) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.endTime = &endTime
	return r
}

// Page
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) Page(page int32) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.page = &page
	return r
}

// Limit (Max: 500)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) Limit(limit int32) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.limit = &limit
	return r
}

// Transfer Direction (FROM/TO)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) Transfers(transfers string) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.transfers = &transfers
	return r
}

// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) TransferFunctionAccountType(transferFunctionAccountType string) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.transferFunctionAccountType = &transferFunctionAccountType
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) Execute() (*SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Execute(r)
}

/*
SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1 Query Managed Sub Account Transfer Log(For Trading Team Master Account)(USER_DATA)

Trading team can use this api to query managed sub account transfer log. This endpoint is available for trading team of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team.
Please refer to link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1(ctx context.Context) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	return ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Execute(r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Request) (*SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/queryTransLogForTradeParent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.transfers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transfers", r.transfers, "form", "")
	} else {
		var defaultValue string = ""
		r.transfers = &defaultValue
	}
	if r.transferFunctionAccountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferFunctionAccountType", r.transferFunctionAccountType, "form", "")
	} else {
		var defaultValue string = ""
		r.transferFunctionAccountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request struct {
	ctx context.Context
	ApiService *ManagedSubAccountAPIService
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	timestamp *int64
	transfers *string
	transferFunctionAccountType *string
	recvWindow *int64
}

// Start Time
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request) StartTime(startTime int64) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.startTime = &startTime
	return r
}

// End Time (The start time and end time interval cannot exceed half a year)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request) EndTime(endTime int64) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.endTime = &endTime
	return r
}

// Page
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request) Page(page int32) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.page = &page
	return r
}

// Limit (Max: 500)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request) Limit(limit int32) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.limit = &limit
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request) Timestamp(timestamp int64) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.timestamp = &timestamp
	return r
}

// Transfer Direction (FROM/TO)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request) Transfers(transfers string) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.transfers = &transfers
	return r
}

// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request) TransferFunctionAccountType(transferFunctionAccountType string) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.transferFunctionAccountType = &transferFunctionAccountType
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request) RecvWindow(recvWindow int64) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request) Execute() (*SubaccountGetManagedSubaccountQueryTransLogV1Resp, *http.Response, error) {
	return r.ApiService.SubaccountGetManagedSubaccountQueryTransLogV1Execute(r)
}

/*
SubaccountGetManagedSubaccountQueryTransLogV1 Query Managed Sub Account Transfer Log (For Trading Team Sub Account)(USER_DATA)

Query Managed Sub Account Transfer Log (For Trading Team Sub Account)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request
*/
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountQueryTransLogV1(ctx context.Context) ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request {
	return ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetManagedSubaccountQueryTransLogV1Resp
func (a *ManagedSubAccountAPIService) SubaccountGetManagedSubaccountQueryTransLogV1Execute(r ManagedSubAccountAPISubaccountGetManagedSubaccountQueryTransLogV1Request) (*SubaccountGetManagedSubaccountQueryTransLogV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetManagedSubaccountQueryTransLogV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManagedSubAccountAPIService.SubaccountGetManagedSubaccountQueryTransLogV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/query-trans-log"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.transfers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transfers", r.transfers, "form", "")
	} else {
		var defaultValue string = ""
		r.transfers = &defaultValue
	}
	if r.transferFunctionAccountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferFunctionAccountType", r.transferFunctionAccountType, "form", "")
	} else {
		var defaultValue string = ""
		r.transferFunctionAccountType = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

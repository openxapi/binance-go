/*
Binance Ufutures API

OpenAPI specification for Binance cryptocurrency exchange - Ufutures API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ufutures

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// MarketDataAPIService MarketDataAPI service
type MarketDataAPIService service

type MarketDataAPIUfuturesGetAggTradesV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
}

func (r MarketDataAPIUfuturesGetAggTradesV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetAggTradesV1Request {
	r.symbol = &symbol
	return r
}

// ID to get aggregate trades from INCLUSIVE.
func (r MarketDataAPIUfuturesGetAggTradesV1Request) FromId(fromId int64) MarketDataAPIUfuturesGetAggTradesV1Request {
	r.fromId = &fromId
	return r
}

// Timestamp in ms to get aggregate trades from INCLUSIVE.
func (r MarketDataAPIUfuturesGetAggTradesV1Request) StartTime(startTime int64) MarketDataAPIUfuturesGetAggTradesV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get aggregate trades until INCLUSIVE.
func (r MarketDataAPIUfuturesGetAggTradesV1Request) EndTime(endTime int64) MarketDataAPIUfuturesGetAggTradesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r MarketDataAPIUfuturesGetAggTradesV1Request) Limit(limit int32) MarketDataAPIUfuturesGetAggTradesV1Request {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetAggTradesV1Request) Execute() ([]UfuturesGetAggTradesV1RespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetAggTradesV1Execute(r)
}

/*
UfuturesGetAggTradesV1 Compressed/Aggregate Trades List

Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetAggTradesV1Request
*/
func (a *MarketDataAPIService) UfuturesGetAggTradesV1(ctx context.Context) MarketDataAPIUfuturesGetAggTradesV1Request {
	return MarketDataAPIUfuturesGetAggTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetAggTradesV1RespItem
func (a *MarketDataAPIService) UfuturesGetAggTradesV1Execute(r MarketDataAPIUfuturesGetAggTradesV1Request) ([]UfuturesGetAggTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetAggTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetAggTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/aggTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetAssetIndexV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
}

// Asset pair
func (r MarketDataAPIUfuturesGetAssetIndexV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetAssetIndexV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetAssetIndexV1Request) Execute() (*UfuturesGetAssetIndexV1Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetAssetIndexV1Execute(r)
}

/*
UfuturesGetAssetIndexV1 Multi-Assets Mode Asset Index

asset index for Multi-Assets mode

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetAssetIndexV1Request
*/
func (a *MarketDataAPIService) UfuturesGetAssetIndexV1(ctx context.Context) MarketDataAPIUfuturesGetAssetIndexV1Request {
	return MarketDataAPIUfuturesGetAssetIndexV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetAssetIndexV1Resp
func (a *MarketDataAPIService) UfuturesGetAssetIndexV1Execute(r MarketDataAPIUfuturesGetAssetIndexV1Request) (*UfuturesGetAssetIndexV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetAssetIndexV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetAssetIndexV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/assetIndex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetConstituentsV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
}

func (r MarketDataAPIUfuturesGetConstituentsV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetConstituentsV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetConstituentsV1Request) Execute() (*UfuturesGetConstituentsV1Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetConstituentsV1Execute(r)
}

/*
UfuturesGetConstituentsV1 Query Index Price Constituents

Query index price constituents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetConstituentsV1Request
*/
func (a *MarketDataAPIService) UfuturesGetConstituentsV1(ctx context.Context) MarketDataAPIUfuturesGetConstituentsV1Request {
	return MarketDataAPIUfuturesGetConstituentsV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetConstituentsV1Resp
func (a *MarketDataAPIService) UfuturesGetConstituentsV1Execute(r MarketDataAPIUfuturesGetConstituentsV1Request) (*UfuturesGetConstituentsV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetConstituentsV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetConstituentsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/constituents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetContinuousKlinesV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	pair *string
	contractType *string
	interval *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r MarketDataAPIUfuturesGetContinuousKlinesV1Request) Pair(pair string) MarketDataAPIUfuturesGetContinuousKlinesV1Request {
	r.pair = &pair
	return r
}

func (r MarketDataAPIUfuturesGetContinuousKlinesV1Request) ContractType(contractType string) MarketDataAPIUfuturesGetContinuousKlinesV1Request {
	r.contractType = &contractType
	return r
}

func (r MarketDataAPIUfuturesGetContinuousKlinesV1Request) Interval(interval string) MarketDataAPIUfuturesGetContinuousKlinesV1Request {
	r.interval = &interval
	return r
}

func (r MarketDataAPIUfuturesGetContinuousKlinesV1Request) StartTime(startTime int64) MarketDataAPIUfuturesGetContinuousKlinesV1Request {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetContinuousKlinesV1Request) EndTime(endTime int64) MarketDataAPIUfuturesGetContinuousKlinesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1500.
func (r MarketDataAPIUfuturesGetContinuousKlinesV1Request) Limit(limit int32) MarketDataAPIUfuturesGetContinuousKlinesV1Request {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetContinuousKlinesV1Request) Execute() ([][]UfuturesGetContinuousKlinesV1200ResponseInnerInner, *http.Response, error) {
	return r.ApiService.UfuturesGetContinuousKlinesV1Execute(r)
}

/*
UfuturesGetContinuousKlinesV1 Continuous Contract Kline/Candlestick Data

Kline/candlestick bars for a specific contract type.
Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetContinuousKlinesV1Request
*/
func (a *MarketDataAPIService) UfuturesGetContinuousKlinesV1(ctx context.Context) MarketDataAPIUfuturesGetContinuousKlinesV1Request {
	return MarketDataAPIUfuturesGetContinuousKlinesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]UfuturesGetContinuousKlinesV1200ResponseInnerInner
func (a *MarketDataAPIService) UfuturesGetContinuousKlinesV1Execute(r MarketDataAPIUfuturesGetContinuousKlinesV1Request) ([][]UfuturesGetContinuousKlinesV1200ResponseInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]UfuturesGetContinuousKlinesV1200ResponseInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetContinuousKlinesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/continuousKlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pair == nil {
		return localVarReturnValue, nil, reportError("pair is required and must be specified")
	}
	if r.contractType == nil {
		return localVarReturnValue, nil, reportError("contractType is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "contractType", r.contractType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetDepthV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	limit *int32
}

func (r MarketDataAPIUfuturesGetDepthV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetDepthV1Request {
	r.symbol = &symbol
	return r
}

// Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
func (r MarketDataAPIUfuturesGetDepthV1Request) Limit(limit int32) MarketDataAPIUfuturesGetDepthV1Request {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetDepthV1Request) Execute() (*UfuturesGetDepthV1Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetDepthV1Execute(r)
}

/*
UfuturesGetDepthV1 Order Book

Query symbol orderbook

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetDepthV1Request
*/
func (a *MarketDataAPIService) UfuturesGetDepthV1(ctx context.Context) MarketDataAPIUfuturesGetDepthV1Request {
	return MarketDataAPIUfuturesGetDepthV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetDepthV1Resp
func (a *MarketDataAPIService) UfuturesGetDepthV1Execute(r MarketDataAPIUfuturesGetDepthV1Request) (*UfuturesGetDepthV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetDepthV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetDepthV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetExchangeInfoV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
}

func (r MarketDataAPIUfuturesGetExchangeInfoV1Request) Execute() (*UfuturesGetExchangeInfoV1Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetExchangeInfoV1Execute(r)
}

/*
UfuturesGetExchangeInfoV1 Exchange Information

Current exchange trading rules and symbol information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetExchangeInfoV1Request
*/
func (a *MarketDataAPIService) UfuturesGetExchangeInfoV1(ctx context.Context) MarketDataAPIUfuturesGetExchangeInfoV1Request {
	return MarketDataAPIUfuturesGetExchangeInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetExchangeInfoV1Resp
func (a *MarketDataAPIService) UfuturesGetExchangeInfoV1Execute(r MarketDataAPIUfuturesGetExchangeInfoV1Request) (*UfuturesGetExchangeInfoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetExchangeInfoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetExchangeInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/exchangeInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetFundingInfoV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
}

func (r MarketDataAPIUfuturesGetFundingInfoV1Request) Execute() ([]UfuturesGetFundingInfoV1RespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetFundingInfoV1Execute(r)
}

/*
UfuturesGetFundingInfoV1 Get Funding Rate Info

Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetFundingInfoV1Request
*/
func (a *MarketDataAPIService) UfuturesGetFundingInfoV1(ctx context.Context) MarketDataAPIUfuturesGetFundingInfoV1Request {
	return MarketDataAPIUfuturesGetFundingInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetFundingInfoV1RespItem
func (a *MarketDataAPIService) UfuturesGetFundingInfoV1Execute(r MarketDataAPIUfuturesGetFundingInfoV1Request) ([]UfuturesGetFundingInfoV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetFundingInfoV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetFundingInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/fundingInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetFundingRateV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r MarketDataAPIUfuturesGetFundingRateV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetFundingRateV1Request {
	r.symbol = &symbol
	return r
}

// Timestamp in ms to get funding rate from INCLUSIVE.
func (r MarketDataAPIUfuturesGetFundingRateV1Request) StartTime(startTime int64) MarketDataAPIUfuturesGetFundingRateV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get funding rate  until INCLUSIVE.
func (r MarketDataAPIUfuturesGetFundingRateV1Request) EndTime(endTime int64) MarketDataAPIUfuturesGetFundingRateV1Request {
	r.endTime = &endTime
	return r
}

// Default 100; max 1000
func (r MarketDataAPIUfuturesGetFundingRateV1Request) Limit(limit int32) MarketDataAPIUfuturesGetFundingRateV1Request {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetFundingRateV1Request) Execute() ([]UfuturesGetFundingRateV1RespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetFundingRateV1Execute(r)
}

/*
UfuturesGetFundingRateV1 Get Funding Rate History

Get Funding Rate History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetFundingRateV1Request
*/
func (a *MarketDataAPIService) UfuturesGetFundingRateV1(ctx context.Context) MarketDataAPIUfuturesGetFundingRateV1Request {
	return MarketDataAPIUfuturesGetFundingRateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetFundingRateV1RespItem
func (a *MarketDataAPIService) UfuturesGetFundingRateV1Execute(r MarketDataAPIUfuturesGetFundingRateV1Request) ([]UfuturesGetFundingRateV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetFundingRateV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetFundingRateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/fundingRate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetFuturesDataBasisRequest struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	pair *string
	contractType *string
	period *string
	limit *int64
	startTime *int64
	endTime *int64
}

// BTCUSDT
func (r MarketDataAPIUfuturesGetFuturesDataBasisRequest) Pair(pair string) MarketDataAPIUfuturesGetFuturesDataBasisRequest {
	r.pair = &pair
	return r
}

// CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
func (r MarketDataAPIUfuturesGetFuturesDataBasisRequest) ContractType(contractType string) MarketDataAPIUfuturesGetFuturesDataBasisRequest {
	r.contractType = &contractType
	return r
}

// &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
func (r MarketDataAPIUfuturesGetFuturesDataBasisRequest) Period(period string) MarketDataAPIUfuturesGetFuturesDataBasisRequest {
	r.period = &period
	return r
}

// Default 30,Max 500
func (r MarketDataAPIUfuturesGetFuturesDataBasisRequest) Limit(limit int64) MarketDataAPIUfuturesGetFuturesDataBasisRequest {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataBasisRequest) StartTime(startTime int64) MarketDataAPIUfuturesGetFuturesDataBasisRequest {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataBasisRequest) EndTime(endTime int64) MarketDataAPIUfuturesGetFuturesDataBasisRequest {
	r.endTime = &endTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataBasisRequest) Execute() ([]UfuturesGetFuturesDataBasisRespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetFuturesDataBasisExecute(r)
}

/*
UfuturesGetFuturesDataBasis Basis

Query future basis

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetFuturesDataBasisRequest
*/
func (a *MarketDataAPIService) UfuturesGetFuturesDataBasis(ctx context.Context) MarketDataAPIUfuturesGetFuturesDataBasisRequest {
	return MarketDataAPIUfuturesGetFuturesDataBasisRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetFuturesDataBasisRespItem
func (a *MarketDataAPIService) UfuturesGetFuturesDataBasisExecute(r MarketDataAPIUfuturesGetFuturesDataBasisRequest) ([]UfuturesGetFuturesDataBasisRespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetFuturesDataBasisRespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetFuturesDataBasis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/futures/data/basis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pair == nil {
		return localVarReturnValue, nil, reportError("pair is required and must be specified")
	}
	if r.contractType == nil {
		return localVarReturnValue, nil, reportError("contractType is required and must be specified")
	}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "contractType", r.contractType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetFuturesDataDeliveryPriceRequest struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	pair *string
}

// e.g BTCUSDT
func (r MarketDataAPIUfuturesGetFuturesDataDeliveryPriceRequest) Pair(pair string) MarketDataAPIUfuturesGetFuturesDataDeliveryPriceRequest {
	r.pair = &pair
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataDeliveryPriceRequest) Execute() ([]UfuturesGetFuturesDataDeliveryPriceRespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetFuturesDataDeliveryPriceExecute(r)
}

/*
UfuturesGetFuturesDataDeliveryPrice Quarterly Contract Settlement Price

Latest price for a symbol or symbols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetFuturesDataDeliveryPriceRequest
*/
func (a *MarketDataAPIService) UfuturesGetFuturesDataDeliveryPrice(ctx context.Context) MarketDataAPIUfuturesGetFuturesDataDeliveryPriceRequest {
	return MarketDataAPIUfuturesGetFuturesDataDeliveryPriceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetFuturesDataDeliveryPriceRespItem
func (a *MarketDataAPIService) UfuturesGetFuturesDataDeliveryPriceExecute(r MarketDataAPIUfuturesGetFuturesDataDeliveryPriceRequest) ([]UfuturesGetFuturesDataDeliveryPriceRespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetFuturesDataDeliveryPriceRespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetFuturesDataDeliveryPrice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/futures/data/delivery-price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pair == nil {
		return localVarReturnValue, nil, reportError("pair is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	period *string
	limit *int64
	startTime *int64
	endTime *int64
}

func (r MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest) Symbol(symbol string) MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest {
	r.symbol = &symbol
	return r
}

// &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
func (r MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest) Period(period string) MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest {
	r.period = &period
	return r
}

// default 30, max 500
func (r MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest) Limit(limit int64) MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest) StartTime(startTime int64) MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest) EndTime(endTime int64) MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest {
	r.endTime = &endTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest) Execute() ([]UfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetFuturesDataGlobalLongShortAccountRatioExecute(r)
}

/*
UfuturesGetFuturesDataGlobalLongShortAccountRatio Long/Short Ratio

Query symbol Long/Short Ratio

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest
*/
func (a *MarketDataAPIService) UfuturesGetFuturesDataGlobalLongShortAccountRatio(ctx context.Context) MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest {
	return MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem
func (a *MarketDataAPIService) UfuturesGetFuturesDataGlobalLongShortAccountRatioExecute(r MarketDataAPIUfuturesGetFuturesDataGlobalLongShortAccountRatioRequest) ([]UfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetFuturesDataGlobalLongShortAccountRatioRespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetFuturesDataGlobalLongShortAccountRatio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/futures/data/globalLongShortAccountRatio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 30
		r.limit = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	period *string
	limit *int64
	startTime *int64
	endTime *int64
}

func (r MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest) Symbol(symbol string) MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest {
	r.symbol = &symbol
	return r
}

// &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
func (r MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest) Period(period string) MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest {
	r.period = &period
	return r
}

// default 30, max 500
func (r MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest) Limit(limit int64) MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest) StartTime(startTime int64) MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest) EndTime(endTime int64) MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest {
	r.endTime = &endTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest) Execute() ([]UfuturesGetFuturesDataOpenInterestHistRespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetFuturesDataOpenInterestHistExecute(r)
}

/*
UfuturesGetFuturesDataOpenInterestHist Open Interest Statistics

Open Interest Statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest
*/
func (a *MarketDataAPIService) UfuturesGetFuturesDataOpenInterestHist(ctx context.Context) MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest {
	return MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetFuturesDataOpenInterestHistRespItem
func (a *MarketDataAPIService) UfuturesGetFuturesDataOpenInterestHistExecute(r MarketDataAPIUfuturesGetFuturesDataOpenInterestHistRequest) ([]UfuturesGetFuturesDataOpenInterestHistRespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetFuturesDataOpenInterestHistRespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetFuturesDataOpenInterestHist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/futures/data/openInterestHist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 30
		r.limit = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	period *string
	limit *int64
	startTime *int64
	endTime *int64
}

func (r MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest) Symbol(symbol string) MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest {
	r.symbol = &symbol
	return r
}

// &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
func (r MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest) Period(period string) MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest {
	r.period = &period
	return r
}

// default 30, max 500
func (r MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest) Limit(limit int64) MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest) StartTime(startTime int64) MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest) EndTime(endTime int64) MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest {
	r.endTime = &endTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest) Execute() ([]UfuturesGetFuturesDataTakerlongshortRatioRespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetFuturesDataTakerlongshortRatioExecute(r)
}

/*
UfuturesGetFuturesDataTakerlongshortRatio Taker Buy/Sell Volume

Taker Buy/Sell Volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest
*/
func (a *MarketDataAPIService) UfuturesGetFuturesDataTakerlongshortRatio(ctx context.Context) MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest {
	return MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetFuturesDataTakerlongshortRatioRespItem
func (a *MarketDataAPIService) UfuturesGetFuturesDataTakerlongshortRatioExecute(r MarketDataAPIUfuturesGetFuturesDataTakerlongshortRatioRequest) ([]UfuturesGetFuturesDataTakerlongshortRatioRespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetFuturesDataTakerlongshortRatioRespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetFuturesDataTakerlongshortRatio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/futures/data/takerlongshortRatio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 30
		r.limit = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	period *string
	limit *int64
	startTime *int64
	endTime *int64
}

func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest) Symbol(symbol string) MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest {
	r.symbol = &symbol
	return r
}

// &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest) Period(period string) MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest {
	r.period = &period
	return r
}

// default 30, max 500
func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest) Limit(limit int64) MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest) StartTime(startTime int64) MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest) EndTime(endTime int64) MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest {
	r.endTime = &endTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest) Execute() ([]UfuturesGetFuturesDataTopLongShortAccountRatioRespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetFuturesDataTopLongShortAccountRatioExecute(r)
}

/*
UfuturesGetFuturesDataTopLongShortAccountRatio Top Trader Long/Short Ratio (Accounts)

The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
Long/Short Ratio (Accounts) = Long Account % / Short Account %

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest
*/
func (a *MarketDataAPIService) UfuturesGetFuturesDataTopLongShortAccountRatio(ctx context.Context) MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest {
	return MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetFuturesDataTopLongShortAccountRatioRespItem
func (a *MarketDataAPIService) UfuturesGetFuturesDataTopLongShortAccountRatioExecute(r MarketDataAPIUfuturesGetFuturesDataTopLongShortAccountRatioRequest) ([]UfuturesGetFuturesDataTopLongShortAccountRatioRespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetFuturesDataTopLongShortAccountRatioRespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetFuturesDataTopLongShortAccountRatio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/futures/data/topLongShortAccountRatio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 30
		r.limit = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	period *string
	limit *int64
	startTime *int64
	endTime *int64
}

func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest) Symbol(symbol string) MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest {
	r.symbol = &symbol
	return r
}

// &amp;#34;5m&amp;#34;,&amp;#34;15m&amp;#34;,&amp;#34;30m&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;2h&amp;#34;,&amp;#34;4h&amp;#34;,&amp;#34;6h&amp;#34;,&amp;#34;12h&amp;#34;,&amp;#34;1d&amp;#34;
func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest) Period(period string) MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest {
	r.period = &period
	return r
}

// default 30, max 500
func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest) Limit(limit int64) MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest) StartTime(startTime int64) MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest) EndTime(endTime int64) MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest {
	r.endTime = &endTime
	return r
}

func (r MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest) Execute() ([]UfuturesGetFuturesDataTopLongShortPositionRatioRespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetFuturesDataTopLongShortPositionRatioExecute(r)
}

/*
UfuturesGetFuturesDataTopLongShortPositionRatio Top Trader Long/Short Ratio (Positions)

The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
Long Position % = Long positions of top traders / Total open positions of top traders
Short Position % = Short positions of top traders / Total open positions of top traders
Long/Short Ratio (Positions) = Long Position % / Short Position %

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest
*/
func (a *MarketDataAPIService) UfuturesGetFuturesDataTopLongShortPositionRatio(ctx context.Context) MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest {
	return MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetFuturesDataTopLongShortPositionRatioRespItem
func (a *MarketDataAPIService) UfuturesGetFuturesDataTopLongShortPositionRatioExecute(r MarketDataAPIUfuturesGetFuturesDataTopLongShortPositionRatioRequest) ([]UfuturesGetFuturesDataTopLongShortPositionRatioRespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetFuturesDataTopLongShortPositionRatioRespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetFuturesDataTopLongShortPositionRatio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/futures/data/topLongShortPositionRatio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 30
		r.limit = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetHistoricalTradesV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	limit *int32
	fromId *int64
}

func (r MarketDataAPIUfuturesGetHistoricalTradesV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetHistoricalTradesV1Request {
	r.symbol = &symbol
	return r
}

// Default 100; max 500.
func (r MarketDataAPIUfuturesGetHistoricalTradesV1Request) Limit(limit int32) MarketDataAPIUfuturesGetHistoricalTradesV1Request {
	r.limit = &limit
	return r
}

// TradeId to fetch from. Default gets most recent trades.
func (r MarketDataAPIUfuturesGetHistoricalTradesV1Request) FromId(fromId int64) MarketDataAPIUfuturesGetHistoricalTradesV1Request {
	r.fromId = &fromId
	return r
}

func (r MarketDataAPIUfuturesGetHistoricalTradesV1Request) Execute() ([]UfuturesGetHistoricalTradesV1RespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetHistoricalTradesV1Execute(r)
}

/*
UfuturesGetHistoricalTradesV1 Old Trades Lookup (MARKET_DATA)

Get older market historical trades.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetHistoricalTradesV1Request
*/
func (a *MarketDataAPIService) UfuturesGetHistoricalTradesV1(ctx context.Context) MarketDataAPIUfuturesGetHistoricalTradesV1Request {
	return MarketDataAPIUfuturesGetHistoricalTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetHistoricalTradesV1RespItem
func (a *MarketDataAPIService) UfuturesGetHistoricalTradesV1Execute(r MarketDataAPIUfuturesGetHistoricalTradesV1Request) ([]UfuturesGetHistoricalTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetHistoricalTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetHistoricalTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/historicalTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetIndexInfoV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
}

func (r MarketDataAPIUfuturesGetIndexInfoV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetIndexInfoV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetIndexInfoV1Request) Execute() ([]UfuturesGetIndexInfoV1RespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetIndexInfoV1Execute(r)
}

/*
UfuturesGetIndexInfoV1 Composite Index Symbol Information

Query composite index symbol information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetIndexInfoV1Request
*/
func (a *MarketDataAPIService) UfuturesGetIndexInfoV1(ctx context.Context) MarketDataAPIUfuturesGetIndexInfoV1Request {
	return MarketDataAPIUfuturesGetIndexInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetIndexInfoV1RespItem
func (a *MarketDataAPIService) UfuturesGetIndexInfoV1Execute(r MarketDataAPIUfuturesGetIndexInfoV1Request) ([]UfuturesGetIndexInfoV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetIndexInfoV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetIndexInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/indexInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetIndexPriceKlinesV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	pair *string
	interval *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r MarketDataAPIUfuturesGetIndexPriceKlinesV1Request) Pair(pair string) MarketDataAPIUfuturesGetIndexPriceKlinesV1Request {
	r.pair = &pair
	return r
}

func (r MarketDataAPIUfuturesGetIndexPriceKlinesV1Request) Interval(interval string) MarketDataAPIUfuturesGetIndexPriceKlinesV1Request {
	r.interval = &interval
	return r
}

func (r MarketDataAPIUfuturesGetIndexPriceKlinesV1Request) StartTime(startTime int64) MarketDataAPIUfuturesGetIndexPriceKlinesV1Request {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetIndexPriceKlinesV1Request) EndTime(endTime int64) MarketDataAPIUfuturesGetIndexPriceKlinesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1500.
func (r MarketDataAPIUfuturesGetIndexPriceKlinesV1Request) Limit(limit int32) MarketDataAPIUfuturesGetIndexPriceKlinesV1Request {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetIndexPriceKlinesV1Request) Execute() ([][]UfuturesGetContinuousKlinesV1200ResponseInnerInner, *http.Response, error) {
	return r.ApiService.UfuturesGetIndexPriceKlinesV1Execute(r)
}

/*
UfuturesGetIndexPriceKlinesV1 Index Price Kline/Candlestick Data

Kline/candlestick bars for the index price of a pair.
Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetIndexPriceKlinesV1Request
*/
func (a *MarketDataAPIService) UfuturesGetIndexPriceKlinesV1(ctx context.Context) MarketDataAPIUfuturesGetIndexPriceKlinesV1Request {
	return MarketDataAPIUfuturesGetIndexPriceKlinesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]UfuturesGetContinuousKlinesV1200ResponseInnerInner
func (a *MarketDataAPIService) UfuturesGetIndexPriceKlinesV1Execute(r MarketDataAPIUfuturesGetIndexPriceKlinesV1Request) ([][]UfuturesGetContinuousKlinesV1200ResponseInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]UfuturesGetContinuousKlinesV1200ResponseInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetIndexPriceKlinesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/indexPriceKlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pair == nil {
		return localVarReturnValue, nil, reportError("pair is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetKlinesV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	interval *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r MarketDataAPIUfuturesGetKlinesV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetKlinesV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetKlinesV1Request) Interval(interval string) MarketDataAPIUfuturesGetKlinesV1Request {
	r.interval = &interval
	return r
}

func (r MarketDataAPIUfuturesGetKlinesV1Request) StartTime(startTime int64) MarketDataAPIUfuturesGetKlinesV1Request {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetKlinesV1Request) EndTime(endTime int64) MarketDataAPIUfuturesGetKlinesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1500.
func (r MarketDataAPIUfuturesGetKlinesV1Request) Limit(limit int32) MarketDataAPIUfuturesGetKlinesV1Request {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetKlinesV1Request) Execute() ([][]UfuturesGetContinuousKlinesV1200ResponseInnerInner, *http.Response, error) {
	return r.ApiService.UfuturesGetKlinesV1Execute(r)
}

/*
UfuturesGetKlinesV1 Kline/Candlestick Data

Kline/candlestick bars for a symbol.
Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetKlinesV1Request
*/
func (a *MarketDataAPIService) UfuturesGetKlinesV1(ctx context.Context) MarketDataAPIUfuturesGetKlinesV1Request {
	return MarketDataAPIUfuturesGetKlinesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]UfuturesGetContinuousKlinesV1200ResponseInnerInner
func (a *MarketDataAPIService) UfuturesGetKlinesV1Execute(r MarketDataAPIUfuturesGetKlinesV1Request) ([][]UfuturesGetContinuousKlinesV1200ResponseInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]UfuturesGetContinuousKlinesV1200ResponseInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetKlinesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/klines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetMarkPriceKlinesV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	interval *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r MarketDataAPIUfuturesGetMarkPriceKlinesV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetMarkPriceKlinesV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetMarkPriceKlinesV1Request) Interval(interval string) MarketDataAPIUfuturesGetMarkPriceKlinesV1Request {
	r.interval = &interval
	return r
}

func (r MarketDataAPIUfuturesGetMarkPriceKlinesV1Request) StartTime(startTime int64) MarketDataAPIUfuturesGetMarkPriceKlinesV1Request {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetMarkPriceKlinesV1Request) EndTime(endTime int64) MarketDataAPIUfuturesGetMarkPriceKlinesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1500.
func (r MarketDataAPIUfuturesGetMarkPriceKlinesV1Request) Limit(limit int32) MarketDataAPIUfuturesGetMarkPriceKlinesV1Request {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetMarkPriceKlinesV1Request) Execute() ([][]UfuturesGetContinuousKlinesV1200ResponseInnerInner, *http.Response, error) {
	return r.ApiService.UfuturesGetMarkPriceKlinesV1Execute(r)
}

/*
UfuturesGetMarkPriceKlinesV1 Mark Price Kline/Candlestick Data

Kline/candlestick bars for the mark price of a symbol.
Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetMarkPriceKlinesV1Request
*/
func (a *MarketDataAPIService) UfuturesGetMarkPriceKlinesV1(ctx context.Context) MarketDataAPIUfuturesGetMarkPriceKlinesV1Request {
	return MarketDataAPIUfuturesGetMarkPriceKlinesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]UfuturesGetContinuousKlinesV1200ResponseInnerInner
func (a *MarketDataAPIService) UfuturesGetMarkPriceKlinesV1Execute(r MarketDataAPIUfuturesGetMarkPriceKlinesV1Request) ([][]UfuturesGetContinuousKlinesV1200ResponseInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]UfuturesGetContinuousKlinesV1200ResponseInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetMarkPriceKlinesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/markPriceKlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetOpenInterestV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
}

func (r MarketDataAPIUfuturesGetOpenInterestV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetOpenInterestV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetOpenInterestV1Request) Execute() (*UfuturesGetOpenInterestV1Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetOpenInterestV1Execute(r)
}

/*
UfuturesGetOpenInterestV1 Open Interest

Get present open interest of a specific symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetOpenInterestV1Request
*/
func (a *MarketDataAPIService) UfuturesGetOpenInterestV1(ctx context.Context) MarketDataAPIUfuturesGetOpenInterestV1Request {
	return MarketDataAPIUfuturesGetOpenInterestV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetOpenInterestV1Resp
func (a *MarketDataAPIService) UfuturesGetOpenInterestV1Execute(r MarketDataAPIUfuturesGetOpenInterestV1Request) (*UfuturesGetOpenInterestV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetOpenInterestV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetOpenInterestV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/openInterest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetPingV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
}

func (r MarketDataAPIUfuturesGetPingV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UfuturesGetPingV1Execute(r)
}

/*
UfuturesGetPingV1 Test Connectivity

Test connectivity to the Rest API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetPingV1Request
*/
func (a *MarketDataAPIService) UfuturesGetPingV1(ctx context.Context) MarketDataAPIUfuturesGetPingV1Request {
	return MarketDataAPIUfuturesGetPingV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MarketDataAPIService) UfuturesGetPingV1Execute(r MarketDataAPIUfuturesGetPingV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetPingV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	interval *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request) Interval(interval string) MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request {
	r.interval = &interval
	return r
}

func (r MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request) StartTime(startTime int64) MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request {
	r.startTime = &startTime
	return r
}

func (r MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request) EndTime(endTime int64) MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1500.
func (r MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request) Limit(limit int32) MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request) Execute() ([][]UfuturesGetContinuousKlinesV1200ResponseInnerInner, *http.Response, error) {
	return r.ApiService.UfuturesGetPremiumIndexKlinesV1Execute(r)
}

/*
UfuturesGetPremiumIndexKlinesV1 Premium index Kline Data

Premium index kline bars of a symbol. Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request
*/
func (a *MarketDataAPIService) UfuturesGetPremiumIndexKlinesV1(ctx context.Context) MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request {
	return MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]UfuturesGetContinuousKlinesV1200ResponseInnerInner
func (a *MarketDataAPIService) UfuturesGetPremiumIndexKlinesV1Execute(r MarketDataAPIUfuturesGetPremiumIndexKlinesV1Request) ([][]UfuturesGetContinuousKlinesV1200ResponseInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]UfuturesGetContinuousKlinesV1200ResponseInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetPremiumIndexKlinesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/premiumIndexKlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetPremiumIndexV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
}

func (r MarketDataAPIUfuturesGetPremiumIndexV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetPremiumIndexV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetPremiumIndexV1Request) Execute() (*UfuturesGetPremiumIndexV1Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetPremiumIndexV1Execute(r)
}

/*
UfuturesGetPremiumIndexV1 Mark Price

Mark Price and Funding Rate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetPremiumIndexV1Request
*/
func (a *MarketDataAPIService) UfuturesGetPremiumIndexV1(ctx context.Context) MarketDataAPIUfuturesGetPremiumIndexV1Request {
	return MarketDataAPIUfuturesGetPremiumIndexV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetPremiumIndexV1Resp
func (a *MarketDataAPIService) UfuturesGetPremiumIndexV1Execute(r MarketDataAPIUfuturesGetPremiumIndexV1Request) (*UfuturesGetPremiumIndexV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetPremiumIndexV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetPremiumIndexV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/premiumIndex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetTicker24hrV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
}

func (r MarketDataAPIUfuturesGetTicker24hrV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetTicker24hrV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetTicker24hrV1Request) Execute() (*UfuturesGetTicker24hrV1Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetTicker24hrV1Execute(r)
}

/*
UfuturesGetTicker24hrV1 24hr Ticker Price Change Statistics

24 hour rolling window price change statistics.
Careful when accessing this with no symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetTicker24hrV1Request
*/
func (a *MarketDataAPIService) UfuturesGetTicker24hrV1(ctx context.Context) MarketDataAPIUfuturesGetTicker24hrV1Request {
	return MarketDataAPIUfuturesGetTicker24hrV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetTicker24hrV1Resp
func (a *MarketDataAPIService) UfuturesGetTicker24hrV1Execute(r MarketDataAPIUfuturesGetTicker24hrV1Request) (*UfuturesGetTicker24hrV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetTicker24hrV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetTicker24hrV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/ticker/24hr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetTickerBookTickerV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
}

func (r MarketDataAPIUfuturesGetTickerBookTickerV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetTickerBookTickerV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetTickerBookTickerV1Request) Execute() (*UfuturesGetTickerBookTickerV1Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetTickerBookTickerV1Execute(r)
}

/*
UfuturesGetTickerBookTickerV1 Symbol Order Book Ticker

Best price/qty on the order book for a symbol or symbols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetTickerBookTickerV1Request
*/
func (a *MarketDataAPIService) UfuturesGetTickerBookTickerV1(ctx context.Context) MarketDataAPIUfuturesGetTickerBookTickerV1Request {
	return MarketDataAPIUfuturesGetTickerBookTickerV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetTickerBookTickerV1Resp
func (a *MarketDataAPIService) UfuturesGetTickerBookTickerV1Execute(r MarketDataAPIUfuturesGetTickerBookTickerV1Request) (*UfuturesGetTickerBookTickerV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetTickerBookTickerV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetTickerBookTickerV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/ticker/bookTicker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetTickerPriceV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
}

func (r MarketDataAPIUfuturesGetTickerPriceV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetTickerPriceV1Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetTickerPriceV1Request) Execute() (*UfuturesGetTickerPriceV1Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetTickerPriceV1Execute(r)
}

/*
UfuturesGetTickerPriceV1 Symbol Price Ticker

Latest price for a symbol or symbols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetTickerPriceV1Request
*/
func (a *MarketDataAPIService) UfuturesGetTickerPriceV1(ctx context.Context) MarketDataAPIUfuturesGetTickerPriceV1Request {
	return MarketDataAPIUfuturesGetTickerPriceV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetTickerPriceV1Resp
func (a *MarketDataAPIService) UfuturesGetTickerPriceV1Execute(r MarketDataAPIUfuturesGetTickerPriceV1Request) (*UfuturesGetTickerPriceV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetTickerPriceV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetTickerPriceV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/ticker/price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetTickerPriceV2Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
}

func (r MarketDataAPIUfuturesGetTickerPriceV2Request) Symbol(symbol string) MarketDataAPIUfuturesGetTickerPriceV2Request {
	r.symbol = &symbol
	return r
}

func (r MarketDataAPIUfuturesGetTickerPriceV2Request) Execute() (*UfuturesGetTickerPriceV2Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetTickerPriceV2Execute(r)
}

/*
UfuturesGetTickerPriceV2 Symbol Price Ticker V2

Latest price for a symbol or symbols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetTickerPriceV2Request
*/
func (a *MarketDataAPIService) UfuturesGetTickerPriceV2(ctx context.Context) MarketDataAPIUfuturesGetTickerPriceV2Request {
	return MarketDataAPIUfuturesGetTickerPriceV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetTickerPriceV2Resp
func (a *MarketDataAPIService) UfuturesGetTickerPriceV2Execute(r MarketDataAPIUfuturesGetTickerPriceV2Request) (*UfuturesGetTickerPriceV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetTickerPriceV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetTickerPriceV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v2/ticker/price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetTimeV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
}

func (r MarketDataAPIUfuturesGetTimeV1Request) Execute() (*UfuturesGetTimeV1Resp, *http.Response, error) {
	return r.ApiService.UfuturesGetTimeV1Execute(r)
}

/*
UfuturesGetTimeV1 Check Server Time

Test connectivity to the Rest API and get the current server time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetTimeV1Request
*/
func (a *MarketDataAPIService) UfuturesGetTimeV1(ctx context.Context) MarketDataAPIUfuturesGetTimeV1Request {
	return MarketDataAPIUfuturesGetTimeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UfuturesGetTimeV1Resp
func (a *MarketDataAPIService) UfuturesGetTimeV1Execute(r MarketDataAPIUfuturesGetTimeV1Request) (*UfuturesGetTimeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UfuturesGetTimeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetTimeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MarketDataAPIUfuturesGetTradesV1Request struct {
	ctx context.Context
	ApiService *MarketDataAPIService
	symbol *string
	limit *int32
}

func (r MarketDataAPIUfuturesGetTradesV1Request) Symbol(symbol string) MarketDataAPIUfuturesGetTradesV1Request {
	r.symbol = &symbol
	return r
}

// Default 500; max 1000.
func (r MarketDataAPIUfuturesGetTradesV1Request) Limit(limit int32) MarketDataAPIUfuturesGetTradesV1Request {
	r.limit = &limit
	return r
}

func (r MarketDataAPIUfuturesGetTradesV1Request) Execute() ([]UfuturesGetTradesV1RespItem, *http.Response, error) {
	return r.ApiService.UfuturesGetTradesV1Execute(r)
}

/*
UfuturesGetTradesV1 Recent Trades List

Get recent market trades

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MarketDataAPIUfuturesGetTradesV1Request
*/
func (a *MarketDataAPIService) UfuturesGetTradesV1(ctx context.Context) MarketDataAPIUfuturesGetTradesV1Request {
	return MarketDataAPIUfuturesGetTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UfuturesGetTradesV1RespItem
func (a *MarketDataAPIService) UfuturesGetTradesV1Execute(r MarketDataAPIUfuturesGetTradesV1Request) ([]UfuturesGetTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UfuturesGetTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketDataAPIService.UfuturesGetTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

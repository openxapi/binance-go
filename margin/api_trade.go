/*
Binance Margin Trading API

OpenAPI specification for Binance exchange - Margin API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package margin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TradeAPIService TradeAPI service
type TradeAPIService service

type ApiMarginCreateMarginApiKeyV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	apiName *string
	timestamp *int64
	ip *string
	permissionMode *string
	publicKey *string
	recvWindow *int64
	symbol *string
}

func (r ApiMarginCreateMarginApiKeyV1Request) ApiName(apiName string) ApiMarginCreateMarginApiKeyV1Request {
	r.apiName = &apiName
	return r
}

func (r ApiMarginCreateMarginApiKeyV1Request) Timestamp(timestamp int64) ApiMarginCreateMarginApiKeyV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiMarginCreateMarginApiKeyV1Request) Ip(ip string) ApiMarginCreateMarginApiKeyV1Request {
	r.ip = &ip
	return r
}

func (r ApiMarginCreateMarginApiKeyV1Request) PermissionMode(permissionMode string) ApiMarginCreateMarginApiKeyV1Request {
	r.permissionMode = &permissionMode
	return r
}

func (r ApiMarginCreateMarginApiKeyV1Request) PublicKey(publicKey string) ApiMarginCreateMarginApiKeyV1Request {
	r.publicKey = &publicKey
	return r
}

func (r ApiMarginCreateMarginApiKeyV1Request) RecvWindow(recvWindow int64) ApiMarginCreateMarginApiKeyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginCreateMarginApiKeyV1Request) Symbol(symbol string) ApiMarginCreateMarginApiKeyV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginCreateMarginApiKeyV1Request) Execute() (*MarginCreateMarginApiKeyV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginApiKeyV1Execute(r)
}

/*
MarginCreateMarginApiKeyV1 Create Special Key(Low-Latency Trading)(TRADE)

**Binance Margin offers low-latency trading through a special key, available exclusively to users with VIP level 4 or higher. **

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCreateMarginApiKeyV1Request
*/
func (a *TradeAPIService) MarginCreateMarginApiKeyV1(ctx context.Context) ApiMarginCreateMarginApiKeyV1Request {
	return ApiMarginCreateMarginApiKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginApiKeyV1Resp
func (a *TradeAPIService) MarginCreateMarginApiKeyV1Execute(r ApiMarginCreateMarginApiKeyV1Request) (*MarginCreateMarginApiKeyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginApiKeyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginApiKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/apiKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiName == nil {
		return localVarReturnValue, nil, reportError("apiName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "apiName", r.apiName, "", "")
	if r.ip != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ip", r.ip, "", "")
	}
	if r.permissionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "permissionMode", r.permissionMode, "", "")
	}
	if r.publicKey != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "publicKey", r.publicKey, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCreateMarginExchangeSmallLiabilityV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	assetNames *[]string
	timestamp *int64
	recvWindow *int64
}

func (r ApiMarginCreateMarginExchangeSmallLiabilityV1Request) AssetNames(assetNames []string) ApiMarginCreateMarginExchangeSmallLiabilityV1Request {
	r.assetNames = &assetNames
	return r
}

func (r ApiMarginCreateMarginExchangeSmallLiabilityV1Request) Timestamp(timestamp int64) ApiMarginCreateMarginExchangeSmallLiabilityV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiMarginCreateMarginExchangeSmallLiabilityV1Request) RecvWindow(recvWindow int64) ApiMarginCreateMarginExchangeSmallLiabilityV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginCreateMarginExchangeSmallLiabilityV1Request) Execute() (*MarginCreateMarginExchangeSmallLiabilityV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginExchangeSmallLiabilityV1Execute(r)
}

/*
MarginCreateMarginExchangeSmallLiabilityV1 Small Liability Exchange (MARGIN)

Small Liability Exchange

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCreateMarginExchangeSmallLiabilityV1Request
*/
func (a *TradeAPIService) MarginCreateMarginExchangeSmallLiabilityV1(ctx context.Context) ApiMarginCreateMarginExchangeSmallLiabilityV1Request {
	return ApiMarginCreateMarginExchangeSmallLiabilityV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginExchangeSmallLiabilityV1Resp
func (a *TradeAPIService) MarginCreateMarginExchangeSmallLiabilityV1Execute(r ApiMarginCreateMarginExchangeSmallLiabilityV1Request) (*MarginCreateMarginExchangeSmallLiabilityV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginExchangeSmallLiabilityV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginExchangeSmallLiabilityV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/exchange-small-liability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetNames == nil {
		return localVarReturnValue, nil, reportError("assetNames is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "assetNames", r.assetNames, "", "csv")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCreateMarginManualLiquidationV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	type_ *string
	recvWindow *int64
	symbol *string
}

func (r ApiMarginCreateMarginManualLiquidationV1Request) Timestamp(timestamp int64) ApiMarginCreateMarginManualLiquidationV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiMarginCreateMarginManualLiquidationV1Request) Type_(type_ string) ApiMarginCreateMarginManualLiquidationV1Request {
	r.type_ = &type_
	return r
}

func (r ApiMarginCreateMarginManualLiquidationV1Request) RecvWindow(recvWindow int64) ApiMarginCreateMarginManualLiquidationV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginCreateMarginManualLiquidationV1Request) Symbol(symbol string) ApiMarginCreateMarginManualLiquidationV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginCreateMarginManualLiquidationV1Request) Execute() (*MarginCreateMarginManualLiquidationV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginManualLiquidationV1Execute(r)
}

/*
MarginCreateMarginManualLiquidationV1 Margin Manual Liquidation(MARGIN)

Margin Manual Liquidation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCreateMarginManualLiquidationV1Request
*/
func (a *TradeAPIService) MarginCreateMarginManualLiquidationV1(ctx context.Context) ApiMarginCreateMarginManualLiquidationV1Request {
	return ApiMarginCreateMarginManualLiquidationV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginManualLiquidationV1Resp
func (a *TradeAPIService) MarginCreateMarginManualLiquidationV1Execute(r ApiMarginCreateMarginManualLiquidationV1Request) (*MarginCreateMarginManualLiquidationV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginManualLiquidationV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginManualLiquidationV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/manual-liquidation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCreateMarginOrderOcoV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	price *string
	quantity *string
	side *string
	stopPrice *string
	symbol *string
	timestamp *int64
	autoRepayAtCancel *bool
	isIsolated *string
	limitClientOrderId *string
	limitIcebergQty *string
	listClientOrderId *string
	newOrderRespType *string
	recvWindow *int64
	selfTradePreventionMode *string
	sideEffectType *string
	stopClientOrderId *string
	stopIcebergQty *string
	stopLimitPrice *string
	stopLimitTimeInForce *string
}

func (r ApiMarginCreateMarginOrderOcoV1Request) Price(price string) ApiMarginCreateMarginOrderOcoV1Request {
	r.price = &price
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) Quantity(quantity string) ApiMarginCreateMarginOrderOcoV1Request {
	r.quantity = &quantity
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) Side(side string) ApiMarginCreateMarginOrderOcoV1Request {
	r.side = &side
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) StopPrice(stopPrice string) ApiMarginCreateMarginOrderOcoV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) Symbol(symbol string) ApiMarginCreateMarginOrderOcoV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) Timestamp(timestamp int64) ApiMarginCreateMarginOrderOcoV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) AutoRepayAtCancel(autoRepayAtCancel bool) ApiMarginCreateMarginOrderOcoV1Request {
	r.autoRepayAtCancel = &autoRepayAtCancel
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) IsIsolated(isIsolated string) ApiMarginCreateMarginOrderOcoV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) LimitClientOrderId(limitClientOrderId string) ApiMarginCreateMarginOrderOcoV1Request {
	r.limitClientOrderId = &limitClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) LimitIcebergQty(limitIcebergQty string) ApiMarginCreateMarginOrderOcoV1Request {
	r.limitIcebergQty = &limitIcebergQty
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) ListClientOrderId(listClientOrderId string) ApiMarginCreateMarginOrderOcoV1Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) NewOrderRespType(newOrderRespType string) ApiMarginCreateMarginOrderOcoV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) RecvWindow(recvWindow int64) ApiMarginCreateMarginOrderOcoV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiMarginCreateMarginOrderOcoV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) SideEffectType(sideEffectType string) ApiMarginCreateMarginOrderOcoV1Request {
	r.sideEffectType = &sideEffectType
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) StopClientOrderId(stopClientOrderId string) ApiMarginCreateMarginOrderOcoV1Request {
	r.stopClientOrderId = &stopClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) StopIcebergQty(stopIcebergQty string) ApiMarginCreateMarginOrderOcoV1Request {
	r.stopIcebergQty = &stopIcebergQty
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) StopLimitPrice(stopLimitPrice string) ApiMarginCreateMarginOrderOcoV1Request {
	r.stopLimitPrice = &stopLimitPrice
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) StopLimitTimeInForce(stopLimitTimeInForce string) ApiMarginCreateMarginOrderOcoV1Request {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}

func (r ApiMarginCreateMarginOrderOcoV1Request) Execute() (*MarginCreateMarginOrderOcoV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginOrderOcoV1Execute(r)
}

/*
MarginCreateMarginOrderOcoV1 Margin Account New OCO (TRADE)

Send in a new OCO for a margin account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCreateMarginOrderOcoV1Request
*/
func (a *TradeAPIService) MarginCreateMarginOrderOcoV1(ctx context.Context) ApiMarginCreateMarginOrderOcoV1Request {
	return ApiMarginCreateMarginOrderOcoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginOrderOcoV1Resp
func (a *TradeAPIService) MarginCreateMarginOrderOcoV1Execute(r ApiMarginCreateMarginOrderOcoV1Request) (*MarginCreateMarginOrderOcoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginOrderOcoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginOrderOcoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoRepayAtCancel != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoRepayAtCancel", r.autoRepayAtCancel, "", "")
	}
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "isIsolated", r.isIsolated, "", "")
	}
	if r.limitClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitClientOrderId", r.limitClientOrderId, "", "")
	}
	if r.limitIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitIcebergQty", r.limitIcebergQty, "", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.sideEffectType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sideEffectType", r.sideEffectType, "", "")
	}
	if r.stopClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopClientOrderId", r.stopClientOrderId, "", "")
	}
	if r.stopIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopIcebergQty", r.stopIcebergQty, "", "")
	}
	if r.stopLimitPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitPrice", r.stopLimitPrice, "", "")
	}
	if r.stopLimitTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitTimeInForce", r.stopLimitTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCreateMarginOrderOtoV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	pendingQuantity *string
	pendingSide *string
	pendingType *string
	symbol *string
	workingIcebergQty *string
	workingPrice *string
	workingQuantity *string
	workingSide *string
	workingType *string
	autoRepayAtCancel *bool
	isIsolated *string
	listClientOrderId *string
	newOrderRespType *string
	pendingClientOrderId *string
	pendingIcebergQty *string
	pendingPrice *string
	pendingStopPrice *string
	pendingTimeInForce *string
	pendingTrailingDelta *string
	selfTradePreventionMode *string
	sideEffectType *string
	workingClientOrderId *string
	workingTimeInForce *string
}

func (r ApiMarginCreateMarginOrderOtoV1Request) PendingQuantity(pendingQuantity string) ApiMarginCreateMarginOrderOtoV1Request {
	r.pendingQuantity = &pendingQuantity
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) PendingSide(pendingSide string) ApiMarginCreateMarginOrderOtoV1Request {
	r.pendingSide = &pendingSide
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) PendingType(pendingType string) ApiMarginCreateMarginOrderOtoV1Request {
	r.pendingType = &pendingType
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) Symbol(symbol string) ApiMarginCreateMarginOrderOtoV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) WorkingIcebergQty(workingIcebergQty string) ApiMarginCreateMarginOrderOtoV1Request {
	r.workingIcebergQty = &workingIcebergQty
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) WorkingPrice(workingPrice string) ApiMarginCreateMarginOrderOtoV1Request {
	r.workingPrice = &workingPrice
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) WorkingQuantity(workingQuantity string) ApiMarginCreateMarginOrderOtoV1Request {
	r.workingQuantity = &workingQuantity
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) WorkingSide(workingSide string) ApiMarginCreateMarginOrderOtoV1Request {
	r.workingSide = &workingSide
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) WorkingType(workingType string) ApiMarginCreateMarginOrderOtoV1Request {
	r.workingType = &workingType
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) AutoRepayAtCancel(autoRepayAtCancel bool) ApiMarginCreateMarginOrderOtoV1Request {
	r.autoRepayAtCancel = &autoRepayAtCancel
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) IsIsolated(isIsolated string) ApiMarginCreateMarginOrderOtoV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) ListClientOrderId(listClientOrderId string) ApiMarginCreateMarginOrderOtoV1Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) NewOrderRespType(newOrderRespType string) ApiMarginCreateMarginOrderOtoV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) PendingClientOrderId(pendingClientOrderId string) ApiMarginCreateMarginOrderOtoV1Request {
	r.pendingClientOrderId = &pendingClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) PendingIcebergQty(pendingIcebergQty string) ApiMarginCreateMarginOrderOtoV1Request {
	r.pendingIcebergQty = &pendingIcebergQty
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) PendingPrice(pendingPrice string) ApiMarginCreateMarginOrderOtoV1Request {
	r.pendingPrice = &pendingPrice
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) PendingStopPrice(pendingStopPrice string) ApiMarginCreateMarginOrderOtoV1Request {
	r.pendingStopPrice = &pendingStopPrice
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) PendingTimeInForce(pendingTimeInForce string) ApiMarginCreateMarginOrderOtoV1Request {
	r.pendingTimeInForce = &pendingTimeInForce
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) PendingTrailingDelta(pendingTrailingDelta string) ApiMarginCreateMarginOrderOtoV1Request {
	r.pendingTrailingDelta = &pendingTrailingDelta
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiMarginCreateMarginOrderOtoV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) SideEffectType(sideEffectType string) ApiMarginCreateMarginOrderOtoV1Request {
	r.sideEffectType = &sideEffectType
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) WorkingClientOrderId(workingClientOrderId string) ApiMarginCreateMarginOrderOtoV1Request {
	r.workingClientOrderId = &workingClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) WorkingTimeInForce(workingTimeInForce string) ApiMarginCreateMarginOrderOtoV1Request {
	r.workingTimeInForce = &workingTimeInForce
	return r
}

func (r ApiMarginCreateMarginOrderOtoV1Request) Execute() (*MarginCreateMarginOrderOtoV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginOrderOtoV1Execute(r)
}

/*
MarginCreateMarginOrderOtoV1 Margin Account New OTO (TRADE)

Post a new OTO order for margin account:

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCreateMarginOrderOtoV1Request
*/
func (a *TradeAPIService) MarginCreateMarginOrderOtoV1(ctx context.Context) ApiMarginCreateMarginOrderOtoV1Request {
	return ApiMarginCreateMarginOrderOtoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginOrderOtoV1Resp
func (a *TradeAPIService) MarginCreateMarginOrderOtoV1Execute(r ApiMarginCreateMarginOrderOtoV1Request) (*MarginCreateMarginOrderOtoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginOrderOtoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginOrderOtoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order/oto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pendingQuantity == nil {
		return localVarReturnValue, nil, reportError("pendingQuantity is required and must be specified")
	}
	if r.pendingSide == nil {
		return localVarReturnValue, nil, reportError("pendingSide is required and must be specified")
	}
	if r.pendingType == nil {
		return localVarReturnValue, nil, reportError("pendingType is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.workingIcebergQty == nil {
		return localVarReturnValue, nil, reportError("workingIcebergQty is required and must be specified")
	}
	if r.workingPrice == nil {
		return localVarReturnValue, nil, reportError("workingPrice is required and must be specified")
	}
	if r.workingQuantity == nil {
		return localVarReturnValue, nil, reportError("workingQuantity is required and must be specified")
	}
	if r.workingSide == nil {
		return localVarReturnValue, nil, reportError("workingSide is required and must be specified")
	}
	if r.workingType == nil {
		return localVarReturnValue, nil, reportError("workingType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoRepayAtCancel != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoRepayAtCancel", r.autoRepayAtCancel, "", "")
	}
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "isIsolated", r.isIsolated, "", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.pendingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingClientOrderId", r.pendingClientOrderId, "", "")
	}
	if r.pendingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingIcebergQty", r.pendingIcebergQty, "", "")
	}
	if r.pendingPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingPrice", r.pendingPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingQuantity", r.pendingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingSide", r.pendingSide, "", "")
	if r.pendingStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStopPrice", r.pendingStopPrice, "", "")
	}
	if r.pendingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingTimeInForce", r.pendingTimeInForce, "", "")
	}
	if r.pendingTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingTrailingDelta", r.pendingTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingType", r.pendingType, "", "")
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	if r.sideEffectType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sideEffectType", r.sideEffectType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.workingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingClientOrderId", r.workingClientOrderId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingIcebergQty", r.workingIcebergQty, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingPrice", r.workingPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingQuantity", r.workingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingSide", r.workingSide, "", "")
	if r.workingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingTimeInForce", r.workingTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCreateMarginOrderOtocoV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	pendingAboveType *string
	pendingQuantity *string
	pendingSide *string
	symbol *string
	workingPrice *string
	workingQuantity *string
	workingSide *string
	workingType *string
	autoRepayAtCancel *bool
	isIsolated *string
	listClientOrderId *string
	newOrderRespType *string
	pendingAboveClientOrderId *string
	pendingAboveIcebergQty *string
	pendingAbovePrice *string
	pendingAboveStopPrice *string
	pendingAboveTimeInForce *string
	pendingAboveTrailingDelta *string
	pendingBelowClientOrderId *string
	pendingBelowIcebergQty *string
	pendingBelowPrice *string
	pendingBelowStopPrice *string
	pendingBelowTimeInForce *string
	pendingBelowTrailingDelta *string
	pendingBelowType *string
	selfTradePreventionMode *string
	sideEffectType *string
	workingClientOrderId *string
	workingIcebergQty *string
	workingTimeInForce *string
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingAboveType(pendingAboveType string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveType = &pendingAboveType
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingQuantity(pendingQuantity string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingQuantity = &pendingQuantity
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingSide(pendingSide string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingSide = &pendingSide
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) Symbol(symbol string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) WorkingPrice(workingPrice string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.workingPrice = &workingPrice
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) WorkingQuantity(workingQuantity string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.workingQuantity = &workingQuantity
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) WorkingSide(workingSide string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.workingSide = &workingSide
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) WorkingType(workingType string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.workingType = &workingType
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) AutoRepayAtCancel(autoRepayAtCancel bool) ApiMarginCreateMarginOrderOtocoV1Request {
	r.autoRepayAtCancel = &autoRepayAtCancel
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) IsIsolated(isIsolated string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) ListClientOrderId(listClientOrderId string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) NewOrderRespType(newOrderRespType string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingAboveClientOrderId(pendingAboveClientOrderId string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveClientOrderId = &pendingAboveClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingAboveIcebergQty(pendingAboveIcebergQty string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveIcebergQty = &pendingAboveIcebergQty
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingAbovePrice(pendingAbovePrice string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingAbovePrice = &pendingAbovePrice
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingAboveStopPrice(pendingAboveStopPrice string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveStopPrice = &pendingAboveStopPrice
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingAboveTimeInForce(pendingAboveTimeInForce string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveTimeInForce = &pendingAboveTimeInForce
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingAboveTrailingDelta(pendingAboveTrailingDelta string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveTrailingDelta = &pendingAboveTrailingDelta
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingBelowClientOrderId(pendingBelowClientOrderId string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowClientOrderId = &pendingBelowClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingBelowIcebergQty(pendingBelowIcebergQty string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowIcebergQty = &pendingBelowIcebergQty
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingBelowPrice(pendingBelowPrice string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowPrice = &pendingBelowPrice
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingBelowStopPrice(pendingBelowStopPrice string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowStopPrice = &pendingBelowStopPrice
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingBelowTimeInForce(pendingBelowTimeInForce string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowTimeInForce = &pendingBelowTimeInForce
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingBelowTrailingDelta(pendingBelowTrailingDelta string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowTrailingDelta = &pendingBelowTrailingDelta
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) PendingBelowType(pendingBelowType string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowType = &pendingBelowType
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) SideEffectType(sideEffectType string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.sideEffectType = &sideEffectType
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) WorkingClientOrderId(workingClientOrderId string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.workingClientOrderId = &workingClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) WorkingIcebergQty(workingIcebergQty string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.workingIcebergQty = &workingIcebergQty
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) WorkingTimeInForce(workingTimeInForce string) ApiMarginCreateMarginOrderOtocoV1Request {
	r.workingTimeInForce = &workingTimeInForce
	return r
}

func (r ApiMarginCreateMarginOrderOtocoV1Request) Execute() (*MarginCreateMarginOrderOtocoV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginOrderOtocoV1Execute(r)
}

/*
MarginCreateMarginOrderOtocoV1 Margin Account New OTOCO (TRADE)

Post a new OTOCO order for margin account：

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCreateMarginOrderOtocoV1Request
*/
func (a *TradeAPIService) MarginCreateMarginOrderOtocoV1(ctx context.Context) ApiMarginCreateMarginOrderOtocoV1Request {
	return ApiMarginCreateMarginOrderOtocoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginOrderOtocoV1Resp
func (a *TradeAPIService) MarginCreateMarginOrderOtocoV1Execute(r ApiMarginCreateMarginOrderOtocoV1Request) (*MarginCreateMarginOrderOtocoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginOrderOtocoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginOrderOtocoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order/otoco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pendingAboveType == nil {
		return localVarReturnValue, nil, reportError("pendingAboveType is required and must be specified")
	}
	if r.pendingQuantity == nil {
		return localVarReturnValue, nil, reportError("pendingQuantity is required and must be specified")
	}
	if r.pendingSide == nil {
		return localVarReturnValue, nil, reportError("pendingSide is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.workingPrice == nil {
		return localVarReturnValue, nil, reportError("workingPrice is required and must be specified")
	}
	if r.workingQuantity == nil {
		return localVarReturnValue, nil, reportError("workingQuantity is required and must be specified")
	}
	if r.workingSide == nil {
		return localVarReturnValue, nil, reportError("workingSide is required and must be specified")
	}
	if r.workingType == nil {
		return localVarReturnValue, nil, reportError("workingType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoRepayAtCancel != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoRepayAtCancel", r.autoRepayAtCancel, "", "")
	}
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "isIsolated", r.isIsolated, "", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.pendingAboveClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveClientOrderId", r.pendingAboveClientOrderId, "", "")
	}
	if r.pendingAboveIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveIcebergQty", r.pendingAboveIcebergQty, "", "")
	}
	if r.pendingAbovePrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAbovePrice", r.pendingAbovePrice, "", "")
	}
	if r.pendingAboveStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStopPrice", r.pendingAboveStopPrice, "", "")
	}
	if r.pendingAboveTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveTimeInForce", r.pendingAboveTimeInForce, "", "")
	}
	if r.pendingAboveTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveTrailingDelta", r.pendingAboveTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveType", r.pendingAboveType, "", "")
	if r.pendingBelowClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowClientOrderId", r.pendingBelowClientOrderId, "", "")
	}
	if r.pendingBelowIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowIcebergQty", r.pendingBelowIcebergQty, "", "")
	}
	if r.pendingBelowPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowPrice", r.pendingBelowPrice, "", "")
	}
	if r.pendingBelowStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStopPrice", r.pendingBelowStopPrice, "", "")
	}
	if r.pendingBelowTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowTimeInForce", r.pendingBelowTimeInForce, "", "")
	}
	if r.pendingBelowTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowTrailingDelta", r.pendingBelowTrailingDelta, "", "")
	}
	if r.pendingBelowType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowType", r.pendingBelowType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingQuantity", r.pendingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingSide", r.pendingSide, "", "")
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	if r.sideEffectType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sideEffectType", r.sideEffectType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.workingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingClientOrderId", r.workingClientOrderId, "", "")
	}
	if r.workingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingIcebergQty", r.workingIcebergQty, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingPrice", r.workingPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingQuantity", r.workingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingSide", r.workingSide, "", "")
	if r.workingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingTimeInForce", r.workingTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCreateMarginOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	autoRepayAtCancel *bool
	icebergQty *string
	isIsolated *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	sideEffectType *string
	stopPrice *string
	timeInForce *string
}

func (r ApiMarginCreateMarginOrderV1Request) Side(side string) ApiMarginCreateMarginOrderV1Request {
	r.side = &side
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) Symbol(symbol string) ApiMarginCreateMarginOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) Timestamp(timestamp int64) ApiMarginCreateMarginOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) Type_(type_ string) ApiMarginCreateMarginOrderV1Request {
	r.type_ = &type_
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) AutoRepayAtCancel(autoRepayAtCancel bool) ApiMarginCreateMarginOrderV1Request {
	r.autoRepayAtCancel = &autoRepayAtCancel
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) IcebergQty(icebergQty string) ApiMarginCreateMarginOrderV1Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) IsIsolated(isIsolated string) ApiMarginCreateMarginOrderV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) NewClientOrderId(newClientOrderId string) ApiMarginCreateMarginOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) NewOrderRespType(newOrderRespType string) ApiMarginCreateMarginOrderV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) Price(price string) ApiMarginCreateMarginOrderV1Request {
	r.price = &price
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) Quantity(quantity string) ApiMarginCreateMarginOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) QuoteOrderQty(quoteOrderQty string) ApiMarginCreateMarginOrderV1Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) RecvWindow(recvWindow int64) ApiMarginCreateMarginOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiMarginCreateMarginOrderV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) SideEffectType(sideEffectType string) ApiMarginCreateMarginOrderV1Request {
	r.sideEffectType = &sideEffectType
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) StopPrice(stopPrice string) ApiMarginCreateMarginOrderV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) TimeInForce(timeInForce string) ApiMarginCreateMarginOrderV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiMarginCreateMarginOrderV1Request) Execute() (*MarginCreateMarginOrderV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginOrderV1Execute(r)
}

/*
MarginCreateMarginOrderV1 Margin Account New Order (TRADE)

Post a new order for margin account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCreateMarginOrderV1Request
*/
func (a *TradeAPIService) MarginCreateMarginOrderV1(ctx context.Context) ApiMarginCreateMarginOrderV1Request {
	return ApiMarginCreateMarginOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginOrderV1Resp
func (a *TradeAPIService) MarginCreateMarginOrderV1Execute(r ApiMarginCreateMarginOrderV1Request) (*MarginCreateMarginOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoRepayAtCancel != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoRepayAtCancel", r.autoRepayAtCancel, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "isIsolated", r.isIsolated, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.sideEffectType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sideEffectType", r.sideEffectType, "", "")
	}
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginDeleteMarginApiKeyV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	apiKey *string
	apiName *string
	symbol *string
	recvWindow *int64
}

func (r ApiMarginDeleteMarginApiKeyV1Request) Timestamp(timestamp int64) ApiMarginDeleteMarginApiKeyV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiMarginDeleteMarginApiKeyV1Request) ApiKey(apiKey string) ApiMarginDeleteMarginApiKeyV1Request {
	r.apiKey = &apiKey
	return r
}

func (r ApiMarginDeleteMarginApiKeyV1Request) ApiName(apiName string) ApiMarginDeleteMarginApiKeyV1Request {
	r.apiName = &apiName
	return r
}

// isolated margin pair
func (r ApiMarginDeleteMarginApiKeyV1Request) Symbol(symbol string) ApiMarginDeleteMarginApiKeyV1Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginDeleteMarginApiKeyV1Request) RecvWindow(recvWindow int64) ApiMarginDeleteMarginApiKeyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginDeleteMarginApiKeyV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MarginDeleteMarginApiKeyV1Execute(r)
}

/*
MarginDeleteMarginApiKeyV1 Delete Special Key(Low-Latency Trading)(TRADE)

This only applies to Special Key for Low Latency Trading.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginDeleteMarginApiKeyV1Request
*/
func (a *TradeAPIService) MarginDeleteMarginApiKeyV1(ctx context.Context) ApiMarginDeleteMarginApiKeyV1Request {
	return ApiMarginDeleteMarginApiKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TradeAPIService) MarginDeleteMarginApiKeyV1Execute(r ApiMarginDeleteMarginApiKeyV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginDeleteMarginApiKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/apiKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.apiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apiKey", r.apiKey, "form", "")
	} else {
		var defaultValue string = ""
		r.apiKey = &defaultValue
	}
	if r.apiName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apiName", r.apiName, "form", "")
	} else {
		var defaultValue string = ""
		r.apiName = &defaultValue
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginDeleteMarginOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	recvWindow *int64
}

func (r ApiMarginDeleteMarginOpenOrdersV1Request) Symbol(symbol string) ApiMarginDeleteMarginOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginDeleteMarginOpenOrdersV1Request) Timestamp(timestamp int64) ApiMarginDeleteMarginOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginDeleteMarginOpenOrdersV1Request) IsIsolated(isIsolated string) ApiMarginDeleteMarginOpenOrdersV1Request {
	r.isIsolated = &isIsolated
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginDeleteMarginOpenOrdersV1Request) RecvWindow(recvWindow int64) ApiMarginDeleteMarginOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginDeleteMarginOpenOrdersV1Request) Execute() ([]MarginDeleteMarginOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.MarginDeleteMarginOpenOrdersV1Execute(r)
}

/*
MarginDeleteMarginOpenOrdersV1 Margin Account Cancel all Open Orders on a Symbol (TRADE)

Cancels all active orders on a symbol for margin account.
This includes OCO orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginDeleteMarginOpenOrdersV1Request
*/
func (a *TradeAPIService) MarginDeleteMarginOpenOrdersV1(ctx context.Context) ApiMarginDeleteMarginOpenOrdersV1Request {
	return ApiMarginDeleteMarginOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginDeleteMarginOpenOrdersV1RespItem
func (a *TradeAPIService) MarginDeleteMarginOpenOrdersV1Execute(r ApiMarginDeleteMarginOpenOrdersV1Request) ([]MarginDeleteMarginOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginDeleteMarginOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginDeleteMarginOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginDeleteMarginOrderListV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	orderListId *int64
	listClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

func (r ApiMarginDeleteMarginOrderListV1Request) Symbol(symbol string) ApiMarginDeleteMarginOrderListV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginDeleteMarginOrderListV1Request) Timestamp(timestamp int64) ApiMarginDeleteMarginOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginDeleteMarginOrderListV1Request) IsIsolated(isIsolated string) ApiMarginDeleteMarginOrderListV1Request {
	r.isIsolated = &isIsolated
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r ApiMarginDeleteMarginOrderListV1Request) OrderListId(orderListId int64) ApiMarginDeleteMarginOrderListV1Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r ApiMarginDeleteMarginOrderListV1Request) ListClientOrderId(listClientOrderId string) ApiMarginDeleteMarginOrderListV1Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiMarginDeleteMarginOrderListV1Request) NewClientOrderId(newClientOrderId string) ApiMarginDeleteMarginOrderListV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginDeleteMarginOrderListV1Request) RecvWindow(recvWindow int64) ApiMarginDeleteMarginOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginDeleteMarginOrderListV1Request) Execute() (*MarginDeleteMarginOrderListV1Resp, *http.Response, error) {
	return r.ApiService.MarginDeleteMarginOrderListV1Execute(r)
}

/*
MarginDeleteMarginOrderListV1 Margin Account Cancel OCO (TRADE)

Cancel an entire Order List for a margin account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginDeleteMarginOrderListV1Request
*/
func (a *TradeAPIService) MarginDeleteMarginOrderListV1(ctx context.Context) ApiMarginDeleteMarginOrderListV1Request {
	return ApiMarginDeleteMarginOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginDeleteMarginOrderListV1Resp
func (a *TradeAPIService) MarginDeleteMarginOrderListV1Execute(r ApiMarginDeleteMarginOrderListV1Request) (*MarginDeleteMarginOrderListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginDeleteMarginOrderListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginDeleteMarginOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listClientOrderId", r.listClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.listClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginDeleteMarginOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	orderId *int64
	origClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

func (r ApiMarginDeleteMarginOrderV1Request) Symbol(symbol string) ApiMarginDeleteMarginOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginDeleteMarginOrderV1Request) Timestamp(timestamp int64) ApiMarginDeleteMarginOrderV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginDeleteMarginOrderV1Request) IsIsolated(isIsolated string) ApiMarginDeleteMarginOrderV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r ApiMarginDeleteMarginOrderV1Request) OrderId(orderId int64) ApiMarginDeleteMarginOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r ApiMarginDeleteMarginOrderV1Request) OrigClientOrderId(origClientOrderId string) ApiMarginDeleteMarginOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default.
func (r ApiMarginDeleteMarginOrderV1Request) NewClientOrderId(newClientOrderId string) ApiMarginDeleteMarginOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginDeleteMarginOrderV1Request) RecvWindow(recvWindow int64) ApiMarginDeleteMarginOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginDeleteMarginOrderV1Request) Execute() (*MarginDeleteMarginOrderV1Resp, *http.Response, error) {
	return r.ApiService.MarginDeleteMarginOrderV1Execute(r)
}

/*
MarginDeleteMarginOrderV1 Margin Account Cancel Order (TRADE)

Cancel an active order for margin account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginDeleteMarginOrderV1Request
*/
func (a *TradeAPIService) MarginDeleteMarginOrderV1(ctx context.Context) ApiMarginDeleteMarginOrderV1Request {
	return ApiMarginDeleteMarginOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginDeleteMarginOrderV1Resp
func (a *TradeAPIService) MarginDeleteMarginOrderV1Execute(r ApiMarginDeleteMarginOrderV1Request) (*MarginDeleteMarginOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginDeleteMarginOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginDeleteMarginOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginAllOrderListV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	isIsolated *string
	symbol *string
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiMarginGetMarginAllOrderListV1Request) Timestamp(timestamp int64) ApiMarginGetMarginAllOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginGetMarginAllOrderListV1Request) IsIsolated(isIsolated string) ApiMarginGetMarginAllOrderListV1Request {
	r.isIsolated = &isIsolated
	return r
}

// mandatory for isolated margin, not supported for cross margin
func (r ApiMarginGetMarginAllOrderListV1Request) Symbol(symbol string) ApiMarginGetMarginAllOrderListV1Request {
	r.symbol = &symbol
	return r
}

// If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
func (r ApiMarginGetMarginAllOrderListV1Request) FromId(fromId int64) ApiMarginGetMarginAllOrderListV1Request {
	r.fromId = &fromId
	return r
}

func (r ApiMarginGetMarginAllOrderListV1Request) StartTime(startTime int64) ApiMarginGetMarginAllOrderListV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiMarginGetMarginAllOrderListV1Request) EndTime(endTime int64) ApiMarginGetMarginAllOrderListV1Request {
	r.endTime = &endTime
	return r
}

// Default Value: 500; Max Value: 1000
func (r ApiMarginGetMarginAllOrderListV1Request) Limit(limit int32) ApiMarginGetMarginAllOrderListV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginAllOrderListV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginAllOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginAllOrderListV1Request) Execute() ([]MarginGetMarginAllOrderListV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginAllOrderListV1Execute(r)
}

/*
MarginGetMarginAllOrderListV1 Query Margin Account's all OCO (USER_DATA)

Retrieves all OCO for a specific margin account based on provided optional parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginAllOrderListV1Request
*/
func (a *TradeAPIService) MarginGetMarginAllOrderListV1(ctx context.Context) ApiMarginGetMarginAllOrderListV1Request {
	return ApiMarginGetMarginAllOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginAllOrderListV1RespItem
func (a *TradeAPIService) MarginGetMarginAllOrderListV1Execute(r ApiMarginGetMarginAllOrderListV1Request) ([]MarginGetMarginAllOrderListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginAllOrderListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginAllOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginAllOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiMarginGetMarginAllOrdersV1Request) Symbol(symbol string) ApiMarginGetMarginAllOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginGetMarginAllOrdersV1Request) Timestamp(timestamp int64) ApiMarginGetMarginAllOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginGetMarginAllOrdersV1Request) IsIsolated(isIsolated string) ApiMarginGetMarginAllOrdersV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r ApiMarginGetMarginAllOrdersV1Request) OrderId(orderId int64) ApiMarginGetMarginAllOrdersV1Request {
	r.orderId = &orderId
	return r
}

func (r ApiMarginGetMarginAllOrdersV1Request) StartTime(startTime int64) ApiMarginGetMarginAllOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiMarginGetMarginAllOrdersV1Request) EndTime(endTime int64) ApiMarginGetMarginAllOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 500.
func (r ApiMarginGetMarginAllOrdersV1Request) Limit(limit int32) ApiMarginGetMarginAllOrdersV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginAllOrdersV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginAllOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginAllOrdersV1Request) Execute() ([]MarginGetMarginAllOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginAllOrdersV1Execute(r)
}

/*
MarginGetMarginAllOrdersV1 Query Margin Account's All Orders (USER_DATA)

Query Margin Account's All Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginAllOrdersV1Request
*/
func (a *TradeAPIService) MarginGetMarginAllOrdersV1(ctx context.Context) ApiMarginGetMarginAllOrdersV1Request {
	return ApiMarginGetMarginAllOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginAllOrdersV1RespItem
func (a *TradeAPIService) MarginGetMarginAllOrdersV1Execute(r ApiMarginGetMarginAllOrdersV1Request) ([]MarginGetMarginAllOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginAllOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginAllOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginApiKeyListV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiMarginGetMarginApiKeyListV1Request) Timestamp(timestamp int64) ApiMarginGetMarginApiKeyListV1Request {
	r.timestamp = &timestamp
	return r
}

// isolated margin pair
func (r ApiMarginGetMarginApiKeyListV1Request) Symbol(symbol string) ApiMarginGetMarginApiKeyListV1Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginApiKeyListV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginApiKeyListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginApiKeyListV1Request) Execute() ([]MarginGetMarginApiKeyListV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginApiKeyListV1Execute(r)
}

/*
MarginGetMarginApiKeyListV1 Query Special key List(Low Latency Trading)(TRADE)

This only applies to Special Key for Low Latency Trading.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginApiKeyListV1Request
*/
func (a *TradeAPIService) MarginGetMarginApiKeyListV1(ctx context.Context) ApiMarginGetMarginApiKeyListV1Request {
	return ApiMarginGetMarginApiKeyListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginApiKeyListV1RespItem
func (a *TradeAPIService) MarginGetMarginApiKeyListV1Execute(r ApiMarginGetMarginApiKeyListV1Request) ([]MarginGetMarginApiKeyListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginApiKeyListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginApiKeyListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/api-key-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginApiKeyV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	apiKey *string
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiMarginGetMarginApiKeyV1Request) ApiKey(apiKey string) ApiMarginGetMarginApiKeyV1Request {
	r.apiKey = &apiKey
	return r
}

func (r ApiMarginGetMarginApiKeyV1Request) Timestamp(timestamp int64) ApiMarginGetMarginApiKeyV1Request {
	r.timestamp = &timestamp
	return r
}

// isolated margin pair
func (r ApiMarginGetMarginApiKeyV1Request) Symbol(symbol string) ApiMarginGetMarginApiKeyV1Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginApiKeyV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginApiKeyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginApiKeyV1Request) Execute() (*MarginGetMarginApiKeyV1Resp, *http.Response, error) {
	return r.ApiService.MarginGetMarginApiKeyV1Execute(r)
}

/*
MarginGetMarginApiKeyV1 Query Special key(Low Latency Trading)(TRADE)

Query Special Key Information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginApiKeyV1Request
*/
func (a *TradeAPIService) MarginGetMarginApiKeyV1(ctx context.Context) ApiMarginGetMarginApiKeyV1Request {
	return ApiMarginGetMarginApiKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginGetMarginApiKeyV1Resp
func (a *TradeAPIService) MarginGetMarginApiKeyV1Execute(r ApiMarginGetMarginApiKeyV1Request) (*MarginGetMarginApiKeyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginGetMarginApiKeyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginApiKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/apiKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "apiKey", r.apiKey, "form", "")
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	current *int32
	size *int32
	timestamp *int64
	startTime *int64
	endTime *int64
	recvWindow *int64
}

// Currently querying page. Start from 1. Default:1
func (r ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request) Current(current int32) ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request) Size(size int32) ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request) Timestamp(timestamp int64) ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// Default: 30 days from current timestamp
func (r ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request) StartTime(startTime int64) ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request) EndTime(endTime int64) ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request) Execute() (*MarginGetMarginExchangeSmallLiabilityHistoryV1Resp, *http.Response, error) {
	return r.ApiService.MarginGetMarginExchangeSmallLiabilityHistoryV1Execute(r)
}

/*
MarginGetMarginExchangeSmallLiabilityHistoryV1 Get Small Liability Exchange History (USER_DATA)

Get Small liability Exchange History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request
*/
func (a *TradeAPIService) MarginGetMarginExchangeSmallLiabilityHistoryV1(ctx context.Context) ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	return ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginGetMarginExchangeSmallLiabilityHistoryV1Resp
func (a *TradeAPIService) MarginGetMarginExchangeSmallLiabilityHistoryV1Execute(r ApiMarginGetMarginExchangeSmallLiabilityHistoryV1Request) (*MarginGetMarginExchangeSmallLiabilityHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginGetMarginExchangeSmallLiabilityHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginExchangeSmallLiabilityHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/exchange-small-liability-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.current == nil {
		return localVarReturnValue, nil, reportError("current is required and must be specified")
	}
	if r.size == nil {
		return localVarReturnValue, nil, reportError("size is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginExchangeSmallLiabilityV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiMarginGetMarginExchangeSmallLiabilityV1Request) Timestamp(timestamp int64) ApiMarginGetMarginExchangeSmallLiabilityV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiMarginGetMarginExchangeSmallLiabilityV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginExchangeSmallLiabilityV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginExchangeSmallLiabilityV1Request) Execute() ([]MarginGetMarginExchangeSmallLiabilityV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginExchangeSmallLiabilityV1Execute(r)
}

/*
MarginGetMarginExchangeSmallLiabilityV1 Get Small Liability Exchange Coin List (USER_DATA)

Query the coins which can be small liability exchange

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginExchangeSmallLiabilityV1Request
*/
func (a *TradeAPIService) MarginGetMarginExchangeSmallLiabilityV1(ctx context.Context) ApiMarginGetMarginExchangeSmallLiabilityV1Request {
	return ApiMarginGetMarginExchangeSmallLiabilityV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginExchangeSmallLiabilityV1RespItem
func (a *TradeAPIService) MarginGetMarginExchangeSmallLiabilityV1Execute(r ApiMarginGetMarginExchangeSmallLiabilityV1Request) ([]MarginGetMarginExchangeSmallLiabilityV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginExchangeSmallLiabilityV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginExchangeSmallLiabilityV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/exchange-small-liability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginForceLiquidationRecV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	isolatedSymbol *string
	current *int64
	size *int64
	recvWindow *int64
}

func (r ApiMarginGetMarginForceLiquidationRecV1Request) Timestamp(timestamp int64) ApiMarginGetMarginForceLiquidationRecV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiMarginGetMarginForceLiquidationRecV1Request) StartTime(startTime int64) ApiMarginGetMarginForceLiquidationRecV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiMarginGetMarginForceLiquidationRecV1Request) EndTime(endTime int64) ApiMarginGetMarginForceLiquidationRecV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiMarginGetMarginForceLiquidationRecV1Request) IsolatedSymbol(isolatedSymbol string) ApiMarginGetMarginForceLiquidationRecV1Request {
	r.isolatedSymbol = &isolatedSymbol
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiMarginGetMarginForceLiquidationRecV1Request) Current(current int64) ApiMarginGetMarginForceLiquidationRecV1Request {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiMarginGetMarginForceLiquidationRecV1Request) Size(size int64) ApiMarginGetMarginForceLiquidationRecV1Request {
	r.size = &size
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginForceLiquidationRecV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginForceLiquidationRecV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginForceLiquidationRecV1Request) Execute() (*MarginGetMarginForceLiquidationRecV1Resp, *http.Response, error) {
	return r.ApiService.MarginGetMarginForceLiquidationRecV1Execute(r)
}

/*
MarginGetMarginForceLiquidationRecV1 Get Force Liquidation Record (USER_DATA)

Get Force Liquidation Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginForceLiquidationRecV1Request
*/
func (a *TradeAPIService) MarginGetMarginForceLiquidationRecV1(ctx context.Context) ApiMarginGetMarginForceLiquidationRecV1Request {
	return ApiMarginGetMarginForceLiquidationRecV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginGetMarginForceLiquidationRecV1Resp
func (a *TradeAPIService) MarginGetMarginForceLiquidationRecV1Execute(r ApiMarginGetMarginForceLiquidationRecV1Request) (*MarginGetMarginForceLiquidationRecV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginGetMarginForceLiquidationRecV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginForceLiquidationRecV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/forceLiquidationRec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.isolatedSymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isolatedSymbol", r.isolatedSymbol, "form", "")
	} else {
		var defaultValue string = ""
		r.isolatedSymbol = &defaultValue
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginMyTradesV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	orderId *int64
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r ApiMarginGetMarginMyTradesV1Request) Symbol(symbol string) ApiMarginGetMarginMyTradesV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginGetMarginMyTradesV1Request) Timestamp(timestamp int64) ApiMarginGetMarginMyTradesV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginGetMarginMyTradesV1Request) IsIsolated(isIsolated string) ApiMarginGetMarginMyTradesV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r ApiMarginGetMarginMyTradesV1Request) OrderId(orderId int64) ApiMarginGetMarginMyTradesV1Request {
	r.orderId = &orderId
	return r
}

func (r ApiMarginGetMarginMyTradesV1Request) StartTime(startTime int64) ApiMarginGetMarginMyTradesV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiMarginGetMarginMyTradesV1Request) EndTime(endTime int64) ApiMarginGetMarginMyTradesV1Request {
	r.endTime = &endTime
	return r
}

// TradeId to fetch from. Default gets most recent trades.
func (r ApiMarginGetMarginMyTradesV1Request) FromId(fromId int64) ApiMarginGetMarginMyTradesV1Request {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r ApiMarginGetMarginMyTradesV1Request) Limit(limit int32) ApiMarginGetMarginMyTradesV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginMyTradesV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginMyTradesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginMyTradesV1Request) Execute() ([]MarginGetMarginMyTradesV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginMyTradesV1Execute(r)
}

/*
MarginGetMarginMyTradesV1 Query Margin Account's Trade List (USER_DATA)

Query Margin Account's Trade List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginMyTradesV1Request
*/
func (a *TradeAPIService) MarginGetMarginMyTradesV1(ctx context.Context) ApiMarginGetMarginMyTradesV1Request {
	return ApiMarginGetMarginMyTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginMyTradesV1RespItem
func (a *TradeAPIService) MarginGetMarginMyTradesV1Execute(r ApiMarginGetMarginMyTradesV1Request) ([]MarginGetMarginMyTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginMyTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginMyTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginOpenOrderListV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	isIsolated *string
	symbol *string
	recvWindow *int64
}

func (r ApiMarginGetMarginOpenOrderListV1Request) Timestamp(timestamp int64) ApiMarginGetMarginOpenOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginGetMarginOpenOrderListV1Request) IsIsolated(isIsolated string) ApiMarginGetMarginOpenOrderListV1Request {
	r.isIsolated = &isIsolated
	return r
}

// mandatory for isolated margin, not supported for cross margin
func (r ApiMarginGetMarginOpenOrderListV1Request) Symbol(symbol string) ApiMarginGetMarginOpenOrderListV1Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginOpenOrderListV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginOpenOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginOpenOrderListV1Request) Execute() ([]MarginGetMarginOpenOrderListV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginOpenOrderListV1Execute(r)
}

/*
MarginGetMarginOpenOrderListV1 Query Margin Account's Open OCO (USER_DATA)

Query Margin Account's Open OCO

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginOpenOrderListV1Request
*/
func (a *TradeAPIService) MarginGetMarginOpenOrderListV1(ctx context.Context) ApiMarginGetMarginOpenOrderListV1Request {
	return ApiMarginGetMarginOpenOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginOpenOrderListV1RespItem
func (a *TradeAPIService) MarginGetMarginOpenOrderListV1Execute(r ApiMarginGetMarginOpenOrderListV1Request) ([]MarginGetMarginOpenOrderListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginOpenOrderListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginOpenOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	isIsolated *string
	recvWindow *int64
}

func (r ApiMarginGetMarginOpenOrdersV1Request) Timestamp(timestamp int64) ApiMarginGetMarginOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiMarginGetMarginOpenOrdersV1Request) Symbol(symbol string) ApiMarginGetMarginOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginGetMarginOpenOrdersV1Request) IsIsolated(isIsolated string) ApiMarginGetMarginOpenOrdersV1Request {
	r.isIsolated = &isIsolated
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginOpenOrdersV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginOpenOrdersV1Request) Execute() ([]MarginGetMarginOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginOpenOrdersV1Execute(r)
}

/*
MarginGetMarginOpenOrdersV1 Query Margin Account's Open Orders (USER_DATA)

Query Margin Account's Open Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginOpenOrdersV1Request
*/
func (a *TradeAPIService) MarginGetMarginOpenOrdersV1(ctx context.Context) ApiMarginGetMarginOpenOrdersV1Request {
	return ApiMarginGetMarginOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginOpenOrdersV1RespItem
func (a *TradeAPIService) MarginGetMarginOpenOrdersV1Execute(r ApiMarginGetMarginOpenOrdersV1Request) ([]MarginGetMarginOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginOrderListV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	isIsolated *string
	symbol *string
	orderListId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r ApiMarginGetMarginOrderListV1Request) Timestamp(timestamp int64) ApiMarginGetMarginOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginGetMarginOrderListV1Request) IsIsolated(isIsolated string) ApiMarginGetMarginOrderListV1Request {
	r.isIsolated = &isIsolated
	return r
}

// mandatory for isolated margin, not supported for cross margin
func (r ApiMarginGetMarginOrderListV1Request) Symbol(symbol string) ApiMarginGetMarginOrderListV1Request {
	r.symbol = &symbol
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;origClientOrderId&#x60; must be provided
func (r ApiMarginGetMarginOrderListV1Request) OrderListId(orderListId int64) ApiMarginGetMarginOrderListV1Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;origClientOrderId&#x60; must be provided
func (r ApiMarginGetMarginOrderListV1Request) OrigClientOrderId(origClientOrderId string) ApiMarginGetMarginOrderListV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginOrderListV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginOrderListV1Request) Execute() (*MarginGetMarginOrderListV1Resp, *http.Response, error) {
	return r.ApiService.MarginGetMarginOrderListV1Execute(r)
}

/*
MarginGetMarginOrderListV1 Query Margin Account's OCO (USER_DATA)

Retrieves a specific OCO based on provided optional parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginOrderListV1Request
*/
func (a *TradeAPIService) MarginGetMarginOrderListV1(ctx context.Context) ApiMarginGetMarginOrderListV1Request {
	return ApiMarginGetMarginOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginGetMarginOrderListV1Resp
func (a *TradeAPIService) MarginGetMarginOrderListV1Execute(r ApiMarginGetMarginOrderListV1Request) (*MarginGetMarginOrderListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginGetMarginOrderListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r ApiMarginGetMarginOrderV1Request) Symbol(symbol string) ApiMarginGetMarginOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginGetMarginOrderV1Request) Timestamp(timestamp int64) ApiMarginGetMarginOrderV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginGetMarginOrderV1Request) IsIsolated(isIsolated string) ApiMarginGetMarginOrderV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r ApiMarginGetMarginOrderV1Request) OrderId(orderId int64) ApiMarginGetMarginOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r ApiMarginGetMarginOrderV1Request) OrigClientOrderId(origClientOrderId string) ApiMarginGetMarginOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginOrderV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginOrderV1Request) Execute() (*MarginGetMarginOrderV1Resp, *http.Response, error) {
	return r.ApiService.MarginGetMarginOrderV1Execute(r)
}

/*
MarginGetMarginOrderV1 Query Margin Account's Order (USER_DATA)

Query Margin Account's Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginOrderV1Request
*/
func (a *TradeAPIService) MarginGetMarginOrderV1(ctx context.Context) ApiMarginGetMarginOrderV1Request {
	return ApiMarginGetMarginOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginGetMarginOrderV1Resp
func (a *TradeAPIService) MarginGetMarginOrderV1Execute(r ApiMarginGetMarginOrderV1Request) (*MarginGetMarginOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginGetMarginOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMarginRateLimitOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	isIsolated *string
	symbol *string
	recvWindow *int64
}

func (r ApiMarginGetMarginRateLimitOrderV1Request) Timestamp(timestamp int64) ApiMarginGetMarginRateLimitOrderV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;，default &amp;#34;FALSE&amp;#34;
func (r ApiMarginGetMarginRateLimitOrderV1Request) IsIsolated(isIsolated string) ApiMarginGetMarginRateLimitOrderV1Request {
	r.isIsolated = &isIsolated
	return r
}

// isolated symbol, mandatory for isolated margin
func (r ApiMarginGetMarginRateLimitOrderV1Request) Symbol(symbol string) ApiMarginGetMarginRateLimitOrderV1Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiMarginGetMarginRateLimitOrderV1Request) RecvWindow(recvWindow int64) ApiMarginGetMarginRateLimitOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMarginRateLimitOrderV1Request) Execute() ([]MarginGetMarginRateLimitOrderV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginRateLimitOrderV1Execute(r)
}

/*
MarginGetMarginRateLimitOrderV1 Query Current Margin Order Count Usage (TRADE)

Displays the user's current margin order count usage for all intervals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMarginRateLimitOrderV1Request
*/
func (a *TradeAPIService) MarginGetMarginRateLimitOrderV1(ctx context.Context) ApiMarginGetMarginRateLimitOrderV1Request {
	return ApiMarginGetMarginRateLimitOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginRateLimitOrderV1RespItem
func (a *TradeAPIService) MarginGetMarginRateLimitOrderV1Execute(r ApiMarginGetMarginRateLimitOrderV1Request) ([]MarginGetMarginRateLimitOrderV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginRateLimitOrderV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginRateLimitOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/rateLimit/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginUpdateMarginApiKeyIpV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	apiKey *string
	ip *string
	timestamp *int64
	recvWindow *int64
	symbol *string
}

func (r ApiMarginUpdateMarginApiKeyIpV1Request) ApiKey(apiKey string) ApiMarginUpdateMarginApiKeyIpV1Request {
	r.apiKey = &apiKey
	return r
}

func (r ApiMarginUpdateMarginApiKeyIpV1Request) Ip(ip string) ApiMarginUpdateMarginApiKeyIpV1Request {
	r.ip = &ip
	return r
}

func (r ApiMarginUpdateMarginApiKeyIpV1Request) Timestamp(timestamp int64) ApiMarginUpdateMarginApiKeyIpV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiMarginUpdateMarginApiKeyIpV1Request) RecvWindow(recvWindow int64) ApiMarginUpdateMarginApiKeyIpV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginUpdateMarginApiKeyIpV1Request) Symbol(symbol string) ApiMarginUpdateMarginApiKeyIpV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiMarginUpdateMarginApiKeyIpV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MarginUpdateMarginApiKeyIpV1Execute(r)
}

/*
MarginUpdateMarginApiKeyIpV1 Edit ip for Special Key(Low-Latency Trading)(TRADE)

Edit ip restriction. This only applies to Special Key for Low Latency Trading.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginUpdateMarginApiKeyIpV1Request
*/
func (a *TradeAPIService) MarginUpdateMarginApiKeyIpV1(ctx context.Context) ApiMarginUpdateMarginApiKeyIpV1Request {
	return ApiMarginUpdateMarginApiKeyIpV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TradeAPIService) MarginUpdateMarginApiKeyIpV1Execute(r ApiMarginUpdateMarginApiKeyIpV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginUpdateMarginApiKeyIpV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/apiKey/ip"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.ip == nil {
		return localVarReturnValue, nil, reportError("ip is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "apiKey", r.apiKey, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ip", r.ip, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Binance Margin API

OpenAPI specification for Binance cryptocurrency exchange - Margin API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package margin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TradeAPIService TradeAPI service
type TradeAPIService service

type TradeAPIMarginCreateMarginApiKeyV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	apiName *string
	timestamp *int64
	ip *string
	permissionMode *string
	publicKey *string
	recvWindow *int64
	symbol *string
}

func (r TradeAPIMarginCreateMarginApiKeyV1Request) ApiName(apiName string) TradeAPIMarginCreateMarginApiKeyV1Request {
	r.apiName = &apiName
	return r
}

func (r TradeAPIMarginCreateMarginApiKeyV1Request) Timestamp(timestamp int64) TradeAPIMarginCreateMarginApiKeyV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIMarginCreateMarginApiKeyV1Request) Ip(ip string) TradeAPIMarginCreateMarginApiKeyV1Request {
	r.ip = &ip
	return r
}

func (r TradeAPIMarginCreateMarginApiKeyV1Request) PermissionMode(permissionMode string) TradeAPIMarginCreateMarginApiKeyV1Request {
	r.permissionMode = &permissionMode
	return r
}

func (r TradeAPIMarginCreateMarginApiKeyV1Request) PublicKey(publicKey string) TradeAPIMarginCreateMarginApiKeyV1Request {
	r.publicKey = &publicKey
	return r
}

func (r TradeAPIMarginCreateMarginApiKeyV1Request) RecvWindow(recvWindow int64) TradeAPIMarginCreateMarginApiKeyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginCreateMarginApiKeyV1Request) Symbol(symbol string) TradeAPIMarginCreateMarginApiKeyV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginCreateMarginApiKeyV1Request) Execute() (*MarginCreateMarginApiKeyV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginApiKeyV1Execute(r)
}

/*
MarginCreateMarginApiKeyV1 Create Special Key(Low-Latency Trading)(TRADE)

**Binance Margin offers low-latency trading through a special key, available exclusively to users with VIP level 4 or higher. **

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginCreateMarginApiKeyV1Request
*/
func (a *TradeAPIService) MarginCreateMarginApiKeyV1(ctx context.Context) TradeAPIMarginCreateMarginApiKeyV1Request {
	return TradeAPIMarginCreateMarginApiKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginApiKeyV1Resp
func (a *TradeAPIService) MarginCreateMarginApiKeyV1Execute(r TradeAPIMarginCreateMarginApiKeyV1Request) (*MarginCreateMarginApiKeyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginApiKeyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginApiKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/apiKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiName == nil {
		return localVarReturnValue, nil, reportError("apiName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "apiName", r.apiName, "", "")
	if r.ip != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ip", r.ip, "", "")
	}
	if r.permissionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "permissionMode", r.permissionMode, "", "")
	}
	if r.publicKey != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "publicKey", r.publicKey, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	assetNames *[]string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request) AssetNames(assetNames []string) TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request {
	r.assetNames = &assetNames
	return r
}

func (r TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request) Timestamp(timestamp int64) TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request) RecvWindow(recvWindow int64) TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request) Execute() (*MarginCreateMarginExchangeSmallLiabilityV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginExchangeSmallLiabilityV1Execute(r)
}

/*
MarginCreateMarginExchangeSmallLiabilityV1 Small Liability Exchange (MARGIN)

Small Liability Exchange

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request
*/
func (a *TradeAPIService) MarginCreateMarginExchangeSmallLiabilityV1(ctx context.Context) TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request {
	return TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginExchangeSmallLiabilityV1Resp
func (a *TradeAPIService) MarginCreateMarginExchangeSmallLiabilityV1Execute(r TradeAPIMarginCreateMarginExchangeSmallLiabilityV1Request) (*MarginCreateMarginExchangeSmallLiabilityV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginExchangeSmallLiabilityV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginExchangeSmallLiabilityV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/exchange-small-liability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetNames == nil {
		return localVarReturnValue, nil, reportError("assetNames is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "assetNames", r.assetNames, "", "csv")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginCreateMarginManualLiquidationV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	type_ *string
	recvWindow *int64
	symbol *string
}

func (r TradeAPIMarginCreateMarginManualLiquidationV1Request) Timestamp(timestamp int64) TradeAPIMarginCreateMarginManualLiquidationV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIMarginCreateMarginManualLiquidationV1Request) Type_(type_ string) TradeAPIMarginCreateMarginManualLiquidationV1Request {
	r.type_ = &type_
	return r
}

func (r TradeAPIMarginCreateMarginManualLiquidationV1Request) RecvWindow(recvWindow int64) TradeAPIMarginCreateMarginManualLiquidationV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginCreateMarginManualLiquidationV1Request) Symbol(symbol string) TradeAPIMarginCreateMarginManualLiquidationV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginCreateMarginManualLiquidationV1Request) Execute() (*MarginCreateMarginManualLiquidationV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginManualLiquidationV1Execute(r)
}

/*
MarginCreateMarginManualLiquidationV1 Margin Manual Liquidation(MARGIN)

Margin Manual Liquidation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginCreateMarginManualLiquidationV1Request
*/
func (a *TradeAPIService) MarginCreateMarginManualLiquidationV1(ctx context.Context) TradeAPIMarginCreateMarginManualLiquidationV1Request {
	return TradeAPIMarginCreateMarginManualLiquidationV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginManualLiquidationV1Resp
func (a *TradeAPIService) MarginCreateMarginManualLiquidationV1Execute(r TradeAPIMarginCreateMarginManualLiquidationV1Request) (*MarginCreateMarginManualLiquidationV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginManualLiquidationV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginManualLiquidationV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/manual-liquidation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginCreateMarginOrderOcoV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	price *string
	quantity *string
	side *string
	stopPrice *string
	symbol *string
	timestamp *int64
	autoRepayAtCancel *bool
	isIsolated *string
	limitClientOrderId *string
	limitIcebergQty *string
	listClientOrderId *string
	newOrderRespType *string
	recvWindow *int64
	selfTradePreventionMode *string
	sideEffectType *string
	stopClientOrderId *string
	stopIcebergQty *string
	stopLimitPrice *string
	stopLimitTimeInForce *string
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) Price(price string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.price = &price
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) Quantity(quantity string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.quantity = &quantity
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) Side(side string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.side = &side
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) StopPrice(stopPrice string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) Symbol(symbol string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) Timestamp(timestamp int64) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) AutoRepayAtCancel(autoRepayAtCancel bool) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.autoRepayAtCancel = &autoRepayAtCancel
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) IsIsolated(isIsolated string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) LimitClientOrderId(limitClientOrderId string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.limitClientOrderId = &limitClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) LimitIcebergQty(limitIcebergQty string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.limitIcebergQty = &limitIcebergQty
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) ListClientOrderId(listClientOrderId string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) NewOrderRespType(newOrderRespType string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) RecvWindow(recvWindow int64) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) SelfTradePreventionMode(selfTradePreventionMode string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) SideEffectType(sideEffectType string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.sideEffectType = &sideEffectType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) StopClientOrderId(stopClientOrderId string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.stopClientOrderId = &stopClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) StopIcebergQty(stopIcebergQty string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.stopIcebergQty = &stopIcebergQty
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) StopLimitPrice(stopLimitPrice string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.stopLimitPrice = &stopLimitPrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) StopLimitTimeInForce(stopLimitTimeInForce string) TradeAPIMarginCreateMarginOrderOcoV1Request {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}

func (r TradeAPIMarginCreateMarginOrderOcoV1Request) Execute() (*MarginCreateMarginOrderOcoV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginOrderOcoV1Execute(r)
}

/*
MarginCreateMarginOrderOcoV1 Margin Account New OCO (TRADE)

Send in a new OCO for a margin account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginCreateMarginOrderOcoV1Request
*/
func (a *TradeAPIService) MarginCreateMarginOrderOcoV1(ctx context.Context) TradeAPIMarginCreateMarginOrderOcoV1Request {
	return TradeAPIMarginCreateMarginOrderOcoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginOrderOcoV1Resp
func (a *TradeAPIService) MarginCreateMarginOrderOcoV1Execute(r TradeAPIMarginCreateMarginOrderOcoV1Request) (*MarginCreateMarginOrderOcoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginOrderOcoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginOrderOcoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoRepayAtCancel != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoRepayAtCancel", r.autoRepayAtCancel, "", "")
	}
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "isIsolated", r.isIsolated, "", "")
	}
	if r.limitClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitClientOrderId", r.limitClientOrderId, "", "")
	}
	if r.limitIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitIcebergQty", r.limitIcebergQty, "", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.sideEffectType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sideEffectType", r.sideEffectType, "", "")
	}
	if r.stopClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopClientOrderId", r.stopClientOrderId, "", "")
	}
	if r.stopIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopIcebergQty", r.stopIcebergQty, "", "")
	}
	if r.stopLimitPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitPrice", r.stopLimitPrice, "", "")
	}
	if r.stopLimitTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitTimeInForce", r.stopLimitTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginCreateMarginOrderOtoV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	pendingQuantity *string
	pendingSide *string
	pendingType *string
	symbol *string
	workingIcebergQty *string
	workingPrice *string
	workingQuantity *string
	workingSide *string
	workingType *string
	autoRepayAtCancel *bool
	isIsolated *string
	listClientOrderId *string
	newOrderRespType *string
	pendingClientOrderId *string
	pendingIcebergQty *string
	pendingPrice *string
	pendingStopPrice *string
	pendingTimeInForce *string
	pendingTrailingDelta *string
	selfTradePreventionMode *string
	sideEffectType *string
	workingClientOrderId *string
	workingTimeInForce *string
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) PendingQuantity(pendingQuantity string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.pendingQuantity = &pendingQuantity
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) PendingSide(pendingSide string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.pendingSide = &pendingSide
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) PendingType(pendingType string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.pendingType = &pendingType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) Symbol(symbol string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) WorkingIcebergQty(workingIcebergQty string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.workingIcebergQty = &workingIcebergQty
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) WorkingPrice(workingPrice string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.workingPrice = &workingPrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) WorkingQuantity(workingQuantity string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.workingQuantity = &workingQuantity
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) WorkingSide(workingSide string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.workingSide = &workingSide
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) WorkingType(workingType string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.workingType = &workingType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) AutoRepayAtCancel(autoRepayAtCancel bool) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.autoRepayAtCancel = &autoRepayAtCancel
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) IsIsolated(isIsolated string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) ListClientOrderId(listClientOrderId string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) NewOrderRespType(newOrderRespType string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) PendingClientOrderId(pendingClientOrderId string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.pendingClientOrderId = &pendingClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) PendingIcebergQty(pendingIcebergQty string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.pendingIcebergQty = &pendingIcebergQty
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) PendingPrice(pendingPrice string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.pendingPrice = &pendingPrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) PendingStopPrice(pendingStopPrice string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.pendingStopPrice = &pendingStopPrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) PendingTimeInForce(pendingTimeInForce string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.pendingTimeInForce = &pendingTimeInForce
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) PendingTrailingDelta(pendingTrailingDelta string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.pendingTrailingDelta = &pendingTrailingDelta
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) SelfTradePreventionMode(selfTradePreventionMode string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) SideEffectType(sideEffectType string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.sideEffectType = &sideEffectType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) WorkingClientOrderId(workingClientOrderId string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.workingClientOrderId = &workingClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) WorkingTimeInForce(workingTimeInForce string) TradeAPIMarginCreateMarginOrderOtoV1Request {
	r.workingTimeInForce = &workingTimeInForce
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtoV1Request) Execute() (*MarginCreateMarginOrderOtoV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginOrderOtoV1Execute(r)
}

/*
MarginCreateMarginOrderOtoV1 Margin Account New OTO (TRADE)

Post a new OTO order for margin account:

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginCreateMarginOrderOtoV1Request
*/
func (a *TradeAPIService) MarginCreateMarginOrderOtoV1(ctx context.Context) TradeAPIMarginCreateMarginOrderOtoV1Request {
	return TradeAPIMarginCreateMarginOrderOtoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginOrderOtoV1Resp
func (a *TradeAPIService) MarginCreateMarginOrderOtoV1Execute(r TradeAPIMarginCreateMarginOrderOtoV1Request) (*MarginCreateMarginOrderOtoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginOrderOtoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginOrderOtoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order/oto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pendingQuantity == nil {
		return localVarReturnValue, nil, reportError("pendingQuantity is required and must be specified")
	}
	if r.pendingSide == nil {
		return localVarReturnValue, nil, reportError("pendingSide is required and must be specified")
	}
	if r.pendingType == nil {
		return localVarReturnValue, nil, reportError("pendingType is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.workingIcebergQty == nil {
		return localVarReturnValue, nil, reportError("workingIcebergQty is required and must be specified")
	}
	if r.workingPrice == nil {
		return localVarReturnValue, nil, reportError("workingPrice is required and must be specified")
	}
	if r.workingQuantity == nil {
		return localVarReturnValue, nil, reportError("workingQuantity is required and must be specified")
	}
	if r.workingSide == nil {
		return localVarReturnValue, nil, reportError("workingSide is required and must be specified")
	}
	if r.workingType == nil {
		return localVarReturnValue, nil, reportError("workingType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoRepayAtCancel != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoRepayAtCancel", r.autoRepayAtCancel, "", "")
	}
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "isIsolated", r.isIsolated, "", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.pendingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingClientOrderId", r.pendingClientOrderId, "", "")
	}
	if r.pendingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingIcebergQty", r.pendingIcebergQty, "", "")
	}
	if r.pendingPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingPrice", r.pendingPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingQuantity", r.pendingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingSide", r.pendingSide, "", "")
	if r.pendingStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStopPrice", r.pendingStopPrice, "", "")
	}
	if r.pendingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingTimeInForce", r.pendingTimeInForce, "", "")
	}
	if r.pendingTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingTrailingDelta", r.pendingTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingType", r.pendingType, "", "")
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	if r.sideEffectType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sideEffectType", r.sideEffectType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.workingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingClientOrderId", r.workingClientOrderId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingIcebergQty", r.workingIcebergQty, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingPrice", r.workingPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingQuantity", r.workingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingSide", r.workingSide, "", "")
	if r.workingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingTimeInForce", r.workingTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginCreateMarginOrderOtocoV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	pendingAboveType *string
	pendingQuantity *string
	pendingSide *string
	symbol *string
	workingPrice *string
	workingQuantity *string
	workingSide *string
	workingType *string
	autoRepayAtCancel *bool
	isIsolated *string
	listClientOrderId *string
	newOrderRespType *string
	pendingAboveClientOrderId *string
	pendingAboveIcebergQty *string
	pendingAbovePrice *string
	pendingAboveStopPrice *string
	pendingAboveTimeInForce *string
	pendingAboveTrailingDelta *string
	pendingBelowClientOrderId *string
	pendingBelowIcebergQty *string
	pendingBelowPrice *string
	pendingBelowStopPrice *string
	pendingBelowTimeInForce *string
	pendingBelowTrailingDelta *string
	pendingBelowType *string
	selfTradePreventionMode *string
	sideEffectType *string
	workingClientOrderId *string
	workingIcebergQty *string
	workingTimeInForce *string
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingAboveType(pendingAboveType string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveType = &pendingAboveType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingQuantity(pendingQuantity string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingQuantity = &pendingQuantity
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingSide(pendingSide string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingSide = &pendingSide
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) Symbol(symbol string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) WorkingPrice(workingPrice string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.workingPrice = &workingPrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) WorkingQuantity(workingQuantity string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.workingQuantity = &workingQuantity
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) WorkingSide(workingSide string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.workingSide = &workingSide
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) WorkingType(workingType string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.workingType = &workingType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) AutoRepayAtCancel(autoRepayAtCancel bool) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.autoRepayAtCancel = &autoRepayAtCancel
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) IsIsolated(isIsolated string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) ListClientOrderId(listClientOrderId string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) NewOrderRespType(newOrderRespType string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingAboveClientOrderId(pendingAboveClientOrderId string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveClientOrderId = &pendingAboveClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingAboveIcebergQty(pendingAboveIcebergQty string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveIcebergQty = &pendingAboveIcebergQty
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingAbovePrice(pendingAbovePrice string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingAbovePrice = &pendingAbovePrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingAboveStopPrice(pendingAboveStopPrice string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveStopPrice = &pendingAboveStopPrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingAboveTimeInForce(pendingAboveTimeInForce string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveTimeInForce = &pendingAboveTimeInForce
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingAboveTrailingDelta(pendingAboveTrailingDelta string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingAboveTrailingDelta = &pendingAboveTrailingDelta
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingBelowClientOrderId(pendingBelowClientOrderId string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowClientOrderId = &pendingBelowClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingBelowIcebergQty(pendingBelowIcebergQty string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowIcebergQty = &pendingBelowIcebergQty
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingBelowPrice(pendingBelowPrice string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowPrice = &pendingBelowPrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingBelowStopPrice(pendingBelowStopPrice string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowStopPrice = &pendingBelowStopPrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingBelowTimeInForce(pendingBelowTimeInForce string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowTimeInForce = &pendingBelowTimeInForce
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingBelowTrailingDelta(pendingBelowTrailingDelta string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowTrailingDelta = &pendingBelowTrailingDelta
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) PendingBelowType(pendingBelowType string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.pendingBelowType = &pendingBelowType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) SelfTradePreventionMode(selfTradePreventionMode string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) SideEffectType(sideEffectType string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.sideEffectType = &sideEffectType
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) WorkingClientOrderId(workingClientOrderId string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.workingClientOrderId = &workingClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) WorkingIcebergQty(workingIcebergQty string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.workingIcebergQty = &workingIcebergQty
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) WorkingTimeInForce(workingTimeInForce string) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	r.workingTimeInForce = &workingTimeInForce
	return r
}

func (r TradeAPIMarginCreateMarginOrderOtocoV1Request) Execute() (*MarginCreateMarginOrderOtocoV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginOrderOtocoV1Execute(r)
}

/*
MarginCreateMarginOrderOtocoV1 Margin Account New OTOCO (TRADE)

Post a new OTOCO order for margin account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginCreateMarginOrderOtocoV1Request
*/
func (a *TradeAPIService) MarginCreateMarginOrderOtocoV1(ctx context.Context) TradeAPIMarginCreateMarginOrderOtocoV1Request {
	return TradeAPIMarginCreateMarginOrderOtocoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginOrderOtocoV1Resp
func (a *TradeAPIService) MarginCreateMarginOrderOtocoV1Execute(r TradeAPIMarginCreateMarginOrderOtocoV1Request) (*MarginCreateMarginOrderOtocoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginOrderOtocoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginOrderOtocoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order/otoco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pendingAboveType == nil {
		return localVarReturnValue, nil, reportError("pendingAboveType is required and must be specified")
	}
	if r.pendingQuantity == nil {
		return localVarReturnValue, nil, reportError("pendingQuantity is required and must be specified")
	}
	if r.pendingSide == nil {
		return localVarReturnValue, nil, reportError("pendingSide is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.workingPrice == nil {
		return localVarReturnValue, nil, reportError("workingPrice is required and must be specified")
	}
	if r.workingQuantity == nil {
		return localVarReturnValue, nil, reportError("workingQuantity is required and must be specified")
	}
	if r.workingSide == nil {
		return localVarReturnValue, nil, reportError("workingSide is required and must be specified")
	}
	if r.workingType == nil {
		return localVarReturnValue, nil, reportError("workingType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoRepayAtCancel != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoRepayAtCancel", r.autoRepayAtCancel, "", "")
	}
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "isIsolated", r.isIsolated, "", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.pendingAboveClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveClientOrderId", r.pendingAboveClientOrderId, "", "")
	}
	if r.pendingAboveIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveIcebergQty", r.pendingAboveIcebergQty, "", "")
	}
	if r.pendingAbovePrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAbovePrice", r.pendingAbovePrice, "", "")
	}
	if r.pendingAboveStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStopPrice", r.pendingAboveStopPrice, "", "")
	}
	if r.pendingAboveTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveTimeInForce", r.pendingAboveTimeInForce, "", "")
	}
	if r.pendingAboveTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveTrailingDelta", r.pendingAboveTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveType", r.pendingAboveType, "", "")
	if r.pendingBelowClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowClientOrderId", r.pendingBelowClientOrderId, "", "")
	}
	if r.pendingBelowIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowIcebergQty", r.pendingBelowIcebergQty, "", "")
	}
	if r.pendingBelowPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowPrice", r.pendingBelowPrice, "", "")
	}
	if r.pendingBelowStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStopPrice", r.pendingBelowStopPrice, "", "")
	}
	if r.pendingBelowTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowTimeInForce", r.pendingBelowTimeInForce, "", "")
	}
	if r.pendingBelowTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowTrailingDelta", r.pendingBelowTrailingDelta, "", "")
	}
	if r.pendingBelowType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowType", r.pendingBelowType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingQuantity", r.pendingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingSide", r.pendingSide, "", "")
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	if r.sideEffectType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sideEffectType", r.sideEffectType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.workingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingClientOrderId", r.workingClientOrderId, "", "")
	}
	if r.workingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingIcebergQty", r.workingIcebergQty, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingPrice", r.workingPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingQuantity", r.workingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingSide", r.workingSide, "", "")
	if r.workingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingTimeInForce", r.workingTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginCreateMarginOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	autoRepayAtCancel *bool
	icebergQty *string
	isIsolated *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	sideEffectType *string
	stopPrice *string
	timeInForce *string
}

func (r TradeAPIMarginCreateMarginOrderV1Request) Side(side string) TradeAPIMarginCreateMarginOrderV1Request {
	r.side = &side
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) Symbol(symbol string) TradeAPIMarginCreateMarginOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) Timestamp(timestamp int64) TradeAPIMarginCreateMarginOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) Type_(type_ string) TradeAPIMarginCreateMarginOrderV1Request {
	r.type_ = &type_
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) AutoRepayAtCancel(autoRepayAtCancel bool) TradeAPIMarginCreateMarginOrderV1Request {
	r.autoRepayAtCancel = &autoRepayAtCancel
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) IcebergQty(icebergQty string) TradeAPIMarginCreateMarginOrderV1Request {
	r.icebergQty = &icebergQty
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) IsIsolated(isIsolated string) TradeAPIMarginCreateMarginOrderV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) NewClientOrderId(newClientOrderId string) TradeAPIMarginCreateMarginOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) NewOrderRespType(newOrderRespType string) TradeAPIMarginCreateMarginOrderV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) Price(price string) TradeAPIMarginCreateMarginOrderV1Request {
	r.price = &price
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) Quantity(quantity string) TradeAPIMarginCreateMarginOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) QuoteOrderQty(quoteOrderQty string) TradeAPIMarginCreateMarginOrderV1Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) RecvWindow(recvWindow int64) TradeAPIMarginCreateMarginOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) SelfTradePreventionMode(selfTradePreventionMode string) TradeAPIMarginCreateMarginOrderV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) SideEffectType(sideEffectType string) TradeAPIMarginCreateMarginOrderV1Request {
	r.sideEffectType = &sideEffectType
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) StopPrice(stopPrice string) TradeAPIMarginCreateMarginOrderV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) TimeInForce(timeInForce string) TradeAPIMarginCreateMarginOrderV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r TradeAPIMarginCreateMarginOrderV1Request) Execute() (*MarginCreateMarginOrderV1Resp, *http.Response, error) {
	return r.ApiService.MarginCreateMarginOrderV1Execute(r)
}

/*
MarginCreateMarginOrderV1 Margin Account New Order (TRADE)

Post a new order for margin account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginCreateMarginOrderV1Request
*/
func (a *TradeAPIService) MarginCreateMarginOrderV1(ctx context.Context) TradeAPIMarginCreateMarginOrderV1Request {
	return TradeAPIMarginCreateMarginOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginCreateMarginOrderV1Resp
func (a *TradeAPIService) MarginCreateMarginOrderV1Execute(r TradeAPIMarginCreateMarginOrderV1Request) (*MarginCreateMarginOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginCreateMarginOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginCreateMarginOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoRepayAtCancel != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoRepayAtCancel", r.autoRepayAtCancel, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "isIsolated", r.isIsolated, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.sideEffectType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sideEffectType", r.sideEffectType, "", "")
	}
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginDeleteMarginApiKeyV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	apiKey *string
	apiName *string
	symbol *string
	recvWindow *int64
}

func (r TradeAPIMarginDeleteMarginApiKeyV1Request) Timestamp(timestamp int64) TradeAPIMarginDeleteMarginApiKeyV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIMarginDeleteMarginApiKeyV1Request) ApiKey(apiKey string) TradeAPIMarginDeleteMarginApiKeyV1Request {
	r.apiKey = &apiKey
	return r
}

func (r TradeAPIMarginDeleteMarginApiKeyV1Request) ApiName(apiName string) TradeAPIMarginDeleteMarginApiKeyV1Request {
	r.apiName = &apiName
	return r
}

// isolated margin pair
func (r TradeAPIMarginDeleteMarginApiKeyV1Request) Symbol(symbol string) TradeAPIMarginDeleteMarginApiKeyV1Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginDeleteMarginApiKeyV1Request) RecvWindow(recvWindow int64) TradeAPIMarginDeleteMarginApiKeyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginDeleteMarginApiKeyV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MarginDeleteMarginApiKeyV1Execute(r)
}

/*
MarginDeleteMarginApiKeyV1 Delete Special Key(Low-Latency Trading)(TRADE)

This only applies to Special Key for Low Latency Trading.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginDeleteMarginApiKeyV1Request
*/
func (a *TradeAPIService) MarginDeleteMarginApiKeyV1(ctx context.Context) TradeAPIMarginDeleteMarginApiKeyV1Request {
	return TradeAPIMarginDeleteMarginApiKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TradeAPIService) MarginDeleteMarginApiKeyV1Execute(r TradeAPIMarginDeleteMarginApiKeyV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginDeleteMarginApiKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/apiKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.apiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apiKey", r.apiKey, "form", "")
	} else {
		var defaultValue string = ""
		r.apiKey = &defaultValue
	}
	if r.apiName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apiName", r.apiName, "form", "")
	} else {
		var defaultValue string = ""
		r.apiName = &defaultValue
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginDeleteMarginOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	recvWindow *int64
}

func (r TradeAPIMarginDeleteMarginOpenOrdersV1Request) Symbol(symbol string) TradeAPIMarginDeleteMarginOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginDeleteMarginOpenOrdersV1Request) Timestamp(timestamp int64) TradeAPIMarginDeleteMarginOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginDeleteMarginOpenOrdersV1Request) IsIsolated(isIsolated string) TradeAPIMarginDeleteMarginOpenOrdersV1Request {
	r.isIsolated = &isIsolated
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginDeleteMarginOpenOrdersV1Request) RecvWindow(recvWindow int64) TradeAPIMarginDeleteMarginOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginDeleteMarginOpenOrdersV1Request) Execute() ([]MarginDeleteMarginOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.MarginDeleteMarginOpenOrdersV1Execute(r)
}

/*
MarginDeleteMarginOpenOrdersV1 Margin Account Cancel all Open Orders on a Symbol (TRADE)

Cancels all active orders on a symbol for margin account.
This includes OCO orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginDeleteMarginOpenOrdersV1Request
*/
func (a *TradeAPIService) MarginDeleteMarginOpenOrdersV1(ctx context.Context) TradeAPIMarginDeleteMarginOpenOrdersV1Request {
	return TradeAPIMarginDeleteMarginOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginDeleteMarginOpenOrdersV1RespItem
func (a *TradeAPIService) MarginDeleteMarginOpenOrdersV1Execute(r TradeAPIMarginDeleteMarginOpenOrdersV1Request) ([]MarginDeleteMarginOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginDeleteMarginOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginDeleteMarginOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginDeleteMarginOrderListV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	orderListId *int64
	listClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

func (r TradeAPIMarginDeleteMarginOrderListV1Request) Symbol(symbol string) TradeAPIMarginDeleteMarginOrderListV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginDeleteMarginOrderListV1Request) Timestamp(timestamp int64) TradeAPIMarginDeleteMarginOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginDeleteMarginOrderListV1Request) IsIsolated(isIsolated string) TradeAPIMarginDeleteMarginOrderListV1Request {
	r.isIsolated = &isIsolated
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r TradeAPIMarginDeleteMarginOrderListV1Request) OrderListId(orderListId int64) TradeAPIMarginDeleteMarginOrderListV1Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r TradeAPIMarginDeleteMarginOrderListV1Request) ListClientOrderId(listClientOrderId string) TradeAPIMarginDeleteMarginOrderListV1Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r TradeAPIMarginDeleteMarginOrderListV1Request) NewClientOrderId(newClientOrderId string) TradeAPIMarginDeleteMarginOrderListV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginDeleteMarginOrderListV1Request) RecvWindow(recvWindow int64) TradeAPIMarginDeleteMarginOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginDeleteMarginOrderListV1Request) Execute() (*MarginDeleteMarginOrderListV1Resp, *http.Response, error) {
	return r.ApiService.MarginDeleteMarginOrderListV1Execute(r)
}

/*
MarginDeleteMarginOrderListV1 Margin Account Cancel OCO (TRADE)

Cancel an entire Order List for a margin account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginDeleteMarginOrderListV1Request
*/
func (a *TradeAPIService) MarginDeleteMarginOrderListV1(ctx context.Context) TradeAPIMarginDeleteMarginOrderListV1Request {
	return TradeAPIMarginDeleteMarginOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginDeleteMarginOrderListV1Resp
func (a *TradeAPIService) MarginDeleteMarginOrderListV1Execute(r TradeAPIMarginDeleteMarginOrderListV1Request) (*MarginDeleteMarginOrderListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginDeleteMarginOrderListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginDeleteMarginOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listClientOrderId", r.listClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.listClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginDeleteMarginOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	orderId *int64
	origClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

func (r TradeAPIMarginDeleteMarginOrderV1Request) Symbol(symbol string) TradeAPIMarginDeleteMarginOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginDeleteMarginOrderV1Request) Timestamp(timestamp int64) TradeAPIMarginDeleteMarginOrderV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginDeleteMarginOrderV1Request) IsIsolated(isIsolated string) TradeAPIMarginDeleteMarginOrderV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r TradeAPIMarginDeleteMarginOrderV1Request) OrderId(orderId int64) TradeAPIMarginDeleteMarginOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIMarginDeleteMarginOrderV1Request) OrigClientOrderId(origClientOrderId string) TradeAPIMarginDeleteMarginOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default.
func (r TradeAPIMarginDeleteMarginOrderV1Request) NewClientOrderId(newClientOrderId string) TradeAPIMarginDeleteMarginOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginDeleteMarginOrderV1Request) RecvWindow(recvWindow int64) TradeAPIMarginDeleteMarginOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginDeleteMarginOrderV1Request) Execute() (*MarginDeleteMarginOrderV1Resp, *http.Response, error) {
	return r.ApiService.MarginDeleteMarginOrderV1Execute(r)
}

/*
MarginDeleteMarginOrderV1 Margin Account Cancel Order (TRADE)

Cancel an active order for margin account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginDeleteMarginOrderV1Request
*/
func (a *TradeAPIService) MarginDeleteMarginOrderV1(ctx context.Context) TradeAPIMarginDeleteMarginOrderV1Request {
	return TradeAPIMarginDeleteMarginOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginDeleteMarginOrderV1Resp
func (a *TradeAPIService) MarginDeleteMarginOrderV1Execute(r TradeAPIMarginDeleteMarginOrderV1Request) (*MarginDeleteMarginOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginDeleteMarginOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginDeleteMarginOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginAllOrderListV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	isIsolated *string
	symbol *string
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginAllOrderListV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginAllOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginGetMarginAllOrderListV1Request) IsIsolated(isIsolated string) TradeAPIMarginGetMarginAllOrderListV1Request {
	r.isIsolated = &isIsolated
	return r
}

// mandatory for isolated margin, not supported for cross margin
func (r TradeAPIMarginGetMarginAllOrderListV1Request) Symbol(symbol string) TradeAPIMarginGetMarginAllOrderListV1Request {
	r.symbol = &symbol
	return r
}

// If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
func (r TradeAPIMarginGetMarginAllOrderListV1Request) FromId(fromId int64) TradeAPIMarginGetMarginAllOrderListV1Request {
	r.fromId = &fromId
	return r
}

func (r TradeAPIMarginGetMarginAllOrderListV1Request) StartTime(startTime int64) TradeAPIMarginGetMarginAllOrderListV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPIMarginGetMarginAllOrderListV1Request) EndTime(endTime int64) TradeAPIMarginGetMarginAllOrderListV1Request {
	r.endTime = &endTime
	return r
}

// Default Value: 500; Max Value: 1000
func (r TradeAPIMarginGetMarginAllOrderListV1Request) Limit(limit int32) TradeAPIMarginGetMarginAllOrderListV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginAllOrderListV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginAllOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginAllOrderListV1Request) Execute() ([]MarginGetMarginAllOrderListV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginAllOrderListV1Execute(r)
}

/*
MarginGetMarginAllOrderListV1 Query Margin Account's all OCO (USER_DATA)

Retrieves all OCO for a specific margin account based on provided optional parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginAllOrderListV1Request
*/
func (a *TradeAPIService) MarginGetMarginAllOrderListV1(ctx context.Context) TradeAPIMarginGetMarginAllOrderListV1Request {
	return TradeAPIMarginGetMarginAllOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginAllOrderListV1RespItem
func (a *TradeAPIService) MarginGetMarginAllOrderListV1Execute(r TradeAPIMarginGetMarginAllOrderListV1Request) ([]MarginGetMarginAllOrderListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginAllOrderListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginAllOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginAllOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginAllOrdersV1Request) Symbol(symbol string) TradeAPIMarginGetMarginAllOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginGetMarginAllOrdersV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginAllOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginGetMarginAllOrdersV1Request) IsIsolated(isIsolated string) TradeAPIMarginGetMarginAllOrdersV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r TradeAPIMarginGetMarginAllOrdersV1Request) OrderId(orderId int64) TradeAPIMarginGetMarginAllOrdersV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIMarginGetMarginAllOrdersV1Request) StartTime(startTime int64) TradeAPIMarginGetMarginAllOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPIMarginGetMarginAllOrdersV1Request) EndTime(endTime int64) TradeAPIMarginGetMarginAllOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 500.
func (r TradeAPIMarginGetMarginAllOrdersV1Request) Limit(limit int32) TradeAPIMarginGetMarginAllOrdersV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginAllOrdersV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginAllOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginAllOrdersV1Request) Execute() ([]MarginGetMarginAllOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginAllOrdersV1Execute(r)
}

/*
MarginGetMarginAllOrdersV1 Query Margin Account's All Orders (USER_DATA)

Query Margin Account's All Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginAllOrdersV1Request
*/
func (a *TradeAPIService) MarginGetMarginAllOrdersV1(ctx context.Context) TradeAPIMarginGetMarginAllOrdersV1Request {
	return TradeAPIMarginGetMarginAllOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginAllOrdersV1RespItem
func (a *TradeAPIService) MarginGetMarginAllOrdersV1Execute(r TradeAPIMarginGetMarginAllOrdersV1Request) ([]MarginGetMarginAllOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginAllOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginAllOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginApiKeyListV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginApiKeyListV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginApiKeyListV1Request {
	r.timestamp = &timestamp
	return r
}

// isolated margin pair
func (r TradeAPIMarginGetMarginApiKeyListV1Request) Symbol(symbol string) TradeAPIMarginGetMarginApiKeyListV1Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginApiKeyListV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginApiKeyListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginApiKeyListV1Request) Execute() ([]MarginGetMarginApiKeyListV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginApiKeyListV1Execute(r)
}

/*
MarginGetMarginApiKeyListV1 Query Special key List(Low Latency Trading)(TRADE)

This only applies to Special Key for Low Latency Trading.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginApiKeyListV1Request
*/
func (a *TradeAPIService) MarginGetMarginApiKeyListV1(ctx context.Context) TradeAPIMarginGetMarginApiKeyListV1Request {
	return TradeAPIMarginGetMarginApiKeyListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginApiKeyListV1RespItem
func (a *TradeAPIService) MarginGetMarginApiKeyListV1Execute(r TradeAPIMarginGetMarginApiKeyListV1Request) ([]MarginGetMarginApiKeyListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginApiKeyListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginApiKeyListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/api-key-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginApiKeyV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	apiKey *string
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginApiKeyV1Request) ApiKey(apiKey string) TradeAPIMarginGetMarginApiKeyV1Request {
	r.apiKey = &apiKey
	return r
}

func (r TradeAPIMarginGetMarginApiKeyV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginApiKeyV1Request {
	r.timestamp = &timestamp
	return r
}

// isolated margin pair
func (r TradeAPIMarginGetMarginApiKeyV1Request) Symbol(symbol string) TradeAPIMarginGetMarginApiKeyV1Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginApiKeyV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginApiKeyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginApiKeyV1Request) Execute() (*MarginGetMarginApiKeyV1Resp, *http.Response, error) {
	return r.ApiService.MarginGetMarginApiKeyV1Execute(r)
}

/*
MarginGetMarginApiKeyV1 Query Special key(Low Latency Trading)(TRADE)

Query Special Key Information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginApiKeyV1Request
*/
func (a *TradeAPIService) MarginGetMarginApiKeyV1(ctx context.Context) TradeAPIMarginGetMarginApiKeyV1Request {
	return TradeAPIMarginGetMarginApiKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginGetMarginApiKeyV1Resp
func (a *TradeAPIService) MarginGetMarginApiKeyV1Execute(r TradeAPIMarginGetMarginApiKeyV1Request) (*MarginGetMarginApiKeyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginGetMarginApiKeyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginApiKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/apiKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "apiKey", r.apiKey, "form", "")
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	current *int32
	size *int32
	timestamp *int64
	startTime *int64
	endTime *int64
	recvWindow *int64
}

// Currently querying page. Start from 1. Default:1
func (r TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request) Current(current int32) TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.current = &current
	return r
}

// Default:10, Max:100
func (r TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request) Size(size int32) TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.size = &size
	return r
}

func (r TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// Default: 30 days from current timestamp
func (r TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request) StartTime(startTime int64) TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request) EndTime(endTime int64) TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.endTime = &endTime
	return r
}

func (r TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request) Execute() (*MarginGetMarginExchangeSmallLiabilityHistoryV1Resp, *http.Response, error) {
	return r.ApiService.MarginGetMarginExchangeSmallLiabilityHistoryV1Execute(r)
}

/*
MarginGetMarginExchangeSmallLiabilityHistoryV1 Get Small Liability Exchange History (USER_DATA)

Get Small liability Exchange History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request
*/
func (a *TradeAPIService) MarginGetMarginExchangeSmallLiabilityHistoryV1(ctx context.Context) TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request {
	return TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginGetMarginExchangeSmallLiabilityHistoryV1Resp
func (a *TradeAPIService) MarginGetMarginExchangeSmallLiabilityHistoryV1Execute(r TradeAPIMarginGetMarginExchangeSmallLiabilityHistoryV1Request) (*MarginGetMarginExchangeSmallLiabilityHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginGetMarginExchangeSmallLiabilityHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginExchangeSmallLiabilityHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/exchange-small-liability-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.current == nil {
		return localVarReturnValue, nil, reportError("current is required and must be specified")
	}
	if r.size == nil {
		return localVarReturnValue, nil, reportError("size is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginExchangeSmallLiabilityV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginExchangeSmallLiabilityV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginExchangeSmallLiabilityV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIMarginGetMarginExchangeSmallLiabilityV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginExchangeSmallLiabilityV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginExchangeSmallLiabilityV1Request) Execute() ([]MarginGetMarginExchangeSmallLiabilityV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginExchangeSmallLiabilityV1Execute(r)
}

/*
MarginGetMarginExchangeSmallLiabilityV1 Get Small Liability Exchange Coin List (USER_DATA)

Query the coins which can be small liability exchange

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginExchangeSmallLiabilityV1Request
*/
func (a *TradeAPIService) MarginGetMarginExchangeSmallLiabilityV1(ctx context.Context) TradeAPIMarginGetMarginExchangeSmallLiabilityV1Request {
	return TradeAPIMarginGetMarginExchangeSmallLiabilityV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginExchangeSmallLiabilityV1RespItem
func (a *TradeAPIService) MarginGetMarginExchangeSmallLiabilityV1Execute(r TradeAPIMarginGetMarginExchangeSmallLiabilityV1Request) ([]MarginGetMarginExchangeSmallLiabilityV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginExchangeSmallLiabilityV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginExchangeSmallLiabilityV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/exchange-small-liability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginForceLiquidationRecV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	isolatedSymbol *string
	current *int64
	size *int64
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginForceLiquidationRecV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginForceLiquidationRecV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIMarginGetMarginForceLiquidationRecV1Request) StartTime(startTime int64) TradeAPIMarginGetMarginForceLiquidationRecV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPIMarginGetMarginForceLiquidationRecV1Request) EndTime(endTime int64) TradeAPIMarginGetMarginForceLiquidationRecV1Request {
	r.endTime = &endTime
	return r
}

func (r TradeAPIMarginGetMarginForceLiquidationRecV1Request) IsolatedSymbol(isolatedSymbol string) TradeAPIMarginGetMarginForceLiquidationRecV1Request {
	r.isolatedSymbol = &isolatedSymbol
	return r
}

// Currently querying page. Start from 1. Default:1
func (r TradeAPIMarginGetMarginForceLiquidationRecV1Request) Current(current int64) TradeAPIMarginGetMarginForceLiquidationRecV1Request {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r TradeAPIMarginGetMarginForceLiquidationRecV1Request) Size(size int64) TradeAPIMarginGetMarginForceLiquidationRecV1Request {
	r.size = &size
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginForceLiquidationRecV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginForceLiquidationRecV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginForceLiquidationRecV1Request) Execute() (*MarginGetMarginForceLiquidationRecV1Resp, *http.Response, error) {
	return r.ApiService.MarginGetMarginForceLiquidationRecV1Execute(r)
}

/*
MarginGetMarginForceLiquidationRecV1 Get Force Liquidation Record (USER_DATA)

Get Force Liquidation Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginForceLiquidationRecV1Request
*/
func (a *TradeAPIService) MarginGetMarginForceLiquidationRecV1(ctx context.Context) TradeAPIMarginGetMarginForceLiquidationRecV1Request {
	return TradeAPIMarginGetMarginForceLiquidationRecV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginGetMarginForceLiquidationRecV1Resp
func (a *TradeAPIService) MarginGetMarginForceLiquidationRecV1Execute(r TradeAPIMarginGetMarginForceLiquidationRecV1Request) (*MarginGetMarginForceLiquidationRecV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginGetMarginForceLiquidationRecV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginForceLiquidationRecV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/forceLiquidationRec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.isolatedSymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isolatedSymbol", r.isolatedSymbol, "form", "")
	} else {
		var defaultValue string = ""
		r.isolatedSymbol = &defaultValue
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginMyTradesV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	orderId *int64
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginMyTradesV1Request) Symbol(symbol string) TradeAPIMarginGetMarginMyTradesV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginGetMarginMyTradesV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginMyTradesV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginGetMarginMyTradesV1Request) IsIsolated(isIsolated string) TradeAPIMarginGetMarginMyTradesV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r TradeAPIMarginGetMarginMyTradesV1Request) OrderId(orderId int64) TradeAPIMarginGetMarginMyTradesV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIMarginGetMarginMyTradesV1Request) StartTime(startTime int64) TradeAPIMarginGetMarginMyTradesV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPIMarginGetMarginMyTradesV1Request) EndTime(endTime int64) TradeAPIMarginGetMarginMyTradesV1Request {
	r.endTime = &endTime
	return r
}

// TradeId to fetch from. Default gets most recent trades.
func (r TradeAPIMarginGetMarginMyTradesV1Request) FromId(fromId int64) TradeAPIMarginGetMarginMyTradesV1Request {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r TradeAPIMarginGetMarginMyTradesV1Request) Limit(limit int32) TradeAPIMarginGetMarginMyTradesV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginMyTradesV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginMyTradesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginMyTradesV1Request) Execute() ([]MarginGetMarginMyTradesV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginMyTradesV1Execute(r)
}

/*
MarginGetMarginMyTradesV1 Query Margin Account's Trade List (USER_DATA)

Query Margin Account's Trade List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginMyTradesV1Request
*/
func (a *TradeAPIService) MarginGetMarginMyTradesV1(ctx context.Context) TradeAPIMarginGetMarginMyTradesV1Request {
	return TradeAPIMarginGetMarginMyTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginMyTradesV1RespItem
func (a *TradeAPIService) MarginGetMarginMyTradesV1Execute(r TradeAPIMarginGetMarginMyTradesV1Request) ([]MarginGetMarginMyTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginMyTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginMyTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginOpenOrderListV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	isIsolated *string
	symbol *string
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginOpenOrderListV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginOpenOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginGetMarginOpenOrderListV1Request) IsIsolated(isIsolated string) TradeAPIMarginGetMarginOpenOrderListV1Request {
	r.isIsolated = &isIsolated
	return r
}

// mandatory for isolated margin, not supported for cross margin
func (r TradeAPIMarginGetMarginOpenOrderListV1Request) Symbol(symbol string) TradeAPIMarginGetMarginOpenOrderListV1Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginOpenOrderListV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginOpenOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginOpenOrderListV1Request) Execute() ([]MarginGetMarginOpenOrderListV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginOpenOrderListV1Execute(r)
}

/*
MarginGetMarginOpenOrderListV1 Query Margin Account's Open OCO (USER_DATA)

Query Margin Account's Open OCO

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginOpenOrderListV1Request
*/
func (a *TradeAPIService) MarginGetMarginOpenOrderListV1(ctx context.Context) TradeAPIMarginGetMarginOpenOrderListV1Request {
	return TradeAPIMarginGetMarginOpenOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginOpenOrderListV1RespItem
func (a *TradeAPIService) MarginGetMarginOpenOrderListV1Execute(r TradeAPIMarginGetMarginOpenOrderListV1Request) ([]MarginGetMarginOpenOrderListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginOpenOrderListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginOpenOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	isIsolated *string
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginOpenOrdersV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIMarginGetMarginOpenOrdersV1Request) Symbol(symbol string) TradeAPIMarginGetMarginOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginGetMarginOpenOrdersV1Request) IsIsolated(isIsolated string) TradeAPIMarginGetMarginOpenOrdersV1Request {
	r.isIsolated = &isIsolated
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginOpenOrdersV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginOpenOrdersV1Request) Execute() ([]MarginGetMarginOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginOpenOrdersV1Execute(r)
}

/*
MarginGetMarginOpenOrdersV1 Query Margin Account's Open Orders (USER_DATA)

Query Margin Account's Open Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginOpenOrdersV1Request
*/
func (a *TradeAPIService) MarginGetMarginOpenOrdersV1(ctx context.Context) TradeAPIMarginGetMarginOpenOrdersV1Request {
	return TradeAPIMarginGetMarginOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginOpenOrdersV1RespItem
func (a *TradeAPIService) MarginGetMarginOpenOrdersV1Execute(r TradeAPIMarginGetMarginOpenOrdersV1Request) ([]MarginGetMarginOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginOrderListV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	isIsolated *string
	symbol *string
	orderListId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginOrderListV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginGetMarginOrderListV1Request) IsIsolated(isIsolated string) TradeAPIMarginGetMarginOrderListV1Request {
	r.isIsolated = &isIsolated
	return r
}

// mandatory for isolated margin, not supported for cross margin
func (r TradeAPIMarginGetMarginOrderListV1Request) Symbol(symbol string) TradeAPIMarginGetMarginOrderListV1Request {
	r.symbol = &symbol
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;origClientOrderId&#x60; must be provided
func (r TradeAPIMarginGetMarginOrderListV1Request) OrderListId(orderListId int64) TradeAPIMarginGetMarginOrderListV1Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;origClientOrderId&#x60; must be provided
func (r TradeAPIMarginGetMarginOrderListV1Request) OrigClientOrderId(origClientOrderId string) TradeAPIMarginGetMarginOrderListV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginOrderListV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginOrderListV1Request) Execute() (*MarginGetMarginOrderListV1Resp, *http.Response, error) {
	return r.ApiService.MarginGetMarginOrderListV1Execute(r)
}

/*
MarginGetMarginOrderListV1 Query Margin Account's OCO (USER_DATA)

Retrieves a specific OCO based on provided optional parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginOrderListV1Request
*/
func (a *TradeAPIService) MarginGetMarginOrderListV1(ctx context.Context) TradeAPIMarginGetMarginOrderListV1Request {
	return TradeAPIMarginGetMarginOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginGetMarginOrderListV1Resp
func (a *TradeAPIService) MarginGetMarginOrderListV1Execute(r TradeAPIMarginGetMarginOrderListV1Request) (*MarginGetMarginOrderListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginGetMarginOrderListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	isIsolated *string
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginOrderV1Request) Symbol(symbol string) TradeAPIMarginGetMarginOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginGetMarginOrderV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginOrderV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginGetMarginOrderV1Request) IsIsolated(isIsolated string) TradeAPIMarginGetMarginOrderV1Request {
	r.isIsolated = &isIsolated
	return r
}

func (r TradeAPIMarginGetMarginOrderV1Request) OrderId(orderId int64) TradeAPIMarginGetMarginOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIMarginGetMarginOrderV1Request) OrigClientOrderId(origClientOrderId string) TradeAPIMarginGetMarginOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginOrderV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginOrderV1Request) Execute() (*MarginGetMarginOrderV1Resp, *http.Response, error) {
	return r.ApiService.MarginGetMarginOrderV1Execute(r)
}

/*
MarginGetMarginOrderV1 Query Margin Account's Order (USER_DATA)

Query Margin Account's Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginOrderV1Request
*/
func (a *TradeAPIService) MarginGetMarginOrderV1(ctx context.Context) TradeAPIMarginGetMarginOrderV1Request {
	return TradeAPIMarginGetMarginOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginGetMarginOrderV1Resp
func (a *TradeAPIService) MarginGetMarginOrderV1Execute(r TradeAPIMarginGetMarginOrderV1Request) (*MarginGetMarginOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarginGetMarginOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginGetMarginRateLimitOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	isIsolated *string
	symbol *string
	recvWindow *int64
}

func (r TradeAPIMarginGetMarginRateLimitOrderV1Request) Timestamp(timestamp int64) TradeAPIMarginGetMarginRateLimitOrderV1Request {
	r.timestamp = &timestamp
	return r
}

// for isolated margin or not, &amp;#34;TRUE&amp;#34;, &amp;#34;FALSE&amp;#34;default &amp;#34;FALSE&amp;#34;
func (r TradeAPIMarginGetMarginRateLimitOrderV1Request) IsIsolated(isIsolated string) TradeAPIMarginGetMarginRateLimitOrderV1Request {
	r.isIsolated = &isIsolated
	return r
}

// isolated symbol, mandatory for isolated margin
func (r TradeAPIMarginGetMarginRateLimitOrderV1Request) Symbol(symbol string) TradeAPIMarginGetMarginRateLimitOrderV1Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r TradeAPIMarginGetMarginRateLimitOrderV1Request) RecvWindow(recvWindow int64) TradeAPIMarginGetMarginRateLimitOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginGetMarginRateLimitOrderV1Request) Execute() ([]MarginGetMarginRateLimitOrderV1RespItem, *http.Response, error) {
	return r.ApiService.MarginGetMarginRateLimitOrderV1Execute(r)
}

/*
MarginGetMarginRateLimitOrderV1 Query Current Margin Order Count Usage (TRADE)

Displays the user's current margin order count usage for all intervals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginGetMarginRateLimitOrderV1Request
*/
func (a *TradeAPIService) MarginGetMarginRateLimitOrderV1(ctx context.Context) TradeAPIMarginGetMarginRateLimitOrderV1Request {
	return TradeAPIMarginGetMarginRateLimitOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginGetMarginRateLimitOrderV1RespItem
func (a *TradeAPIService) MarginGetMarginRateLimitOrderV1Execute(r TradeAPIMarginGetMarginRateLimitOrderV1Request) ([]MarginGetMarginRateLimitOrderV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MarginGetMarginRateLimitOrderV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginGetMarginRateLimitOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/rateLimit/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.isIsolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isIsolated", r.isIsolated, "form", "")
	} else {
		var defaultValue string = ""
		r.isIsolated = &defaultValue
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIMarginUpdateMarginApiKeyIpV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	apiKey *string
	ip *string
	timestamp *int64
	recvWindow *int64
	symbol *string
}

func (r TradeAPIMarginUpdateMarginApiKeyIpV1Request) ApiKey(apiKey string) TradeAPIMarginUpdateMarginApiKeyIpV1Request {
	r.apiKey = &apiKey
	return r
}

func (r TradeAPIMarginUpdateMarginApiKeyIpV1Request) Ip(ip string) TradeAPIMarginUpdateMarginApiKeyIpV1Request {
	r.ip = &ip
	return r
}

func (r TradeAPIMarginUpdateMarginApiKeyIpV1Request) Timestamp(timestamp int64) TradeAPIMarginUpdateMarginApiKeyIpV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIMarginUpdateMarginApiKeyIpV1Request) RecvWindow(recvWindow int64) TradeAPIMarginUpdateMarginApiKeyIpV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIMarginUpdateMarginApiKeyIpV1Request) Symbol(symbol string) TradeAPIMarginUpdateMarginApiKeyIpV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIMarginUpdateMarginApiKeyIpV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MarginUpdateMarginApiKeyIpV1Execute(r)
}

/*
MarginUpdateMarginApiKeyIpV1 Edit ip for Special Key(Low-Latency Trading)(TRADE)

Edit ip restriction. This only applies to Special Key for Low Latency Trading.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIMarginUpdateMarginApiKeyIpV1Request
*/
func (a *TradeAPIService) MarginUpdateMarginApiKeyIpV1(ctx context.Context) TradeAPIMarginUpdateMarginApiKeyIpV1Request {
	return TradeAPIMarginUpdateMarginApiKeyIpV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TradeAPIService) MarginUpdateMarginApiKeyIpV1Execute(r TradeAPIMarginUpdateMarginApiKeyIpV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.MarginUpdateMarginApiKeyIpV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/apiKey/ip"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.ip == nil {
		return localVarReturnValue, nil, reportError("ip is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "apiKey", r.apiKey, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ip", r.ip, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

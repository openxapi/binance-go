/*
Binance Cmfutures API

OpenAPI specification for Binance cryptocurrency exchange - Cmfutures API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cmfutures

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// TradeAPIService TradeAPI service
type TradeAPIService service

type TradeAPICmfuturesCreateBatchOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	batchOrders *[]CmfuturesCreateBatchOrderV1ReqBatchOrdersItem
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPICmfuturesCreateBatchOrdersV1Request) BatchOrders(batchOrders []CmfuturesCreateBatchOrderV1ReqBatchOrdersItem) TradeAPICmfuturesCreateBatchOrdersV1Request {
	r.batchOrders = &batchOrders
	return r
}

func (r TradeAPICmfuturesCreateBatchOrdersV1Request) Timestamp(timestamp int64) TradeAPICmfuturesCreateBatchOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesCreateBatchOrdersV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesCreateBatchOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesCreateBatchOrdersV1Request) Execute() ([]CmfuturesCreateBatchOrdersV1RespInner, *http.Response, error) {
	return r.ApiService.CmfuturesCreateBatchOrdersV1Execute(r)
}

/*
CmfuturesCreateBatchOrdersV1 Place Multiple Orders(TRADE)

Place multiple orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesCreateBatchOrdersV1Request
*/
func (a *TradeAPIService) CmfuturesCreateBatchOrdersV1(ctx context.Context) TradeAPICmfuturesCreateBatchOrdersV1Request {
	return TradeAPICmfuturesCreateBatchOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesCreateBatchOrdersV1RespInner
func (a *TradeAPIService) CmfuturesCreateBatchOrdersV1Execute(r TradeAPICmfuturesCreateBatchOrdersV1Request) ([]CmfuturesCreateBatchOrdersV1RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesCreateBatchOrdersV1RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesCreateBatchOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/batchOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchOrders == nil {
		return localVarReturnValue, nil, reportError("batchOrders is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "batchOrders", r.batchOrders, "", "csv")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesCreateCountdownCancelAllV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	countdownTime *int64
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPICmfuturesCreateCountdownCancelAllV1Request) CountdownTime(countdownTime int64) TradeAPICmfuturesCreateCountdownCancelAllV1Request {
	r.countdownTime = &countdownTime
	return r
}

func (r TradeAPICmfuturesCreateCountdownCancelAllV1Request) Symbol(symbol string) TradeAPICmfuturesCreateCountdownCancelAllV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesCreateCountdownCancelAllV1Request) Timestamp(timestamp int64) TradeAPICmfuturesCreateCountdownCancelAllV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesCreateCountdownCancelAllV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesCreateCountdownCancelAllV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesCreateCountdownCancelAllV1Request) Execute() (*CmfuturesCreateCountdownCancelAllV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesCreateCountdownCancelAllV1Execute(r)
}

/*
CmfuturesCreateCountdownCancelAllV1 Auto-Cancel All Open Orders (TRADE)

Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns approximately every 10 milliseconds, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesCreateCountdownCancelAllV1Request
*/
func (a *TradeAPIService) CmfuturesCreateCountdownCancelAllV1(ctx context.Context) TradeAPICmfuturesCreateCountdownCancelAllV1Request {
	return TradeAPICmfuturesCreateCountdownCancelAllV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesCreateCountdownCancelAllV1Resp
func (a *TradeAPIService) CmfuturesCreateCountdownCancelAllV1Execute(r TradeAPICmfuturesCreateCountdownCancelAllV1Request) (*CmfuturesCreateCountdownCancelAllV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesCreateCountdownCancelAllV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesCreateCountdownCancelAllV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/countdownCancelAll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.countdownTime == nil {
		return localVarReturnValue, nil, reportError("countdownTime is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "countdownTime", r.countdownTime, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesCreateLeverageV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	leverage *int32
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPICmfuturesCreateLeverageV1Request) Leverage(leverage int32) TradeAPICmfuturesCreateLeverageV1Request {
	r.leverage = &leverage
	return r
}

func (r TradeAPICmfuturesCreateLeverageV1Request) Symbol(symbol string) TradeAPICmfuturesCreateLeverageV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesCreateLeverageV1Request) Timestamp(timestamp int64) TradeAPICmfuturesCreateLeverageV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesCreateLeverageV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesCreateLeverageV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesCreateLeverageV1Request) Execute() (*CmfuturesCreateLeverageV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesCreateLeverageV1Execute(r)
}

/*
CmfuturesCreateLeverageV1 Change Initial Leverage (TRADE)

Change user's initial leverage in the specific symbol market.
For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesCreateLeverageV1Request
*/
func (a *TradeAPIService) CmfuturesCreateLeverageV1(ctx context.Context) TradeAPICmfuturesCreateLeverageV1Request {
	return TradeAPICmfuturesCreateLeverageV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesCreateLeverageV1Resp
func (a *TradeAPIService) CmfuturesCreateLeverageV1Execute(r TradeAPICmfuturesCreateLeverageV1Request) (*CmfuturesCreateLeverageV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesCreateLeverageV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesCreateLeverageV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/leverage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leverage == nil {
		return localVarReturnValue, nil, reportError("leverage is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "leverage", r.leverage, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesCreateMarginTypeV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	marginType *string
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPICmfuturesCreateMarginTypeV1Request) MarginType(marginType string) TradeAPICmfuturesCreateMarginTypeV1Request {
	r.marginType = &marginType
	return r
}

func (r TradeAPICmfuturesCreateMarginTypeV1Request) Symbol(symbol string) TradeAPICmfuturesCreateMarginTypeV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesCreateMarginTypeV1Request) Timestamp(timestamp int64) TradeAPICmfuturesCreateMarginTypeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesCreateMarginTypeV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesCreateMarginTypeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesCreateMarginTypeV1Request) Execute() (*CmfuturesCreateMarginTypeV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesCreateMarginTypeV1Execute(r)
}

/*
CmfuturesCreateMarginTypeV1 Change Margin Type (TRADE)

Change user's margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type.
With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesCreateMarginTypeV1Request
*/
func (a *TradeAPIService) CmfuturesCreateMarginTypeV1(ctx context.Context) TradeAPICmfuturesCreateMarginTypeV1Request {
	return TradeAPICmfuturesCreateMarginTypeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesCreateMarginTypeV1Resp
func (a *TradeAPIService) CmfuturesCreateMarginTypeV1Execute(r TradeAPICmfuturesCreateMarginTypeV1Request) (*CmfuturesCreateMarginTypeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesCreateMarginTypeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesCreateMarginTypeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/marginType"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.marginType == nil {
		return localVarReturnValue, nil, reportError("marginType is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "marginType", r.marginType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesCreateOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	activationPrice *string
	callbackRate *string
	closePosition *string
	newClientOrderId *string
	newOrderRespType *string
	positionSide *string
	price *string
	priceMatch *string
	priceProtect *string
	quantity *string
	recvWindow *int64
	reduceOnly *string
	selfTradePreventionMode *string
	stopPrice *string
	timeInForce *string
	workingType *string
}

func (r TradeAPICmfuturesCreateOrderV1Request) Side(side string) TradeAPICmfuturesCreateOrderV1Request {
	r.side = &side
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) Symbol(symbol string) TradeAPICmfuturesCreateOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) Timestamp(timestamp int64) TradeAPICmfuturesCreateOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) Type_(type_ string) TradeAPICmfuturesCreateOrderV1Request {
	r.type_ = &type_
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) ActivationPrice(activationPrice string) TradeAPICmfuturesCreateOrderV1Request {
	r.activationPrice = &activationPrice
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) CallbackRate(callbackRate string) TradeAPICmfuturesCreateOrderV1Request {
	r.callbackRate = &callbackRate
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) ClosePosition(closePosition string) TradeAPICmfuturesCreateOrderV1Request {
	r.closePosition = &closePosition
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) NewClientOrderId(newClientOrderId string) TradeAPICmfuturesCreateOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) NewOrderRespType(newOrderRespType string) TradeAPICmfuturesCreateOrderV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) PositionSide(positionSide string) TradeAPICmfuturesCreateOrderV1Request {
	r.positionSide = &positionSide
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) Price(price string) TradeAPICmfuturesCreateOrderV1Request {
	r.price = &price
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) PriceMatch(priceMatch string) TradeAPICmfuturesCreateOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) PriceProtect(priceProtect string) TradeAPICmfuturesCreateOrderV1Request {
	r.priceProtect = &priceProtect
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) Quantity(quantity string) TradeAPICmfuturesCreateOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesCreateOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) ReduceOnly(reduceOnly string) TradeAPICmfuturesCreateOrderV1Request {
	r.reduceOnly = &reduceOnly
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) SelfTradePreventionMode(selfTradePreventionMode string) TradeAPICmfuturesCreateOrderV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) StopPrice(stopPrice string) TradeAPICmfuturesCreateOrderV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) TimeInForce(timeInForce string) TradeAPICmfuturesCreateOrderV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) WorkingType(workingType string) TradeAPICmfuturesCreateOrderV1Request {
	r.workingType = &workingType
	return r
}

func (r TradeAPICmfuturesCreateOrderV1Request) Execute() (*CmfuturesCreateOrderV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesCreateOrderV1Execute(r)
}

/*
CmfuturesCreateOrderV1 New Order (TRADE)

Send in a new order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesCreateOrderV1Request
*/
func (a *TradeAPIService) CmfuturesCreateOrderV1(ctx context.Context) TradeAPICmfuturesCreateOrderV1Request {
	return TradeAPICmfuturesCreateOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesCreateOrderV1Resp
func (a *TradeAPIService) CmfuturesCreateOrderV1Execute(r TradeAPICmfuturesCreateOrderV1Request) (*CmfuturesCreateOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesCreateOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesCreateOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.activationPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "activationPrice", r.activationPrice, "", "")
	}
	if r.callbackRate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callbackRate", r.callbackRate, "", "")
	}
	if r.closePosition != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "closePosition", r.closePosition, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	if r.priceProtect != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceProtect", r.priceProtect, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.reduceOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reduceOnly", r.reduceOnly, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.workingType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesCreatePositionMarginV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	amount *string
	symbol *string
	timestamp *int64
	type_ *int32
	positionSide *string
	recvWindow *int64
}

func (r TradeAPICmfuturesCreatePositionMarginV1Request) Amount(amount string) TradeAPICmfuturesCreatePositionMarginV1Request {
	r.amount = &amount
	return r
}

func (r TradeAPICmfuturesCreatePositionMarginV1Request) Symbol(symbol string) TradeAPICmfuturesCreatePositionMarginV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesCreatePositionMarginV1Request) Timestamp(timestamp int64) TradeAPICmfuturesCreatePositionMarginV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesCreatePositionMarginV1Request) Type_(type_ int32) TradeAPICmfuturesCreatePositionMarginV1Request {
	r.type_ = &type_
	return r
}

func (r TradeAPICmfuturesCreatePositionMarginV1Request) PositionSide(positionSide string) TradeAPICmfuturesCreatePositionMarginV1Request {
	r.positionSide = &positionSide
	return r
}

func (r TradeAPICmfuturesCreatePositionMarginV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesCreatePositionMarginV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesCreatePositionMarginV1Request) Execute() (*CmfuturesCreatePositionMarginV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesCreatePositionMarginV1Execute(r)
}

/*
CmfuturesCreatePositionMarginV1 Modify Isolated Position Margin(TRADE)

Modify Isolated Position Margin

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesCreatePositionMarginV1Request
*/
func (a *TradeAPIService) CmfuturesCreatePositionMarginV1(ctx context.Context) TradeAPICmfuturesCreatePositionMarginV1Request {
	return TradeAPICmfuturesCreatePositionMarginV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesCreatePositionMarginV1Resp
func (a *TradeAPIService) CmfuturesCreatePositionMarginV1Execute(r TradeAPICmfuturesCreatePositionMarginV1Request) (*CmfuturesCreatePositionMarginV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesCreatePositionMarginV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesCreatePositionMarginV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/positionMargin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesCreatePositionSideDualV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	dualSidePosition *string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPICmfuturesCreatePositionSideDualV1Request) DualSidePosition(dualSidePosition string) TradeAPICmfuturesCreatePositionSideDualV1Request {
	r.dualSidePosition = &dualSidePosition
	return r
}

func (r TradeAPICmfuturesCreatePositionSideDualV1Request) Timestamp(timestamp int64) TradeAPICmfuturesCreatePositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesCreatePositionSideDualV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesCreatePositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesCreatePositionSideDualV1Request) Execute() (*CmfuturesCreatePositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesCreatePositionSideDualV1Execute(r)
}

/*
CmfuturesCreatePositionSideDualV1 Change Position Mode(TRADE)

Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesCreatePositionSideDualV1Request
*/
func (a *TradeAPIService) CmfuturesCreatePositionSideDualV1(ctx context.Context) TradeAPICmfuturesCreatePositionSideDualV1Request {
	return TradeAPICmfuturesCreatePositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesCreatePositionSideDualV1Resp
func (a *TradeAPIService) CmfuturesCreatePositionSideDualV1Execute(r TradeAPICmfuturesCreatePositionSideDualV1Request) (*CmfuturesCreatePositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesCreatePositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesCreatePositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dualSidePosition == nil {
		return localVarReturnValue, nil, reportError("dualSidePosition is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "dualSidePosition", r.dualSidePosition, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesDeleteAllOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPICmfuturesDeleteAllOpenOrdersV1Request) Symbol(symbol string) TradeAPICmfuturesDeleteAllOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesDeleteAllOpenOrdersV1Request) Timestamp(timestamp int64) TradeAPICmfuturesDeleteAllOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesDeleteAllOpenOrdersV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesDeleteAllOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesDeleteAllOpenOrdersV1Request) Execute() (*CmfuturesDeleteAllOpenOrdersV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesDeleteAllOpenOrdersV1Execute(r)
}

/*
CmfuturesDeleteAllOpenOrdersV1 Cancel All Open Orders(TRADE)

Cancel All Open Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesDeleteAllOpenOrdersV1Request
*/
func (a *TradeAPIService) CmfuturesDeleteAllOpenOrdersV1(ctx context.Context) TradeAPICmfuturesDeleteAllOpenOrdersV1Request {
	return TradeAPICmfuturesDeleteAllOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesDeleteAllOpenOrdersV1Resp
func (a *TradeAPIService) CmfuturesDeleteAllOpenOrdersV1Execute(r TradeAPICmfuturesDeleteAllOpenOrdersV1Request) (*CmfuturesDeleteAllOpenOrdersV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesDeleteAllOpenOrdersV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesDeleteAllOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/allOpenOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesDeleteBatchOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderIdList *[]int64
	origClientOrderIdList *[]string
	recvWindow *int64
}

func (r TradeAPICmfuturesDeleteBatchOrdersV1Request) Symbol(symbol string) TradeAPICmfuturesDeleteBatchOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesDeleteBatchOrdersV1Request) Timestamp(timestamp int64) TradeAPICmfuturesDeleteBatchOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

// max length 10 &lt;br/&gt; e.g. [1234567,2345678]
func (r TradeAPICmfuturesDeleteBatchOrdersV1Request) OrderIdList(orderIdList []int64) TradeAPICmfuturesDeleteBatchOrdersV1Request {
	r.orderIdList = &orderIdList
	return r
}

// max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
func (r TradeAPICmfuturesDeleteBatchOrdersV1Request) OrigClientOrderIdList(origClientOrderIdList []string) TradeAPICmfuturesDeleteBatchOrdersV1Request {
	r.origClientOrderIdList = &origClientOrderIdList
	return r
}

func (r TradeAPICmfuturesDeleteBatchOrdersV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesDeleteBatchOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesDeleteBatchOrdersV1Request) Execute() ([]CmfuturesDeleteBatchOrdersV1RespInner, *http.Response, error) {
	return r.ApiService.CmfuturesDeleteBatchOrdersV1Execute(r)
}

/*
CmfuturesDeleteBatchOrdersV1 Cancel Multiple Orders(TRADE)

Cancel Multiple Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesDeleteBatchOrdersV1Request
*/
func (a *TradeAPIService) CmfuturesDeleteBatchOrdersV1(ctx context.Context) TradeAPICmfuturesDeleteBatchOrdersV1Request {
	return TradeAPICmfuturesDeleteBatchOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesDeleteBatchOrdersV1RespInner
func (a *TradeAPIService) CmfuturesDeleteBatchOrdersV1Execute(r TradeAPICmfuturesDeleteBatchOrdersV1Request) ([]CmfuturesDeleteBatchOrdersV1RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesDeleteBatchOrdersV1RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesDeleteBatchOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/batchOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderIdList != nil {
		t := *r.orderIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderIdList", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderIdList", t, "form", "multi")
		}
	}
	if r.origClientOrderIdList != nil {
		t := *r.origClientOrderIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderIdList", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderIdList", t, "form", "multi")
		}
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesDeleteOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r TradeAPICmfuturesDeleteOrderV1Request) Symbol(symbol string) TradeAPICmfuturesDeleteOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesDeleteOrderV1Request) Timestamp(timestamp int64) TradeAPICmfuturesDeleteOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesDeleteOrderV1Request) OrderId(orderId int64) TradeAPICmfuturesDeleteOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPICmfuturesDeleteOrderV1Request) OrigClientOrderId(origClientOrderId string) TradeAPICmfuturesDeleteOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r TradeAPICmfuturesDeleteOrderV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesDeleteOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesDeleteOrderV1Request) Execute() (*CmfuturesDeleteOrderV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesDeleteOrderV1Execute(r)
}

/*
CmfuturesDeleteOrderV1 Cancel Order (TRADE)

Cancel an active order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesDeleteOrderV1Request
*/
func (a *TradeAPIService) CmfuturesDeleteOrderV1(ctx context.Context) TradeAPICmfuturesDeleteOrderV1Request {
	return TradeAPICmfuturesDeleteOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesDeleteOrderV1Resp
func (a *TradeAPIService) CmfuturesDeleteOrderV1Execute(r TradeAPICmfuturesDeleteOrderV1Request) (*CmfuturesDeleteOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesDeleteOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesDeleteOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesGetAdlQuantileV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r TradeAPICmfuturesGetAdlQuantileV1Request) Timestamp(timestamp int64) TradeAPICmfuturesGetAdlQuantileV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesGetAdlQuantileV1Request) Symbol(symbol string) TradeAPICmfuturesGetAdlQuantileV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesGetAdlQuantileV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesGetAdlQuantileV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesGetAdlQuantileV1Request) Execute() ([]CmfuturesGetAdlQuantileV1RespItem, *http.Response, error) {
	return r.ApiService.CmfuturesGetAdlQuantileV1Execute(r)
}

/*
CmfuturesGetAdlQuantileV1 Position ADL Quantile Estimation(USER_DATA)

Query position ADL quantile estimation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesGetAdlQuantileV1Request
*/
func (a *TradeAPIService) CmfuturesGetAdlQuantileV1(ctx context.Context) TradeAPICmfuturesGetAdlQuantileV1Request {
	return TradeAPICmfuturesGetAdlQuantileV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesGetAdlQuantileV1RespItem
func (a *TradeAPIService) CmfuturesGetAdlQuantileV1Execute(r TradeAPICmfuturesGetAdlQuantileV1Request) ([]CmfuturesGetAdlQuantileV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesGetAdlQuantileV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesGetAdlQuantileV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/adlQuantile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesGetAllOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	pair *string
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPICmfuturesGetAllOrdersV1Request) Timestamp(timestamp int64) TradeAPICmfuturesGetAllOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesGetAllOrdersV1Request) Symbol(symbol string) TradeAPICmfuturesGetAllOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesGetAllOrdersV1Request) Pair(pair string) TradeAPICmfuturesGetAllOrdersV1Request {
	r.pair = &pair
	return r
}

func (r TradeAPICmfuturesGetAllOrdersV1Request) OrderId(orderId int64) TradeAPICmfuturesGetAllOrdersV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPICmfuturesGetAllOrdersV1Request) StartTime(startTime int64) TradeAPICmfuturesGetAllOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPICmfuturesGetAllOrdersV1Request) EndTime(endTime int64) TradeAPICmfuturesGetAllOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 50; max 100.
func (r TradeAPICmfuturesGetAllOrdersV1Request) Limit(limit int32) TradeAPICmfuturesGetAllOrdersV1Request {
	r.limit = &limit
	return r
}

func (r TradeAPICmfuturesGetAllOrdersV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesGetAllOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesGetAllOrdersV1Request) Execute() ([]CmfuturesGetAllOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.CmfuturesGetAllOrdersV1Execute(r)
}

/*
CmfuturesGetAllOrdersV1 All Orders (USER_DATA)

Get all account orders; active, canceled, or filled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesGetAllOrdersV1Request
*/
func (a *TradeAPIService) CmfuturesGetAllOrdersV1(ctx context.Context) TradeAPICmfuturesGetAllOrdersV1Request {
	return TradeAPICmfuturesGetAllOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesGetAllOrdersV1RespItem
func (a *TradeAPIService) CmfuturesGetAllOrdersV1Execute(r TradeAPICmfuturesGetAllOrdersV1Request) ([]CmfuturesGetAllOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesGetAllOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesGetAllOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	} else {
		var defaultValue string = ""
		r.pair = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesGetForceOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	autoCloseType *string
	recvWindow *int64
	limit *int32
	startTime *int64
	endTime *int64
}

func (r TradeAPICmfuturesGetForceOrdersV1Request) Timestamp(timestamp int64) TradeAPICmfuturesGetForceOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesGetForceOrdersV1Request) Symbol(symbol string) TradeAPICmfuturesGetForceOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesGetForceOrdersV1Request) AutoCloseType(autoCloseType string) TradeAPICmfuturesGetForceOrdersV1Request {
	r.autoCloseType = &autoCloseType
	return r
}

func (r TradeAPICmfuturesGetForceOrdersV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesGetForceOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesGetForceOrdersV1Request) Limit(limit int32) TradeAPICmfuturesGetForceOrdersV1Request {
	r.limit = &limit
	return r
}

func (r TradeAPICmfuturesGetForceOrdersV1Request) StartTime(startTime int64) TradeAPICmfuturesGetForceOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPICmfuturesGetForceOrdersV1Request) EndTime(endTime int64) TradeAPICmfuturesGetForceOrdersV1Request {
	r.endTime = &endTime
	return r
}

func (r TradeAPICmfuturesGetForceOrdersV1Request) Execute() ([]CmfuturesGetForceOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.CmfuturesGetForceOrdersV1Execute(r)
}

/*
CmfuturesGetForceOrdersV1 User's Force Orders(USER_DATA)

User's Force Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesGetForceOrdersV1Request
*/
func (a *TradeAPIService) CmfuturesGetForceOrdersV1(ctx context.Context) TradeAPICmfuturesGetForceOrdersV1Request {
	return TradeAPICmfuturesGetForceOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesGetForceOrdersV1RespItem
func (a *TradeAPIService) CmfuturesGetForceOrdersV1Execute(r TradeAPICmfuturesGetForceOrdersV1Request) ([]CmfuturesGetForceOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesGetForceOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesGetForceOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/forceOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.autoCloseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCloseType", r.autoCloseType, "form", "")
	} else {
		var defaultValue string = ""
		r.autoCloseType = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesGetOpenOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r TradeAPICmfuturesGetOpenOrderV1Request) Symbol(symbol string) TradeAPICmfuturesGetOpenOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesGetOpenOrderV1Request) Timestamp(timestamp int64) TradeAPICmfuturesGetOpenOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesGetOpenOrderV1Request) OrderId(orderId int64) TradeAPICmfuturesGetOpenOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPICmfuturesGetOpenOrderV1Request) OrigClientOrderId(origClientOrderId string) TradeAPICmfuturesGetOpenOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r TradeAPICmfuturesGetOpenOrderV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesGetOpenOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesGetOpenOrderV1Request) Execute() (*CmfuturesGetOpenOrderV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesGetOpenOrderV1Execute(r)
}

/*
CmfuturesGetOpenOrderV1 Query Current Open Order(USER_DATA)

Query Current Open Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesGetOpenOrderV1Request
*/
func (a *TradeAPIService) CmfuturesGetOpenOrderV1(ctx context.Context) TradeAPICmfuturesGetOpenOrderV1Request {
	return TradeAPICmfuturesGetOpenOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesGetOpenOrderV1Resp
func (a *TradeAPIService) CmfuturesGetOpenOrderV1Execute(r TradeAPICmfuturesGetOpenOrderV1Request) (*CmfuturesGetOpenOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesGetOpenOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesGetOpenOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/openOrder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesGetOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	pair *string
	recvWindow *int64
}

func (r TradeAPICmfuturesGetOpenOrdersV1Request) Timestamp(timestamp int64) TradeAPICmfuturesGetOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesGetOpenOrdersV1Request) Symbol(symbol string) TradeAPICmfuturesGetOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesGetOpenOrdersV1Request) Pair(pair string) TradeAPICmfuturesGetOpenOrdersV1Request {
	r.pair = &pair
	return r
}

func (r TradeAPICmfuturesGetOpenOrdersV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesGetOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesGetOpenOrdersV1Request) Execute() ([]CmfuturesGetOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.CmfuturesGetOpenOrdersV1Execute(r)
}

/*
CmfuturesGetOpenOrdersV1 Current All Open Orders (USER_DATA)

Get all open orders on a symbol. Careful when accessing this with no symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesGetOpenOrdersV1Request
*/
func (a *TradeAPIService) CmfuturesGetOpenOrdersV1(ctx context.Context) TradeAPICmfuturesGetOpenOrdersV1Request {
	return TradeAPICmfuturesGetOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesGetOpenOrdersV1RespItem
func (a *TradeAPIService) CmfuturesGetOpenOrdersV1Execute(r TradeAPICmfuturesGetOpenOrdersV1Request) ([]CmfuturesGetOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesGetOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesGetOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	} else {
		var defaultValue string = ""
		r.pair = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesGetOrderAmendmentV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPICmfuturesGetOrderAmendmentV1Request) Symbol(symbol string) TradeAPICmfuturesGetOrderAmendmentV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesGetOrderAmendmentV1Request) Timestamp(timestamp int64) TradeAPICmfuturesGetOrderAmendmentV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesGetOrderAmendmentV1Request) OrderId(orderId int64) TradeAPICmfuturesGetOrderAmendmentV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPICmfuturesGetOrderAmendmentV1Request) OrigClientOrderId(origClientOrderId string) TradeAPICmfuturesGetOrderAmendmentV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Timestamp in ms to get modification history from INCLUSIVE
func (r TradeAPICmfuturesGetOrderAmendmentV1Request) StartTime(startTime int64) TradeAPICmfuturesGetOrderAmendmentV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get modification history until INCLUSIVE
func (r TradeAPICmfuturesGetOrderAmendmentV1Request) EndTime(endTime int64) TradeAPICmfuturesGetOrderAmendmentV1Request {
	r.endTime = &endTime
	return r
}

// Default 50; max 100
func (r TradeAPICmfuturesGetOrderAmendmentV1Request) Limit(limit int32) TradeAPICmfuturesGetOrderAmendmentV1Request {
	r.limit = &limit
	return r
}

func (r TradeAPICmfuturesGetOrderAmendmentV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesGetOrderAmendmentV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesGetOrderAmendmentV1Request) Execute() ([]CmfuturesGetOrderAmendmentV1RespItem, *http.Response, error) {
	return r.ApiService.CmfuturesGetOrderAmendmentV1Execute(r)
}

/*
CmfuturesGetOrderAmendmentV1 Get Order Modify History (USER_DATA)

Get order modification history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesGetOrderAmendmentV1Request
*/
func (a *TradeAPIService) CmfuturesGetOrderAmendmentV1(ctx context.Context) TradeAPICmfuturesGetOrderAmendmentV1Request {
	return TradeAPICmfuturesGetOrderAmendmentV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesGetOrderAmendmentV1RespItem
func (a *TradeAPIService) CmfuturesGetOrderAmendmentV1Execute(r TradeAPICmfuturesGetOrderAmendmentV1Request) ([]CmfuturesGetOrderAmendmentV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesGetOrderAmendmentV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesGetOrderAmendmentV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/orderAmendment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesGetOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r TradeAPICmfuturesGetOrderV1Request) Symbol(symbol string) TradeAPICmfuturesGetOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesGetOrderV1Request) Timestamp(timestamp int64) TradeAPICmfuturesGetOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesGetOrderV1Request) OrderId(orderId int64) TradeAPICmfuturesGetOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPICmfuturesGetOrderV1Request) OrigClientOrderId(origClientOrderId string) TradeAPICmfuturesGetOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r TradeAPICmfuturesGetOrderV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesGetOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesGetOrderV1Request) Execute() (*CmfuturesGetOrderV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesGetOrderV1Execute(r)
}

/*
CmfuturesGetOrderV1 Query Order (USER_DATA)

Check an order's status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesGetOrderV1Request
*/
func (a *TradeAPIService) CmfuturesGetOrderV1(ctx context.Context) TradeAPICmfuturesGetOrderV1Request {
	return TradeAPICmfuturesGetOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesGetOrderV1Resp
func (a *TradeAPIService) CmfuturesGetOrderV1Execute(r TradeAPICmfuturesGetOrderV1Request) (*CmfuturesGetOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesGetOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesGetOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesGetPositionMarginHistoryV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	type_ *int32
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPICmfuturesGetPositionMarginHistoryV1Request) Symbol(symbol string) TradeAPICmfuturesGetPositionMarginHistoryV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesGetPositionMarginHistoryV1Request) Timestamp(timestamp int64) TradeAPICmfuturesGetPositionMarginHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// 1: Add position margin,2: Reduce position margin
func (r TradeAPICmfuturesGetPositionMarginHistoryV1Request) Type_(type_ int32) TradeAPICmfuturesGetPositionMarginHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r TradeAPICmfuturesGetPositionMarginHistoryV1Request) StartTime(startTime int64) TradeAPICmfuturesGetPositionMarginHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPICmfuturesGetPositionMarginHistoryV1Request) EndTime(endTime int64) TradeAPICmfuturesGetPositionMarginHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default: 50
func (r TradeAPICmfuturesGetPositionMarginHistoryV1Request) Limit(limit int32) TradeAPICmfuturesGetPositionMarginHistoryV1Request {
	r.limit = &limit
	return r
}

func (r TradeAPICmfuturesGetPositionMarginHistoryV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesGetPositionMarginHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesGetPositionMarginHistoryV1Request) Execute() ([]CmfuturesGetPositionMarginHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.CmfuturesGetPositionMarginHistoryV1Execute(r)
}

/*
CmfuturesGetPositionMarginHistoryV1 Get Position Margin Change History(TRADE)

Get position margin change history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesGetPositionMarginHistoryV1Request
*/
func (a *TradeAPIService) CmfuturesGetPositionMarginHistoryV1(ctx context.Context) TradeAPICmfuturesGetPositionMarginHistoryV1Request {
	return TradeAPICmfuturesGetPositionMarginHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesGetPositionMarginHistoryV1RespItem
func (a *TradeAPIService) CmfuturesGetPositionMarginHistoryV1Execute(r TradeAPICmfuturesGetPositionMarginHistoryV1Request) ([]CmfuturesGetPositionMarginHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesGetPositionMarginHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesGetPositionMarginHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/positionMargin/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesGetPositionRiskV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	marginAsset *string
	pair *string
	recvWindow *int64
}

func (r TradeAPICmfuturesGetPositionRiskV1Request) Timestamp(timestamp int64) TradeAPICmfuturesGetPositionRiskV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesGetPositionRiskV1Request) MarginAsset(marginAsset string) TradeAPICmfuturesGetPositionRiskV1Request {
	r.marginAsset = &marginAsset
	return r
}

func (r TradeAPICmfuturesGetPositionRiskV1Request) Pair(pair string) TradeAPICmfuturesGetPositionRiskV1Request {
	r.pair = &pair
	return r
}

func (r TradeAPICmfuturesGetPositionRiskV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesGetPositionRiskV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesGetPositionRiskV1Request) Execute() ([]CmfuturesGetPositionRiskV1RespItem, *http.Response, error) {
	return r.ApiService.CmfuturesGetPositionRiskV1Execute(r)
}

/*
CmfuturesGetPositionRiskV1 Position Information(USER_DATA)

Get current account information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesGetPositionRiskV1Request
*/
func (a *TradeAPIService) CmfuturesGetPositionRiskV1(ctx context.Context) TradeAPICmfuturesGetPositionRiskV1Request {
	return TradeAPICmfuturesGetPositionRiskV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesGetPositionRiskV1RespItem
func (a *TradeAPIService) CmfuturesGetPositionRiskV1Execute(r TradeAPICmfuturesGetPositionRiskV1Request) ([]CmfuturesGetPositionRiskV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesGetPositionRiskV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesGetPositionRiskV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.marginAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marginAsset", r.marginAsset, "form", "")
	} else {
		var defaultValue string = ""
		r.marginAsset = &defaultValue
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	} else {
		var defaultValue string = ""
		r.pair = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesGetUserTradesV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	pair *string
	orderId *string
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPICmfuturesGetUserTradesV1Request) Timestamp(timestamp int64) TradeAPICmfuturesGetUserTradesV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesGetUserTradesV1Request) Symbol(symbol string) TradeAPICmfuturesGetUserTradesV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesGetUserTradesV1Request) Pair(pair string) TradeAPICmfuturesGetUserTradesV1Request {
	r.pair = &pair
	return r
}

func (r TradeAPICmfuturesGetUserTradesV1Request) OrderId(orderId string) TradeAPICmfuturesGetUserTradesV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPICmfuturesGetUserTradesV1Request) StartTime(startTime int64) TradeAPICmfuturesGetUserTradesV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPICmfuturesGetUserTradesV1Request) EndTime(endTime int64) TradeAPICmfuturesGetUserTradesV1Request {
	r.endTime = &endTime
	return r
}

// Trade id to fetch from. Default gets most recent trades.
func (r TradeAPICmfuturesGetUserTradesV1Request) FromId(fromId int64) TradeAPICmfuturesGetUserTradesV1Request {
	r.fromId = &fromId
	return r
}

// Default 50; max 1000
func (r TradeAPICmfuturesGetUserTradesV1Request) Limit(limit int32) TradeAPICmfuturesGetUserTradesV1Request {
	r.limit = &limit
	return r
}

func (r TradeAPICmfuturesGetUserTradesV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesGetUserTradesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesGetUserTradesV1Request) Execute() ([]CmfuturesGetUserTradesV1RespItem, *http.Response, error) {
	return r.ApiService.CmfuturesGetUserTradesV1Execute(r)
}

/*
CmfuturesGetUserTradesV1 Account Trade List (USER_DATA)

Get trades for a specific account and symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesGetUserTradesV1Request
*/
func (a *TradeAPIService) CmfuturesGetUserTradesV1(ctx context.Context) TradeAPICmfuturesGetUserTradesV1Request {
	return TradeAPICmfuturesGetUserTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesGetUserTradesV1RespItem
func (a *TradeAPIService) CmfuturesGetUserTradesV1Execute(r TradeAPICmfuturesGetUserTradesV1Request) ([]CmfuturesGetUserTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesGetUserTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesGetUserTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/userTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	} else {
		var defaultValue string = ""
		r.pair = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	} else {
		var defaultValue string = ""
		r.orderId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesUpdateBatchOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	batchOrders *map[string]interface{}
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPICmfuturesUpdateBatchOrdersV1Request) BatchOrders(batchOrders map[string]interface{}) TradeAPICmfuturesUpdateBatchOrdersV1Request {
	r.batchOrders = &batchOrders
	return r
}

func (r TradeAPICmfuturesUpdateBatchOrdersV1Request) Timestamp(timestamp int64) TradeAPICmfuturesUpdateBatchOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesUpdateBatchOrdersV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesUpdateBatchOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesUpdateBatchOrdersV1Request) Execute() ([]CmfuturesUpdateBatchOrdersV1RespInner, *http.Response, error) {
	return r.ApiService.CmfuturesUpdateBatchOrdersV1Execute(r)
}

/*
CmfuturesUpdateBatchOrdersV1 Modify Multiple Orders(TRADE)

Modify Multiple Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesUpdateBatchOrdersV1Request
*/
func (a *TradeAPIService) CmfuturesUpdateBatchOrdersV1(ctx context.Context) TradeAPICmfuturesUpdateBatchOrdersV1Request {
	return TradeAPICmfuturesUpdateBatchOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CmfuturesUpdateBatchOrdersV1RespInner
func (a *TradeAPIService) CmfuturesUpdateBatchOrdersV1Execute(r TradeAPICmfuturesUpdateBatchOrdersV1Request) ([]CmfuturesUpdateBatchOrdersV1RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CmfuturesUpdateBatchOrdersV1RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesUpdateBatchOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/batchOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchOrders == nil {
		return localVarReturnValue, nil, reportError("batchOrders is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "batchOrders", r.batchOrders, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPICmfuturesUpdateOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	side *string
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	price *string
	priceMatch *string
	quantity *string
	recvWindow *int64
}

func (r TradeAPICmfuturesUpdateOrderV1Request) Side(side string) TradeAPICmfuturesUpdateOrderV1Request {
	r.side = &side
	return r
}

func (r TradeAPICmfuturesUpdateOrderV1Request) Symbol(symbol string) TradeAPICmfuturesUpdateOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPICmfuturesUpdateOrderV1Request) Timestamp(timestamp int64) TradeAPICmfuturesUpdateOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPICmfuturesUpdateOrderV1Request) OrderId(orderId int64) TradeAPICmfuturesUpdateOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPICmfuturesUpdateOrderV1Request) OrigClientOrderId(origClientOrderId string) TradeAPICmfuturesUpdateOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r TradeAPICmfuturesUpdateOrderV1Request) Price(price string) TradeAPICmfuturesUpdateOrderV1Request {
	r.price = &price
	return r
}

func (r TradeAPICmfuturesUpdateOrderV1Request) PriceMatch(priceMatch string) TradeAPICmfuturesUpdateOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r TradeAPICmfuturesUpdateOrderV1Request) Quantity(quantity string) TradeAPICmfuturesUpdateOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r TradeAPICmfuturesUpdateOrderV1Request) RecvWindow(recvWindow int64) TradeAPICmfuturesUpdateOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPICmfuturesUpdateOrderV1Request) Execute() (*CmfuturesUpdateOrderV1Resp, *http.Response, error) {
	return r.ApiService.CmfuturesUpdateOrderV1Execute(r)
}

/*
CmfuturesUpdateOrderV1 Modify Order (TRADE)

Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPICmfuturesUpdateOrderV1Request
*/
func (a *TradeAPIService) CmfuturesUpdateOrderV1(ctx context.Context) TradeAPICmfuturesUpdateOrderV1Request {
	return TradeAPICmfuturesUpdateOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CmfuturesUpdateOrderV1Resp
func (a *TradeAPIService) CmfuturesUpdateOrderV1Execute(r TradeAPICmfuturesUpdateOrderV1Request) (*CmfuturesUpdateOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CmfuturesUpdateOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.CmfuturesUpdateOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "orderId", r.orderId, "", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "origClientOrderId", r.origClientOrderId, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

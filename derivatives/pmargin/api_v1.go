/*
Binance Pmargin API

OpenAPI specification for Binance cryptocurrency exchange - Pmargin API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pmargin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// V1APIService V1API service
type V1APIService service

type V1APIPmarginCreateAssetCollectionV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateAssetCollectionV1Request) Asset(asset string) V1APIPmarginCreateAssetCollectionV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginCreateAssetCollectionV1Request) Timestamp(timestamp int64) V1APIPmarginCreateAssetCollectionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateAssetCollectionV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateAssetCollectionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateAssetCollectionV1Request) Execute() (*PmarginCreateAssetCollectionV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateAssetCollectionV1Execute(r)
}

/*
PmarginCreateAssetCollectionV1 Fund Collection by Asset(TRADE)

Transfers specific asset from Futures Account to Margin account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateAssetCollectionV1Request
*/
func (a *V1APIService) PmarginCreateAssetCollectionV1(ctx context.Context) V1APIPmarginCreateAssetCollectionV1Request {
	return V1APIPmarginCreateAssetCollectionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateAssetCollectionV1Resp
func (a *V1APIService) PmarginCreateAssetCollectionV1Execute(r V1APIPmarginCreateAssetCollectionV1Request) (*PmarginCreateAssetCollectionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateAssetCollectionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateAssetCollectionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/asset-collection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateAutoCollectionV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateAutoCollectionV1Request) Timestamp(timestamp int64) V1APIPmarginCreateAutoCollectionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateAutoCollectionV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateAutoCollectionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateAutoCollectionV1Request) Execute() (*PmarginCreateAutoCollectionV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateAutoCollectionV1Execute(r)
}

/*
PmarginCreateAutoCollectionV1 Fund Auto-collection(TRADE)

Fund collection for Portfolio Margin

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateAutoCollectionV1Request
*/
func (a *V1APIService) PmarginCreateAutoCollectionV1(ctx context.Context) V1APIPmarginCreateAutoCollectionV1Request {
	return V1APIPmarginCreateAutoCollectionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateAutoCollectionV1Resp
func (a *V1APIService) PmarginCreateAutoCollectionV1Execute(r V1APIPmarginCreateAutoCollectionV1Request) (*PmarginCreateAutoCollectionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateAutoCollectionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateAutoCollectionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/auto-collection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateBnbTransferV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	timestamp *int64
	transferSide *string
	recvWindow *int64
}

func (r V1APIPmarginCreateBnbTransferV1Request) Amount(amount string) V1APIPmarginCreateBnbTransferV1Request {
	r.amount = &amount
	return r
}

func (r V1APIPmarginCreateBnbTransferV1Request) Timestamp(timestamp int64) V1APIPmarginCreateBnbTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateBnbTransferV1Request) TransferSide(transferSide string) V1APIPmarginCreateBnbTransferV1Request {
	r.transferSide = &transferSide
	return r
}

func (r V1APIPmarginCreateBnbTransferV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateBnbTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateBnbTransferV1Request) Execute() (*PmarginCreateBnbTransferV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateBnbTransferV1Execute(r)
}

/*
PmarginCreateBnbTransferV1 BNB transfer (TRADE)

Transfer BNB in and out of UM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateBnbTransferV1Request
*/
func (a *V1APIService) PmarginCreateBnbTransferV1(ctx context.Context) V1APIPmarginCreateBnbTransferV1Request {
	return V1APIPmarginCreateBnbTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateBnbTransferV1Resp
func (a *V1APIService) PmarginCreateBnbTransferV1Execute(r V1APIPmarginCreateBnbTransferV1Request) (*PmarginCreateBnbTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateBnbTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateBnbTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/bnb-transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.transferSide == nil {
		return localVarReturnValue, nil, reportError("transferSide is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "transferSide", r.transferSide, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateCmConditionalOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	side *string
	strategyType *string
	symbol *string
	timestamp *int64
	activationPrice *string
	callbackRate *string
	newClientStrategyId *string
	positionSide *string
	price *string
	priceProtect *string
	quantity *string
	recvWindow *int64
	reduceOnly *string
	stopPrice *string
	timeInForce *string
	workingType *string
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) Side(side string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.side = &side
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) StrategyType(strategyType string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.strategyType = &strategyType
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) Symbol(symbol string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) Timestamp(timestamp int64) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) ActivationPrice(activationPrice string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.activationPrice = &activationPrice
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) CallbackRate(callbackRate string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.callbackRate = &callbackRate
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) NewClientStrategyId(newClientStrategyId string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.newClientStrategyId = &newClientStrategyId
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) PositionSide(positionSide string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.positionSide = &positionSide
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) Price(price string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.price = &price
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) PriceProtect(priceProtect string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.priceProtect = &priceProtect
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) Quantity(quantity string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) ReduceOnly(reduceOnly string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.reduceOnly = &reduceOnly
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) StopPrice(stopPrice string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) TimeInForce(timeInForce string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) WorkingType(workingType string) V1APIPmarginCreateCmConditionalOrderV1Request {
	r.workingType = &workingType
	return r
}

func (r V1APIPmarginCreateCmConditionalOrderV1Request) Execute() (*PmarginCreateCmConditionalOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateCmConditionalOrderV1Execute(r)
}

/*
PmarginCreateCmConditionalOrderV1 New CM Conditional Order(TRADE)

New CM Conditional Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateCmConditionalOrderV1Request
*/
func (a *V1APIService) PmarginCreateCmConditionalOrderV1(ctx context.Context) V1APIPmarginCreateCmConditionalOrderV1Request {
	return V1APIPmarginCreateCmConditionalOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateCmConditionalOrderV1Resp
func (a *V1APIService) PmarginCreateCmConditionalOrderV1Execute(r V1APIPmarginCreateCmConditionalOrderV1Request) (*PmarginCreateCmConditionalOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateCmConditionalOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateCmConditionalOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/conditional/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.strategyType == nil {
		return localVarReturnValue, nil, reportError("strategyType is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.activationPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "activationPrice", r.activationPrice, "", "")
	}
	if r.callbackRate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callbackRate", r.callbackRate, "", "")
	}
	if r.newClientStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientStrategyId", r.newClientStrategyId, "", "")
	}
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.priceProtect != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceProtect", r.priceProtect, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.reduceOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reduceOnly", r.reduceOnly, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.workingType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateCmLeverageV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	leverage *int32
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateCmLeverageV1Request) Leverage(leverage int32) V1APIPmarginCreateCmLeverageV1Request {
	r.leverage = &leverage
	return r
}

func (r V1APIPmarginCreateCmLeverageV1Request) Symbol(symbol string) V1APIPmarginCreateCmLeverageV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginCreateCmLeverageV1Request) Timestamp(timestamp int64) V1APIPmarginCreateCmLeverageV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateCmLeverageV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateCmLeverageV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateCmLeverageV1Request) Execute() (*PmarginCreateCmLeverageV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateCmLeverageV1Execute(r)
}

/*
PmarginCreateCmLeverageV1 Change CM Initial Leverage (TRADE)

Change user's initial leverage of specific symbol in CM.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateCmLeverageV1Request
*/
func (a *V1APIService) PmarginCreateCmLeverageV1(ctx context.Context) V1APIPmarginCreateCmLeverageV1Request {
	return V1APIPmarginCreateCmLeverageV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateCmLeverageV1Resp
func (a *V1APIService) PmarginCreateCmLeverageV1Execute(r V1APIPmarginCreateCmLeverageV1Request) (*PmarginCreateCmLeverageV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateCmLeverageV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateCmLeverageV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/leverage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leverage == nil {
		return localVarReturnValue, nil, reportError("leverage is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "leverage", r.leverage, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateCmOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	newClientOrderId *string
	newOrderRespType *string
	positionSide *string
	price *string
	priceMatch *string
	quantity *string
	recvWindow *int64
	reduceOnly *string
	timeInForce *string
}

func (r V1APIPmarginCreateCmOrderV1Request) Side(side string) V1APIPmarginCreateCmOrderV1Request {
	r.side = &side
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) Symbol(symbol string) V1APIPmarginCreateCmOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) Timestamp(timestamp int64) V1APIPmarginCreateCmOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) Type_(type_ string) V1APIPmarginCreateCmOrderV1Request {
	r.type_ = &type_
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) NewClientOrderId(newClientOrderId string) V1APIPmarginCreateCmOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) NewOrderRespType(newOrderRespType string) V1APIPmarginCreateCmOrderV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) PositionSide(positionSide string) V1APIPmarginCreateCmOrderV1Request {
	r.positionSide = &positionSide
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) Price(price string) V1APIPmarginCreateCmOrderV1Request {
	r.price = &price
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) PriceMatch(priceMatch string) V1APIPmarginCreateCmOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) Quantity(quantity string) V1APIPmarginCreateCmOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateCmOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) ReduceOnly(reduceOnly string) V1APIPmarginCreateCmOrderV1Request {
	r.reduceOnly = &reduceOnly
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) TimeInForce(timeInForce string) V1APIPmarginCreateCmOrderV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V1APIPmarginCreateCmOrderV1Request) Execute() (*PmarginCreateCmOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateCmOrderV1Execute(r)
}

/*
PmarginCreateCmOrderV1 New CM Order(TRADE)

Place new CM order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateCmOrderV1Request
*/
func (a *V1APIService) PmarginCreateCmOrderV1(ctx context.Context) V1APIPmarginCreateCmOrderV1Request {
	return V1APIPmarginCreateCmOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateCmOrderV1Resp
func (a *V1APIService) PmarginCreateCmOrderV1Execute(r V1APIPmarginCreateCmOrderV1Request) (*PmarginCreateCmOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateCmOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateCmOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.reduceOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reduceOnly", r.reduceOnly, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateCmPositionSideDualV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	dualSidePosition *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateCmPositionSideDualV1Request) DualSidePosition(dualSidePosition string) V1APIPmarginCreateCmPositionSideDualV1Request {
	r.dualSidePosition = &dualSidePosition
	return r
}

func (r V1APIPmarginCreateCmPositionSideDualV1Request) Timestamp(timestamp int64) V1APIPmarginCreateCmPositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateCmPositionSideDualV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateCmPositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateCmPositionSideDualV1Request) Execute() (*PmarginCreateCmPositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateCmPositionSideDualV1Execute(r)
}

/*
PmarginCreateCmPositionSideDualV1 Change CM Position Mode(TRADE)

Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateCmPositionSideDualV1Request
*/
func (a *V1APIService) PmarginCreateCmPositionSideDualV1(ctx context.Context) V1APIPmarginCreateCmPositionSideDualV1Request {
	return V1APIPmarginCreateCmPositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateCmPositionSideDualV1Resp
func (a *V1APIService) PmarginCreateCmPositionSideDualV1Execute(r V1APIPmarginCreateCmPositionSideDualV1Request) (*PmarginCreateCmPositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateCmPositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateCmPositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dualSidePosition == nil {
		return localVarReturnValue, nil, reportError("dualSidePosition is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "dualSidePosition", r.dualSidePosition, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateListenKeyV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIPmarginCreateListenKeyV1Request) Execute() (*PmarginCreateListenKeyV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateListenKeyV1Execute(r)
}

/*
PmarginCreateListenKeyV1 Start User Data Stream(USER_STREAM)

Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateListenKeyV1Request
*/
func (a *V1APIService) PmarginCreateListenKeyV1(ctx context.Context) V1APIPmarginCreateListenKeyV1Request {
	return V1APIPmarginCreateListenKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateListenKeyV1Resp
func (a *V1APIService) PmarginCreateListenKeyV1Execute(r V1APIPmarginCreateListenKeyV1Request) (*PmarginCreateListenKeyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateListenKeyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateListenKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/listenKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateMarginLoanV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateMarginLoanV1Request) Amount(amount string) V1APIPmarginCreateMarginLoanV1Request {
	r.amount = &amount
	return r
}

func (r V1APIPmarginCreateMarginLoanV1Request) Asset(asset string) V1APIPmarginCreateMarginLoanV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginCreateMarginLoanV1Request) Timestamp(timestamp int64) V1APIPmarginCreateMarginLoanV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateMarginLoanV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateMarginLoanV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateMarginLoanV1Request) Execute() (*PmarginCreateMarginLoanV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateMarginLoanV1Execute(r)
}

/*
PmarginCreateMarginLoanV1 Margin Account Borrow(MARGIN)

Apply for a margin loan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateMarginLoanV1Request
*/
func (a *V1APIService) PmarginCreateMarginLoanV1(ctx context.Context) V1APIPmarginCreateMarginLoanV1Request {
	return V1APIPmarginCreateMarginLoanV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateMarginLoanV1Resp
func (a *V1APIService) PmarginCreateMarginLoanV1Execute(r V1APIPmarginCreateMarginLoanV1Request) (*PmarginCreateMarginLoanV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateMarginLoanV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateMarginLoanV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/marginLoan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateMarginOrderOcoV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	price *string
	quantity *string
	side *string
	stopPrice *string
	symbol *string
	timestamp *int64
	limitClientOrderId *string
	limitIcebergQty *string
	listClientOrderId *string
	newOrderRespType *string
	recvWindow *int64
	sideEffectType *string
	stopClientOrderId *string
	stopIcebergQty *string
	stopLimitPrice *string
	stopLimitTimeInForce *string
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) Price(price string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.price = &price
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) Quantity(quantity string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) Side(side string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.side = &side
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) StopPrice(stopPrice string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) Symbol(symbol string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) Timestamp(timestamp int64) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) LimitClientOrderId(limitClientOrderId string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.limitClientOrderId = &limitClientOrderId
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) LimitIcebergQty(limitIcebergQty string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.limitIcebergQty = &limitIcebergQty
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) ListClientOrderId(listClientOrderId string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) NewOrderRespType(newOrderRespType string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) SideEffectType(sideEffectType string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.sideEffectType = &sideEffectType
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) StopClientOrderId(stopClientOrderId string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.stopClientOrderId = &stopClientOrderId
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) StopIcebergQty(stopIcebergQty string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.stopIcebergQty = &stopIcebergQty
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) StopLimitPrice(stopLimitPrice string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.stopLimitPrice = &stopLimitPrice
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) StopLimitTimeInForce(stopLimitTimeInForce string) V1APIPmarginCreateMarginOrderOcoV1Request {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}

func (r V1APIPmarginCreateMarginOrderOcoV1Request) Execute() (*PmarginCreateMarginOrderOcoV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateMarginOrderOcoV1Execute(r)
}

/*
PmarginCreateMarginOrderOcoV1 Margin Account New OCO(TRADE)

Send in a new OCO for a margin account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateMarginOrderOcoV1Request
*/
func (a *V1APIService) PmarginCreateMarginOrderOcoV1(ctx context.Context) V1APIPmarginCreateMarginOrderOcoV1Request {
	return V1APIPmarginCreateMarginOrderOcoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateMarginOrderOcoV1Resp
func (a *V1APIService) PmarginCreateMarginOrderOcoV1Execute(r V1APIPmarginCreateMarginOrderOcoV1Request) (*PmarginCreateMarginOrderOcoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateMarginOrderOcoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateMarginOrderOcoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.limitClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitClientOrderId", r.limitClientOrderId, "", "")
	}
	if r.limitIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitIcebergQty", r.limitIcebergQty, "", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.sideEffectType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sideEffectType", r.sideEffectType, "", "")
	}
	if r.stopClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopClientOrderId", r.stopClientOrderId, "", "")
	}
	if r.stopIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopIcebergQty", r.stopIcebergQty, "", "")
	}
	if r.stopLimitPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitPrice", r.stopLimitPrice, "", "")
	}
	if r.stopLimitTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitTimeInForce", r.stopLimitTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateMarginOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	autoRepayAtCancel *bool
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	sideEffectType *string
	stopPrice *string
	timeInForce *string
}

func (r V1APIPmarginCreateMarginOrderV1Request) Side(side string) V1APIPmarginCreateMarginOrderV1Request {
	r.side = &side
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) Symbol(symbol string) V1APIPmarginCreateMarginOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) Timestamp(timestamp int64) V1APIPmarginCreateMarginOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) Type_(type_ string) V1APIPmarginCreateMarginOrderV1Request {
	r.type_ = &type_
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) AutoRepayAtCancel(autoRepayAtCancel bool) V1APIPmarginCreateMarginOrderV1Request {
	r.autoRepayAtCancel = &autoRepayAtCancel
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) IcebergQty(icebergQty string) V1APIPmarginCreateMarginOrderV1Request {
	r.icebergQty = &icebergQty
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) NewClientOrderId(newClientOrderId string) V1APIPmarginCreateMarginOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) NewOrderRespType(newOrderRespType string) V1APIPmarginCreateMarginOrderV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) Price(price string) V1APIPmarginCreateMarginOrderV1Request {
	r.price = &price
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) Quantity(quantity string) V1APIPmarginCreateMarginOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) QuoteOrderQty(quoteOrderQty string) V1APIPmarginCreateMarginOrderV1Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateMarginOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) SelfTradePreventionMode(selfTradePreventionMode string) V1APIPmarginCreateMarginOrderV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) SideEffectType(sideEffectType string) V1APIPmarginCreateMarginOrderV1Request {
	r.sideEffectType = &sideEffectType
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) StopPrice(stopPrice string) V1APIPmarginCreateMarginOrderV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) TimeInForce(timeInForce string) V1APIPmarginCreateMarginOrderV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V1APIPmarginCreateMarginOrderV1Request) Execute() (*PmarginCreateMarginOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateMarginOrderV1Execute(r)
}

/*
PmarginCreateMarginOrderV1 New Margin Order(TRADE)

New Margin Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateMarginOrderV1Request
*/
func (a *V1APIService) PmarginCreateMarginOrderV1(ctx context.Context) V1APIPmarginCreateMarginOrderV1Request {
	return V1APIPmarginCreateMarginOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateMarginOrderV1Resp
func (a *V1APIService) PmarginCreateMarginOrderV1Execute(r V1APIPmarginCreateMarginOrderV1Request) (*PmarginCreateMarginOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateMarginOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateMarginOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoRepayAtCancel != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "autoRepayAtCancel", r.autoRepayAtCancel, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.sideEffectType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sideEffectType", r.sideEffectType, "", "")
	}
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateMarginRepayDebtV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	asset *string
	timestamp *int64
	amount *string
	recvWindow *int64
	specifyRepayAssets *string
}

func (r V1APIPmarginCreateMarginRepayDebtV1Request) Asset(asset string) V1APIPmarginCreateMarginRepayDebtV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginCreateMarginRepayDebtV1Request) Timestamp(timestamp int64) V1APIPmarginCreateMarginRepayDebtV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateMarginRepayDebtV1Request) Amount(amount string) V1APIPmarginCreateMarginRepayDebtV1Request {
	r.amount = &amount
	return r
}

func (r V1APIPmarginCreateMarginRepayDebtV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateMarginRepayDebtV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateMarginRepayDebtV1Request) SpecifyRepayAssets(specifyRepayAssets string) V1APIPmarginCreateMarginRepayDebtV1Request {
	r.specifyRepayAssets = &specifyRepayAssets
	return r
}

func (r V1APIPmarginCreateMarginRepayDebtV1Request) Execute() (*PmarginCreateMarginRepayDebtV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateMarginRepayDebtV1Execute(r)
}

/*
PmarginCreateMarginRepayDebtV1 Margin Account Repay Debt(TRADE)

Repay debt for a margin loan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateMarginRepayDebtV1Request
*/
func (a *V1APIService) PmarginCreateMarginRepayDebtV1(ctx context.Context) V1APIPmarginCreateMarginRepayDebtV1Request {
	return V1APIPmarginCreateMarginRepayDebtV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateMarginRepayDebtV1Resp
func (a *V1APIService) PmarginCreateMarginRepayDebtV1Execute(r V1APIPmarginCreateMarginRepayDebtV1Request) (*PmarginCreateMarginRepayDebtV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateMarginRepayDebtV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateMarginRepayDebtV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/repay-debt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.specifyRepayAssets != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "specifyRepayAssets", r.specifyRepayAssets, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateRepayFuturesNegativeBalanceV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateRepayFuturesNegativeBalanceV1Request) Timestamp(timestamp int64) V1APIPmarginCreateRepayFuturesNegativeBalanceV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateRepayFuturesNegativeBalanceV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateRepayFuturesNegativeBalanceV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateRepayFuturesNegativeBalanceV1Request) Execute() (*PmarginCreateRepayFuturesNegativeBalanceV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateRepayFuturesNegativeBalanceV1Execute(r)
}

/*
PmarginCreateRepayFuturesNegativeBalanceV1 Repay futures Negative Balance(USER_DATA)

Repay futures Negative Balance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateRepayFuturesNegativeBalanceV1Request
*/
func (a *V1APIService) PmarginCreateRepayFuturesNegativeBalanceV1(ctx context.Context) V1APIPmarginCreateRepayFuturesNegativeBalanceV1Request {
	return V1APIPmarginCreateRepayFuturesNegativeBalanceV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateRepayFuturesNegativeBalanceV1Resp
func (a *V1APIService) PmarginCreateRepayFuturesNegativeBalanceV1Execute(r V1APIPmarginCreateRepayFuturesNegativeBalanceV1Request) (*PmarginCreateRepayFuturesNegativeBalanceV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateRepayFuturesNegativeBalanceV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateRepayFuturesNegativeBalanceV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/repay-futures-negative-balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateRepayFuturesSwitchV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	autoRepay *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateRepayFuturesSwitchV1Request) AutoRepay(autoRepay string) V1APIPmarginCreateRepayFuturesSwitchV1Request {
	r.autoRepay = &autoRepay
	return r
}

func (r V1APIPmarginCreateRepayFuturesSwitchV1Request) Timestamp(timestamp int64) V1APIPmarginCreateRepayFuturesSwitchV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateRepayFuturesSwitchV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateRepayFuturesSwitchV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateRepayFuturesSwitchV1Request) Execute() (*PmarginCreateRepayFuturesSwitchV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateRepayFuturesSwitchV1Execute(r)
}

/*
PmarginCreateRepayFuturesSwitchV1 Change Auto-repay-futures Status(TRADE)

Change Auto-repay-futures Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateRepayFuturesSwitchV1Request
*/
func (a *V1APIService) PmarginCreateRepayFuturesSwitchV1(ctx context.Context) V1APIPmarginCreateRepayFuturesSwitchV1Request {
	return V1APIPmarginCreateRepayFuturesSwitchV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateRepayFuturesSwitchV1Resp
func (a *V1APIService) PmarginCreateRepayFuturesSwitchV1Execute(r V1APIPmarginCreateRepayFuturesSwitchV1Request) (*PmarginCreateRepayFuturesSwitchV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateRepayFuturesSwitchV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateRepayFuturesSwitchV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/repay-futures-switch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.autoRepay == nil {
		return localVarReturnValue, nil, reportError("autoRepay is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "autoRepay", r.autoRepay, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateRepayLoanV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateRepayLoanV1Request) Amount(amount string) V1APIPmarginCreateRepayLoanV1Request {
	r.amount = &amount
	return r
}

func (r V1APIPmarginCreateRepayLoanV1Request) Asset(asset string) V1APIPmarginCreateRepayLoanV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginCreateRepayLoanV1Request) Timestamp(timestamp int64) V1APIPmarginCreateRepayLoanV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateRepayLoanV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateRepayLoanV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateRepayLoanV1Request) Execute() (*PmarginCreateRepayLoanV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateRepayLoanV1Execute(r)
}

/*
PmarginCreateRepayLoanV1 Margin Account Repay(MARGIN)

Repay for a margin loan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateRepayLoanV1Request
*/
func (a *V1APIService) PmarginCreateRepayLoanV1(ctx context.Context) V1APIPmarginCreateRepayLoanV1Request {
	return V1APIPmarginCreateRepayLoanV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateRepayLoanV1Resp
func (a *V1APIService) PmarginCreateRepayLoanV1Execute(r V1APIPmarginCreateRepayLoanV1Request) (*PmarginCreateRepayLoanV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateRepayLoanV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateRepayLoanV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/repayLoan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateUmConditionalOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	side *string
	strategyType *string
	symbol *string
	timestamp *int64
	activationPrice *string
	callbackRate *string
	goodTillDate *int64
	newClientStrategyId *string
	positionSide *string
	price *string
	priceMatch *string
	priceProtect *string
	quantity *string
	recvWindow *int64
	reduceOnly *string
	selfTradePreventionMode *string
	stopPrice *string
	timeInForce *string
	workingType *string
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) Side(side string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.side = &side
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) StrategyType(strategyType string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.strategyType = &strategyType
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) Symbol(symbol string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) Timestamp(timestamp int64) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) ActivationPrice(activationPrice string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.activationPrice = &activationPrice
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) CallbackRate(callbackRate string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.callbackRate = &callbackRate
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) GoodTillDate(goodTillDate int64) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.goodTillDate = &goodTillDate
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) NewClientStrategyId(newClientStrategyId string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.newClientStrategyId = &newClientStrategyId
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) PositionSide(positionSide string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.positionSide = &positionSide
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) Price(price string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.price = &price
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) PriceMatch(priceMatch string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) PriceProtect(priceProtect string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.priceProtect = &priceProtect
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) Quantity(quantity string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) ReduceOnly(reduceOnly string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.reduceOnly = &reduceOnly
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) SelfTradePreventionMode(selfTradePreventionMode string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) StopPrice(stopPrice string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) TimeInForce(timeInForce string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) WorkingType(workingType string) V1APIPmarginCreateUmConditionalOrderV1Request {
	r.workingType = &workingType
	return r
}

func (r V1APIPmarginCreateUmConditionalOrderV1Request) Execute() (*PmarginCreateUmConditionalOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateUmConditionalOrderV1Execute(r)
}

/*
PmarginCreateUmConditionalOrderV1 New UM Conditional Order (TRADE)

Place new UM conditional order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateUmConditionalOrderV1Request
*/
func (a *V1APIService) PmarginCreateUmConditionalOrderV1(ctx context.Context) V1APIPmarginCreateUmConditionalOrderV1Request {
	return V1APIPmarginCreateUmConditionalOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateUmConditionalOrderV1Resp
func (a *V1APIService) PmarginCreateUmConditionalOrderV1Execute(r V1APIPmarginCreateUmConditionalOrderV1Request) (*PmarginCreateUmConditionalOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateUmConditionalOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateUmConditionalOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/conditional/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.strategyType == nil {
		return localVarReturnValue, nil, reportError("strategyType is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.activationPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "activationPrice", r.activationPrice, "", "")
	}
	if r.callbackRate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callbackRate", r.callbackRate, "", "")
	}
	if r.goodTillDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "goodTillDate", r.goodTillDate, "", "")
	}
	if r.newClientStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientStrategyId", r.newClientStrategyId, "", "")
	}
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	if r.priceProtect != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceProtect", r.priceProtect, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.reduceOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reduceOnly", r.reduceOnly, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.workingType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateUmFeeBurnV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	feeBurn *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateUmFeeBurnV1Request) FeeBurn(feeBurn string) V1APIPmarginCreateUmFeeBurnV1Request {
	r.feeBurn = &feeBurn
	return r
}

func (r V1APIPmarginCreateUmFeeBurnV1Request) Timestamp(timestamp int64) V1APIPmarginCreateUmFeeBurnV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateUmFeeBurnV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateUmFeeBurnV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateUmFeeBurnV1Request) Execute() (*PmarginCreateUmFeeBurnV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateUmFeeBurnV1Execute(r)
}

/*
PmarginCreateUmFeeBurnV1 Toggle BNB Burn On UM Futures Trade (TRADE)

Change user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateUmFeeBurnV1Request
*/
func (a *V1APIService) PmarginCreateUmFeeBurnV1(ctx context.Context) V1APIPmarginCreateUmFeeBurnV1Request {
	return V1APIPmarginCreateUmFeeBurnV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateUmFeeBurnV1Resp
func (a *V1APIService) PmarginCreateUmFeeBurnV1Execute(r V1APIPmarginCreateUmFeeBurnV1Request) (*PmarginCreateUmFeeBurnV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateUmFeeBurnV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateUmFeeBurnV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/feeBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.feeBurn == nil {
		return localVarReturnValue, nil, reportError("feeBurn is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "feeBurn", r.feeBurn, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateUmLeverageV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	leverage *int32
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateUmLeverageV1Request) Leverage(leverage int32) V1APIPmarginCreateUmLeverageV1Request {
	r.leverage = &leverage
	return r
}

func (r V1APIPmarginCreateUmLeverageV1Request) Symbol(symbol string) V1APIPmarginCreateUmLeverageV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginCreateUmLeverageV1Request) Timestamp(timestamp int64) V1APIPmarginCreateUmLeverageV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateUmLeverageV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateUmLeverageV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateUmLeverageV1Request) Execute() (*PmarginCreateUmLeverageV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateUmLeverageV1Execute(r)
}

/*
PmarginCreateUmLeverageV1 Change UM Initial Leverage(TRADE)

Change user's initial leverage of specific symbol in UM.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateUmLeverageV1Request
*/
func (a *V1APIService) PmarginCreateUmLeverageV1(ctx context.Context) V1APIPmarginCreateUmLeverageV1Request {
	return V1APIPmarginCreateUmLeverageV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateUmLeverageV1Resp
func (a *V1APIService) PmarginCreateUmLeverageV1Execute(r V1APIPmarginCreateUmLeverageV1Request) (*PmarginCreateUmLeverageV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateUmLeverageV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateUmLeverageV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/leverage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leverage == nil {
		return localVarReturnValue, nil, reportError("leverage is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "leverage", r.leverage, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateUmOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	goodTillDate *int64
	newClientOrderId *string
	newOrderRespType *string
	positionSide *string
	price *string
	priceMatch *string
	quantity *string
	recvWindow *int64
	reduceOnly *string
	selfTradePreventionMode *string
	timeInForce *string
}

func (r V1APIPmarginCreateUmOrderV1Request) Side(side string) V1APIPmarginCreateUmOrderV1Request {
	r.side = &side
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) Symbol(symbol string) V1APIPmarginCreateUmOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) Timestamp(timestamp int64) V1APIPmarginCreateUmOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) Type_(type_ string) V1APIPmarginCreateUmOrderV1Request {
	r.type_ = &type_
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) GoodTillDate(goodTillDate int64) V1APIPmarginCreateUmOrderV1Request {
	r.goodTillDate = &goodTillDate
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) NewClientOrderId(newClientOrderId string) V1APIPmarginCreateUmOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) NewOrderRespType(newOrderRespType string) V1APIPmarginCreateUmOrderV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) PositionSide(positionSide string) V1APIPmarginCreateUmOrderV1Request {
	r.positionSide = &positionSide
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) Price(price string) V1APIPmarginCreateUmOrderV1Request {
	r.price = &price
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) PriceMatch(priceMatch string) V1APIPmarginCreateUmOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) Quantity(quantity string) V1APIPmarginCreateUmOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateUmOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) ReduceOnly(reduceOnly string) V1APIPmarginCreateUmOrderV1Request {
	r.reduceOnly = &reduceOnly
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) SelfTradePreventionMode(selfTradePreventionMode string) V1APIPmarginCreateUmOrderV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) TimeInForce(timeInForce string) V1APIPmarginCreateUmOrderV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V1APIPmarginCreateUmOrderV1Request) Execute() (*PmarginCreateUmOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateUmOrderV1Execute(r)
}

/*
PmarginCreateUmOrderV1 New UM Order (TRADE)

Place new UM order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateUmOrderV1Request
*/
func (a *V1APIService) PmarginCreateUmOrderV1(ctx context.Context) V1APIPmarginCreateUmOrderV1Request {
	return V1APIPmarginCreateUmOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateUmOrderV1Resp
func (a *V1APIService) PmarginCreateUmOrderV1Execute(r V1APIPmarginCreateUmOrderV1Request) (*PmarginCreateUmOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateUmOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateUmOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.goodTillDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "goodTillDate", r.goodTillDate, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.reduceOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reduceOnly", r.reduceOnly, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginCreateUmPositionSideDualV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	dualSidePosition *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginCreateUmPositionSideDualV1Request) DualSidePosition(dualSidePosition string) V1APIPmarginCreateUmPositionSideDualV1Request {
	r.dualSidePosition = &dualSidePosition
	return r
}

func (r V1APIPmarginCreateUmPositionSideDualV1Request) Timestamp(timestamp int64) V1APIPmarginCreateUmPositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginCreateUmPositionSideDualV1Request) RecvWindow(recvWindow int64) V1APIPmarginCreateUmPositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginCreateUmPositionSideDualV1Request) Execute() (*PmarginCreateUmPositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateUmPositionSideDualV1Execute(r)
}

/*
PmarginCreateUmPositionSideDualV1 Change UM Position Mode(TRADE)

Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginCreateUmPositionSideDualV1Request
*/
func (a *V1APIService) PmarginCreateUmPositionSideDualV1(ctx context.Context) V1APIPmarginCreateUmPositionSideDualV1Request {
	return V1APIPmarginCreateUmPositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateUmPositionSideDualV1Resp
func (a *V1APIService) PmarginCreateUmPositionSideDualV1Execute(r V1APIPmarginCreateUmPositionSideDualV1Request) (*PmarginCreateUmPositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateUmPositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginCreateUmPositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dualSidePosition == nil {
		return localVarReturnValue, nil, reportError("dualSidePosition is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "dualSidePosition", r.dualSidePosition, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteCmAllOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginDeleteCmAllOpenOrdersV1Request) Symbol(symbol string) V1APIPmarginDeleteCmAllOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteCmAllOpenOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteCmAllOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginDeleteCmAllOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteCmAllOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteCmAllOpenOrdersV1Request) Execute() (*PmarginDeleteCmAllOpenOrdersV1Resp, *http.Response, error) {
	return r.ApiService.PmarginDeleteCmAllOpenOrdersV1Execute(r)
}

/*
PmarginDeleteCmAllOpenOrdersV1 Cancel All CM Open Orders(TRADE)

Cancel all active LIMIT orders on specific symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteCmAllOpenOrdersV1Request
*/
func (a *V1APIService) PmarginDeleteCmAllOpenOrdersV1(ctx context.Context) V1APIPmarginDeleteCmAllOpenOrdersV1Request {
	return V1APIPmarginDeleteCmAllOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginDeleteCmAllOpenOrdersV1Resp
func (a *V1APIService) PmarginDeleteCmAllOpenOrdersV1Execute(r V1APIPmarginDeleteCmAllOpenOrdersV1Request) (*PmarginDeleteCmAllOpenOrdersV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginDeleteCmAllOpenOrdersV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteCmAllOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/allOpenOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request) Symbol(symbol string) V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request) Execute() (*PmarginDeleteCmConditionalAllOpenOrdersV1Resp, *http.Response, error) {
	return r.ApiService.PmarginDeleteCmConditionalAllOpenOrdersV1Execute(r)
}

/*
PmarginDeleteCmConditionalAllOpenOrdersV1 Cancel All CM Open Conditional Orders(TRADE)

Cancel All CM Open Conditional Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request
*/
func (a *V1APIService) PmarginDeleteCmConditionalAllOpenOrdersV1(ctx context.Context) V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request {
	return V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginDeleteCmConditionalAllOpenOrdersV1Resp
func (a *V1APIService) PmarginDeleteCmConditionalAllOpenOrdersV1Execute(r V1APIPmarginDeleteCmConditionalAllOpenOrdersV1Request) (*PmarginDeleteCmConditionalAllOpenOrdersV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginDeleteCmConditionalAllOpenOrdersV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteCmConditionalAllOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/conditional/allOpenOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteCmConditionalOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	strategyId *int64
	newClientStrategyId *string
	recvWindow *int64
}

func (r V1APIPmarginDeleteCmConditionalOrderV1Request) Symbol(symbol string) V1APIPmarginDeleteCmConditionalOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteCmConditionalOrderV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteCmConditionalOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginDeleteCmConditionalOrderV1Request) StrategyId(strategyId int64) V1APIPmarginDeleteCmConditionalOrderV1Request {
	r.strategyId = &strategyId
	return r
}

func (r V1APIPmarginDeleteCmConditionalOrderV1Request) NewClientStrategyId(newClientStrategyId string) V1APIPmarginDeleteCmConditionalOrderV1Request {
	r.newClientStrategyId = &newClientStrategyId
	return r
}

func (r V1APIPmarginDeleteCmConditionalOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteCmConditionalOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteCmConditionalOrderV1Request) Execute() (*PmarginDeleteCmConditionalOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginDeleteCmConditionalOrderV1Execute(r)
}

/*
PmarginDeleteCmConditionalOrderV1 Cancel CM Conditional Order(TRADE)

Cancel CM Conditional Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteCmConditionalOrderV1Request
*/
func (a *V1APIService) PmarginDeleteCmConditionalOrderV1(ctx context.Context) V1APIPmarginDeleteCmConditionalOrderV1Request {
	return V1APIPmarginDeleteCmConditionalOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginDeleteCmConditionalOrderV1Resp
func (a *V1APIService) PmarginDeleteCmConditionalOrderV1Execute(r V1APIPmarginDeleteCmConditionalOrderV1Request) (*PmarginDeleteCmConditionalOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginDeleteCmConditionalOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteCmConditionalOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/conditional/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategyId", r.strategyId, "form", "")
	}
	if r.newClientStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientStrategyId", r.newClientStrategyId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientStrategyId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteCmOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIPmarginDeleteCmOrderV1Request) Symbol(symbol string) V1APIPmarginDeleteCmOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteCmOrderV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteCmOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginDeleteCmOrderV1Request) OrderId(orderId int64) V1APIPmarginDeleteCmOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginDeleteCmOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginDeleteCmOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIPmarginDeleteCmOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteCmOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteCmOrderV1Request) Execute() (*PmarginDeleteCmOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginDeleteCmOrderV1Execute(r)
}

/*
PmarginDeleteCmOrderV1 Cancel CM Order(TRADE)

Cancel an active LIMIT order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteCmOrderV1Request
*/
func (a *V1APIService) PmarginDeleteCmOrderV1(ctx context.Context) V1APIPmarginDeleteCmOrderV1Request {
	return V1APIPmarginDeleteCmOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginDeleteCmOrderV1Resp
func (a *V1APIService) PmarginDeleteCmOrderV1Execute(r V1APIPmarginDeleteCmOrderV1Request) (*PmarginDeleteCmOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginDeleteCmOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteCmOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteListenKeyV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIPmarginDeleteListenKeyV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PmarginDeleteListenKeyV1Execute(r)
}

/*
PmarginDeleteListenKeyV1 Close User Data Stream(USER_STREAM)

Close out a user data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteListenKeyV1Request
*/
func (a *V1APIService) PmarginDeleteListenKeyV1(ctx context.Context) V1APIPmarginDeleteListenKeyV1Request {
	return V1APIPmarginDeleteListenKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V1APIService) PmarginDeleteListenKeyV1Execute(r V1APIPmarginDeleteListenKeyV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteListenKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/listenKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteMarginAllOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginDeleteMarginAllOpenOrdersV1Request) Symbol(symbol string) V1APIPmarginDeleteMarginAllOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteMarginAllOpenOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteMarginAllOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginDeleteMarginAllOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteMarginAllOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteMarginAllOpenOrdersV1Request) Execute() ([]PmarginDeleteMarginAllOpenOrdersV1RespInner, *http.Response, error) {
	return r.ApiService.PmarginDeleteMarginAllOpenOrdersV1Execute(r)
}

/*
PmarginDeleteMarginAllOpenOrdersV1 Cancel Margin Account All Open Orders on a Symbol(TRADE)

Cancel Margin Account All Open Orders on a Symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteMarginAllOpenOrdersV1Request
*/
func (a *V1APIService) PmarginDeleteMarginAllOpenOrdersV1(ctx context.Context) V1APIPmarginDeleteMarginAllOpenOrdersV1Request {
	return V1APIPmarginDeleteMarginAllOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginDeleteMarginAllOpenOrdersV1RespInner
func (a *V1APIService) PmarginDeleteMarginAllOpenOrdersV1Execute(r V1APIPmarginDeleteMarginAllOpenOrdersV1Request) ([]PmarginDeleteMarginAllOpenOrdersV1RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginDeleteMarginAllOpenOrdersV1RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteMarginAllOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/allOpenOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteMarginOrderListV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderListId *int64
	listClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

func (r V1APIPmarginDeleteMarginOrderListV1Request) Symbol(symbol string) V1APIPmarginDeleteMarginOrderListV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteMarginOrderListV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteMarginOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r V1APIPmarginDeleteMarginOrderListV1Request) OrderListId(orderListId int64) V1APIPmarginDeleteMarginOrderListV1Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r V1APIPmarginDeleteMarginOrderListV1Request) ListClientOrderId(listClientOrderId string) V1APIPmarginDeleteMarginOrderListV1Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r V1APIPmarginDeleteMarginOrderListV1Request) NewClientOrderId(newClientOrderId string) V1APIPmarginDeleteMarginOrderListV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginDeleteMarginOrderListV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteMarginOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteMarginOrderListV1Request) Execute() (*PmarginDeleteMarginOrderListV1Resp, *http.Response, error) {
	return r.ApiService.PmarginDeleteMarginOrderListV1Execute(r)
}

/*
PmarginDeleteMarginOrderListV1 Cancel Margin Account OCO Orders(TRADE)

Cancel Margin Account OCO Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteMarginOrderListV1Request
*/
func (a *V1APIService) PmarginDeleteMarginOrderListV1(ctx context.Context) V1APIPmarginDeleteMarginOrderListV1Request {
	return V1APIPmarginDeleteMarginOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginDeleteMarginOrderListV1Resp
func (a *V1APIService) PmarginDeleteMarginOrderListV1Execute(r V1APIPmarginDeleteMarginOrderListV1Request) (*PmarginDeleteMarginOrderListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginDeleteMarginOrderListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteMarginOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listClientOrderId", r.listClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.listClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteMarginOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

func (r V1APIPmarginDeleteMarginOrderV1Request) Symbol(symbol string) V1APIPmarginDeleteMarginOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteMarginOrderV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteMarginOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginDeleteMarginOrderV1Request) OrderId(orderId int64) V1APIPmarginDeleteMarginOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginDeleteMarginOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginDeleteMarginOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default.
func (r V1APIPmarginDeleteMarginOrderV1Request) NewClientOrderId(newClientOrderId string) V1APIPmarginDeleteMarginOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V1APIPmarginDeleteMarginOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteMarginOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteMarginOrderV1Request) Execute() (*PmarginDeleteMarginOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginDeleteMarginOrderV1Execute(r)
}

/*
PmarginDeleteMarginOrderV1 Cancel Margin Account Order(TRADE)

Cancel Margin Account Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteMarginOrderV1Request
*/
func (a *V1APIService) PmarginDeleteMarginOrderV1(ctx context.Context) V1APIPmarginDeleteMarginOrderV1Request {
	return V1APIPmarginDeleteMarginOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginDeleteMarginOrderV1Resp
func (a *V1APIService) PmarginDeleteMarginOrderV1Execute(r V1APIPmarginDeleteMarginOrderV1Request) (*PmarginDeleteMarginOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginDeleteMarginOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteMarginOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteUmAllOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginDeleteUmAllOpenOrdersV1Request) Symbol(symbol string) V1APIPmarginDeleteUmAllOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteUmAllOpenOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteUmAllOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginDeleteUmAllOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteUmAllOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteUmAllOpenOrdersV1Request) Execute() (*PmarginDeleteUmAllOpenOrdersV1Resp, *http.Response, error) {
	return r.ApiService.PmarginDeleteUmAllOpenOrdersV1Execute(r)
}

/*
PmarginDeleteUmAllOpenOrdersV1 Cancel All UM Open Orders(TRADE)

Cancel all active LIMIT orders on specific symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteUmAllOpenOrdersV1Request
*/
func (a *V1APIService) PmarginDeleteUmAllOpenOrdersV1(ctx context.Context) V1APIPmarginDeleteUmAllOpenOrdersV1Request {
	return V1APIPmarginDeleteUmAllOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginDeleteUmAllOpenOrdersV1Resp
func (a *V1APIService) PmarginDeleteUmAllOpenOrdersV1Execute(r V1APIPmarginDeleteUmAllOpenOrdersV1Request) (*PmarginDeleteUmAllOpenOrdersV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginDeleteUmAllOpenOrdersV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteUmAllOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/allOpenOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request) Symbol(symbol string) V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request) Execute() (*PmarginDeleteUmConditionalAllOpenOrdersV1Resp, *http.Response, error) {
	return r.ApiService.PmarginDeleteUmConditionalAllOpenOrdersV1Execute(r)
}

/*
PmarginDeleteUmConditionalAllOpenOrdersV1 Cancel All UM Open Conditional Orders (TRADE)

Cancel All UM Open Conditional Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request
*/
func (a *V1APIService) PmarginDeleteUmConditionalAllOpenOrdersV1(ctx context.Context) V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request {
	return V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginDeleteUmConditionalAllOpenOrdersV1Resp
func (a *V1APIService) PmarginDeleteUmConditionalAllOpenOrdersV1Execute(r V1APIPmarginDeleteUmConditionalAllOpenOrdersV1Request) (*PmarginDeleteUmConditionalAllOpenOrdersV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginDeleteUmConditionalAllOpenOrdersV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteUmConditionalAllOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/conditional/allOpenOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteUmConditionalOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	strategyId *int64
	newClientStrategyId *string
	recvWindow *int64
}

func (r V1APIPmarginDeleteUmConditionalOrderV1Request) Symbol(symbol string) V1APIPmarginDeleteUmConditionalOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteUmConditionalOrderV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteUmConditionalOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginDeleteUmConditionalOrderV1Request) StrategyId(strategyId int64) V1APIPmarginDeleteUmConditionalOrderV1Request {
	r.strategyId = &strategyId
	return r
}

func (r V1APIPmarginDeleteUmConditionalOrderV1Request) NewClientStrategyId(newClientStrategyId string) V1APIPmarginDeleteUmConditionalOrderV1Request {
	r.newClientStrategyId = &newClientStrategyId
	return r
}

func (r V1APIPmarginDeleteUmConditionalOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteUmConditionalOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteUmConditionalOrderV1Request) Execute() (*PmarginDeleteUmConditionalOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginDeleteUmConditionalOrderV1Execute(r)
}

/*
PmarginDeleteUmConditionalOrderV1 Cancel UM Conditional Order(TRADE)

Cancel UM Conditional Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteUmConditionalOrderV1Request
*/
func (a *V1APIService) PmarginDeleteUmConditionalOrderV1(ctx context.Context) V1APIPmarginDeleteUmConditionalOrderV1Request {
	return V1APIPmarginDeleteUmConditionalOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginDeleteUmConditionalOrderV1Resp
func (a *V1APIService) PmarginDeleteUmConditionalOrderV1Execute(r V1APIPmarginDeleteUmConditionalOrderV1Request) (*PmarginDeleteUmConditionalOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginDeleteUmConditionalOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteUmConditionalOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/conditional/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategyId", r.strategyId, "form", "")
	}
	if r.newClientStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientStrategyId", r.newClientStrategyId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientStrategyId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginDeleteUmOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIPmarginDeleteUmOrderV1Request) Symbol(symbol string) V1APIPmarginDeleteUmOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginDeleteUmOrderV1Request) Timestamp(timestamp int64) V1APIPmarginDeleteUmOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginDeleteUmOrderV1Request) OrderId(orderId int64) V1APIPmarginDeleteUmOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginDeleteUmOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginDeleteUmOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIPmarginDeleteUmOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginDeleteUmOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginDeleteUmOrderV1Request) Execute() (*PmarginDeleteUmOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginDeleteUmOrderV1Execute(r)
}

/*
PmarginDeleteUmOrderV1 Cancel UM Order(TRADE)

Cancel an active UM LIMIT order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginDeleteUmOrderV1Request
*/
func (a *V1APIService) PmarginDeleteUmOrderV1(ctx context.Context) V1APIPmarginDeleteUmOrderV1Request {
	return V1APIPmarginDeleteUmOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginDeleteUmOrderV1Resp
func (a *V1APIService) PmarginDeleteUmOrderV1Execute(r V1APIPmarginDeleteUmOrderV1Request) (*PmarginDeleteUmOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginDeleteUmOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginDeleteUmOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetAccountV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetAccountV1Request) Timestamp(timestamp int64) V1APIPmarginGetAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetAccountV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetAccountV1Request) Execute() (*PmarginGetAccountV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetAccountV1Execute(r)
}

/*
PmarginGetAccountV1 Account Information(USER_DATA)

Query account information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetAccountV1Request
*/
func (a *V1APIService) PmarginGetAccountV1(ctx context.Context) V1APIPmarginGetAccountV1Request {
	return V1APIPmarginGetAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetAccountV1Resp
func (a *V1APIService) PmarginGetAccountV1Execute(r V1APIPmarginGetAccountV1Request) (*PmarginGetAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetBalanceV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	asset *string
	recvWindow *int64
}

func (r V1APIPmarginGetBalanceV1Request) Timestamp(timestamp int64) V1APIPmarginGetBalanceV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetBalanceV1Request) Asset(asset string) V1APIPmarginGetBalanceV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginGetBalanceV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetBalanceV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetBalanceV1Request) Execute() (*PmarginGetBalanceV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetBalanceV1Execute(r)
}

/*
PmarginGetBalanceV1 Account Balance(USER_DATA)

Query account balance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetBalanceV1Request
*/
func (a *V1APIService) PmarginGetBalanceV1(ctx context.Context) V1APIPmarginGetBalanceV1Request {
	return V1APIPmarginGetBalanceV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetBalanceV1Resp
func (a *V1APIService) PmarginGetBalanceV1Execute(r V1APIPmarginGetBalanceV1Request) (*PmarginGetBalanceV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetBalanceV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetBalanceV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmAccountV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetCmAccountV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmAccountV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmAccountV1Request) Execute() (*PmarginGetCmAccountV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetCmAccountV1Execute(r)
}

/*
PmarginGetCmAccountV1 Get CM Account Detail(USER_DATA)

Get current CM account asset and position information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmAccountV1Request
*/
func (a *V1APIService) PmarginGetCmAccountV1(ctx context.Context) V1APIPmarginGetCmAccountV1Request {
	return V1APIPmarginGetCmAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetCmAccountV1Resp
func (a *V1APIService) PmarginGetCmAccountV1Execute(r V1APIPmarginGetCmAccountV1Request) (*PmarginGetCmAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetCmAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmAdlQuantileV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIPmarginGetCmAdlQuantileV1Request) Execute() ([]PmarginGetCmAdlQuantileV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmAdlQuantileV1Execute(r)
}

/*
PmarginGetCmAdlQuantileV1 CM Position ADL Quantile Estimation(USER_DATA)

Query CM Position ADL Quantile Estimation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmAdlQuantileV1Request
*/
func (a *V1APIService) PmarginGetCmAdlQuantileV1(ctx context.Context) V1APIPmarginGetCmAdlQuantileV1Request {
	return V1APIPmarginGetCmAdlQuantileV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmAdlQuantileV1RespItem
func (a *V1APIService) PmarginGetCmAdlQuantileV1Execute(r V1APIPmarginGetCmAdlQuantileV1Request) ([]PmarginGetCmAdlQuantileV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmAdlQuantileV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmAdlQuantileV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/adlQuantile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmAllOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	pair *string
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetCmAllOrdersV1Request) Symbol(symbol string) V1APIPmarginGetCmAllOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmAllOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmAllOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmAllOrdersV1Request) Pair(pair string) V1APIPmarginGetCmAllOrdersV1Request {
	r.pair = &pair
	return r
}

func (r V1APIPmarginGetCmAllOrdersV1Request) OrderId(orderId int64) V1APIPmarginGetCmAllOrdersV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetCmAllOrdersV1Request) StartTime(startTime int64) V1APIPmarginGetCmAllOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetCmAllOrdersV1Request) EndTime(endTime int64) V1APIPmarginGetCmAllOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 50; max 100.
func (r V1APIPmarginGetCmAllOrdersV1Request) Limit(limit int32) V1APIPmarginGetCmAllOrdersV1Request {
	r.limit = &limit
	return r
}

func (r V1APIPmarginGetCmAllOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmAllOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmAllOrdersV1Request) Execute() ([]PmarginGetCmAllOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmAllOrdersV1Execute(r)
}

/*
PmarginGetCmAllOrdersV1 Query All CM Orders (USER_DATA)

Get all account CM orders; active, canceled, or filled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmAllOrdersV1Request
*/
func (a *V1APIService) PmarginGetCmAllOrdersV1(ctx context.Context) V1APIPmarginGetCmAllOrdersV1Request {
	return V1APIPmarginGetCmAllOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmAllOrdersV1RespItem
func (a *V1APIService) PmarginGetCmAllOrdersV1Execute(r V1APIPmarginGetCmAllOrdersV1Request) ([]PmarginGetCmAllOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmAllOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmAllOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	} else {
		var defaultValue string = ""
		r.pair = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmCommissionRateV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetCmCommissionRateV1Request) Symbol(symbol string) V1APIPmarginGetCmCommissionRateV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmCommissionRateV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmCommissionRateV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmCommissionRateV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmCommissionRateV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmCommissionRateV1Request) Execute() (*PmarginGetCmCommissionRateV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetCmCommissionRateV1Execute(r)
}

/*
PmarginGetCmCommissionRateV1 Get User Commission Rate for CM(USER_DATA)

Get User Commission Rate for CM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmCommissionRateV1Request
*/
func (a *V1APIService) PmarginGetCmCommissionRateV1(ctx context.Context) V1APIPmarginGetCmCommissionRateV1Request {
	return V1APIPmarginGetCmCommissionRateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetCmCommissionRateV1Resp
func (a *V1APIService) PmarginGetCmCommissionRateV1Execute(r V1APIPmarginGetCmCommissionRateV1Request) (*PmarginGetCmCommissionRateV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetCmCommissionRateV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmCommissionRateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/commissionRate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmConditionalAllOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	strategyId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetCmConditionalAllOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmConditionalAllOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmConditionalAllOrdersV1Request) Symbol(symbol string) V1APIPmarginGetCmConditionalAllOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmConditionalAllOrdersV1Request) StrategyId(strategyId int64) V1APIPmarginGetCmConditionalAllOrdersV1Request {
	r.strategyId = &strategyId
	return r
}

func (r V1APIPmarginGetCmConditionalAllOrdersV1Request) StartTime(startTime int64) V1APIPmarginGetCmConditionalAllOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetCmConditionalAllOrdersV1Request) EndTime(endTime int64) V1APIPmarginGetCmConditionalAllOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r V1APIPmarginGetCmConditionalAllOrdersV1Request) Limit(limit int32) V1APIPmarginGetCmConditionalAllOrdersV1Request {
	r.limit = &limit
	return r
}

func (r V1APIPmarginGetCmConditionalAllOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmConditionalAllOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmConditionalAllOrdersV1Request) Execute() ([]PmarginGetCmConditionalAllOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmConditionalAllOrdersV1Execute(r)
}

/*
PmarginGetCmConditionalAllOrdersV1 Query All CM Conditional Orders(USER_DATA)

Query All CM Conditional Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmConditionalAllOrdersV1Request
*/
func (a *V1APIService) PmarginGetCmConditionalAllOrdersV1(ctx context.Context) V1APIPmarginGetCmConditionalAllOrdersV1Request {
	return V1APIPmarginGetCmConditionalAllOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmConditionalAllOrdersV1RespItem
func (a *V1APIService) PmarginGetCmConditionalAllOrdersV1Execute(r V1APIPmarginGetCmConditionalAllOrdersV1Request) ([]PmarginGetCmConditionalAllOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmConditionalAllOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmConditionalAllOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/conditional/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategyId", r.strategyId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmConditionalOpenOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	strategyId *int64
	newClientStrategyId *string
	recvWindow *int64
}

func (r V1APIPmarginGetCmConditionalOpenOrderV1Request) Symbol(symbol string) V1APIPmarginGetCmConditionalOpenOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmConditionalOpenOrderV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmConditionalOpenOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmConditionalOpenOrderV1Request) StrategyId(strategyId int64) V1APIPmarginGetCmConditionalOpenOrderV1Request {
	r.strategyId = &strategyId
	return r
}

func (r V1APIPmarginGetCmConditionalOpenOrderV1Request) NewClientStrategyId(newClientStrategyId string) V1APIPmarginGetCmConditionalOpenOrderV1Request {
	r.newClientStrategyId = &newClientStrategyId
	return r
}

func (r V1APIPmarginGetCmConditionalOpenOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmConditionalOpenOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmConditionalOpenOrderV1Request) Execute() (*PmarginGetCmConditionalOpenOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetCmConditionalOpenOrderV1Execute(r)
}

/*
PmarginGetCmConditionalOpenOrderV1 Query Current CM Open Conditional Order(USER_DATA)

Query Current CM Open Conditional Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmConditionalOpenOrderV1Request
*/
func (a *V1APIService) PmarginGetCmConditionalOpenOrderV1(ctx context.Context) V1APIPmarginGetCmConditionalOpenOrderV1Request {
	return V1APIPmarginGetCmConditionalOpenOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetCmConditionalOpenOrderV1Resp
func (a *V1APIService) PmarginGetCmConditionalOpenOrderV1Execute(r V1APIPmarginGetCmConditionalOpenOrderV1Request) (*PmarginGetCmConditionalOpenOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetCmConditionalOpenOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmConditionalOpenOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/conditional/openOrder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategyId", r.strategyId, "form", "")
	}
	if r.newClientStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientStrategyId", r.newClientStrategyId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientStrategyId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmConditionalOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIPmarginGetCmConditionalOpenOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmConditionalOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmConditionalOpenOrdersV1Request) Symbol(symbol string) V1APIPmarginGetCmConditionalOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmConditionalOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmConditionalOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmConditionalOpenOrdersV1Request) Execute() ([]PmarginGetCmConditionalOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmConditionalOpenOrdersV1Execute(r)
}

/*
PmarginGetCmConditionalOpenOrdersV1 Query All Current CM Open Conditional Orders (USER_DATA)

Get all open conditional orders on a symbol. Careful when accessing this with no symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmConditionalOpenOrdersV1Request
*/
func (a *V1APIService) PmarginGetCmConditionalOpenOrdersV1(ctx context.Context) V1APIPmarginGetCmConditionalOpenOrdersV1Request {
	return V1APIPmarginGetCmConditionalOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmConditionalOpenOrdersV1RespItem
func (a *V1APIService) PmarginGetCmConditionalOpenOrdersV1Execute(r V1APIPmarginGetCmConditionalOpenOrdersV1Request) ([]PmarginGetCmConditionalOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmConditionalOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmConditionalOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/conditional/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmConditionalOrderHistoryV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	strategyId *int64
	newClientStrategyId *string
	recvWindow *int64
}

func (r V1APIPmarginGetCmConditionalOrderHistoryV1Request) Symbol(symbol string) V1APIPmarginGetCmConditionalOrderHistoryV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmConditionalOrderHistoryV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmConditionalOrderHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmConditionalOrderHistoryV1Request) StrategyId(strategyId int64) V1APIPmarginGetCmConditionalOrderHistoryV1Request {
	r.strategyId = &strategyId
	return r
}

func (r V1APIPmarginGetCmConditionalOrderHistoryV1Request) NewClientStrategyId(newClientStrategyId string) V1APIPmarginGetCmConditionalOrderHistoryV1Request {
	r.newClientStrategyId = &newClientStrategyId
	return r
}

func (r V1APIPmarginGetCmConditionalOrderHistoryV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmConditionalOrderHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmConditionalOrderHistoryV1Request) Execute() (*PmarginGetCmConditionalOrderHistoryV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetCmConditionalOrderHistoryV1Execute(r)
}

/*
PmarginGetCmConditionalOrderHistoryV1 Query CM Conditional Order History(USER_DATA)

Query CM Conditional Order History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmConditionalOrderHistoryV1Request
*/
func (a *V1APIService) PmarginGetCmConditionalOrderHistoryV1(ctx context.Context) V1APIPmarginGetCmConditionalOrderHistoryV1Request {
	return V1APIPmarginGetCmConditionalOrderHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetCmConditionalOrderHistoryV1Resp
func (a *V1APIService) PmarginGetCmConditionalOrderHistoryV1Execute(r V1APIPmarginGetCmConditionalOrderHistoryV1Request) (*PmarginGetCmConditionalOrderHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetCmConditionalOrderHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmConditionalOrderHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/conditional/orderHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategyId", r.strategyId, "form", "")
	}
	if r.newClientStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientStrategyId", r.newClientStrategyId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientStrategyId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmForceOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	autoCloseType *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetCmForceOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmForceOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmForceOrdersV1Request) Symbol(symbol string) V1APIPmarginGetCmForceOrdersV1Request {
	r.symbol = &symbol
	return r
}

// &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
func (r V1APIPmarginGetCmForceOrdersV1Request) AutoCloseType(autoCloseType string) V1APIPmarginGetCmForceOrdersV1Request {
	r.autoCloseType = &autoCloseType
	return r
}

func (r V1APIPmarginGetCmForceOrdersV1Request) StartTime(startTime int64) V1APIPmarginGetCmForceOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetCmForceOrdersV1Request) EndTime(endTime int64) V1APIPmarginGetCmForceOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 50; max 100.
func (r V1APIPmarginGetCmForceOrdersV1Request) Limit(limit int32) V1APIPmarginGetCmForceOrdersV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetCmForceOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmForceOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmForceOrdersV1Request) Execute() ([]PmarginGetCmForceOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmForceOrdersV1Execute(r)
}

/*
PmarginGetCmForceOrdersV1 Query User's CM Force Orders(USER_DATA)

Query User's CM Force Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmForceOrdersV1Request
*/
func (a *V1APIService) PmarginGetCmForceOrdersV1(ctx context.Context) V1APIPmarginGetCmForceOrdersV1Request {
	return V1APIPmarginGetCmForceOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmForceOrdersV1RespItem
func (a *V1APIService) PmarginGetCmForceOrdersV1Execute(r V1APIPmarginGetCmForceOrdersV1Request) ([]PmarginGetCmForceOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmForceOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmForceOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/forceOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.autoCloseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCloseType", r.autoCloseType, "form", "")
	} else {
		var defaultValue string = ""
		r.autoCloseType = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmIncomeV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	incomeType *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetCmIncomeV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmIncomeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmIncomeV1Request) Symbol(symbol string) V1APIPmarginGetCmIncomeV1Request {
	r.symbol = &symbol
	return r
}

// &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
func (r V1APIPmarginGetCmIncomeV1Request) IncomeType(incomeType string) V1APIPmarginGetCmIncomeV1Request {
	r.incomeType = &incomeType
	return r
}

// Timestamp in ms to get funding from INCLUSIVE.
func (r V1APIPmarginGetCmIncomeV1Request) StartTime(startTime int64) V1APIPmarginGetCmIncomeV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get funding until INCLUSIVE.
func (r V1APIPmarginGetCmIncomeV1Request) EndTime(endTime int64) V1APIPmarginGetCmIncomeV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APIPmarginGetCmIncomeV1Request) Page(page int32) V1APIPmarginGetCmIncomeV1Request {
	r.page = &page
	return r
}

// Default 100; max 1000
func (r V1APIPmarginGetCmIncomeV1Request) Limit(limit int32) V1APIPmarginGetCmIncomeV1Request {
	r.limit = &limit
	return r
}

func (r V1APIPmarginGetCmIncomeV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmIncomeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmIncomeV1Request) Execute() ([]PmarginGetCmIncomeV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmIncomeV1Execute(r)
}

/*
PmarginGetCmIncomeV1 Get CM Income History(USER_DATA)

Get CM Income History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmIncomeV1Request
*/
func (a *V1APIService) PmarginGetCmIncomeV1(ctx context.Context) V1APIPmarginGetCmIncomeV1Request {
	return V1APIPmarginGetCmIncomeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmIncomeV1RespItem
func (a *V1APIService) PmarginGetCmIncomeV1Execute(r V1APIPmarginGetCmIncomeV1Request) ([]PmarginGetCmIncomeV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmIncomeV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmIncomeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/income"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.incomeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incomeType", r.incomeType, "form", "")
	} else {
		var defaultValue string = ""
		r.incomeType = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmLeverageBracketV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIPmarginGetCmLeverageBracketV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmLeverageBracketV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmLeverageBracketV1Request) Symbol(symbol string) V1APIPmarginGetCmLeverageBracketV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmLeverageBracketV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmLeverageBracketV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmLeverageBracketV1Request) Execute() ([]PmarginGetCmLeverageBracketV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmLeverageBracketV1Execute(r)
}

/*
PmarginGetCmLeverageBracketV1 CM Notional and Leverage Brackets(USER_DATA)

Query CM notional and leverage brackets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmLeverageBracketV1Request
*/
func (a *V1APIService) PmarginGetCmLeverageBracketV1(ctx context.Context) V1APIPmarginGetCmLeverageBracketV1Request {
	return V1APIPmarginGetCmLeverageBracketV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmLeverageBracketV1RespItem
func (a *V1APIService) PmarginGetCmLeverageBracketV1Execute(r V1APIPmarginGetCmLeverageBracketV1Request) ([]PmarginGetCmLeverageBracketV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmLeverageBracketV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmLeverageBracketV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/leverageBracket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmOpenOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIPmarginGetCmOpenOrderV1Request) Symbol(symbol string) V1APIPmarginGetCmOpenOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmOpenOrderV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmOpenOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmOpenOrderV1Request) OrderId(orderId int64) V1APIPmarginGetCmOpenOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetCmOpenOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginGetCmOpenOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIPmarginGetCmOpenOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmOpenOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmOpenOrderV1Request) Execute() (*PmarginGetCmOpenOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetCmOpenOrderV1Execute(r)
}

/*
PmarginGetCmOpenOrderV1 Query Current CM Open Order (USER_DATA)

Query current CM open order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmOpenOrderV1Request
*/
func (a *V1APIService) PmarginGetCmOpenOrderV1(ctx context.Context) V1APIPmarginGetCmOpenOrderV1Request {
	return V1APIPmarginGetCmOpenOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetCmOpenOrderV1Resp
func (a *V1APIService) PmarginGetCmOpenOrderV1Execute(r V1APIPmarginGetCmOpenOrderV1Request) (*PmarginGetCmOpenOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetCmOpenOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmOpenOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/openOrder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	pair *string
	recvWindow *int64
}

func (r V1APIPmarginGetCmOpenOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmOpenOrdersV1Request) Symbol(symbol string) V1APIPmarginGetCmOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmOpenOrdersV1Request) Pair(pair string) V1APIPmarginGetCmOpenOrdersV1Request {
	r.pair = &pair
	return r
}

func (r V1APIPmarginGetCmOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmOpenOrdersV1Request) Execute() ([]PmarginGetCmOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmOpenOrdersV1Execute(r)
}

/*
PmarginGetCmOpenOrdersV1 Query All Current CM Open Orders(USER_DATA)

Get all open orders on a symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmOpenOrdersV1Request
*/
func (a *V1APIService) PmarginGetCmOpenOrdersV1(ctx context.Context) V1APIPmarginGetCmOpenOrdersV1Request {
	return V1APIPmarginGetCmOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmOpenOrdersV1RespItem
func (a *V1APIService) PmarginGetCmOpenOrdersV1Execute(r V1APIPmarginGetCmOpenOrdersV1Request) ([]PmarginGetCmOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	} else {
		var defaultValue string = ""
		r.pair = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmOrderAmendmentV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetCmOrderAmendmentV1Request) Symbol(symbol string) V1APIPmarginGetCmOrderAmendmentV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmOrderAmendmentV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmOrderAmendmentV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmOrderAmendmentV1Request) OrderId(orderId int64) V1APIPmarginGetCmOrderAmendmentV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetCmOrderAmendmentV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginGetCmOrderAmendmentV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Timestamp in ms to get modification history from INCLUSIVE
func (r V1APIPmarginGetCmOrderAmendmentV1Request) StartTime(startTime int64) V1APIPmarginGetCmOrderAmendmentV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get modification history until INCLUSIVE
func (r V1APIPmarginGetCmOrderAmendmentV1Request) EndTime(endTime int64) V1APIPmarginGetCmOrderAmendmentV1Request {
	r.endTime = &endTime
	return r
}

// Default 50, max 100
func (r V1APIPmarginGetCmOrderAmendmentV1Request) Limit(limit int32) V1APIPmarginGetCmOrderAmendmentV1Request {
	r.limit = &limit
	return r
}

func (r V1APIPmarginGetCmOrderAmendmentV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmOrderAmendmentV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmOrderAmendmentV1Request) Execute() ([]PmarginGetCmOrderAmendmentV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmOrderAmendmentV1Execute(r)
}

/*
PmarginGetCmOrderAmendmentV1 Query CM Modify Order History(TRADE)

Get order modification history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmOrderAmendmentV1Request
*/
func (a *V1APIService) PmarginGetCmOrderAmendmentV1(ctx context.Context) V1APIPmarginGetCmOrderAmendmentV1Request {
	return V1APIPmarginGetCmOrderAmendmentV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmOrderAmendmentV1RespItem
func (a *V1APIService) PmarginGetCmOrderAmendmentV1Execute(r V1APIPmarginGetCmOrderAmendmentV1Request) ([]PmarginGetCmOrderAmendmentV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmOrderAmendmentV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmOrderAmendmentV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/orderAmendment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIPmarginGetCmOrderV1Request) Symbol(symbol string) V1APIPmarginGetCmOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmOrderV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmOrderV1Request) OrderId(orderId int64) V1APIPmarginGetCmOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetCmOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginGetCmOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIPmarginGetCmOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmOrderV1Request) Execute() (*PmarginGetCmOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetCmOrderV1Execute(r)
}

/*
PmarginGetCmOrderV1 Query CM Order(USER_DATA)

Check an CM order's status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmOrderV1Request
*/
func (a *V1APIService) PmarginGetCmOrderV1(ctx context.Context) V1APIPmarginGetCmOrderV1Request {
	return V1APIPmarginGetCmOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetCmOrderV1Resp
func (a *V1APIService) PmarginGetCmOrderV1Execute(r V1APIPmarginGetCmOrderV1Request) (*PmarginGetCmOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetCmOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmPositionRiskV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	marginAsset *string
	pair *string
	recvWindow *int64
}

func (r V1APIPmarginGetCmPositionRiskV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmPositionRiskV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmPositionRiskV1Request) MarginAsset(marginAsset string) V1APIPmarginGetCmPositionRiskV1Request {
	r.marginAsset = &marginAsset
	return r
}

func (r V1APIPmarginGetCmPositionRiskV1Request) Pair(pair string) V1APIPmarginGetCmPositionRiskV1Request {
	r.pair = &pair
	return r
}

func (r V1APIPmarginGetCmPositionRiskV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmPositionRiskV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmPositionRiskV1Request) Execute() ([]PmarginGetCmPositionRiskV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmPositionRiskV1Execute(r)
}

/*
PmarginGetCmPositionRiskV1 Query CM Position Information(USER_DATA)

Get current CM position information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmPositionRiskV1Request
*/
func (a *V1APIService) PmarginGetCmPositionRiskV1(ctx context.Context) V1APIPmarginGetCmPositionRiskV1Request {
	return V1APIPmarginGetCmPositionRiskV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmPositionRiskV1RespItem
func (a *V1APIService) PmarginGetCmPositionRiskV1Execute(r V1APIPmarginGetCmPositionRiskV1Request) ([]PmarginGetCmPositionRiskV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmPositionRiskV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmPositionRiskV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.marginAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marginAsset", r.marginAsset, "form", "")
	} else {
		var defaultValue string = ""
		r.marginAsset = &defaultValue
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	} else {
		var defaultValue string = ""
		r.pair = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmPositionSideDualV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetCmPositionSideDualV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmPositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmPositionSideDualV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmPositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmPositionSideDualV1Request) Execute() (*PmarginGetCmPositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetCmPositionSideDualV1Execute(r)
}

/*
PmarginGetCmPositionSideDualV1 Get CM Current Position Mode(USER_DATA)

Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmPositionSideDualV1Request
*/
func (a *V1APIService) PmarginGetCmPositionSideDualV1(ctx context.Context) V1APIPmarginGetCmPositionSideDualV1Request {
	return V1APIPmarginGetCmPositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetCmPositionSideDualV1Resp
func (a *V1APIService) PmarginGetCmPositionSideDualV1Execute(r V1APIPmarginGetCmPositionSideDualV1Request) (*PmarginGetCmPositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetCmPositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmPositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetCmUserTradesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	pair *string
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetCmUserTradesV1Request) Timestamp(timestamp int64) V1APIPmarginGetCmUserTradesV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetCmUserTradesV1Request) Symbol(symbol string) V1APIPmarginGetCmUserTradesV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetCmUserTradesV1Request) Pair(pair string) V1APIPmarginGetCmUserTradesV1Request {
	r.pair = &pair
	return r
}

func (r V1APIPmarginGetCmUserTradesV1Request) StartTime(startTime int64) V1APIPmarginGetCmUserTradesV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetCmUserTradesV1Request) EndTime(endTime int64) V1APIPmarginGetCmUserTradesV1Request {
	r.endTime = &endTime
	return r
}

// Trade id to fetch from. Default gets most recent trades.
func (r V1APIPmarginGetCmUserTradesV1Request) FromId(fromId int64) V1APIPmarginGetCmUserTradesV1Request {
	r.fromId = &fromId
	return r
}

// Default 50; max 1000.
func (r V1APIPmarginGetCmUserTradesV1Request) Limit(limit int32) V1APIPmarginGetCmUserTradesV1Request {
	r.limit = &limit
	return r
}

func (r V1APIPmarginGetCmUserTradesV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetCmUserTradesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetCmUserTradesV1Request) Execute() ([]PmarginGetCmUserTradesV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmUserTradesV1Execute(r)
}

/*
PmarginGetCmUserTradesV1 CM Account Trade List(USER_DATA)

Get trades for a specific account and CM symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetCmUserTradesV1Request
*/
func (a *V1APIService) PmarginGetCmUserTradesV1(ctx context.Context) V1APIPmarginGetCmUserTradesV1Request {
	return V1APIPmarginGetCmUserTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmUserTradesV1RespItem
func (a *V1APIService) PmarginGetCmUserTradesV1Execute(r V1APIPmarginGetCmUserTradesV1Request) ([]PmarginGetCmUserTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmUserTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetCmUserTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/userTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	} else {
		var defaultValue string = ""
		r.pair = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginAllOrderListV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetMarginAllOrderListV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginAllOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// If supplied, neither startTime or endTime can be provided
func (r V1APIPmarginGetMarginAllOrderListV1Request) FromId(fromId int64) V1APIPmarginGetMarginAllOrderListV1Request {
	r.fromId = &fromId
	return r
}

func (r V1APIPmarginGetMarginAllOrderListV1Request) StartTime(startTime int64) V1APIPmarginGetMarginAllOrderListV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetMarginAllOrderListV1Request) EndTime(endTime int64) V1APIPmarginGetMarginAllOrderListV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 500.
func (r V1APIPmarginGetMarginAllOrderListV1Request) Limit(limit int32) V1APIPmarginGetMarginAllOrderListV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetMarginAllOrderListV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginAllOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginAllOrderListV1Request) Execute() ([]PmarginGetMarginAllOrderListV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetMarginAllOrderListV1Execute(r)
}

/*
PmarginGetMarginAllOrderListV1 Query Margin Account's all OCO (USER_DATA)

Query all OCO for a specific margin account based on provided optional parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginAllOrderListV1Request
*/
func (a *V1APIService) PmarginGetMarginAllOrderListV1(ctx context.Context) V1APIPmarginGetMarginAllOrderListV1Request {
	return V1APIPmarginGetMarginAllOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetMarginAllOrderListV1RespItem
func (a *V1APIService) PmarginGetMarginAllOrderListV1Execute(r V1APIPmarginGetMarginAllOrderListV1Request) ([]PmarginGetMarginAllOrderListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetMarginAllOrderListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginAllOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginAllOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetMarginAllOrdersV1Request) Symbol(symbol string) V1APIPmarginGetMarginAllOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetMarginAllOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginAllOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetMarginAllOrdersV1Request) OrderId(orderId int64) V1APIPmarginGetMarginAllOrdersV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetMarginAllOrdersV1Request) StartTime(startTime int64) V1APIPmarginGetMarginAllOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetMarginAllOrdersV1Request) EndTime(endTime int64) V1APIPmarginGetMarginAllOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 500.
func (r V1APIPmarginGetMarginAllOrdersV1Request) Limit(limit int32) V1APIPmarginGetMarginAllOrdersV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetMarginAllOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginAllOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginAllOrdersV1Request) Execute() ([]PmarginGetMarginAllOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetMarginAllOrdersV1Execute(r)
}

/*
PmarginGetMarginAllOrdersV1 Query All Margin Account Orders (USER_DATA)

Query All Margin Account Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginAllOrdersV1Request
*/
func (a *V1APIService) PmarginGetMarginAllOrdersV1(ctx context.Context) V1APIPmarginGetMarginAllOrdersV1Request {
	return V1APIPmarginGetMarginAllOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetMarginAllOrdersV1RespItem
func (a *V1APIService) PmarginGetMarginAllOrdersV1Execute(r V1APIPmarginGetMarginAllOrdersV1Request) ([]PmarginGetMarginAllOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetMarginAllOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginAllOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginForceOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	recvWindow *int64
}

func (r V1APIPmarginGetMarginForceOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginForceOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetMarginForceOrdersV1Request) StartTime(startTime int64) V1APIPmarginGetMarginForceOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetMarginForceOrdersV1Request) EndTime(endTime int64) V1APIPmarginGetMarginForceOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r V1APIPmarginGetMarginForceOrdersV1Request) Current(current int64) V1APIPmarginGetMarginForceOrdersV1Request {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r V1APIPmarginGetMarginForceOrdersV1Request) Size(size int64) V1APIPmarginGetMarginForceOrdersV1Request {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetMarginForceOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginForceOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginForceOrdersV1Request) Execute() (*PmarginGetMarginForceOrdersV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginForceOrdersV1Execute(r)
}

/*
PmarginGetMarginForceOrdersV1 Query User's Margin Force Orders(USER_DATA)

Query user's margin force orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginForceOrdersV1Request
*/
func (a *V1APIService) PmarginGetMarginForceOrdersV1(ctx context.Context) V1APIPmarginGetMarginForceOrdersV1Request {
	return V1APIPmarginGetMarginForceOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginForceOrdersV1Resp
func (a *V1APIService) PmarginGetMarginForceOrdersV1Execute(r V1APIPmarginGetMarginForceOrdersV1Request) (*PmarginGetMarginForceOrdersV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginForceOrdersV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginForceOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/forceOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginMarginInterestHistoryV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	asset *string
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	archived *string
	recvWindow *int64
}

func (r V1APIPmarginGetMarginMarginInterestHistoryV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginMarginInterestHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetMarginMarginInterestHistoryV1Request) Asset(asset string) V1APIPmarginGetMarginMarginInterestHistoryV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginGetMarginMarginInterestHistoryV1Request) StartTime(startTime int64) V1APIPmarginGetMarginMarginInterestHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetMarginMarginInterestHistoryV1Request) EndTime(endTime int64) V1APIPmarginGetMarginMarginInterestHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r V1APIPmarginGetMarginMarginInterestHistoryV1Request) Current(current int64) V1APIPmarginGetMarginMarginInterestHistoryV1Request {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r V1APIPmarginGetMarginMarginInterestHistoryV1Request) Size(size int64) V1APIPmarginGetMarginMarginInterestHistoryV1Request {
	r.size = &size
	return r
}

// Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
func (r V1APIPmarginGetMarginMarginInterestHistoryV1Request) Archived(archived string) V1APIPmarginGetMarginMarginInterestHistoryV1Request {
	r.archived = &archived
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V1APIPmarginGetMarginMarginInterestHistoryV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginMarginInterestHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginMarginInterestHistoryV1Request) Execute() (*PmarginGetMarginMarginInterestHistoryV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginMarginInterestHistoryV1Execute(r)
}

/*
PmarginGetMarginMarginInterestHistoryV1 Get Margin Borrow/Loan Interest History(USER_DATA)

Get Margin Borrow/Loan Interest History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginMarginInterestHistoryV1Request
*/
func (a *V1APIService) PmarginGetMarginMarginInterestHistoryV1(ctx context.Context) V1APIPmarginGetMarginMarginInterestHistoryV1Request {
	return V1APIPmarginGetMarginMarginInterestHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginMarginInterestHistoryV1Resp
func (a *V1APIService) PmarginGetMarginMarginInterestHistoryV1Execute(r V1APIPmarginGetMarginMarginInterestHistoryV1Request) (*PmarginGetMarginMarginInterestHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginMarginInterestHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginMarginInterestHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/marginInterestHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	} else {
		var defaultValue string = "false"
		r.archived = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginMarginLoanV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	asset *string
	timestamp *int64
	txId *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	archived *string
	recvWindow *int64
}

func (r V1APIPmarginGetMarginMarginLoanV1Request) Asset(asset string) V1APIPmarginGetMarginMarginLoanV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginGetMarginMarginLoanV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginMarginLoanV1Request {
	r.timestamp = &timestamp
	return r
}

// the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60;
func (r V1APIPmarginGetMarginMarginLoanV1Request) TxId(txId int64) V1APIPmarginGetMarginMarginLoanV1Request {
	r.txId = &txId
	return r
}

func (r V1APIPmarginGetMarginMarginLoanV1Request) StartTime(startTime int64) V1APIPmarginGetMarginMarginLoanV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetMarginMarginLoanV1Request) EndTime(endTime int64) V1APIPmarginGetMarginMarginLoanV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r V1APIPmarginGetMarginMarginLoanV1Request) Current(current int64) V1APIPmarginGetMarginMarginLoanV1Request {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r V1APIPmarginGetMarginMarginLoanV1Request) Size(size int64) V1APIPmarginGetMarginMarginLoanV1Request {
	r.size = &size
	return r
}

// Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
func (r V1APIPmarginGetMarginMarginLoanV1Request) Archived(archived string) V1APIPmarginGetMarginMarginLoanV1Request {
	r.archived = &archived
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetMarginMarginLoanV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginMarginLoanV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginMarginLoanV1Request) Execute() (*PmarginGetMarginMarginLoanV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginMarginLoanV1Execute(r)
}

/*
PmarginGetMarginMarginLoanV1 Query Margin Loan Record(USER_DATA)

Query margin loan record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginMarginLoanV1Request
*/
func (a *V1APIService) PmarginGetMarginMarginLoanV1(ctx context.Context) V1APIPmarginGetMarginMarginLoanV1Request {
	return V1APIPmarginGetMarginMarginLoanV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginMarginLoanV1Resp
func (a *V1APIService) PmarginGetMarginMarginLoanV1Execute(r V1APIPmarginGetMarginMarginLoanV1Request) (*PmarginGetMarginMarginLoanV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginMarginLoanV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginMarginLoanV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/marginLoan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	} else {
		var defaultValue string = "false"
		r.archived = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginMaxBorrowableV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetMarginMaxBorrowableV1Request) Asset(asset string) V1APIPmarginGetMarginMaxBorrowableV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginGetMarginMaxBorrowableV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginMaxBorrowableV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V1APIPmarginGetMarginMaxBorrowableV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginMaxBorrowableV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginMaxBorrowableV1Request) Execute() (*PmarginGetMarginMaxBorrowableV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginMaxBorrowableV1Execute(r)
}

/*
PmarginGetMarginMaxBorrowableV1 Margin Max Borrow(USER_DATA)

Query margin max borrow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginMaxBorrowableV1Request
*/
func (a *V1APIService) PmarginGetMarginMaxBorrowableV1(ctx context.Context) V1APIPmarginGetMarginMaxBorrowableV1Request {
	return V1APIPmarginGetMarginMaxBorrowableV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginMaxBorrowableV1Resp
func (a *V1APIService) PmarginGetMarginMaxBorrowableV1Execute(r V1APIPmarginGetMarginMaxBorrowableV1Request) (*PmarginGetMarginMaxBorrowableV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginMaxBorrowableV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginMaxBorrowableV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/maxBorrowable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginMaxWithdrawV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetMarginMaxWithdrawV1Request) Asset(asset string) V1APIPmarginGetMarginMaxWithdrawV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginGetMarginMaxWithdrawV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginMaxWithdrawV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V1APIPmarginGetMarginMaxWithdrawV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginMaxWithdrawV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginMaxWithdrawV1Request) Execute() (*PmarginGetMarginMaxWithdrawV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginMaxWithdrawV1Execute(r)
}

/*
PmarginGetMarginMaxWithdrawV1 Query Margin Max Withdraw(USER_DATA)

Query Margin Max Withdraw

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginMaxWithdrawV1Request
*/
func (a *V1APIService) PmarginGetMarginMaxWithdrawV1(ctx context.Context) V1APIPmarginGetMarginMaxWithdrawV1Request {
	return V1APIPmarginGetMarginMaxWithdrawV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginMaxWithdrawV1Resp
func (a *V1APIService) PmarginGetMarginMaxWithdrawV1Execute(r V1APIPmarginGetMarginMaxWithdrawV1Request) (*PmarginGetMarginMaxWithdrawV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginMaxWithdrawV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginMaxWithdrawV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/maxWithdraw"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginMyTradesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetMarginMyTradesV1Request) Symbol(symbol string) V1APIPmarginGetMarginMyTradesV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetMarginMyTradesV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginMyTradesV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetMarginMyTradesV1Request) OrderId(orderId int64) V1APIPmarginGetMarginMyTradesV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetMarginMyTradesV1Request) StartTime(startTime int64) V1APIPmarginGetMarginMyTradesV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetMarginMyTradesV1Request) EndTime(endTime int64) V1APIPmarginGetMarginMyTradesV1Request {
	r.endTime = &endTime
	return r
}

// TradeId to fetch from. Default gets most recent trades.
func (r V1APIPmarginGetMarginMyTradesV1Request) FromId(fromId int64) V1APIPmarginGetMarginMyTradesV1Request {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r V1APIPmarginGetMarginMyTradesV1Request) Limit(limit int32) V1APIPmarginGetMarginMyTradesV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetMarginMyTradesV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginMyTradesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginMyTradesV1Request) Execute() ([]PmarginGetMarginMyTradesV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetMarginMyTradesV1Execute(r)
}

/*
PmarginGetMarginMyTradesV1 Margin Account Trade List (USER_DATA)

Margin Account Trade List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginMyTradesV1Request
*/
func (a *V1APIService) PmarginGetMarginMyTradesV1(ctx context.Context) V1APIPmarginGetMarginMyTradesV1Request {
	return V1APIPmarginGetMarginMyTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetMarginMyTradesV1RespItem
func (a *V1APIService) PmarginGetMarginMyTradesV1Execute(r V1APIPmarginGetMarginMyTradesV1Request) ([]PmarginGetMarginMyTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetMarginMyTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginMyTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginOpenOrderListV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetMarginOpenOrderListV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginOpenOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetMarginOpenOrderListV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginOpenOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginOpenOrderListV1Request) Execute() ([]PmarginGetMarginOpenOrderListV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetMarginOpenOrderListV1Execute(r)
}

/*
PmarginGetMarginOpenOrderListV1 Query Margin Account's Open OCO (USER_DATA)

Query Margin Account's Open OCO

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginOpenOrderListV1Request
*/
func (a *V1APIService) PmarginGetMarginOpenOrderListV1(ctx context.Context) V1APIPmarginGetMarginOpenOrderListV1Request {
	return V1APIPmarginGetMarginOpenOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetMarginOpenOrderListV1RespItem
func (a *V1APIService) PmarginGetMarginOpenOrderListV1Execute(r V1APIPmarginGetMarginOpenOrderListV1Request) ([]PmarginGetMarginOpenOrderListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetMarginOpenOrderListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginOpenOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetMarginOpenOrdersV1Request) Symbol(symbol string) V1APIPmarginGetMarginOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetMarginOpenOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetMarginOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginOpenOrdersV1Request) Execute() ([]PmarginGetMarginOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetMarginOpenOrdersV1Execute(r)
}

/*
PmarginGetMarginOpenOrdersV1 Query Current Margin Open Order (USER_DATA)

Query Current Margin Open Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginOpenOrdersV1Request
*/
func (a *V1APIService) PmarginGetMarginOpenOrdersV1(ctx context.Context) V1APIPmarginGetMarginOpenOrdersV1Request {
	return V1APIPmarginGetMarginOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetMarginOpenOrdersV1RespItem
func (a *V1APIService) PmarginGetMarginOpenOrdersV1Execute(r V1APIPmarginGetMarginOpenOrdersV1Request) ([]PmarginGetMarginOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetMarginOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginOrderListV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	orderListId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIPmarginGetMarginOrderListV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginOrderListV1Request {
	r.timestamp = &timestamp
	return r
}

// Either orderListId or origClientOrderId must be provided
func (r V1APIPmarginGetMarginOrderListV1Request) OrderListId(orderListId int64) V1APIPmarginGetMarginOrderListV1Request {
	r.orderListId = &orderListId
	return r
}

// Either orderListId or origClientOrderId must be provided
func (r V1APIPmarginGetMarginOrderListV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginGetMarginOrderListV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetMarginOrderListV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginOrderListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginOrderListV1Request) Execute() (*PmarginGetMarginOrderListV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginOrderListV1Execute(r)
}

/*
PmarginGetMarginOrderListV1 Query Margin Account's OCO (USER_DATA)

Retrieves a specific OCO based on provided optional parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginOrderListV1Request
*/
func (a *V1APIService) PmarginGetMarginOrderListV1(ctx context.Context) V1APIPmarginGetMarginOrderListV1Request {
	return V1APIPmarginGetMarginOrderListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginOrderListV1Resp
func (a *V1APIService) PmarginGetMarginOrderListV1Execute(r V1APIPmarginGetMarginOrderListV1Request) (*PmarginGetMarginOrderListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginOrderListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginOrderListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIPmarginGetMarginOrderV1Request) Symbol(symbol string) V1APIPmarginGetMarginOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetMarginOrderV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetMarginOrderV1Request) OrderId(orderId int64) V1APIPmarginGetMarginOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetMarginOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginGetMarginOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetMarginOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginOrderV1Request) Execute() (*PmarginGetMarginOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginOrderV1Execute(r)
}

/*
PmarginGetMarginOrderV1 Query Margin Account Order (USER_DATA)

Query Margin Account Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginOrderV1Request
*/
func (a *V1APIService) PmarginGetMarginOrderV1(ctx context.Context) V1APIPmarginGetMarginOrderV1Request {
	return V1APIPmarginGetMarginOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginOrderV1Resp
func (a *V1APIService) PmarginGetMarginOrderV1Execute(r V1APIPmarginGetMarginOrderV1Request) (*PmarginGetMarginOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetMarginRepayLoanV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	asset *string
	timestamp *int64
	txId *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	archived *string
	recvWindow *int64
}

func (r V1APIPmarginGetMarginRepayLoanV1Request) Asset(asset string) V1APIPmarginGetMarginRepayLoanV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginGetMarginRepayLoanV1Request) Timestamp(timestamp int64) V1APIPmarginGetMarginRepayLoanV1Request {
	r.timestamp = &timestamp
	return r
}

// the tranId in &#x60;POST/papi/v1/repayLoan&#x60;
func (r V1APIPmarginGetMarginRepayLoanV1Request) TxId(txId int64) V1APIPmarginGetMarginRepayLoanV1Request {
	r.txId = &txId
	return r
}

func (r V1APIPmarginGetMarginRepayLoanV1Request) StartTime(startTime int64) V1APIPmarginGetMarginRepayLoanV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetMarginRepayLoanV1Request) EndTime(endTime int64) V1APIPmarginGetMarginRepayLoanV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r V1APIPmarginGetMarginRepayLoanV1Request) Current(current int64) V1APIPmarginGetMarginRepayLoanV1Request {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r V1APIPmarginGetMarginRepayLoanV1Request) Size(size int64) V1APIPmarginGetMarginRepayLoanV1Request {
	r.size = &size
	return r
}

// Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
func (r V1APIPmarginGetMarginRepayLoanV1Request) Archived(archived string) V1APIPmarginGetMarginRepayLoanV1Request {
	r.archived = &archived
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetMarginRepayLoanV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetMarginRepayLoanV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetMarginRepayLoanV1Request) Execute() (*PmarginGetMarginRepayLoanV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginRepayLoanV1Execute(r)
}

/*
PmarginGetMarginRepayLoanV1 Query Margin repay Record(USER_DATA)

Query margin repay record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetMarginRepayLoanV1Request
*/
func (a *V1APIService) PmarginGetMarginRepayLoanV1(ctx context.Context) V1APIPmarginGetMarginRepayLoanV1Request {
	return V1APIPmarginGetMarginRepayLoanV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginRepayLoanV1Resp
func (a *V1APIService) PmarginGetMarginRepayLoanV1Execute(r V1APIPmarginGetMarginRepayLoanV1Request) (*PmarginGetMarginRepayLoanV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginRepayLoanV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetMarginRepayLoanV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/repayLoan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	} else {
		var defaultValue string = "false"
		r.archived = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetPingV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIPmarginGetPingV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PmarginGetPingV1Execute(r)
}

/*
PmarginGetPingV1 Test Connectivity

Test connectivity to the Rest API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetPingV1Request
*/
func (a *V1APIService) PmarginGetPingV1(ctx context.Context) V1APIPmarginGetPingV1Request {
	return V1APIPmarginGetPingV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V1APIService) PmarginGetPingV1Execute(r V1APIPmarginGetPingV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetPingV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetPortfolioInterestHistoryV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	asset *string
	startTime *int64
	endTime *int64
	size *int64
	recvWindow *int64
}

func (r V1APIPmarginGetPortfolioInterestHistoryV1Request) Timestamp(timestamp int64) V1APIPmarginGetPortfolioInterestHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetPortfolioInterestHistoryV1Request) Asset(asset string) V1APIPmarginGetPortfolioInterestHistoryV1Request {
	r.asset = &asset
	return r
}

func (r V1APIPmarginGetPortfolioInterestHistoryV1Request) StartTime(startTime int64) V1APIPmarginGetPortfolioInterestHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetPortfolioInterestHistoryV1Request) EndTime(endTime int64) V1APIPmarginGetPortfolioInterestHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default:10 Max:100
func (r V1APIPmarginGetPortfolioInterestHistoryV1Request) Size(size int64) V1APIPmarginGetPortfolioInterestHistoryV1Request {
	r.size = &size
	return r
}

func (r V1APIPmarginGetPortfolioInterestHistoryV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetPortfolioInterestHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetPortfolioInterestHistoryV1Request) Execute() ([]PmarginGetPortfolioInterestHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetPortfolioInterestHistoryV1Execute(r)
}

/*
PmarginGetPortfolioInterestHistoryV1 Query Portfolio Margin Negative Balance Interest History(USER_DATA)

Query interest history of negative balance for portfolio margin.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetPortfolioInterestHistoryV1Request
*/
func (a *V1APIService) PmarginGetPortfolioInterestHistoryV1(ctx context.Context) V1APIPmarginGetPortfolioInterestHistoryV1Request {
	return V1APIPmarginGetPortfolioInterestHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetPortfolioInterestHistoryV1RespItem
func (a *V1APIService) PmarginGetPortfolioInterestHistoryV1Execute(r V1APIPmarginGetPortfolioInterestHistoryV1Request) ([]PmarginGetPortfolioInterestHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetPortfolioInterestHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetPortfolioInterestHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/portfolio/interest-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) StartTime(startTime int64) V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) EndTime(endTime int64) V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) Timestamp(timestamp int64) V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) Execute() (*PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetPortfolioNegativeBalanceExchangeRecordV1Execute(r)
}

/*
PmarginGetPortfolioNegativeBalanceExchangeRecordV1 Query User Negative Balance Auto Exchange Record (USER_DATA)

Query user negative balance auto exchange record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request
*/
func (a *V1APIService) PmarginGetPortfolioNegativeBalanceExchangeRecordV1(ctx context.Context) V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
	return V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp
func (a *V1APIService) PmarginGetPortfolioNegativeBalanceExchangeRecordV1Execute(r V1APIPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) (*PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetPortfolioNegativeBalanceExchangeRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/portfolio/negative-balance-exchange-record"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetRateLimitOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetRateLimitOrderV1Request) Timestamp(timestamp int64) V1APIPmarginGetRateLimitOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetRateLimitOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetRateLimitOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetRateLimitOrderV1Request) Execute() ([]PmarginGetRateLimitOrderV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetRateLimitOrderV1Execute(r)
}

/*
PmarginGetRateLimitOrderV1 Query User Rate Limit (USER_DATA)

Query User Rate Limit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetRateLimitOrderV1Request
*/
func (a *V1APIService) PmarginGetRateLimitOrderV1(ctx context.Context) V1APIPmarginGetRateLimitOrderV1Request {
	return V1APIPmarginGetRateLimitOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetRateLimitOrderV1RespItem
func (a *V1APIService) PmarginGetRateLimitOrderV1Execute(r V1APIPmarginGetRateLimitOrderV1Request) ([]PmarginGetRateLimitOrderV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetRateLimitOrderV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetRateLimitOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/rateLimit/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetRepayFuturesSwitchV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetRepayFuturesSwitchV1Request) Timestamp(timestamp int64) V1APIPmarginGetRepayFuturesSwitchV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetRepayFuturesSwitchV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetRepayFuturesSwitchV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetRepayFuturesSwitchV1Request) Execute() (*PmarginGetRepayFuturesSwitchV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetRepayFuturesSwitchV1Execute(r)
}

/*
PmarginGetRepayFuturesSwitchV1 Get Auto-repay-futures Status(USER_DATA)

Query Auto-repay-futures Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetRepayFuturesSwitchV1Request
*/
func (a *V1APIService) PmarginGetRepayFuturesSwitchV1(ctx context.Context) V1APIPmarginGetRepayFuturesSwitchV1Request {
	return V1APIPmarginGetRepayFuturesSwitchV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetRepayFuturesSwitchV1Resp
func (a *V1APIService) PmarginGetRepayFuturesSwitchV1Execute(r V1APIPmarginGetRepayFuturesSwitchV1Request) (*PmarginGetRepayFuturesSwitchV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetRepayFuturesSwitchV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetRepayFuturesSwitchV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/repay-futures-switch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmAccountConfigV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetUmAccountConfigV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmAccountConfigV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmAccountConfigV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmAccountConfigV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmAccountConfigV1Request) Execute() (*PmarginGetUmAccountConfigV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmAccountConfigV1Execute(r)
}

/*
PmarginGetUmAccountConfigV1 UM Futures Account Configuration(USER_DATA)

Query UM Futures account configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmAccountConfigV1Request
*/
func (a *V1APIService) PmarginGetUmAccountConfigV1(ctx context.Context) V1APIPmarginGetUmAccountConfigV1Request {
	return V1APIPmarginGetUmAccountConfigV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmAccountConfigV1Resp
func (a *V1APIService) PmarginGetUmAccountConfigV1Execute(r V1APIPmarginGetUmAccountConfigV1Request) (*PmarginGetUmAccountConfigV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmAccountConfigV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmAccountConfigV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/accountConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmAccountV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetUmAccountV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmAccountV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmAccountV1Request) Execute() (*PmarginGetUmAccountV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmAccountV1Execute(r)
}

/*
PmarginGetUmAccountV1 Get UM Account Detail(USER_DATA)

Get current UM account asset and position information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmAccountV1Request
*/
func (a *V1APIService) PmarginGetUmAccountV1(ctx context.Context) V1APIPmarginGetUmAccountV1Request {
	return V1APIPmarginGetUmAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmAccountV1Resp
func (a *V1APIService) PmarginGetUmAccountV1Execute(r V1APIPmarginGetUmAccountV1Request) (*PmarginGetUmAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmAdlQuantileV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIPmarginGetUmAdlQuantileV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmAdlQuantileV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmAdlQuantileV1Request) Symbol(symbol string) V1APIPmarginGetUmAdlQuantileV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmAdlQuantileV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmAdlQuantileV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmAdlQuantileV1Request) Execute() ([]PmarginGetUmAdlQuantileV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmAdlQuantileV1Execute(r)
}

/*
PmarginGetUmAdlQuantileV1 UM Position ADL Quantile Estimation(USER_DATA)

Query UM Position ADL Quantile Estimation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmAdlQuantileV1Request
*/
func (a *V1APIService) PmarginGetUmAdlQuantileV1(ctx context.Context) V1APIPmarginGetUmAdlQuantileV1Request {
	return V1APIPmarginGetUmAdlQuantileV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmAdlQuantileV1RespItem
func (a *V1APIService) PmarginGetUmAdlQuantileV1Execute(r V1APIPmarginGetUmAdlQuantileV1Request) ([]PmarginGetUmAdlQuantileV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmAdlQuantileV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmAdlQuantileV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/adlQuantile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmAllOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetUmAllOrdersV1Request) Symbol(symbol string) V1APIPmarginGetUmAllOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmAllOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmAllOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmAllOrdersV1Request) OrderId(orderId int64) V1APIPmarginGetUmAllOrdersV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetUmAllOrdersV1Request) StartTime(startTime int64) V1APIPmarginGetUmAllOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetUmAllOrdersV1Request) EndTime(endTime int64) V1APIPmarginGetUmAllOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r V1APIPmarginGetUmAllOrdersV1Request) Limit(limit int32) V1APIPmarginGetUmAllOrdersV1Request {
	r.limit = &limit
	return r
}

func (r V1APIPmarginGetUmAllOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmAllOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmAllOrdersV1Request) Execute() ([]PmarginGetUmAllOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmAllOrdersV1Execute(r)
}

/*
PmarginGetUmAllOrdersV1 Query All UM Orders(USER_DATA)

Get all account UM orders; active, canceled, or filled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmAllOrdersV1Request
*/
func (a *V1APIService) PmarginGetUmAllOrdersV1(ctx context.Context) V1APIPmarginGetUmAllOrdersV1Request {
	return V1APIPmarginGetUmAllOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmAllOrdersV1RespItem
func (a *V1APIService) PmarginGetUmAllOrdersV1Execute(r V1APIPmarginGetUmAllOrdersV1Request) ([]PmarginGetUmAllOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmAllOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmAllOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmApiTradingStatusV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIPmarginGetUmApiTradingStatusV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmApiTradingStatusV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmApiTradingStatusV1Request) Symbol(symbol string) V1APIPmarginGetUmApiTradingStatusV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmApiTradingStatusV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmApiTradingStatusV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmApiTradingStatusV1Request) Execute() (*PmarginGetUmApiTradingStatusV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmApiTradingStatusV1Execute(r)
}

/*
PmarginGetUmApiTradingStatusV1 Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)

Portfolio Margin UM Trading Quantitative Rules Indicators

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmApiTradingStatusV1Request
*/
func (a *V1APIService) PmarginGetUmApiTradingStatusV1(ctx context.Context) V1APIPmarginGetUmApiTradingStatusV1Request {
	return V1APIPmarginGetUmApiTradingStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmApiTradingStatusV1Resp
func (a *V1APIService) PmarginGetUmApiTradingStatusV1Execute(r V1APIPmarginGetUmApiTradingStatusV1Request) (*PmarginGetUmApiTradingStatusV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmApiTradingStatusV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmApiTradingStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/apiTradingStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmCommissionRateV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetUmCommissionRateV1Request) Symbol(symbol string) V1APIPmarginGetUmCommissionRateV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmCommissionRateV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmCommissionRateV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmCommissionRateV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmCommissionRateV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmCommissionRateV1Request) Execute() (*PmarginGetUmCommissionRateV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmCommissionRateV1Execute(r)
}

/*
PmarginGetUmCommissionRateV1 Get User Commission Rate for UM(USER_DATA)

Get User Commission Rate for UM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmCommissionRateV1Request
*/
func (a *V1APIService) PmarginGetUmCommissionRateV1(ctx context.Context) V1APIPmarginGetUmCommissionRateV1Request {
	return V1APIPmarginGetUmCommissionRateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmCommissionRateV1Resp
func (a *V1APIService) PmarginGetUmCommissionRateV1Execute(r V1APIPmarginGetUmCommissionRateV1Request) (*PmarginGetUmCommissionRateV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmCommissionRateV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmCommissionRateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/commissionRate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmConditionalAllOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	strategyId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetUmConditionalAllOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmConditionalAllOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmConditionalAllOrdersV1Request) Symbol(symbol string) V1APIPmarginGetUmConditionalAllOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmConditionalAllOrdersV1Request) StrategyId(strategyId int64) V1APIPmarginGetUmConditionalAllOrdersV1Request {
	r.strategyId = &strategyId
	return r
}

func (r V1APIPmarginGetUmConditionalAllOrdersV1Request) StartTime(startTime int64) V1APIPmarginGetUmConditionalAllOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetUmConditionalAllOrdersV1Request) EndTime(endTime int64) V1APIPmarginGetUmConditionalAllOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r V1APIPmarginGetUmConditionalAllOrdersV1Request) Limit(limit int32) V1APIPmarginGetUmConditionalAllOrdersV1Request {
	r.limit = &limit
	return r
}

func (r V1APIPmarginGetUmConditionalAllOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmConditionalAllOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmConditionalAllOrdersV1Request) Execute() ([]PmarginGetUmConditionalAllOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmConditionalAllOrdersV1Execute(r)
}

/*
PmarginGetUmConditionalAllOrdersV1 Query All UM Conditional Orders(USER_DATA)

Query All UM Conditional Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmConditionalAllOrdersV1Request
*/
func (a *V1APIService) PmarginGetUmConditionalAllOrdersV1(ctx context.Context) V1APIPmarginGetUmConditionalAllOrdersV1Request {
	return V1APIPmarginGetUmConditionalAllOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmConditionalAllOrdersV1RespItem
func (a *V1APIService) PmarginGetUmConditionalAllOrdersV1Execute(r V1APIPmarginGetUmConditionalAllOrdersV1Request) ([]PmarginGetUmConditionalAllOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmConditionalAllOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmConditionalAllOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/conditional/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategyId", r.strategyId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmConditionalOpenOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	strategyId *int64
	newClientStrategyId *string
	recvWindow *int64
}

func (r V1APIPmarginGetUmConditionalOpenOrderV1Request) Symbol(symbol string) V1APIPmarginGetUmConditionalOpenOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmConditionalOpenOrderV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmConditionalOpenOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmConditionalOpenOrderV1Request) StrategyId(strategyId int64) V1APIPmarginGetUmConditionalOpenOrderV1Request {
	r.strategyId = &strategyId
	return r
}

func (r V1APIPmarginGetUmConditionalOpenOrderV1Request) NewClientStrategyId(newClientStrategyId string) V1APIPmarginGetUmConditionalOpenOrderV1Request {
	r.newClientStrategyId = &newClientStrategyId
	return r
}

func (r V1APIPmarginGetUmConditionalOpenOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmConditionalOpenOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmConditionalOpenOrderV1Request) Execute() (*PmarginGetUmConditionalOpenOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmConditionalOpenOrderV1Execute(r)
}

/*
PmarginGetUmConditionalOpenOrderV1 Query Current UM Open Conditional Order(USER_DATA)

Query Current UM Open Conditional Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmConditionalOpenOrderV1Request
*/
func (a *V1APIService) PmarginGetUmConditionalOpenOrderV1(ctx context.Context) V1APIPmarginGetUmConditionalOpenOrderV1Request {
	return V1APIPmarginGetUmConditionalOpenOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmConditionalOpenOrderV1Resp
func (a *V1APIService) PmarginGetUmConditionalOpenOrderV1Execute(r V1APIPmarginGetUmConditionalOpenOrderV1Request) (*PmarginGetUmConditionalOpenOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmConditionalOpenOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmConditionalOpenOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/conditional/openOrder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategyId", r.strategyId, "form", "")
	}
	if r.newClientStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientStrategyId", r.newClientStrategyId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientStrategyId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmConditionalOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIPmarginGetUmConditionalOpenOrdersV1Request) Execute() ([]PmarginGetUmConditionalOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmConditionalOpenOrdersV1Execute(r)
}

/*
PmarginGetUmConditionalOpenOrdersV1 Query All Current UM Open Conditional Orders(USER_DATA)

Get all open conditional orders on a symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmConditionalOpenOrdersV1Request
*/
func (a *V1APIService) PmarginGetUmConditionalOpenOrdersV1(ctx context.Context) V1APIPmarginGetUmConditionalOpenOrdersV1Request {
	return V1APIPmarginGetUmConditionalOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmConditionalOpenOrdersV1RespItem
func (a *V1APIService) PmarginGetUmConditionalOpenOrdersV1Execute(r V1APIPmarginGetUmConditionalOpenOrdersV1Request) ([]PmarginGetUmConditionalOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmConditionalOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmConditionalOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/conditional/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmConditionalOrderHistoryV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	strategyId *int64
	newClientStrategyId *string
	recvWindow *int64
}

func (r V1APIPmarginGetUmConditionalOrderHistoryV1Request) Symbol(symbol string) V1APIPmarginGetUmConditionalOrderHistoryV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmConditionalOrderHistoryV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmConditionalOrderHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmConditionalOrderHistoryV1Request) StrategyId(strategyId int64) V1APIPmarginGetUmConditionalOrderHistoryV1Request {
	r.strategyId = &strategyId
	return r
}

func (r V1APIPmarginGetUmConditionalOrderHistoryV1Request) NewClientStrategyId(newClientStrategyId string) V1APIPmarginGetUmConditionalOrderHistoryV1Request {
	r.newClientStrategyId = &newClientStrategyId
	return r
}

func (r V1APIPmarginGetUmConditionalOrderHistoryV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmConditionalOrderHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmConditionalOrderHistoryV1Request) Execute() (*PmarginGetUmConditionalOrderHistoryV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmConditionalOrderHistoryV1Execute(r)
}

/*
PmarginGetUmConditionalOrderHistoryV1 Query UM Conditional Order History(USER_DATA)

Query UM Conditional Order History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmConditionalOrderHistoryV1Request
*/
func (a *V1APIService) PmarginGetUmConditionalOrderHistoryV1(ctx context.Context) V1APIPmarginGetUmConditionalOrderHistoryV1Request {
	return V1APIPmarginGetUmConditionalOrderHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmConditionalOrderHistoryV1Resp
func (a *V1APIService) PmarginGetUmConditionalOrderHistoryV1Execute(r V1APIPmarginGetUmConditionalOrderHistoryV1Request) (*PmarginGetUmConditionalOrderHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmConditionalOrderHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmConditionalOrderHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/conditional/orderHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "strategyId", r.strategyId, "form", "")
	}
	if r.newClientStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientStrategyId", r.newClientStrategyId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientStrategyId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmFeeBurnV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetUmFeeBurnV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmFeeBurnV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmFeeBurnV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmFeeBurnV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmFeeBurnV1Request) Execute() (*PmarginGetUmFeeBurnV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmFeeBurnV1Execute(r)
}

/*
PmarginGetUmFeeBurnV1 Get UM Futures BNB Burn Status (USER_DATA)

Get user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmFeeBurnV1Request
*/
func (a *V1APIService) PmarginGetUmFeeBurnV1(ctx context.Context) V1APIPmarginGetUmFeeBurnV1Request {
	return V1APIPmarginGetUmFeeBurnV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmFeeBurnV1Resp
func (a *V1APIService) PmarginGetUmFeeBurnV1Execute(r V1APIPmarginGetUmFeeBurnV1Request) (*PmarginGetUmFeeBurnV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmFeeBurnV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmFeeBurnV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/feeBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmForceOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	autoCloseType *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetUmForceOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmForceOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmForceOrdersV1Request) Symbol(symbol string) V1APIPmarginGetUmForceOrdersV1Request {
	r.symbol = &symbol
	return r
}

// &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders.
func (r V1APIPmarginGetUmForceOrdersV1Request) AutoCloseType(autoCloseType string) V1APIPmarginGetUmForceOrdersV1Request {
	r.autoCloseType = &autoCloseType
	return r
}

func (r V1APIPmarginGetUmForceOrdersV1Request) StartTime(startTime int64) V1APIPmarginGetUmForceOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetUmForceOrdersV1Request) EndTime(endTime int64) V1APIPmarginGetUmForceOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 50; max 100.
func (r V1APIPmarginGetUmForceOrdersV1Request) Limit(limit int32) V1APIPmarginGetUmForceOrdersV1Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r V1APIPmarginGetUmForceOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmForceOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmForceOrdersV1Request) Execute() ([]PmarginGetUmForceOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmForceOrdersV1Execute(r)
}

/*
PmarginGetUmForceOrdersV1 Query User's UM Force Orders (USER_DATA)

Query User's UM Force Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmForceOrdersV1Request
*/
func (a *V1APIService) PmarginGetUmForceOrdersV1(ctx context.Context) V1APIPmarginGetUmForceOrdersV1Request {
	return V1APIPmarginGetUmForceOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmForceOrdersV1RespItem
func (a *V1APIService) PmarginGetUmForceOrdersV1Execute(r V1APIPmarginGetUmForceOrdersV1Request) ([]PmarginGetUmForceOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmForceOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmForceOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/forceOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.autoCloseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCloseType", r.autoCloseType, "form", "")
	} else {
		var defaultValue string = ""
		r.autoCloseType = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmIncomeAsynIdV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	downloadId *string
	timestamp *int64
	recvWindow *int64
}

// get by download id api
func (r V1APIPmarginGetUmIncomeAsynIdV1Request) DownloadId(downloadId string) V1APIPmarginGetUmIncomeAsynIdV1Request {
	r.downloadId = &downloadId
	return r
}

func (r V1APIPmarginGetUmIncomeAsynIdV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmIncomeAsynIdV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmIncomeAsynIdV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmIncomeAsynIdV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmIncomeAsynIdV1Request) Execute() (*PmarginGetUmIncomeAsynIdV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmIncomeAsynIdV1Execute(r)
}

/*
PmarginGetUmIncomeAsynIdV1 Get UM Futures Transaction Download Link by Id(USER_DATA)

Get UM futures Transaction download link by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmIncomeAsynIdV1Request
*/
func (a *V1APIService) PmarginGetUmIncomeAsynIdV1(ctx context.Context) V1APIPmarginGetUmIncomeAsynIdV1Request {
	return V1APIPmarginGetUmIncomeAsynIdV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmIncomeAsynIdV1Resp
func (a *V1APIService) PmarginGetUmIncomeAsynIdV1Execute(r V1APIPmarginGetUmIncomeAsynIdV1Request) (*PmarginGetUmIncomeAsynIdV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmIncomeAsynIdV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmIncomeAsynIdV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/income/asyn/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadId == nil {
		return localVarReturnValue, nil, reportError("downloadId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "downloadId", r.downloadId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmIncomeAsynV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

// Timestamp in ms
func (r V1APIPmarginGetUmIncomeAsynV1Request) StartTime(startTime int64) V1APIPmarginGetUmIncomeAsynV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms
func (r V1APIPmarginGetUmIncomeAsynV1Request) EndTime(endTime int64) V1APIPmarginGetUmIncomeAsynV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APIPmarginGetUmIncomeAsynV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmIncomeAsynV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmIncomeAsynV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmIncomeAsynV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmIncomeAsynV1Request) Execute() (*PmarginGetUmIncomeAsynV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmIncomeAsynV1Execute(r)
}

/*
PmarginGetUmIncomeAsynV1 Get Download Id For UM Futures Transaction History (USER_DATA)

Get download id for UM futures transaction history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmIncomeAsynV1Request
*/
func (a *V1APIService) PmarginGetUmIncomeAsynV1(ctx context.Context) V1APIPmarginGetUmIncomeAsynV1Request {
	return V1APIPmarginGetUmIncomeAsynV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmIncomeAsynV1Resp
func (a *V1APIService) PmarginGetUmIncomeAsynV1Execute(r V1APIPmarginGetUmIncomeAsynV1Request) (*PmarginGetUmIncomeAsynV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmIncomeAsynV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmIncomeAsynV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/income/asyn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmIncomeV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	incomeType *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetUmIncomeV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmIncomeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmIncomeV1Request) Symbol(symbol string) V1APIPmarginGetUmIncomeV1Request {
	r.symbol = &symbol
	return r
}

// TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
func (r V1APIPmarginGetUmIncomeV1Request) IncomeType(incomeType string) V1APIPmarginGetUmIncomeV1Request {
	r.incomeType = &incomeType
	return r
}

// Timestamp in ms to get funding from INCLUSIVE.
func (r V1APIPmarginGetUmIncomeV1Request) StartTime(startTime int64) V1APIPmarginGetUmIncomeV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get funding until INCLUSIVE.
func (r V1APIPmarginGetUmIncomeV1Request) EndTime(endTime int64) V1APIPmarginGetUmIncomeV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APIPmarginGetUmIncomeV1Request) Page(page int32) V1APIPmarginGetUmIncomeV1Request {
	r.page = &page
	return r
}

// Default 100; max 1000
func (r V1APIPmarginGetUmIncomeV1Request) Limit(limit int32) V1APIPmarginGetUmIncomeV1Request {
	r.limit = &limit
	return r
}

func (r V1APIPmarginGetUmIncomeV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmIncomeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmIncomeV1Request) Execute() ([]PmarginGetUmIncomeV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmIncomeV1Execute(r)
}

/*
PmarginGetUmIncomeV1 Get UM Income History(USER_DATA)

Get UM Income History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmIncomeV1Request
*/
func (a *V1APIService) PmarginGetUmIncomeV1(ctx context.Context) V1APIPmarginGetUmIncomeV1Request {
	return V1APIPmarginGetUmIncomeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmIncomeV1RespItem
func (a *V1APIService) PmarginGetUmIncomeV1Execute(r V1APIPmarginGetUmIncomeV1Request) ([]PmarginGetUmIncomeV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmIncomeV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmIncomeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/income"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.incomeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incomeType", r.incomeType, "form", "")
	} else {
		var defaultValue string = ""
		r.incomeType = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmLeverageBracketV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIPmarginGetUmLeverageBracketV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmLeverageBracketV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmLeverageBracketV1Request) Symbol(symbol string) V1APIPmarginGetUmLeverageBracketV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmLeverageBracketV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmLeverageBracketV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmLeverageBracketV1Request) Execute() ([]PmarginGetUmLeverageBracketV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmLeverageBracketV1Execute(r)
}

/*
PmarginGetUmLeverageBracketV1 UM Notional and Leverage Brackets (USER_DATA)

Query UM notional and leverage brackets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmLeverageBracketV1Request
*/
func (a *V1APIService) PmarginGetUmLeverageBracketV1(ctx context.Context) V1APIPmarginGetUmLeverageBracketV1Request {
	return V1APIPmarginGetUmLeverageBracketV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmLeverageBracketV1RespItem
func (a *V1APIService) PmarginGetUmLeverageBracketV1Execute(r V1APIPmarginGetUmLeverageBracketV1Request) ([]PmarginGetUmLeverageBracketV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmLeverageBracketV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmLeverageBracketV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/leverageBracket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmOpenOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIPmarginGetUmOpenOrderV1Request) Symbol(symbol string) V1APIPmarginGetUmOpenOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmOpenOrderV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmOpenOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmOpenOrderV1Request) OrderId(orderId int64) V1APIPmarginGetUmOpenOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetUmOpenOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginGetUmOpenOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIPmarginGetUmOpenOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmOpenOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmOpenOrderV1Request) Execute() (*PmarginGetUmOpenOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmOpenOrderV1Execute(r)
}

/*
PmarginGetUmOpenOrderV1 Query Current UM Open Order(USER_DATA)

Query current UM open order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmOpenOrderV1Request
*/
func (a *V1APIService) PmarginGetUmOpenOrderV1(ctx context.Context) V1APIPmarginGetUmOpenOrderV1Request {
	return V1APIPmarginGetUmOpenOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmOpenOrderV1Resp
func (a *V1APIService) PmarginGetUmOpenOrderV1Execute(r V1APIPmarginGetUmOpenOrderV1Request) (*PmarginGetUmOpenOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmOpenOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmOpenOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/openOrder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIPmarginGetUmOpenOrdersV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmOpenOrdersV1Request) Symbol(symbol string) V1APIPmarginGetUmOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmOpenOrdersV1Request) Execute() ([]PmarginGetUmOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmOpenOrdersV1Execute(r)
}

/*
PmarginGetUmOpenOrdersV1 Query All Current UM Open Orders(USER_DATA)

Get all open orders on a symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmOpenOrdersV1Request
*/
func (a *V1APIService) PmarginGetUmOpenOrdersV1(ctx context.Context) V1APIPmarginGetUmOpenOrdersV1Request {
	return V1APIPmarginGetUmOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmOpenOrdersV1RespItem
func (a *V1APIService) PmarginGetUmOpenOrdersV1Execute(r V1APIPmarginGetUmOpenOrdersV1Request) ([]PmarginGetUmOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmOrderAmendmentV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetUmOrderAmendmentV1Request) Symbol(symbol string) V1APIPmarginGetUmOrderAmendmentV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmOrderAmendmentV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmOrderAmendmentV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmOrderAmendmentV1Request) OrderId(orderId int64) V1APIPmarginGetUmOrderAmendmentV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetUmOrderAmendmentV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginGetUmOrderAmendmentV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Timestamp in ms to get modification history from INCLUSIVE
func (r V1APIPmarginGetUmOrderAmendmentV1Request) StartTime(startTime int64) V1APIPmarginGetUmOrderAmendmentV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get modification history until INCLUSIVE
func (r V1APIPmarginGetUmOrderAmendmentV1Request) EndTime(endTime int64) V1APIPmarginGetUmOrderAmendmentV1Request {
	r.endTime = &endTime
	return r
}

// Default 500, max 1000
func (r V1APIPmarginGetUmOrderAmendmentV1Request) Limit(limit int32) V1APIPmarginGetUmOrderAmendmentV1Request {
	r.limit = &limit
	return r
}

func (r V1APIPmarginGetUmOrderAmendmentV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmOrderAmendmentV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmOrderAmendmentV1Request) Execute() ([]PmarginGetUmOrderAmendmentV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmOrderAmendmentV1Execute(r)
}

/*
PmarginGetUmOrderAmendmentV1 Query UM Modify Order History(TRADE)

Get order modification history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmOrderAmendmentV1Request
*/
func (a *V1APIService) PmarginGetUmOrderAmendmentV1(ctx context.Context) V1APIPmarginGetUmOrderAmendmentV1Request {
	return V1APIPmarginGetUmOrderAmendmentV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmOrderAmendmentV1RespItem
func (a *V1APIService) PmarginGetUmOrderAmendmentV1Execute(r V1APIPmarginGetUmOrderAmendmentV1Request) ([]PmarginGetUmOrderAmendmentV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmOrderAmendmentV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmOrderAmendmentV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/orderAmendment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmOrderAsynIdV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	downloadId *string
	timestamp *int64
	recvWindow *int64
}

// get by download id api
func (r V1APIPmarginGetUmOrderAsynIdV1Request) DownloadId(downloadId string) V1APIPmarginGetUmOrderAsynIdV1Request {
	r.downloadId = &downloadId
	return r
}

func (r V1APIPmarginGetUmOrderAsynIdV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmOrderAsynIdV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmOrderAsynIdV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmOrderAsynIdV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmOrderAsynIdV1Request) Execute() (*PmarginGetUmOrderAsynIdV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmOrderAsynIdV1Execute(r)
}

/*
PmarginGetUmOrderAsynIdV1 Get UM Futures Order Download Link by Id(USER_DATA)

Get UM futures order download link by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmOrderAsynIdV1Request
*/
func (a *V1APIService) PmarginGetUmOrderAsynIdV1(ctx context.Context) V1APIPmarginGetUmOrderAsynIdV1Request {
	return V1APIPmarginGetUmOrderAsynIdV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmOrderAsynIdV1Resp
func (a *V1APIService) PmarginGetUmOrderAsynIdV1Execute(r V1APIPmarginGetUmOrderAsynIdV1Request) (*PmarginGetUmOrderAsynIdV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmOrderAsynIdV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmOrderAsynIdV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/order/asyn/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadId == nil {
		return localVarReturnValue, nil, reportError("downloadId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "downloadId", r.downloadId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmOrderAsynV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

// Timestamp in ms
func (r V1APIPmarginGetUmOrderAsynV1Request) StartTime(startTime int64) V1APIPmarginGetUmOrderAsynV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms
func (r V1APIPmarginGetUmOrderAsynV1Request) EndTime(endTime int64) V1APIPmarginGetUmOrderAsynV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APIPmarginGetUmOrderAsynV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmOrderAsynV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmOrderAsynV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmOrderAsynV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmOrderAsynV1Request) Execute() (*PmarginGetUmOrderAsynV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmOrderAsynV1Execute(r)
}

/*
PmarginGetUmOrderAsynV1 Get Download Id For UM Futures Order History (USER_DATA)

Get download id for UM futures order history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmOrderAsynV1Request
*/
func (a *V1APIService) PmarginGetUmOrderAsynV1(ctx context.Context) V1APIPmarginGetUmOrderAsynV1Request {
	return V1APIPmarginGetUmOrderAsynV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmOrderAsynV1Resp
func (a *V1APIService) PmarginGetUmOrderAsynV1Execute(r V1APIPmarginGetUmOrderAsynV1Request) (*PmarginGetUmOrderAsynV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmOrderAsynV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmOrderAsynV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/order/asyn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIPmarginGetUmOrderV1Request) Symbol(symbol string) V1APIPmarginGetUmOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmOrderV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmOrderV1Request) OrderId(orderId int64) V1APIPmarginGetUmOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginGetUmOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginGetUmOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIPmarginGetUmOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmOrderV1Request) Execute() (*PmarginGetUmOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmOrderV1Execute(r)
}

/*
PmarginGetUmOrderV1 Query UM Order (USER_DATA)

Check an UM order's status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmOrderV1Request
*/
func (a *V1APIService) PmarginGetUmOrderV1(ctx context.Context) V1APIPmarginGetUmOrderV1Request {
	return V1APIPmarginGetUmOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmOrderV1Resp
func (a *V1APIService) PmarginGetUmOrderV1Execute(r V1APIPmarginGetUmOrderV1Request) (*PmarginGetUmOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmPositionRiskV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIPmarginGetUmPositionRiskV1Request) Execute() ([]PmarginGetUmPositionRiskV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmPositionRiskV1Execute(r)
}

/*
PmarginGetUmPositionRiskV1 Query UM Position Information(USER_DATA)

Get current UM position information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmPositionRiskV1Request
*/
func (a *V1APIService) PmarginGetUmPositionRiskV1(ctx context.Context) V1APIPmarginGetUmPositionRiskV1Request {
	return V1APIPmarginGetUmPositionRiskV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmPositionRiskV1RespItem
func (a *V1APIService) PmarginGetUmPositionRiskV1Execute(r V1APIPmarginGetUmPositionRiskV1Request) ([]PmarginGetUmPositionRiskV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmPositionRiskV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmPositionRiskV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmPositionSideDualV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIPmarginGetUmPositionSideDualV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmPositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmPositionSideDualV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmPositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmPositionSideDualV1Request) Execute() (*PmarginGetUmPositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmPositionSideDualV1Execute(r)
}

/*
PmarginGetUmPositionSideDualV1 Get UM Current Position Mode(USER_DATA)

Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmPositionSideDualV1Request
*/
func (a *V1APIService) PmarginGetUmPositionSideDualV1(ctx context.Context) V1APIPmarginGetUmPositionSideDualV1Request {
	return V1APIPmarginGetUmPositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmPositionSideDualV1Resp
func (a *V1APIService) PmarginGetUmPositionSideDualV1Execute(r V1APIPmarginGetUmPositionSideDualV1Request) (*PmarginGetUmPositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmPositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmPositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmSymbolConfigV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIPmarginGetUmSymbolConfigV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmSymbolConfigV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmSymbolConfigV1Request) Symbol(symbol string) V1APIPmarginGetUmSymbolConfigV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmSymbolConfigV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmSymbolConfigV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmSymbolConfigV1Request) Execute() ([]PmarginGetUmSymbolConfigV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmSymbolConfigV1Execute(r)
}

/*
PmarginGetUmSymbolConfigV1 UM Futures Symbol Configuration(USER_DATA)

Get current UM account symbol configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmSymbolConfigV1Request
*/
func (a *V1APIService) PmarginGetUmSymbolConfigV1(ctx context.Context) V1APIPmarginGetUmSymbolConfigV1Request {
	return V1APIPmarginGetUmSymbolConfigV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmSymbolConfigV1RespItem
func (a *V1APIService) PmarginGetUmSymbolConfigV1Execute(r V1APIPmarginGetUmSymbolConfigV1Request) ([]PmarginGetUmSymbolConfigV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmSymbolConfigV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmSymbolConfigV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/symbolConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmTradeAsynIdV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	downloadId *string
	timestamp *int64
	recvWindow *int64
}

// get by download id api
func (r V1APIPmarginGetUmTradeAsynIdV1Request) DownloadId(downloadId string) V1APIPmarginGetUmTradeAsynIdV1Request {
	r.downloadId = &downloadId
	return r
}

func (r V1APIPmarginGetUmTradeAsynIdV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmTradeAsynIdV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmTradeAsynIdV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmTradeAsynIdV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmTradeAsynIdV1Request) Execute() (*PmarginGetUmTradeAsynIdV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmTradeAsynIdV1Execute(r)
}

/*
PmarginGetUmTradeAsynIdV1 Get UM Futures Trade Download Link by Id(USER_DATA)

Get UM futures trade download link by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmTradeAsynIdV1Request
*/
func (a *V1APIService) PmarginGetUmTradeAsynIdV1(ctx context.Context) V1APIPmarginGetUmTradeAsynIdV1Request {
	return V1APIPmarginGetUmTradeAsynIdV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmTradeAsynIdV1Resp
func (a *V1APIService) PmarginGetUmTradeAsynIdV1Execute(r V1APIPmarginGetUmTradeAsynIdV1Request) (*PmarginGetUmTradeAsynIdV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmTradeAsynIdV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmTradeAsynIdV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/trade/asyn/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadId == nil {
		return localVarReturnValue, nil, reportError("downloadId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "downloadId", r.downloadId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmTradeAsynV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

// Timestamp in ms
func (r V1APIPmarginGetUmTradeAsynV1Request) StartTime(startTime int64) V1APIPmarginGetUmTradeAsynV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms
func (r V1APIPmarginGetUmTradeAsynV1Request) EndTime(endTime int64) V1APIPmarginGetUmTradeAsynV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APIPmarginGetUmTradeAsynV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmTradeAsynV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmTradeAsynV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmTradeAsynV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmTradeAsynV1Request) Execute() (*PmarginGetUmTradeAsynV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmTradeAsynV1Execute(r)
}

/*
PmarginGetUmTradeAsynV1 Get Download Id For UM Futures Trade History (USER_DATA)

Get download id for UM futures trade history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmTradeAsynV1Request
*/
func (a *V1APIService) PmarginGetUmTradeAsynV1(ctx context.Context) V1APIPmarginGetUmTradeAsynV1Request {
	return V1APIPmarginGetUmTradeAsynV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmTradeAsynV1Resp
func (a *V1APIService) PmarginGetUmTradeAsynV1Execute(r V1APIPmarginGetUmTradeAsynV1Request) (*PmarginGetUmTradeAsynV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmTradeAsynV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmTradeAsynV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/trade/asyn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginGetUmUserTradesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIPmarginGetUmUserTradesV1Request) Symbol(symbol string) V1APIPmarginGetUmUserTradesV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginGetUmUserTradesV1Request) Timestamp(timestamp int64) V1APIPmarginGetUmUserTradesV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginGetUmUserTradesV1Request) StartTime(startTime int64) V1APIPmarginGetUmUserTradesV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIPmarginGetUmUserTradesV1Request) EndTime(endTime int64) V1APIPmarginGetUmUserTradesV1Request {
	r.endTime = &endTime
	return r
}

// Trade id to fetch from. Default gets most recent trades.
func (r V1APIPmarginGetUmUserTradesV1Request) FromId(fromId int64) V1APIPmarginGetUmUserTradesV1Request {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r V1APIPmarginGetUmUserTradesV1Request) Limit(limit int32) V1APIPmarginGetUmUserTradesV1Request {
	r.limit = &limit
	return r
}

func (r V1APIPmarginGetUmUserTradesV1Request) RecvWindow(recvWindow int64) V1APIPmarginGetUmUserTradesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginGetUmUserTradesV1Request) Execute() ([]PmarginGetUmUserTradesV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmUserTradesV1Execute(r)
}

/*
PmarginGetUmUserTradesV1 UM Account Trade List(USER_DATA)

Get trades for a specific account and UM symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginGetUmUserTradesV1Request
*/
func (a *V1APIService) PmarginGetUmUserTradesV1(ctx context.Context) V1APIPmarginGetUmUserTradesV1Request {
	return V1APIPmarginGetUmUserTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmUserTradesV1RespItem
func (a *V1APIService) PmarginGetUmUserTradesV1Execute(r V1APIPmarginGetUmUserTradesV1Request) ([]PmarginGetUmUserTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmUserTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginGetUmUserTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/userTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginUpdateCmOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	price *string
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	priceMatch *string
	recvWindow *int64
}

func (r V1APIPmarginUpdateCmOrderV1Request) Price(price string) V1APIPmarginUpdateCmOrderV1Request {
	r.price = &price
	return r
}

func (r V1APIPmarginUpdateCmOrderV1Request) Quantity(quantity string) V1APIPmarginUpdateCmOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIPmarginUpdateCmOrderV1Request) Side(side string) V1APIPmarginUpdateCmOrderV1Request {
	r.side = &side
	return r
}

func (r V1APIPmarginUpdateCmOrderV1Request) Symbol(symbol string) V1APIPmarginUpdateCmOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginUpdateCmOrderV1Request) Timestamp(timestamp int64) V1APIPmarginUpdateCmOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginUpdateCmOrderV1Request) OrderId(orderId int64) V1APIPmarginUpdateCmOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginUpdateCmOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginUpdateCmOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIPmarginUpdateCmOrderV1Request) PriceMatch(priceMatch string) V1APIPmarginUpdateCmOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r V1APIPmarginUpdateCmOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginUpdateCmOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginUpdateCmOrderV1Request) Execute() (*PmarginUpdateCmOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginUpdateCmOrderV1Execute(r)
}

/*
PmarginUpdateCmOrderV1 Modify CM Order(TRADE)

Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginUpdateCmOrderV1Request
*/
func (a *V1APIService) PmarginUpdateCmOrderV1(ctx context.Context) V1APIPmarginUpdateCmOrderV1Request {
	return V1APIPmarginUpdateCmOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginUpdateCmOrderV1Resp
func (a *V1APIService) PmarginUpdateCmOrderV1Execute(r V1APIPmarginUpdateCmOrderV1Request) (*PmarginUpdateCmOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginUpdateCmOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginUpdateCmOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "orderId", r.orderId, "", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "origClientOrderId", r.origClientOrderId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginUpdateListenKeyV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIPmarginUpdateListenKeyV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PmarginUpdateListenKeyV1Execute(r)
}

/*
PmarginUpdateListenKeyV1 Keepalive User Data Stream (USER_STREAM)

Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 60 minutes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginUpdateListenKeyV1Request
*/
func (a *V1APIService) PmarginUpdateListenKeyV1(ctx context.Context) V1APIPmarginUpdateListenKeyV1Request {
	return V1APIPmarginUpdateListenKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V1APIService) PmarginUpdateListenKeyV1Execute(r V1APIPmarginUpdateListenKeyV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginUpdateListenKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/listenKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIPmarginUpdateUmOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	price *string
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	priceMatch *string
	recvWindow *int64
}

func (r V1APIPmarginUpdateUmOrderV1Request) Price(price string) V1APIPmarginUpdateUmOrderV1Request {
	r.price = &price
	return r
}

func (r V1APIPmarginUpdateUmOrderV1Request) Quantity(quantity string) V1APIPmarginUpdateUmOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIPmarginUpdateUmOrderV1Request) Side(side string) V1APIPmarginUpdateUmOrderV1Request {
	r.side = &side
	return r
}

func (r V1APIPmarginUpdateUmOrderV1Request) Symbol(symbol string) V1APIPmarginUpdateUmOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIPmarginUpdateUmOrderV1Request) Timestamp(timestamp int64) V1APIPmarginUpdateUmOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIPmarginUpdateUmOrderV1Request) OrderId(orderId int64) V1APIPmarginUpdateUmOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIPmarginUpdateUmOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIPmarginUpdateUmOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIPmarginUpdateUmOrderV1Request) PriceMatch(priceMatch string) V1APIPmarginUpdateUmOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r V1APIPmarginUpdateUmOrderV1Request) RecvWindow(recvWindow int64) V1APIPmarginUpdateUmOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIPmarginUpdateUmOrderV1Request) Execute() (*PmarginUpdateUmOrderV1Resp, *http.Response, error) {
	return r.ApiService.PmarginUpdateUmOrderV1Execute(r)
}

/*
PmarginUpdateUmOrderV1 Modify UM Order(TRADE)

Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIPmarginUpdateUmOrderV1Request
*/
func (a *V1APIService) PmarginUpdateUmOrderV1(ctx context.Context) V1APIPmarginUpdateUmOrderV1Request {
	return V1APIPmarginUpdateUmOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginUpdateUmOrderV1Resp
func (a *V1APIService) PmarginUpdateUmOrderV1Execute(r V1APIPmarginUpdateUmOrderV1Request) (*PmarginUpdateUmOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginUpdateUmOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.PmarginUpdateUmOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "orderId", r.orderId, "", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "origClientOrderId", r.origClientOrderId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

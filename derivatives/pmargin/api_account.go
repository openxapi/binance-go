/*
Binance Portfolio Margin API

OpenAPI specification for Binance exchange - Pmargin API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pmargin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AccountAPIService AccountAPI service
type AccountAPIService service

type ApiPmarginCreateAssetCollectionV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginCreateAssetCollectionV1Request) Asset(asset string) ApiPmarginCreateAssetCollectionV1Request {
	r.asset = &asset
	return r
}

func (r ApiPmarginCreateAssetCollectionV1Request) Timestamp(timestamp int64) ApiPmarginCreateAssetCollectionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginCreateAssetCollectionV1Request) RecvWindow(recvWindow int64) ApiPmarginCreateAssetCollectionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginCreateAssetCollectionV1Request) Execute() (*PmarginCreateAssetCollectionV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateAssetCollectionV1Execute(r)
}

/*
PmarginCreateAssetCollectionV1 Fund Collection by Asset(TRADE)

Transfers specific asset from Futures Account to Margin account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginCreateAssetCollectionV1Request
*/
func (a *AccountAPIService) PmarginCreateAssetCollectionV1(ctx context.Context) ApiPmarginCreateAssetCollectionV1Request {
	return ApiPmarginCreateAssetCollectionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateAssetCollectionV1Resp
func (a *AccountAPIService) PmarginCreateAssetCollectionV1Execute(r ApiPmarginCreateAssetCollectionV1Request) (*PmarginCreateAssetCollectionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateAssetCollectionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginCreateAssetCollectionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/asset-collection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginCreateAutoCollectionV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginCreateAutoCollectionV1Request) Timestamp(timestamp int64) ApiPmarginCreateAutoCollectionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginCreateAutoCollectionV1Request) RecvWindow(recvWindow int64) ApiPmarginCreateAutoCollectionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginCreateAutoCollectionV1Request) Execute() (*PmarginCreateAutoCollectionV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateAutoCollectionV1Execute(r)
}

/*
PmarginCreateAutoCollectionV1 Fund Auto-collection(TRADE)

Fund collection for Portfolio Margin

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginCreateAutoCollectionV1Request
*/
func (a *AccountAPIService) PmarginCreateAutoCollectionV1(ctx context.Context) ApiPmarginCreateAutoCollectionV1Request {
	return ApiPmarginCreateAutoCollectionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateAutoCollectionV1Resp
func (a *AccountAPIService) PmarginCreateAutoCollectionV1Execute(r ApiPmarginCreateAutoCollectionV1Request) (*PmarginCreateAutoCollectionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateAutoCollectionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginCreateAutoCollectionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/auto-collection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginCreateBnbTransferV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	amount *string
	timestamp *int64
	transferSide *string
	recvWindow *int64
}

func (r ApiPmarginCreateBnbTransferV1Request) Amount(amount string) ApiPmarginCreateBnbTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiPmarginCreateBnbTransferV1Request) Timestamp(timestamp int64) ApiPmarginCreateBnbTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginCreateBnbTransferV1Request) TransferSide(transferSide string) ApiPmarginCreateBnbTransferV1Request {
	r.transferSide = &transferSide
	return r
}

func (r ApiPmarginCreateBnbTransferV1Request) RecvWindow(recvWindow int64) ApiPmarginCreateBnbTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginCreateBnbTransferV1Request) Execute() (*PmarginCreateBnbTransferV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateBnbTransferV1Execute(r)
}

/*
PmarginCreateBnbTransferV1 BNB transfer (TRADE)

Transfer BNB in and out of UM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginCreateBnbTransferV1Request
*/
func (a *AccountAPIService) PmarginCreateBnbTransferV1(ctx context.Context) ApiPmarginCreateBnbTransferV1Request {
	return ApiPmarginCreateBnbTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateBnbTransferV1Resp
func (a *AccountAPIService) PmarginCreateBnbTransferV1Execute(r ApiPmarginCreateBnbTransferV1Request) (*PmarginCreateBnbTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateBnbTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginCreateBnbTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/bnb-transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.transferSide == nil {
		return localVarReturnValue, nil, reportError("transferSide is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "transferSide", r.transferSide, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginCreateCmLeverageV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	leverage *int32
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginCreateCmLeverageV1Request) Leverage(leverage int32) ApiPmarginCreateCmLeverageV1Request {
	r.leverage = &leverage
	return r
}

func (r ApiPmarginCreateCmLeverageV1Request) Symbol(symbol string) ApiPmarginCreateCmLeverageV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiPmarginCreateCmLeverageV1Request) Timestamp(timestamp int64) ApiPmarginCreateCmLeverageV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginCreateCmLeverageV1Request) RecvWindow(recvWindow int64) ApiPmarginCreateCmLeverageV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginCreateCmLeverageV1Request) Execute() (*PmarginCreateCmLeverageV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateCmLeverageV1Execute(r)
}

/*
PmarginCreateCmLeverageV1 Change CM Initial Leverage (TRADE)

Change user's initial leverage of specific symbol in CM.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginCreateCmLeverageV1Request
*/
func (a *AccountAPIService) PmarginCreateCmLeverageV1(ctx context.Context) ApiPmarginCreateCmLeverageV1Request {
	return ApiPmarginCreateCmLeverageV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateCmLeverageV1Resp
func (a *AccountAPIService) PmarginCreateCmLeverageV1Execute(r ApiPmarginCreateCmLeverageV1Request) (*PmarginCreateCmLeverageV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateCmLeverageV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginCreateCmLeverageV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/leverage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leverage == nil {
		return localVarReturnValue, nil, reportError("leverage is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "leverage", r.leverage, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginCreateCmPositionSideDualV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	dualSidePosition *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginCreateCmPositionSideDualV1Request) DualSidePosition(dualSidePosition string) ApiPmarginCreateCmPositionSideDualV1Request {
	r.dualSidePosition = &dualSidePosition
	return r
}

func (r ApiPmarginCreateCmPositionSideDualV1Request) Timestamp(timestamp int64) ApiPmarginCreateCmPositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginCreateCmPositionSideDualV1Request) RecvWindow(recvWindow int64) ApiPmarginCreateCmPositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginCreateCmPositionSideDualV1Request) Execute() (*PmarginCreateCmPositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateCmPositionSideDualV1Execute(r)
}

/*
PmarginCreateCmPositionSideDualV1 Change CM Position Mode(TRADE)

Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginCreateCmPositionSideDualV1Request
*/
func (a *AccountAPIService) PmarginCreateCmPositionSideDualV1(ctx context.Context) ApiPmarginCreateCmPositionSideDualV1Request {
	return ApiPmarginCreateCmPositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateCmPositionSideDualV1Resp
func (a *AccountAPIService) PmarginCreateCmPositionSideDualV1Execute(r ApiPmarginCreateCmPositionSideDualV1Request) (*PmarginCreateCmPositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateCmPositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginCreateCmPositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dualSidePosition == nil {
		return localVarReturnValue, nil, reportError("dualSidePosition is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "dualSidePosition", r.dualSidePosition, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginCreateRepayFuturesNegativeBalanceV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginCreateRepayFuturesNegativeBalanceV1Request) Timestamp(timestamp int64) ApiPmarginCreateRepayFuturesNegativeBalanceV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginCreateRepayFuturesNegativeBalanceV1Request) RecvWindow(recvWindow int64) ApiPmarginCreateRepayFuturesNegativeBalanceV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginCreateRepayFuturesNegativeBalanceV1Request) Execute() (*PmarginCreateRepayFuturesNegativeBalanceV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateRepayFuturesNegativeBalanceV1Execute(r)
}

/*
PmarginCreateRepayFuturesNegativeBalanceV1 Repay futures Negative Balance(USER_DATA)

Repay futures Negative Balance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginCreateRepayFuturesNegativeBalanceV1Request
*/
func (a *AccountAPIService) PmarginCreateRepayFuturesNegativeBalanceV1(ctx context.Context) ApiPmarginCreateRepayFuturesNegativeBalanceV1Request {
	return ApiPmarginCreateRepayFuturesNegativeBalanceV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateRepayFuturesNegativeBalanceV1Resp
func (a *AccountAPIService) PmarginCreateRepayFuturesNegativeBalanceV1Execute(r ApiPmarginCreateRepayFuturesNegativeBalanceV1Request) (*PmarginCreateRepayFuturesNegativeBalanceV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateRepayFuturesNegativeBalanceV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginCreateRepayFuturesNegativeBalanceV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/repay-futures-negative-balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginCreateRepayFuturesSwitchV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	autoRepay *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginCreateRepayFuturesSwitchV1Request) AutoRepay(autoRepay string) ApiPmarginCreateRepayFuturesSwitchV1Request {
	r.autoRepay = &autoRepay
	return r
}

func (r ApiPmarginCreateRepayFuturesSwitchV1Request) Timestamp(timestamp int64) ApiPmarginCreateRepayFuturesSwitchV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginCreateRepayFuturesSwitchV1Request) RecvWindow(recvWindow int64) ApiPmarginCreateRepayFuturesSwitchV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginCreateRepayFuturesSwitchV1Request) Execute() (*PmarginCreateRepayFuturesSwitchV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateRepayFuturesSwitchV1Execute(r)
}

/*
PmarginCreateRepayFuturesSwitchV1 Change Auto-repay-futures Status(TRADE)

Change Auto-repay-futures Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginCreateRepayFuturesSwitchV1Request
*/
func (a *AccountAPIService) PmarginCreateRepayFuturesSwitchV1(ctx context.Context) ApiPmarginCreateRepayFuturesSwitchV1Request {
	return ApiPmarginCreateRepayFuturesSwitchV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateRepayFuturesSwitchV1Resp
func (a *AccountAPIService) PmarginCreateRepayFuturesSwitchV1Execute(r ApiPmarginCreateRepayFuturesSwitchV1Request) (*PmarginCreateRepayFuturesSwitchV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateRepayFuturesSwitchV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginCreateRepayFuturesSwitchV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/repay-futures-switch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.autoRepay == nil {
		return localVarReturnValue, nil, reportError("autoRepay is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "autoRepay", r.autoRepay, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginCreateUmLeverageV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	leverage *int32
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginCreateUmLeverageV1Request) Leverage(leverage int32) ApiPmarginCreateUmLeverageV1Request {
	r.leverage = &leverage
	return r
}

func (r ApiPmarginCreateUmLeverageV1Request) Symbol(symbol string) ApiPmarginCreateUmLeverageV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiPmarginCreateUmLeverageV1Request) Timestamp(timestamp int64) ApiPmarginCreateUmLeverageV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginCreateUmLeverageV1Request) RecvWindow(recvWindow int64) ApiPmarginCreateUmLeverageV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginCreateUmLeverageV1Request) Execute() (*PmarginCreateUmLeverageV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateUmLeverageV1Execute(r)
}

/*
PmarginCreateUmLeverageV1 Change UM Initial Leverage(TRADE)

Change user's initial leverage of specific symbol in UM.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginCreateUmLeverageV1Request
*/
func (a *AccountAPIService) PmarginCreateUmLeverageV1(ctx context.Context) ApiPmarginCreateUmLeverageV1Request {
	return ApiPmarginCreateUmLeverageV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateUmLeverageV1Resp
func (a *AccountAPIService) PmarginCreateUmLeverageV1Execute(r ApiPmarginCreateUmLeverageV1Request) (*PmarginCreateUmLeverageV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateUmLeverageV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginCreateUmLeverageV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/leverage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leverage == nil {
		return localVarReturnValue, nil, reportError("leverage is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "leverage", r.leverage, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginCreateUmPositionSideDualV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	dualSidePosition *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginCreateUmPositionSideDualV1Request) DualSidePosition(dualSidePosition string) ApiPmarginCreateUmPositionSideDualV1Request {
	r.dualSidePosition = &dualSidePosition
	return r
}

func (r ApiPmarginCreateUmPositionSideDualV1Request) Timestamp(timestamp int64) ApiPmarginCreateUmPositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginCreateUmPositionSideDualV1Request) RecvWindow(recvWindow int64) ApiPmarginCreateUmPositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginCreateUmPositionSideDualV1Request) Execute() (*PmarginCreateUmPositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.PmarginCreateUmPositionSideDualV1Execute(r)
}

/*
PmarginCreateUmPositionSideDualV1 Change UM Position Mode(TRADE)

Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginCreateUmPositionSideDualV1Request
*/
func (a *AccountAPIService) PmarginCreateUmPositionSideDualV1(ctx context.Context) ApiPmarginCreateUmPositionSideDualV1Request {
	return ApiPmarginCreateUmPositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginCreateUmPositionSideDualV1Resp
func (a *AccountAPIService) PmarginCreateUmPositionSideDualV1Execute(r ApiPmarginCreateUmPositionSideDualV1Request) (*PmarginCreateUmPositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginCreateUmPositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginCreateUmPositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dualSidePosition == nil {
		return localVarReturnValue, nil, reportError("dualSidePosition is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "dualSidePosition", r.dualSidePosition, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetAccountV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetAccountV1Request) Timestamp(timestamp int64) ApiPmarginGetAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetAccountV1Request) RecvWindow(recvWindow int64) ApiPmarginGetAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetAccountV1Request) Execute() (*PmarginGetAccountV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetAccountV1Execute(r)
}

/*
PmarginGetAccountV1 Account Information(USER_DATA)

Query account information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetAccountV1Request
*/
func (a *AccountAPIService) PmarginGetAccountV1(ctx context.Context) ApiPmarginGetAccountV1Request {
	return ApiPmarginGetAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetAccountV1Resp
func (a *AccountAPIService) PmarginGetAccountV1Execute(r ApiPmarginGetAccountV1Request) (*PmarginGetAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetBalanceV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	asset *string
	recvWindow *int64
}

func (r ApiPmarginGetBalanceV1Request) Timestamp(timestamp int64) ApiPmarginGetBalanceV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetBalanceV1Request) Asset(asset string) ApiPmarginGetBalanceV1Request {
	r.asset = &asset
	return r
}

func (r ApiPmarginGetBalanceV1Request) RecvWindow(recvWindow int64) ApiPmarginGetBalanceV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetBalanceV1Request) Execute() (*PmarginGetBalanceV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetBalanceV1Execute(r)
}

/*
PmarginGetBalanceV1 Account Balance(USER_DATA)

Query account balance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetBalanceV1Request
*/
func (a *AccountAPIService) PmarginGetBalanceV1(ctx context.Context) ApiPmarginGetBalanceV1Request {
	return ApiPmarginGetBalanceV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetBalanceV1Resp
func (a *AccountAPIService) PmarginGetBalanceV1Execute(r ApiPmarginGetBalanceV1Request) (*PmarginGetBalanceV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetBalanceV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetBalanceV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetCmAccountV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetCmAccountV1Request) Timestamp(timestamp int64) ApiPmarginGetCmAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetCmAccountV1Request) RecvWindow(recvWindow int64) ApiPmarginGetCmAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetCmAccountV1Request) Execute() (*PmarginGetCmAccountV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetCmAccountV1Execute(r)
}

/*
PmarginGetCmAccountV1 Get CM Account Detail(USER_DATA)

Get current CM account asset and position information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetCmAccountV1Request
*/
func (a *AccountAPIService) PmarginGetCmAccountV1(ctx context.Context) ApiPmarginGetCmAccountV1Request {
	return ApiPmarginGetCmAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetCmAccountV1Resp
func (a *AccountAPIService) PmarginGetCmAccountV1Execute(r ApiPmarginGetCmAccountV1Request) (*PmarginGetCmAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetCmAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetCmAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetCmCommissionRateV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetCmCommissionRateV1Request) Symbol(symbol string) ApiPmarginGetCmCommissionRateV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiPmarginGetCmCommissionRateV1Request) Timestamp(timestamp int64) ApiPmarginGetCmCommissionRateV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetCmCommissionRateV1Request) RecvWindow(recvWindow int64) ApiPmarginGetCmCommissionRateV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetCmCommissionRateV1Request) Execute() (*PmarginGetCmCommissionRateV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetCmCommissionRateV1Execute(r)
}

/*
PmarginGetCmCommissionRateV1 Get User Commission Rate for CM(USER_DATA)

Get User Commission Rate for CM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetCmCommissionRateV1Request
*/
func (a *AccountAPIService) PmarginGetCmCommissionRateV1(ctx context.Context) ApiPmarginGetCmCommissionRateV1Request {
	return ApiPmarginGetCmCommissionRateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetCmCommissionRateV1Resp
func (a *AccountAPIService) PmarginGetCmCommissionRateV1Execute(r ApiPmarginGetCmCommissionRateV1Request) (*PmarginGetCmCommissionRateV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetCmCommissionRateV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetCmCommissionRateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/commissionRate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetCmIncomeV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	symbol *string
	incomeType *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ApiPmarginGetCmIncomeV1Request) Timestamp(timestamp int64) ApiPmarginGetCmIncomeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetCmIncomeV1Request) Symbol(symbol string) ApiPmarginGetCmIncomeV1Request {
	r.symbol = &symbol
	return r
}

// &amp;#34;TRANSFER&amp;#34;,&amp;#34;WELCOME_BONUS&amp;#34;, &amp;#34;FUNDING_FEE&amp;#34;, &amp;#34;REALIZED_PNL&amp;#34;, &amp;#34;COMMISSION&amp;#34;, &amp;#34;INSURANCE_CLEAR&amp;#34;, and &amp;#34;DELIVERED_SETTELMENT&amp;#34;
func (r ApiPmarginGetCmIncomeV1Request) IncomeType(incomeType string) ApiPmarginGetCmIncomeV1Request {
	r.incomeType = &incomeType
	return r
}

// Timestamp in ms to get funding from INCLUSIVE.
func (r ApiPmarginGetCmIncomeV1Request) StartTime(startTime int64) ApiPmarginGetCmIncomeV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get funding until INCLUSIVE.
func (r ApiPmarginGetCmIncomeV1Request) EndTime(endTime int64) ApiPmarginGetCmIncomeV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiPmarginGetCmIncomeV1Request) Page(page int32) ApiPmarginGetCmIncomeV1Request {
	r.page = &page
	return r
}

// Default 100; max 1000
func (r ApiPmarginGetCmIncomeV1Request) Limit(limit int32) ApiPmarginGetCmIncomeV1Request {
	r.limit = &limit
	return r
}

func (r ApiPmarginGetCmIncomeV1Request) RecvWindow(recvWindow int64) ApiPmarginGetCmIncomeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetCmIncomeV1Request) Execute() ([]PmarginGetCmIncomeV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmIncomeV1Execute(r)
}

/*
PmarginGetCmIncomeV1 Get CM Income History(USER_DATA)

Get CM Income History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetCmIncomeV1Request
*/
func (a *AccountAPIService) PmarginGetCmIncomeV1(ctx context.Context) ApiPmarginGetCmIncomeV1Request {
	return ApiPmarginGetCmIncomeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmIncomeV1RespItem
func (a *AccountAPIService) PmarginGetCmIncomeV1Execute(r ApiPmarginGetCmIncomeV1Request) ([]PmarginGetCmIncomeV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmIncomeV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetCmIncomeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/income"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.incomeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incomeType", r.incomeType, "form", "")
	} else {
		var defaultValue string = ""
		r.incomeType = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetCmLeverageBracketV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiPmarginGetCmLeverageBracketV1Request) Timestamp(timestamp int64) ApiPmarginGetCmLeverageBracketV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetCmLeverageBracketV1Request) Symbol(symbol string) ApiPmarginGetCmLeverageBracketV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiPmarginGetCmLeverageBracketV1Request) RecvWindow(recvWindow int64) ApiPmarginGetCmLeverageBracketV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetCmLeverageBracketV1Request) Execute() ([]PmarginGetCmLeverageBracketV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmLeverageBracketV1Execute(r)
}

/*
PmarginGetCmLeverageBracketV1 CM Notional and Leverage Brackets(USER_DATA)

Query CM notional and leverage brackets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetCmLeverageBracketV1Request
*/
func (a *AccountAPIService) PmarginGetCmLeverageBracketV1(ctx context.Context) ApiPmarginGetCmLeverageBracketV1Request {
	return ApiPmarginGetCmLeverageBracketV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmLeverageBracketV1RespItem
func (a *AccountAPIService) PmarginGetCmLeverageBracketV1Execute(r ApiPmarginGetCmLeverageBracketV1Request) ([]PmarginGetCmLeverageBracketV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmLeverageBracketV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetCmLeverageBracketV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/leverageBracket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetCmPositionRiskV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	marginAsset *string
	pair *string
	recvWindow *int64
}

func (r ApiPmarginGetCmPositionRiskV1Request) Timestamp(timestamp int64) ApiPmarginGetCmPositionRiskV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetCmPositionRiskV1Request) MarginAsset(marginAsset string) ApiPmarginGetCmPositionRiskV1Request {
	r.marginAsset = &marginAsset
	return r
}

func (r ApiPmarginGetCmPositionRiskV1Request) Pair(pair string) ApiPmarginGetCmPositionRiskV1Request {
	r.pair = &pair
	return r
}

func (r ApiPmarginGetCmPositionRiskV1Request) RecvWindow(recvWindow int64) ApiPmarginGetCmPositionRiskV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetCmPositionRiskV1Request) Execute() ([]PmarginGetCmPositionRiskV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetCmPositionRiskV1Execute(r)
}

/*
PmarginGetCmPositionRiskV1 Query CM Position Information(USER_DATA)

Get current CM position information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetCmPositionRiskV1Request
*/
func (a *AccountAPIService) PmarginGetCmPositionRiskV1(ctx context.Context) ApiPmarginGetCmPositionRiskV1Request {
	return ApiPmarginGetCmPositionRiskV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetCmPositionRiskV1RespItem
func (a *AccountAPIService) PmarginGetCmPositionRiskV1Execute(r ApiPmarginGetCmPositionRiskV1Request) ([]PmarginGetCmPositionRiskV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetCmPositionRiskV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetCmPositionRiskV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.marginAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "marginAsset", r.marginAsset, "form", "")
	} else {
		var defaultValue string = ""
		r.marginAsset = &defaultValue
	}
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	} else {
		var defaultValue string = ""
		r.pair = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetCmPositionSideDualV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetCmPositionSideDualV1Request) Timestamp(timestamp int64) ApiPmarginGetCmPositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetCmPositionSideDualV1Request) RecvWindow(recvWindow int64) ApiPmarginGetCmPositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetCmPositionSideDualV1Request) Execute() (*PmarginGetCmPositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetCmPositionSideDualV1Execute(r)
}

/*
PmarginGetCmPositionSideDualV1 Get CM Current Position Mode(USER_DATA)

Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetCmPositionSideDualV1Request
*/
func (a *AccountAPIService) PmarginGetCmPositionSideDualV1(ctx context.Context) ApiPmarginGetCmPositionSideDualV1Request {
	return ApiPmarginGetCmPositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetCmPositionSideDualV1Resp
func (a *AccountAPIService) PmarginGetCmPositionSideDualV1Execute(r ApiPmarginGetCmPositionSideDualV1Request) (*PmarginGetCmPositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetCmPositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetCmPositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/cm/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetMarginMarginInterestHistoryV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	asset *string
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	archived *string
	recvWindow *int64
}

func (r ApiPmarginGetMarginMarginInterestHistoryV1Request) Timestamp(timestamp int64) ApiPmarginGetMarginMarginInterestHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetMarginMarginInterestHistoryV1Request) Asset(asset string) ApiPmarginGetMarginMarginInterestHistoryV1Request {
	r.asset = &asset
	return r
}

func (r ApiPmarginGetMarginMarginInterestHistoryV1Request) StartTime(startTime int64) ApiPmarginGetMarginMarginInterestHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiPmarginGetMarginMarginInterestHistoryV1Request) EndTime(endTime int64) ApiPmarginGetMarginMarginInterestHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiPmarginGetMarginMarginInterestHistoryV1Request) Current(current int64) ApiPmarginGetMarginMarginInterestHistoryV1Request {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiPmarginGetMarginMarginInterestHistoryV1Request) Size(size int64) ApiPmarginGetMarginMarginInterestHistoryV1Request {
	r.size = &size
	return r
}

// Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
func (r ApiPmarginGetMarginMarginInterestHistoryV1Request) Archived(archived string) ApiPmarginGetMarginMarginInterestHistoryV1Request {
	r.archived = &archived
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiPmarginGetMarginMarginInterestHistoryV1Request) RecvWindow(recvWindow int64) ApiPmarginGetMarginMarginInterestHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetMarginMarginInterestHistoryV1Request) Execute() (*PmarginGetMarginMarginInterestHistoryV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginMarginInterestHistoryV1Execute(r)
}

/*
PmarginGetMarginMarginInterestHistoryV1 Get Margin Borrow/Loan Interest History(USER_DATA)

Get Margin Borrow/Loan Interest History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetMarginMarginInterestHistoryV1Request
*/
func (a *AccountAPIService) PmarginGetMarginMarginInterestHistoryV1(ctx context.Context) ApiPmarginGetMarginMarginInterestHistoryV1Request {
	return ApiPmarginGetMarginMarginInterestHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginMarginInterestHistoryV1Resp
func (a *AccountAPIService) PmarginGetMarginMarginInterestHistoryV1Execute(r ApiPmarginGetMarginMarginInterestHistoryV1Request) (*PmarginGetMarginMarginInterestHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginMarginInterestHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetMarginMarginInterestHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/marginInterestHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	} else {
		var defaultValue string = ""
		r.archived = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetMarginMarginLoanV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	asset *string
	timestamp *int64
	txId *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	archived *string
	recvWindow *int64
}

func (r ApiPmarginGetMarginMarginLoanV1Request) Asset(asset string) ApiPmarginGetMarginMarginLoanV1Request {
	r.asset = &asset
	return r
}

func (r ApiPmarginGetMarginMarginLoanV1Request) Timestamp(timestamp int64) ApiPmarginGetMarginMarginLoanV1Request {
	r.timestamp = &timestamp
	return r
}

// the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60;
func (r ApiPmarginGetMarginMarginLoanV1Request) TxId(txId int64) ApiPmarginGetMarginMarginLoanV1Request {
	r.txId = &txId
	return r
}

func (r ApiPmarginGetMarginMarginLoanV1Request) StartTime(startTime int64) ApiPmarginGetMarginMarginLoanV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiPmarginGetMarginMarginLoanV1Request) EndTime(endTime int64) ApiPmarginGetMarginMarginLoanV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiPmarginGetMarginMarginLoanV1Request) Current(current int64) ApiPmarginGetMarginMarginLoanV1Request {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiPmarginGetMarginMarginLoanV1Request) Size(size int64) ApiPmarginGetMarginMarginLoanV1Request {
	r.size = &size
	return r
}

// Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
func (r ApiPmarginGetMarginMarginLoanV1Request) Archived(archived string) ApiPmarginGetMarginMarginLoanV1Request {
	r.archived = &archived
	return r
}

// The value cannot be greater than 60000
func (r ApiPmarginGetMarginMarginLoanV1Request) RecvWindow(recvWindow int64) ApiPmarginGetMarginMarginLoanV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetMarginMarginLoanV1Request) Execute() (*PmarginGetMarginMarginLoanV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginMarginLoanV1Execute(r)
}

/*
PmarginGetMarginMarginLoanV1 Query Margin Loan Record(USER_DATA)

Query margin loan record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetMarginMarginLoanV1Request
*/
func (a *AccountAPIService) PmarginGetMarginMarginLoanV1(ctx context.Context) ApiPmarginGetMarginMarginLoanV1Request {
	return ApiPmarginGetMarginMarginLoanV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginMarginLoanV1Resp
func (a *AccountAPIService) PmarginGetMarginMarginLoanV1Execute(r ApiPmarginGetMarginMarginLoanV1Request) (*PmarginGetMarginMarginLoanV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginMarginLoanV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetMarginMarginLoanV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/marginLoan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	} else {
		var defaultValue string = ""
		r.archived = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetMarginMaxBorrowableV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetMarginMaxBorrowableV1Request) Asset(asset string) ApiPmarginGetMarginMaxBorrowableV1Request {
	r.asset = &asset
	return r
}

func (r ApiPmarginGetMarginMaxBorrowableV1Request) Timestamp(timestamp int64) ApiPmarginGetMarginMaxBorrowableV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiPmarginGetMarginMaxBorrowableV1Request) RecvWindow(recvWindow int64) ApiPmarginGetMarginMaxBorrowableV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetMarginMaxBorrowableV1Request) Execute() (*PmarginGetMarginMaxBorrowableV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginMaxBorrowableV1Execute(r)
}

/*
PmarginGetMarginMaxBorrowableV1 Margin Max Borrow(USER_DATA)

Query margin max borrow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetMarginMaxBorrowableV1Request
*/
func (a *AccountAPIService) PmarginGetMarginMaxBorrowableV1(ctx context.Context) ApiPmarginGetMarginMaxBorrowableV1Request {
	return ApiPmarginGetMarginMaxBorrowableV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginMaxBorrowableV1Resp
func (a *AccountAPIService) PmarginGetMarginMaxBorrowableV1Execute(r ApiPmarginGetMarginMaxBorrowableV1Request) (*PmarginGetMarginMaxBorrowableV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginMaxBorrowableV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetMarginMaxBorrowableV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/maxBorrowable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetMarginMaxWithdrawV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetMarginMaxWithdrawV1Request) Asset(asset string) ApiPmarginGetMarginMaxWithdrawV1Request {
	r.asset = &asset
	return r
}

func (r ApiPmarginGetMarginMaxWithdrawV1Request) Timestamp(timestamp int64) ApiPmarginGetMarginMaxWithdrawV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiPmarginGetMarginMaxWithdrawV1Request) RecvWindow(recvWindow int64) ApiPmarginGetMarginMaxWithdrawV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetMarginMaxWithdrawV1Request) Execute() (*PmarginGetMarginMaxWithdrawV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginMaxWithdrawV1Execute(r)
}

/*
PmarginGetMarginMaxWithdrawV1 Query Margin Max Withdraw(USER_DATA)

Query Margin Max Withdraw

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetMarginMaxWithdrawV1Request
*/
func (a *AccountAPIService) PmarginGetMarginMaxWithdrawV1(ctx context.Context) ApiPmarginGetMarginMaxWithdrawV1Request {
	return ApiPmarginGetMarginMaxWithdrawV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginMaxWithdrawV1Resp
func (a *AccountAPIService) PmarginGetMarginMaxWithdrawV1Execute(r ApiPmarginGetMarginMaxWithdrawV1Request) (*PmarginGetMarginMaxWithdrawV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginMaxWithdrawV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetMarginMaxWithdrawV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/maxWithdraw"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetMarginRepayLoanV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	asset *string
	timestamp *int64
	txId *int64
	startTime *int64
	endTime *int64
	current *int64
	size *int64
	archived *string
	recvWindow *int64
}

func (r ApiPmarginGetMarginRepayLoanV1Request) Asset(asset string) ApiPmarginGetMarginRepayLoanV1Request {
	r.asset = &asset
	return r
}

func (r ApiPmarginGetMarginRepayLoanV1Request) Timestamp(timestamp int64) ApiPmarginGetMarginRepayLoanV1Request {
	r.timestamp = &timestamp
	return r
}

// the tranId in &#x60;POST/papi/v1/repayLoan&#x60;
func (r ApiPmarginGetMarginRepayLoanV1Request) TxId(txId int64) ApiPmarginGetMarginRepayLoanV1Request {
	r.txId = &txId
	return r
}

func (r ApiPmarginGetMarginRepayLoanV1Request) StartTime(startTime int64) ApiPmarginGetMarginRepayLoanV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiPmarginGetMarginRepayLoanV1Request) EndTime(endTime int64) ApiPmarginGetMarginRepayLoanV1Request {
	r.endTime = &endTime
	return r
}

// Currently querying page. Start from 1. Default:1
func (r ApiPmarginGetMarginRepayLoanV1Request) Current(current int64) ApiPmarginGetMarginRepayLoanV1Request {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiPmarginGetMarginRepayLoanV1Request) Size(size int64) ApiPmarginGetMarginRepayLoanV1Request {
	r.size = &size
	return r
}

// Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago
func (r ApiPmarginGetMarginRepayLoanV1Request) Archived(archived string) ApiPmarginGetMarginRepayLoanV1Request {
	r.archived = &archived
	return r
}

// The value cannot be greater than 60000
func (r ApiPmarginGetMarginRepayLoanV1Request) RecvWindow(recvWindow int64) ApiPmarginGetMarginRepayLoanV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetMarginRepayLoanV1Request) Execute() (*PmarginGetMarginRepayLoanV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetMarginRepayLoanV1Execute(r)
}

/*
PmarginGetMarginRepayLoanV1 Query Margin repay Record(USER_DATA)

Query margin repay record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetMarginRepayLoanV1Request
*/
func (a *AccountAPIService) PmarginGetMarginRepayLoanV1(ctx context.Context) ApiPmarginGetMarginRepayLoanV1Request {
	return ApiPmarginGetMarginRepayLoanV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetMarginRepayLoanV1Resp
func (a *AccountAPIService) PmarginGetMarginRepayLoanV1Execute(r ApiPmarginGetMarginRepayLoanV1Request) (*PmarginGetMarginRepayLoanV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetMarginRepayLoanV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetMarginRepayLoanV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/margin/repayLoan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	} else {
		var defaultValue string = ""
		r.archived = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetPortfolioInterestHistoryV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	asset *string
	startTime *int64
	endTime *int64
	size *int64
	recvWindow *int64
}

func (r ApiPmarginGetPortfolioInterestHistoryV1Request) Timestamp(timestamp int64) ApiPmarginGetPortfolioInterestHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetPortfolioInterestHistoryV1Request) Asset(asset string) ApiPmarginGetPortfolioInterestHistoryV1Request {
	r.asset = &asset
	return r
}

func (r ApiPmarginGetPortfolioInterestHistoryV1Request) StartTime(startTime int64) ApiPmarginGetPortfolioInterestHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiPmarginGetPortfolioInterestHistoryV1Request) EndTime(endTime int64) ApiPmarginGetPortfolioInterestHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default:10 Max:100
func (r ApiPmarginGetPortfolioInterestHistoryV1Request) Size(size int64) ApiPmarginGetPortfolioInterestHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiPmarginGetPortfolioInterestHistoryV1Request) RecvWindow(recvWindow int64) ApiPmarginGetPortfolioInterestHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetPortfolioInterestHistoryV1Request) Execute() ([]PmarginGetPortfolioInterestHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetPortfolioInterestHistoryV1Execute(r)
}

/*
PmarginGetPortfolioInterestHistoryV1 Query Portfolio Margin Negative Balance Interest History(USER_DATA)

Query interest history of negative balance for portfolio margin.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetPortfolioInterestHistoryV1Request
*/
func (a *AccountAPIService) PmarginGetPortfolioInterestHistoryV1(ctx context.Context) ApiPmarginGetPortfolioInterestHistoryV1Request {
	return ApiPmarginGetPortfolioInterestHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetPortfolioInterestHistoryV1RespItem
func (a *AccountAPIService) PmarginGetPortfolioInterestHistoryV1Execute(r ApiPmarginGetPortfolioInterestHistoryV1Request) ([]PmarginGetPortfolioInterestHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetPortfolioInterestHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetPortfolioInterestHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/portfolio/interest-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) StartTime(startTime int64) ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) EndTime(endTime int64) ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) Timestamp(timestamp int64) ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than 60000
func (r ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) RecvWindow(recvWindow int64) ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) Execute() (*PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetPortfolioNegativeBalanceExchangeRecordV1Execute(r)
}

/*
PmarginGetPortfolioNegativeBalanceExchangeRecordV1 Query User Negative Balance Auto Exchange Record (USER_DATA)

Query user negative balance auto exchange record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request
*/
func (a *AccountAPIService) PmarginGetPortfolioNegativeBalanceExchangeRecordV1(ctx context.Context) ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request {
	return ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp
func (a *AccountAPIService) PmarginGetPortfolioNegativeBalanceExchangeRecordV1Execute(r ApiPmarginGetPortfolioNegativeBalanceExchangeRecordV1Request) (*PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetPortfolioNegativeBalanceExchangeRecordV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetPortfolioNegativeBalanceExchangeRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/portfolio/negative-balance-exchange-record"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetRateLimitOrderV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetRateLimitOrderV1Request) Timestamp(timestamp int64) ApiPmarginGetRateLimitOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetRateLimitOrderV1Request) RecvWindow(recvWindow int64) ApiPmarginGetRateLimitOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetRateLimitOrderV1Request) Execute() ([]PmarginGetRateLimitOrderV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetRateLimitOrderV1Execute(r)
}

/*
PmarginGetRateLimitOrderV1 Query User Rate Limit (USER_DATA)

Query User Rate Limit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetRateLimitOrderV1Request
*/
func (a *AccountAPIService) PmarginGetRateLimitOrderV1(ctx context.Context) ApiPmarginGetRateLimitOrderV1Request {
	return ApiPmarginGetRateLimitOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetRateLimitOrderV1RespItem
func (a *AccountAPIService) PmarginGetRateLimitOrderV1Execute(r ApiPmarginGetRateLimitOrderV1Request) ([]PmarginGetRateLimitOrderV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetRateLimitOrderV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetRateLimitOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/rateLimit/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetRepayFuturesSwitchV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetRepayFuturesSwitchV1Request) Timestamp(timestamp int64) ApiPmarginGetRepayFuturesSwitchV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetRepayFuturesSwitchV1Request) RecvWindow(recvWindow int64) ApiPmarginGetRepayFuturesSwitchV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetRepayFuturesSwitchV1Request) Execute() (*PmarginGetRepayFuturesSwitchV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetRepayFuturesSwitchV1Execute(r)
}

/*
PmarginGetRepayFuturesSwitchV1 Get Auto-repay-futures Status(USER_DATA)

Query Auto-repay-futures Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetRepayFuturesSwitchV1Request
*/
func (a *AccountAPIService) PmarginGetRepayFuturesSwitchV1(ctx context.Context) ApiPmarginGetRepayFuturesSwitchV1Request {
	return ApiPmarginGetRepayFuturesSwitchV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetRepayFuturesSwitchV1Resp
func (a *AccountAPIService) PmarginGetRepayFuturesSwitchV1Execute(r ApiPmarginGetRepayFuturesSwitchV1Request) (*PmarginGetRepayFuturesSwitchV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetRepayFuturesSwitchV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetRepayFuturesSwitchV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/repay-futures-switch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmAccountConfigV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetUmAccountConfigV1Request) Timestamp(timestamp int64) ApiPmarginGetUmAccountConfigV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmAccountConfigV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmAccountConfigV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmAccountConfigV1Request) Execute() (*PmarginGetUmAccountConfigV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmAccountConfigV1Execute(r)
}

/*
PmarginGetUmAccountConfigV1 UM Futures Account Configuration(USER_DATA)

Query UM Futures account configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmAccountConfigV1Request
*/
func (a *AccountAPIService) PmarginGetUmAccountConfigV1(ctx context.Context) ApiPmarginGetUmAccountConfigV1Request {
	return ApiPmarginGetUmAccountConfigV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmAccountConfigV1Resp
func (a *AccountAPIService) PmarginGetUmAccountConfigV1Execute(r ApiPmarginGetUmAccountConfigV1Request) (*PmarginGetUmAccountConfigV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmAccountConfigV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmAccountConfigV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/accountConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmAccountV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetUmAccountV1Request) Timestamp(timestamp int64) ApiPmarginGetUmAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmAccountV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmAccountV1Request) Execute() (*PmarginGetUmAccountV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmAccountV1Execute(r)
}

/*
PmarginGetUmAccountV1 Get UM Account Detail(USER_DATA)

Get current UM account asset and position information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmAccountV1Request
*/
func (a *AccountAPIService) PmarginGetUmAccountV1(ctx context.Context) ApiPmarginGetUmAccountV1Request {
	return ApiPmarginGetUmAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmAccountV1Resp
func (a *AccountAPIService) PmarginGetUmAccountV1Execute(r ApiPmarginGetUmAccountV1Request) (*PmarginGetUmAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmAccountV2Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetUmAccountV2Request) Timestamp(timestamp int64) ApiPmarginGetUmAccountV2Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmAccountV2Request) RecvWindow(recvWindow int64) ApiPmarginGetUmAccountV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmAccountV2Request) Execute() (*PmarginGetUmAccountV2Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmAccountV2Execute(r)
}

/*
PmarginGetUmAccountV2 Get UM Account Detail V2(USER_DATA)

Get current UM account asset and position information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmAccountV2Request
*/
func (a *AccountAPIService) PmarginGetUmAccountV2(ctx context.Context) ApiPmarginGetUmAccountV2Request {
	return ApiPmarginGetUmAccountV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmAccountV2Resp
func (a *AccountAPIService) PmarginGetUmAccountV2Execute(r ApiPmarginGetUmAccountV2Request) (*PmarginGetUmAccountV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmAccountV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmAccountV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v2/um/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmApiTradingStatusV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiPmarginGetUmApiTradingStatusV1Request) Timestamp(timestamp int64) ApiPmarginGetUmApiTradingStatusV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmApiTradingStatusV1Request) Symbol(symbol string) ApiPmarginGetUmApiTradingStatusV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiPmarginGetUmApiTradingStatusV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmApiTradingStatusV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmApiTradingStatusV1Request) Execute() (*PmarginGetUmApiTradingStatusV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmApiTradingStatusV1Execute(r)
}

/*
PmarginGetUmApiTradingStatusV1 Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)

Portfolio Margin UM Trading Quantitative Rules Indicators

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmApiTradingStatusV1Request
*/
func (a *AccountAPIService) PmarginGetUmApiTradingStatusV1(ctx context.Context) ApiPmarginGetUmApiTradingStatusV1Request {
	return ApiPmarginGetUmApiTradingStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmApiTradingStatusV1Resp
func (a *AccountAPIService) PmarginGetUmApiTradingStatusV1Execute(r ApiPmarginGetUmApiTradingStatusV1Request) (*PmarginGetUmApiTradingStatusV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmApiTradingStatusV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmApiTradingStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/apiTradingStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmCommissionRateV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetUmCommissionRateV1Request) Symbol(symbol string) ApiPmarginGetUmCommissionRateV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiPmarginGetUmCommissionRateV1Request) Timestamp(timestamp int64) ApiPmarginGetUmCommissionRateV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmCommissionRateV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmCommissionRateV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmCommissionRateV1Request) Execute() (*PmarginGetUmCommissionRateV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmCommissionRateV1Execute(r)
}

/*
PmarginGetUmCommissionRateV1 Get User Commission Rate for UM(USER_DATA)

Get User Commission Rate for UM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmCommissionRateV1Request
*/
func (a *AccountAPIService) PmarginGetUmCommissionRateV1(ctx context.Context) ApiPmarginGetUmCommissionRateV1Request {
	return ApiPmarginGetUmCommissionRateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmCommissionRateV1Resp
func (a *AccountAPIService) PmarginGetUmCommissionRateV1Execute(r ApiPmarginGetUmCommissionRateV1Request) (*PmarginGetUmCommissionRateV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmCommissionRateV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmCommissionRateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/commissionRate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmIncomeAsynIdV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	downloadId *string
	timestamp *int64
	recvWindow *int64
}

// get by download id api
func (r ApiPmarginGetUmIncomeAsynIdV1Request) DownloadId(downloadId string) ApiPmarginGetUmIncomeAsynIdV1Request {
	r.downloadId = &downloadId
	return r
}

func (r ApiPmarginGetUmIncomeAsynIdV1Request) Timestamp(timestamp int64) ApiPmarginGetUmIncomeAsynIdV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmIncomeAsynIdV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmIncomeAsynIdV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmIncomeAsynIdV1Request) Execute() (*PmarginGetUmIncomeAsynIdV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmIncomeAsynIdV1Execute(r)
}

/*
PmarginGetUmIncomeAsynIdV1 Get UM Futures Transaction Download Link by Id(USER_DATA)

Get UM futures Transaction download link by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmIncomeAsynIdV1Request
*/
func (a *AccountAPIService) PmarginGetUmIncomeAsynIdV1(ctx context.Context) ApiPmarginGetUmIncomeAsynIdV1Request {
	return ApiPmarginGetUmIncomeAsynIdV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmIncomeAsynIdV1Resp
func (a *AccountAPIService) PmarginGetUmIncomeAsynIdV1Execute(r ApiPmarginGetUmIncomeAsynIdV1Request) (*PmarginGetUmIncomeAsynIdV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmIncomeAsynIdV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmIncomeAsynIdV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/income/asyn/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadId == nil {
		return localVarReturnValue, nil, reportError("downloadId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "downloadId", r.downloadId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmIncomeAsynV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

// Timestamp in ms
func (r ApiPmarginGetUmIncomeAsynV1Request) StartTime(startTime int64) ApiPmarginGetUmIncomeAsynV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms
func (r ApiPmarginGetUmIncomeAsynV1Request) EndTime(endTime int64) ApiPmarginGetUmIncomeAsynV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiPmarginGetUmIncomeAsynV1Request) Timestamp(timestamp int64) ApiPmarginGetUmIncomeAsynV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmIncomeAsynV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmIncomeAsynV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmIncomeAsynV1Request) Execute() (*PmarginGetUmIncomeAsynV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmIncomeAsynV1Execute(r)
}

/*
PmarginGetUmIncomeAsynV1 Get Download Id For UM Futures Transaction History (USER_DATA)

Get download id for UM futures transaction history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmIncomeAsynV1Request
*/
func (a *AccountAPIService) PmarginGetUmIncomeAsynV1(ctx context.Context) ApiPmarginGetUmIncomeAsynV1Request {
	return ApiPmarginGetUmIncomeAsynV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmIncomeAsynV1Resp
func (a *AccountAPIService) PmarginGetUmIncomeAsynV1Execute(r ApiPmarginGetUmIncomeAsynV1Request) (*PmarginGetUmIncomeAsynV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmIncomeAsynV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmIncomeAsynV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/income/asyn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmIncomeV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	symbol *string
	incomeType *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ApiPmarginGetUmIncomeV1Request) Timestamp(timestamp int64) ApiPmarginGetUmIncomeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmIncomeV1Request) Symbol(symbol string) ApiPmarginGetUmIncomeV1Request {
	r.symbol = &symbol
	return r
}

// TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
func (r ApiPmarginGetUmIncomeV1Request) IncomeType(incomeType string) ApiPmarginGetUmIncomeV1Request {
	r.incomeType = &incomeType
	return r
}

// Timestamp in ms to get funding from INCLUSIVE.
func (r ApiPmarginGetUmIncomeV1Request) StartTime(startTime int64) ApiPmarginGetUmIncomeV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get funding until INCLUSIVE.
func (r ApiPmarginGetUmIncomeV1Request) EndTime(endTime int64) ApiPmarginGetUmIncomeV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiPmarginGetUmIncomeV1Request) Page(page int32) ApiPmarginGetUmIncomeV1Request {
	r.page = &page
	return r
}

// Default 100; max 1000
func (r ApiPmarginGetUmIncomeV1Request) Limit(limit int32) ApiPmarginGetUmIncomeV1Request {
	r.limit = &limit
	return r
}

func (r ApiPmarginGetUmIncomeV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmIncomeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmIncomeV1Request) Execute() ([]PmarginGetUmIncomeV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmIncomeV1Execute(r)
}

/*
PmarginGetUmIncomeV1 Get UM Income History(USER_DATA)

Get UM Income History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmIncomeV1Request
*/
func (a *AccountAPIService) PmarginGetUmIncomeV1(ctx context.Context) ApiPmarginGetUmIncomeV1Request {
	return ApiPmarginGetUmIncomeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmIncomeV1RespItem
func (a *AccountAPIService) PmarginGetUmIncomeV1Execute(r ApiPmarginGetUmIncomeV1Request) ([]PmarginGetUmIncomeV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmIncomeV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmIncomeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/income"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.incomeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incomeType", r.incomeType, "form", "")
	} else {
		var defaultValue string = ""
		r.incomeType = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmLeverageBracketV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiPmarginGetUmLeverageBracketV1Request) Timestamp(timestamp int64) ApiPmarginGetUmLeverageBracketV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmLeverageBracketV1Request) Symbol(symbol string) ApiPmarginGetUmLeverageBracketV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiPmarginGetUmLeverageBracketV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmLeverageBracketV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmLeverageBracketV1Request) Execute() ([]PmarginGetUmLeverageBracketV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmLeverageBracketV1Execute(r)
}

/*
PmarginGetUmLeverageBracketV1 UM Notional and Leverage Brackets (USER_DATA)

Query UM notional and leverage brackets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmLeverageBracketV1Request
*/
func (a *AccountAPIService) PmarginGetUmLeverageBracketV1(ctx context.Context) ApiPmarginGetUmLeverageBracketV1Request {
	return ApiPmarginGetUmLeverageBracketV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmLeverageBracketV1RespItem
func (a *AccountAPIService) PmarginGetUmLeverageBracketV1Execute(r ApiPmarginGetUmLeverageBracketV1Request) ([]PmarginGetUmLeverageBracketV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmLeverageBracketV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmLeverageBracketV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/leverageBracket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmOrderAsynIdV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	downloadId *string
	timestamp *int64
	recvWindow *int64
}

// get by download id api
func (r ApiPmarginGetUmOrderAsynIdV1Request) DownloadId(downloadId string) ApiPmarginGetUmOrderAsynIdV1Request {
	r.downloadId = &downloadId
	return r
}

func (r ApiPmarginGetUmOrderAsynIdV1Request) Timestamp(timestamp int64) ApiPmarginGetUmOrderAsynIdV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmOrderAsynIdV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmOrderAsynIdV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmOrderAsynIdV1Request) Execute() (*PmarginGetUmOrderAsynIdV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmOrderAsynIdV1Execute(r)
}

/*
PmarginGetUmOrderAsynIdV1 Get UM Futures Order Download Link by Id(USER_DATA)

Get UM futures order download link by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmOrderAsynIdV1Request
*/
func (a *AccountAPIService) PmarginGetUmOrderAsynIdV1(ctx context.Context) ApiPmarginGetUmOrderAsynIdV1Request {
	return ApiPmarginGetUmOrderAsynIdV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmOrderAsynIdV1Resp
func (a *AccountAPIService) PmarginGetUmOrderAsynIdV1Execute(r ApiPmarginGetUmOrderAsynIdV1Request) (*PmarginGetUmOrderAsynIdV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmOrderAsynIdV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmOrderAsynIdV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/order/asyn/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadId == nil {
		return localVarReturnValue, nil, reportError("downloadId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "downloadId", r.downloadId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmOrderAsynV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

// Timestamp in ms
func (r ApiPmarginGetUmOrderAsynV1Request) StartTime(startTime int64) ApiPmarginGetUmOrderAsynV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms
func (r ApiPmarginGetUmOrderAsynV1Request) EndTime(endTime int64) ApiPmarginGetUmOrderAsynV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiPmarginGetUmOrderAsynV1Request) Timestamp(timestamp int64) ApiPmarginGetUmOrderAsynV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmOrderAsynV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmOrderAsynV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmOrderAsynV1Request) Execute() (*PmarginGetUmOrderAsynV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmOrderAsynV1Execute(r)
}

/*
PmarginGetUmOrderAsynV1 Get Download Id For UM Futures Order History (USER_DATA)

Get download id for UM futures order history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmOrderAsynV1Request
*/
func (a *AccountAPIService) PmarginGetUmOrderAsynV1(ctx context.Context) ApiPmarginGetUmOrderAsynV1Request {
	return ApiPmarginGetUmOrderAsynV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmOrderAsynV1Resp
func (a *AccountAPIService) PmarginGetUmOrderAsynV1Execute(r ApiPmarginGetUmOrderAsynV1Request) (*PmarginGetUmOrderAsynV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmOrderAsynV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmOrderAsynV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/order/asyn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmPositionRiskV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
}

func (r ApiPmarginGetUmPositionRiskV1Request) Execute() ([]PmarginGetUmPositionRiskV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmPositionRiskV1Execute(r)
}

/*
PmarginGetUmPositionRiskV1 Query UM Position Information(USER_DATA)

Get current UM position information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmPositionRiskV1Request
*/
func (a *AccountAPIService) PmarginGetUmPositionRiskV1(ctx context.Context) ApiPmarginGetUmPositionRiskV1Request {
	return ApiPmarginGetUmPositionRiskV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmPositionRiskV1RespItem
func (a *AccountAPIService) PmarginGetUmPositionRiskV1Execute(r ApiPmarginGetUmPositionRiskV1Request) ([]PmarginGetUmPositionRiskV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmPositionRiskV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmPositionRiskV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmPositionSideDualV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiPmarginGetUmPositionSideDualV1Request) Timestamp(timestamp int64) ApiPmarginGetUmPositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmPositionSideDualV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmPositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmPositionSideDualV1Request) Execute() (*PmarginGetUmPositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmPositionSideDualV1Execute(r)
}

/*
PmarginGetUmPositionSideDualV1 Get UM Current Position Mode(USER_DATA)

Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmPositionSideDualV1Request
*/
func (a *AccountAPIService) PmarginGetUmPositionSideDualV1(ctx context.Context) ApiPmarginGetUmPositionSideDualV1Request {
	return ApiPmarginGetUmPositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmPositionSideDualV1Resp
func (a *AccountAPIService) PmarginGetUmPositionSideDualV1Execute(r ApiPmarginGetUmPositionSideDualV1Request) (*PmarginGetUmPositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmPositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmPositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmSymbolConfigV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiPmarginGetUmSymbolConfigV1Request) Timestamp(timestamp int64) ApiPmarginGetUmSymbolConfigV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmSymbolConfigV1Request) Symbol(symbol string) ApiPmarginGetUmSymbolConfigV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiPmarginGetUmSymbolConfigV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmSymbolConfigV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmSymbolConfigV1Request) Execute() ([]PmarginGetUmSymbolConfigV1RespItem, *http.Response, error) {
	return r.ApiService.PmarginGetUmSymbolConfigV1Execute(r)
}

/*
PmarginGetUmSymbolConfigV1 UM Futures Symbol Configuration(USER_DATA)

Get current UM account symbol configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmSymbolConfigV1Request
*/
func (a *AccountAPIService) PmarginGetUmSymbolConfigV1(ctx context.Context) ApiPmarginGetUmSymbolConfigV1Request {
	return ApiPmarginGetUmSymbolConfigV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PmarginGetUmSymbolConfigV1RespItem
func (a *AccountAPIService) PmarginGetUmSymbolConfigV1Execute(r ApiPmarginGetUmSymbolConfigV1Request) ([]PmarginGetUmSymbolConfigV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PmarginGetUmSymbolConfigV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmSymbolConfigV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/symbolConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmTradeAsynIdV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	downloadId *string
	timestamp *int64
	recvWindow *int64
}

// get by download id api
func (r ApiPmarginGetUmTradeAsynIdV1Request) DownloadId(downloadId string) ApiPmarginGetUmTradeAsynIdV1Request {
	r.downloadId = &downloadId
	return r
}

func (r ApiPmarginGetUmTradeAsynIdV1Request) Timestamp(timestamp int64) ApiPmarginGetUmTradeAsynIdV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmTradeAsynIdV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmTradeAsynIdV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmTradeAsynIdV1Request) Execute() (*PmarginGetUmTradeAsynIdV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmTradeAsynIdV1Execute(r)
}

/*
PmarginGetUmTradeAsynIdV1 Get UM Futures Trade Download Link by Id(USER_DATA)

Get UM futures trade download link by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmTradeAsynIdV1Request
*/
func (a *AccountAPIService) PmarginGetUmTradeAsynIdV1(ctx context.Context) ApiPmarginGetUmTradeAsynIdV1Request {
	return ApiPmarginGetUmTradeAsynIdV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmTradeAsynIdV1Resp
func (a *AccountAPIService) PmarginGetUmTradeAsynIdV1Execute(r ApiPmarginGetUmTradeAsynIdV1Request) (*PmarginGetUmTradeAsynIdV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmTradeAsynIdV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmTradeAsynIdV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/trade/asyn/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadId == nil {
		return localVarReturnValue, nil, reportError("downloadId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "downloadId", r.downloadId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPmarginGetUmTradeAsynV1Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

// Timestamp in ms
func (r ApiPmarginGetUmTradeAsynV1Request) StartTime(startTime int64) ApiPmarginGetUmTradeAsynV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms
func (r ApiPmarginGetUmTradeAsynV1Request) EndTime(endTime int64) ApiPmarginGetUmTradeAsynV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiPmarginGetUmTradeAsynV1Request) Timestamp(timestamp int64) ApiPmarginGetUmTradeAsynV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiPmarginGetUmTradeAsynV1Request) RecvWindow(recvWindow int64) ApiPmarginGetUmTradeAsynV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiPmarginGetUmTradeAsynV1Request) Execute() (*PmarginGetUmTradeAsynV1Resp, *http.Response, error) {
	return r.ApiService.PmarginGetUmTradeAsynV1Execute(r)
}

/*
PmarginGetUmTradeAsynV1 Get Download Id For UM Futures Trade History (USER_DATA)

Get download id for UM futures trade history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPmarginGetUmTradeAsynV1Request
*/
func (a *AccountAPIService) PmarginGetUmTradeAsynV1(ctx context.Context) ApiPmarginGetUmTradeAsynV1Request {
	return ApiPmarginGetUmTradeAsynV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PmarginGetUmTradeAsynV1Resp
func (a *AccountAPIService) PmarginGetUmTradeAsynV1Execute(r ApiPmarginGetUmTradeAsynV1Request) (*PmarginGetUmTradeAsynV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PmarginGetUmTradeAsynV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.PmarginGetUmTradeAsynV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/papi/v1/um/trade/asyn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Binance Options API

OpenAPI specification for Binance exchange - Options API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package options

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// MarketMakerEndpointsAPIService MarketMakerEndpointsAPI service
type MarketMakerEndpointsAPIService service

type ApiOptionsCreateCountdownCancelAllHeartBeatV1Request struct {
	ctx context.Context
	ApiService *MarketMakerEndpointsAPIService
	timestamp *int64
	underlyings *string
	recvWindow *int64
}

func (r ApiOptionsCreateCountdownCancelAllHeartBeatV1Request) Timestamp(timestamp int64) ApiOptionsCreateCountdownCancelAllHeartBeatV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiOptionsCreateCountdownCancelAllHeartBeatV1Request) Underlyings(underlyings string) ApiOptionsCreateCountdownCancelAllHeartBeatV1Request {
	r.underlyings = &underlyings
	return r
}

func (r ApiOptionsCreateCountdownCancelAllHeartBeatV1Request) RecvWindow(recvWindow int64) ApiOptionsCreateCountdownCancelAllHeartBeatV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiOptionsCreateCountdownCancelAllHeartBeatV1Request) Execute() (*OptionsCreateCountdownCancelAllHeartBeatV1Resp, *http.Response, error) {
	return r.ApiService.OptionsCreateCountdownCancelAllHeartBeatV1Execute(r)
}

/*
OptionsCreateCountdownCancelAllHeartBeatV1 Auto-Cancel All Open Orders (Kill-Switch) Heartbeat (TRADE)

This endpoint resets the time from which the countdown will begin to the time this messaged is received.  It should be called repeatedly as heartbeats.  Multiple heartbeats can be updated at once by specifying the underlying symbols as a list (ex. BTCUSDT,ETHUSDT) in the underlyings parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOptionsCreateCountdownCancelAllHeartBeatV1Request
*/
func (a *MarketMakerEndpointsAPIService) OptionsCreateCountdownCancelAllHeartBeatV1(ctx context.Context) ApiOptionsCreateCountdownCancelAllHeartBeatV1Request {
	return ApiOptionsCreateCountdownCancelAllHeartBeatV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OptionsCreateCountdownCancelAllHeartBeatV1Resp
func (a *MarketMakerEndpointsAPIService) OptionsCreateCountdownCancelAllHeartBeatV1Execute(r ApiOptionsCreateCountdownCancelAllHeartBeatV1Request) (*OptionsCreateCountdownCancelAllHeartBeatV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OptionsCreateCountdownCancelAllHeartBeatV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketMakerEndpointsAPIService.OptionsCreateCountdownCancelAllHeartBeatV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eapi/v1/countdownCancelAllHeartBeat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.underlyings == nil {
		return localVarReturnValue, nil, reportError("underlyings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "underlyings", r.underlyings, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOptionsCreateCountdownCancelAllV1Request struct {
	ctx context.Context
	ApiService *MarketMakerEndpointsAPIService
	countdownTime *int64
	timestamp *int64
	underlying *string
	recvWindow *int64
}

func (r ApiOptionsCreateCountdownCancelAllV1Request) CountdownTime(countdownTime int64) ApiOptionsCreateCountdownCancelAllV1Request {
	r.countdownTime = &countdownTime
	return r
}

func (r ApiOptionsCreateCountdownCancelAllV1Request) Timestamp(timestamp int64) ApiOptionsCreateCountdownCancelAllV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiOptionsCreateCountdownCancelAllV1Request) Underlying(underlying string) ApiOptionsCreateCountdownCancelAllV1Request {
	r.underlying = &underlying
	return r
}

func (r ApiOptionsCreateCountdownCancelAllV1Request) RecvWindow(recvWindow int64) ApiOptionsCreateCountdownCancelAllV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiOptionsCreateCountdownCancelAllV1Request) Execute() (*OptionsCreateCountdownCancelAllV1Resp, *http.Response, error) {
	return r.ApiService.OptionsCreateCountdownCancelAllV1Execute(r)
}

/*
OptionsCreateCountdownCancelAllV1 Set Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)

This endpoint sets the parameters of the auto-cancel feature which cancels all open orders (both market maker protection and non market maker protection order types) of the underlying symbol at the end of the specified countdown time period if no heartbeat message is sent.  After the countdown time period, all open orders will be cancelled and new orders will be rejected with error code -2010 until either a heartbeat message is sent or the auto-cancel feature is turned off by setting countdownTime to 0.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOptionsCreateCountdownCancelAllV1Request
*/
func (a *MarketMakerEndpointsAPIService) OptionsCreateCountdownCancelAllV1(ctx context.Context) ApiOptionsCreateCountdownCancelAllV1Request {
	return ApiOptionsCreateCountdownCancelAllV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OptionsCreateCountdownCancelAllV1Resp
func (a *MarketMakerEndpointsAPIService) OptionsCreateCountdownCancelAllV1Execute(r ApiOptionsCreateCountdownCancelAllV1Request) (*OptionsCreateCountdownCancelAllV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OptionsCreateCountdownCancelAllV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketMakerEndpointsAPIService.OptionsCreateCountdownCancelAllV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eapi/v1/countdownCancelAll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.countdownTime == nil {
		return localVarReturnValue, nil, reportError("countdownTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.underlying == nil {
		return localVarReturnValue, nil, reportError("underlying is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "countdownTime", r.countdownTime, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "underlying", r.underlying, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOptionsCreateMmpResetV1Request struct {
	ctx context.Context
	ApiService *MarketMakerEndpointsAPIService
	timestamp *int64
	recvWindow *int64
	underlying *string
}

func (r ApiOptionsCreateMmpResetV1Request) Timestamp(timestamp int64) ApiOptionsCreateMmpResetV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiOptionsCreateMmpResetV1Request) RecvWindow(recvWindow int64) ApiOptionsCreateMmpResetV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiOptionsCreateMmpResetV1Request) Underlying(underlying string) ApiOptionsCreateMmpResetV1Request {
	r.underlying = &underlying
	return r
}

func (r ApiOptionsCreateMmpResetV1Request) Execute() (*OptionsCreateMmpResetV1Resp, *http.Response, error) {
	return r.ApiService.OptionsCreateMmpResetV1Execute(r)
}

/*
OptionsCreateMmpResetV1 Reset Market Maker Protection Config (TRADE)

Reset MMP, start MMP order again.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOptionsCreateMmpResetV1Request
*/
func (a *MarketMakerEndpointsAPIService) OptionsCreateMmpResetV1(ctx context.Context) ApiOptionsCreateMmpResetV1Request {
	return ApiOptionsCreateMmpResetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OptionsCreateMmpResetV1Resp
func (a *MarketMakerEndpointsAPIService) OptionsCreateMmpResetV1Execute(r ApiOptionsCreateMmpResetV1Request) (*OptionsCreateMmpResetV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OptionsCreateMmpResetV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketMakerEndpointsAPIService.OptionsCreateMmpResetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eapi/v1/mmpReset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.underlying != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "underlying", r.underlying, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOptionsCreateMmpSetV1Request struct {
	ctx context.Context
	ApiService *MarketMakerEndpointsAPIService
	timestamp *int64
	deltaLimit *string
	frozenTimeInMilliseconds *int64
	qtyLimit *string
	recvWindow *int64
	underlying *string
	windowTimeInMilliseconds *int64
}

func (r ApiOptionsCreateMmpSetV1Request) Timestamp(timestamp int64) ApiOptionsCreateMmpSetV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiOptionsCreateMmpSetV1Request) DeltaLimit(deltaLimit string) ApiOptionsCreateMmpSetV1Request {
	r.deltaLimit = &deltaLimit
	return r
}

func (r ApiOptionsCreateMmpSetV1Request) FrozenTimeInMilliseconds(frozenTimeInMilliseconds int64) ApiOptionsCreateMmpSetV1Request {
	r.frozenTimeInMilliseconds = &frozenTimeInMilliseconds
	return r
}

func (r ApiOptionsCreateMmpSetV1Request) QtyLimit(qtyLimit string) ApiOptionsCreateMmpSetV1Request {
	r.qtyLimit = &qtyLimit
	return r
}

func (r ApiOptionsCreateMmpSetV1Request) RecvWindow(recvWindow int64) ApiOptionsCreateMmpSetV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiOptionsCreateMmpSetV1Request) Underlying(underlying string) ApiOptionsCreateMmpSetV1Request {
	r.underlying = &underlying
	return r
}

func (r ApiOptionsCreateMmpSetV1Request) WindowTimeInMilliseconds(windowTimeInMilliseconds int64) ApiOptionsCreateMmpSetV1Request {
	r.windowTimeInMilliseconds = &windowTimeInMilliseconds
	return r
}

func (r ApiOptionsCreateMmpSetV1Request) Execute() (*OptionsCreateMmpSetV1Resp, *http.Response, error) {
	return r.ApiService.OptionsCreateMmpSetV1Execute(r)
}

/*
OptionsCreateMmpSetV1 Set Market Maker Protection Config (TRADE)

Set config for MMP.
Market Maker Protection(MMP) is a set of protection mechanism for option market maker, this mechanism is able to prevent mass trading in short period time. Once market maker's account branches the threshold, the Market Maker Protection will be triggered. When Market Maker Protection triggers, all the current MMP orders will be canceled, new MMP orders will be rejected. Market maker can use this time to reevaluate market and modify order price.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOptionsCreateMmpSetV1Request
*/
func (a *MarketMakerEndpointsAPIService) OptionsCreateMmpSetV1(ctx context.Context) ApiOptionsCreateMmpSetV1Request {
	return ApiOptionsCreateMmpSetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OptionsCreateMmpSetV1Resp
func (a *MarketMakerEndpointsAPIService) OptionsCreateMmpSetV1Execute(r ApiOptionsCreateMmpSetV1Request) (*OptionsCreateMmpSetV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OptionsCreateMmpSetV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketMakerEndpointsAPIService.OptionsCreateMmpSetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eapi/v1/mmpSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.deltaLimit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "deltaLimit", r.deltaLimit, "", "")
	}
	if r.frozenTimeInMilliseconds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "frozenTimeInMilliseconds", r.frozenTimeInMilliseconds, "", "")
	}
	if r.qtyLimit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "qtyLimit", r.qtyLimit, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.underlying != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "underlying", r.underlying, "", "")
	}
	if r.windowTimeInMilliseconds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "windowTimeInMilliseconds", r.windowTimeInMilliseconds, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOptionsGetCountdownCancelAllV1Request struct {
	ctx context.Context
	ApiService *MarketMakerEndpointsAPIService
	timestamp *int64
	underlying *string
	recvWindow *int64
}

func (r ApiOptionsGetCountdownCancelAllV1Request) Timestamp(timestamp int64) ApiOptionsGetCountdownCancelAllV1Request {
	r.timestamp = &timestamp
	return r
}

// Option underlying, e.g BTCUSDT
func (r ApiOptionsGetCountdownCancelAllV1Request) Underlying(underlying string) ApiOptionsGetCountdownCancelAllV1Request {
	r.underlying = &underlying
	return r
}

func (r ApiOptionsGetCountdownCancelAllV1Request) RecvWindow(recvWindow int64) ApiOptionsGetCountdownCancelAllV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiOptionsGetCountdownCancelAllV1Request) Execute() (*OptionsGetCountdownCancelAllV1Resp, *http.Response, error) {
	return r.ApiService.OptionsGetCountdownCancelAllV1Execute(r)
}

/*
OptionsGetCountdownCancelAllV1 Get Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)

This endpoint returns the auto-cancel parameters for each underlying symbol. Note only active auto-cancel parameters will be returned, if countdownTime is set to 0 (ie. countdownTime has been turned off), the underlying symbol and corresponding countdownTime parameter will not be returned in the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOptionsGetCountdownCancelAllV1Request
*/
func (a *MarketMakerEndpointsAPIService) OptionsGetCountdownCancelAllV1(ctx context.Context) ApiOptionsGetCountdownCancelAllV1Request {
	return ApiOptionsGetCountdownCancelAllV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OptionsGetCountdownCancelAllV1Resp
func (a *MarketMakerEndpointsAPIService) OptionsGetCountdownCancelAllV1Execute(r ApiOptionsGetCountdownCancelAllV1Request) (*OptionsGetCountdownCancelAllV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OptionsGetCountdownCancelAllV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketMakerEndpointsAPIService.OptionsGetCountdownCancelAllV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eapi/v1/countdownCancelAll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.underlying != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "underlying", r.underlying, "form", "")
	} else {
		var defaultValue string = ""
		r.underlying = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOptionsGetMarginAccountV1Request struct {
	ctx context.Context
	ApiService *MarketMakerEndpointsAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiOptionsGetMarginAccountV1Request) Timestamp(timestamp int64) ApiOptionsGetMarginAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiOptionsGetMarginAccountV1Request) RecvWindow(recvWindow int64) ApiOptionsGetMarginAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiOptionsGetMarginAccountV1Request) Execute() (*OptionsGetMarginAccountV1Resp, *http.Response, error) {
	return r.ApiService.OptionsGetMarginAccountV1Execute(r)
}

/*
OptionsGetMarginAccountV1 Option Margin Account Information (USER_DATA)

Get current account information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOptionsGetMarginAccountV1Request
*/
func (a *MarketMakerEndpointsAPIService) OptionsGetMarginAccountV1(ctx context.Context) ApiOptionsGetMarginAccountV1Request {
	return ApiOptionsGetMarginAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OptionsGetMarginAccountV1Resp
func (a *MarketMakerEndpointsAPIService) OptionsGetMarginAccountV1Execute(r ApiOptionsGetMarginAccountV1Request) (*OptionsGetMarginAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OptionsGetMarginAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketMakerEndpointsAPIService.OptionsGetMarginAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eapi/v1/marginAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOptionsGetMmpV1Request struct {
	ctx context.Context
	ApiService *MarketMakerEndpointsAPIService
	timestamp *int64
	underlying *string
	recvWindow *int64
}

func (r ApiOptionsGetMmpV1Request) Timestamp(timestamp int64) ApiOptionsGetMmpV1Request {
	r.timestamp = &timestamp
	return r
}

// underlying, e.g BTCUSDT
func (r ApiOptionsGetMmpV1Request) Underlying(underlying string) ApiOptionsGetMmpV1Request {
	r.underlying = &underlying
	return r
}

func (r ApiOptionsGetMmpV1Request) RecvWindow(recvWindow int64) ApiOptionsGetMmpV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiOptionsGetMmpV1Request) Execute() (*OptionsGetMmpV1Resp, *http.Response, error) {
	return r.ApiService.OptionsGetMmpV1Execute(r)
}

/*
OptionsGetMmpV1 Get Market Maker Protection Config (TRADE)

Get config for MMP.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOptionsGetMmpV1Request
*/
func (a *MarketMakerEndpointsAPIService) OptionsGetMmpV1(ctx context.Context) ApiOptionsGetMmpV1Request {
	return ApiOptionsGetMmpV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OptionsGetMmpV1Resp
func (a *MarketMakerEndpointsAPIService) OptionsGetMmpV1Execute(r ApiOptionsGetMmpV1Request) (*OptionsGetMmpV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OptionsGetMmpV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarketMakerEndpointsAPIService.OptionsGetMmpV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eapi/v1/mmp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.underlying != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "underlying", r.underlying, "form", "")
	} else {
		var defaultValue string = ""
		r.underlying = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

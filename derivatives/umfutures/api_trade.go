/*
Binance Umfutures API

OpenAPI specification for Binance cryptocurrency exchange - Umfutures API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package umfutures

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// TradeAPIService TradeAPI service
type TradeAPIService service

type TradeAPIUmfuturesCreateBatchOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	batchOrders *[]UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPIUmfuturesCreateBatchOrdersV1Request) BatchOrders(batchOrders []UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem) TradeAPIUmfuturesCreateBatchOrdersV1Request {
	r.batchOrders = &batchOrders
	return r
}

func (r TradeAPIUmfuturesCreateBatchOrdersV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesCreateBatchOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesCreateBatchOrdersV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesCreateBatchOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesCreateBatchOrdersV1Request) Execute() ([]UmfuturesCreateBatchOrdersV1RespInner, *http.Response, error) {
	return r.ApiService.UmfuturesCreateBatchOrdersV1Execute(r)
}

/*
UmfuturesCreateBatchOrdersV1 Place Multiple Orders(TRADE)

Place Multiple Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesCreateBatchOrdersV1Request
*/
func (a *TradeAPIService) UmfuturesCreateBatchOrdersV1(ctx context.Context) TradeAPIUmfuturesCreateBatchOrdersV1Request {
	return TradeAPIUmfuturesCreateBatchOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesCreateBatchOrdersV1RespInner
func (a *TradeAPIService) UmfuturesCreateBatchOrdersV1Execute(r TradeAPIUmfuturesCreateBatchOrdersV1Request) ([]UmfuturesCreateBatchOrdersV1RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesCreateBatchOrdersV1RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesCreateBatchOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/batchOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchOrders == nil {
		return localVarReturnValue, nil, reportError("batchOrders is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "batchOrders", r.batchOrders, "", "csv")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesCreateCountdownCancelAllV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	umfuturesCreateCountdownCancelAllV1Req *UmfuturesCreateCountdownCancelAllV1Req
}

func (r TradeAPIUmfuturesCreateCountdownCancelAllV1Request) UmfuturesCreateCountdownCancelAllV1Req(umfuturesCreateCountdownCancelAllV1Req UmfuturesCreateCountdownCancelAllV1Req) TradeAPIUmfuturesCreateCountdownCancelAllV1Request {
	r.umfuturesCreateCountdownCancelAllV1Req = &umfuturesCreateCountdownCancelAllV1Req
	return r
}

func (r TradeAPIUmfuturesCreateCountdownCancelAllV1Request) Execute() (*UmfuturesCreateCountdownCancelAllV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateCountdownCancelAllV1Execute(r)
}

/*
UmfuturesCreateCountdownCancelAllV1 Auto-Cancel All Open Orders (TRADE)

Cancel all open orders of the specified symbol at the end of the specified countdown.
The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesCreateCountdownCancelAllV1Request
*/
func (a *TradeAPIService) UmfuturesCreateCountdownCancelAllV1(ctx context.Context) TradeAPIUmfuturesCreateCountdownCancelAllV1Request {
	return TradeAPIUmfuturesCreateCountdownCancelAllV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateCountdownCancelAllV1Resp
func (a *TradeAPIService) UmfuturesCreateCountdownCancelAllV1Execute(r TradeAPIUmfuturesCreateCountdownCancelAllV1Request) (*UmfuturesCreateCountdownCancelAllV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateCountdownCancelAllV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesCreateCountdownCancelAllV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/countdownCancelAll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.umfuturesCreateCountdownCancelAllV1Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesCreateLeverageV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	leverage *int32
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPIUmfuturesCreateLeverageV1Request) Leverage(leverage int32) TradeAPIUmfuturesCreateLeverageV1Request {
	r.leverage = &leverage
	return r
}

func (r TradeAPIUmfuturesCreateLeverageV1Request) Symbol(symbol string) TradeAPIUmfuturesCreateLeverageV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesCreateLeverageV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesCreateLeverageV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesCreateLeverageV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesCreateLeverageV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesCreateLeverageV1Request) Execute() (*UmfuturesCreateLeverageV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateLeverageV1Execute(r)
}

/*
UmfuturesCreateLeverageV1 Change Initial Leverage(TRADE)

Change user's initial leverage of specific symbol market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesCreateLeverageV1Request
*/
func (a *TradeAPIService) UmfuturesCreateLeverageV1(ctx context.Context) TradeAPIUmfuturesCreateLeverageV1Request {
	return TradeAPIUmfuturesCreateLeverageV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateLeverageV1Resp
func (a *TradeAPIService) UmfuturesCreateLeverageV1Execute(r TradeAPIUmfuturesCreateLeverageV1Request) (*UmfuturesCreateLeverageV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateLeverageV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesCreateLeverageV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/leverage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leverage == nil {
		return localVarReturnValue, nil, reportError("leverage is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "leverage", r.leverage, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesCreateMarginTypeV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	marginType *string
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPIUmfuturesCreateMarginTypeV1Request) MarginType(marginType string) TradeAPIUmfuturesCreateMarginTypeV1Request {
	r.marginType = &marginType
	return r
}

func (r TradeAPIUmfuturesCreateMarginTypeV1Request) Symbol(symbol string) TradeAPIUmfuturesCreateMarginTypeV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesCreateMarginTypeV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesCreateMarginTypeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesCreateMarginTypeV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesCreateMarginTypeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesCreateMarginTypeV1Request) Execute() (*UmfuturesCreateMarginTypeV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateMarginTypeV1Execute(r)
}

/*
UmfuturesCreateMarginTypeV1 Change Margin Type(TRADE)

Change symbol level margin type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesCreateMarginTypeV1Request
*/
func (a *TradeAPIService) UmfuturesCreateMarginTypeV1(ctx context.Context) TradeAPIUmfuturesCreateMarginTypeV1Request {
	return TradeAPIUmfuturesCreateMarginTypeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateMarginTypeV1Resp
func (a *TradeAPIService) UmfuturesCreateMarginTypeV1Execute(r TradeAPIUmfuturesCreateMarginTypeV1Request) (*UmfuturesCreateMarginTypeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateMarginTypeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesCreateMarginTypeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/marginType"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.marginType == nil {
		return localVarReturnValue, nil, reportError("marginType is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "marginType", r.marginType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesCreateMultiAssetsMarginV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	multiAssetsMargin *string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPIUmfuturesCreateMultiAssetsMarginV1Request) MultiAssetsMargin(multiAssetsMargin string) TradeAPIUmfuturesCreateMultiAssetsMarginV1Request {
	r.multiAssetsMargin = &multiAssetsMargin
	return r
}

func (r TradeAPIUmfuturesCreateMultiAssetsMarginV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesCreateMultiAssetsMarginV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesCreateMultiAssetsMarginV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesCreateMultiAssetsMarginV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesCreateMultiAssetsMarginV1Request) Execute() (*UmfuturesCreateMultiAssetsMarginV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateMultiAssetsMarginV1Execute(r)
}

/*
UmfuturesCreateMultiAssetsMarginV1 Change Multi-Assets Mode (TRADE)

Change user's Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesCreateMultiAssetsMarginV1Request
*/
func (a *TradeAPIService) UmfuturesCreateMultiAssetsMarginV1(ctx context.Context) TradeAPIUmfuturesCreateMultiAssetsMarginV1Request {
	return TradeAPIUmfuturesCreateMultiAssetsMarginV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateMultiAssetsMarginV1Resp
func (a *TradeAPIService) UmfuturesCreateMultiAssetsMarginV1Execute(r TradeAPIUmfuturesCreateMultiAssetsMarginV1Request) (*UmfuturesCreateMultiAssetsMarginV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateMultiAssetsMarginV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesCreateMultiAssetsMarginV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/multiAssetsMargin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.multiAssetsMargin == nil {
		return localVarReturnValue, nil, reportError("multiAssetsMargin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "multiAssetsMargin", r.multiAssetsMargin, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesCreateOrderTestV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	activationPrice *string
	callbackRate *string
	closePosition *string
	goodTillDate *int64
	newClientOrderId *string
	newOrderRespType *string
	positionSide *string
	price *string
	priceMatch *string
	priceProtect *string
	quantity *string
	recvWindow *int64
	reduceOnly *string
	selfTradePreventionMode *string
	stopPrice *string
	timeInForce *string
	workingType *string
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) Side(side string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.side = &side
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) Symbol(symbol string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) Type_(type_ string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.type_ = &type_
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) ActivationPrice(activationPrice string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.activationPrice = &activationPrice
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) CallbackRate(callbackRate string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.callbackRate = &callbackRate
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) ClosePosition(closePosition string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.closePosition = &closePosition
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) GoodTillDate(goodTillDate int64) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.goodTillDate = &goodTillDate
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) NewClientOrderId(newClientOrderId string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) NewOrderRespType(newOrderRespType string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) PositionSide(positionSide string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.positionSide = &positionSide
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) Price(price string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.price = &price
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) PriceMatch(priceMatch string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) PriceProtect(priceProtect string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.priceProtect = &priceProtect
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) Quantity(quantity string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.quantity = &quantity
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) ReduceOnly(reduceOnly string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.reduceOnly = &reduceOnly
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) SelfTradePreventionMode(selfTradePreventionMode string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) StopPrice(stopPrice string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) TimeInForce(timeInForce string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) WorkingType(workingType string) TradeAPIUmfuturesCreateOrderTestV1Request {
	r.workingType = &workingType
	return r
}

func (r TradeAPIUmfuturesCreateOrderTestV1Request) Execute() (*UmfuturesCreateOrderTestV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateOrderTestV1Execute(r)
}

/*
UmfuturesCreateOrderTestV1 Test Order(TRADE)

Testing order request, this order will not be submitted to matching engine

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesCreateOrderTestV1Request
*/
func (a *TradeAPIService) UmfuturesCreateOrderTestV1(ctx context.Context) TradeAPIUmfuturesCreateOrderTestV1Request {
	return TradeAPIUmfuturesCreateOrderTestV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateOrderTestV1Resp
func (a *TradeAPIService) UmfuturesCreateOrderTestV1Execute(r TradeAPIUmfuturesCreateOrderTestV1Request) (*UmfuturesCreateOrderTestV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateOrderTestV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesCreateOrderTestV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.activationPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "activationPrice", r.activationPrice, "", "")
	}
	if r.callbackRate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callbackRate", r.callbackRate, "", "")
	}
	if r.closePosition != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "closePosition", r.closePosition, "", "")
	}
	if r.goodTillDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "goodTillDate", r.goodTillDate, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	if r.priceProtect != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceProtect", r.priceProtect, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.reduceOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reduceOnly", r.reduceOnly, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.workingType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesCreateOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	activationPrice *string
	callbackRate *string
	closePosition *string
	goodTillDate *int64
	newClientOrderId *string
	newOrderRespType *string
	positionSide *string
	price *string
	priceMatch *string
	priceProtect *string
	quantity *string
	recvWindow *int64
	reduceOnly *string
	selfTradePreventionMode *string
	stopPrice *string
	timeInForce *string
	workingType *string
}

func (r TradeAPIUmfuturesCreateOrderV1Request) Side(side string) TradeAPIUmfuturesCreateOrderV1Request {
	r.side = &side
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) Symbol(symbol string) TradeAPIUmfuturesCreateOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesCreateOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) Type_(type_ string) TradeAPIUmfuturesCreateOrderV1Request {
	r.type_ = &type_
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) ActivationPrice(activationPrice string) TradeAPIUmfuturesCreateOrderV1Request {
	r.activationPrice = &activationPrice
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) CallbackRate(callbackRate string) TradeAPIUmfuturesCreateOrderV1Request {
	r.callbackRate = &callbackRate
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) ClosePosition(closePosition string) TradeAPIUmfuturesCreateOrderV1Request {
	r.closePosition = &closePosition
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) GoodTillDate(goodTillDate int64) TradeAPIUmfuturesCreateOrderV1Request {
	r.goodTillDate = &goodTillDate
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) NewClientOrderId(newClientOrderId string) TradeAPIUmfuturesCreateOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) NewOrderRespType(newOrderRespType string) TradeAPIUmfuturesCreateOrderV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) PositionSide(positionSide string) TradeAPIUmfuturesCreateOrderV1Request {
	r.positionSide = &positionSide
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) Price(price string) TradeAPIUmfuturesCreateOrderV1Request {
	r.price = &price
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) PriceMatch(priceMatch string) TradeAPIUmfuturesCreateOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) PriceProtect(priceProtect string) TradeAPIUmfuturesCreateOrderV1Request {
	r.priceProtect = &priceProtect
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) Quantity(quantity string) TradeAPIUmfuturesCreateOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesCreateOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) ReduceOnly(reduceOnly string) TradeAPIUmfuturesCreateOrderV1Request {
	r.reduceOnly = &reduceOnly
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) SelfTradePreventionMode(selfTradePreventionMode string) TradeAPIUmfuturesCreateOrderV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) StopPrice(stopPrice string) TradeAPIUmfuturesCreateOrderV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) TimeInForce(timeInForce string) TradeAPIUmfuturesCreateOrderV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) WorkingType(workingType string) TradeAPIUmfuturesCreateOrderV1Request {
	r.workingType = &workingType
	return r
}

func (r TradeAPIUmfuturesCreateOrderV1Request) Execute() (*UmfuturesCreateOrderV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateOrderV1Execute(r)
}

/*
UmfuturesCreateOrderV1 New Order(TRADE)

Send in a new order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesCreateOrderV1Request
*/
func (a *TradeAPIService) UmfuturesCreateOrderV1(ctx context.Context) TradeAPIUmfuturesCreateOrderV1Request {
	return TradeAPIUmfuturesCreateOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateOrderV1Resp
func (a *TradeAPIService) UmfuturesCreateOrderV1Execute(r TradeAPIUmfuturesCreateOrderV1Request) (*UmfuturesCreateOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesCreateOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.activationPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "activationPrice", r.activationPrice, "", "")
	}
	if r.callbackRate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callbackRate", r.callbackRate, "", "")
	}
	if r.closePosition != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "closePosition", r.closePosition, "", "")
	}
	if r.goodTillDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "goodTillDate", r.goodTillDate, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	if r.priceProtect != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceProtect", r.priceProtect, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.reduceOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reduceOnly", r.reduceOnly, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.workingType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesCreatePositionMarginV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	amount *string
	symbol *string
	timestamp *int64
	type_ *int32
	positionSide *string
	recvWindow *int64
}

func (r TradeAPIUmfuturesCreatePositionMarginV1Request) Amount(amount string) TradeAPIUmfuturesCreatePositionMarginV1Request {
	r.amount = &amount
	return r
}

func (r TradeAPIUmfuturesCreatePositionMarginV1Request) Symbol(symbol string) TradeAPIUmfuturesCreatePositionMarginV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesCreatePositionMarginV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesCreatePositionMarginV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesCreatePositionMarginV1Request) Type_(type_ int32) TradeAPIUmfuturesCreatePositionMarginV1Request {
	r.type_ = &type_
	return r
}

func (r TradeAPIUmfuturesCreatePositionMarginV1Request) PositionSide(positionSide string) TradeAPIUmfuturesCreatePositionMarginV1Request {
	r.positionSide = &positionSide
	return r
}

func (r TradeAPIUmfuturesCreatePositionMarginV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesCreatePositionMarginV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesCreatePositionMarginV1Request) Execute() (*UmfuturesCreatePositionMarginV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreatePositionMarginV1Execute(r)
}

/*
UmfuturesCreatePositionMarginV1 Modify Isolated Position Margin(TRADE)

Modify Isolated Position Margin

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesCreatePositionMarginV1Request
*/
func (a *TradeAPIService) UmfuturesCreatePositionMarginV1(ctx context.Context) TradeAPIUmfuturesCreatePositionMarginV1Request {
	return TradeAPIUmfuturesCreatePositionMarginV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreatePositionMarginV1Resp
func (a *TradeAPIService) UmfuturesCreatePositionMarginV1Execute(r TradeAPIUmfuturesCreatePositionMarginV1Request) (*UmfuturesCreatePositionMarginV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreatePositionMarginV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesCreatePositionMarginV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/positionMargin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesCreatePositionSideDualV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	dualSidePosition *string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPIUmfuturesCreatePositionSideDualV1Request) DualSidePosition(dualSidePosition string) TradeAPIUmfuturesCreatePositionSideDualV1Request {
	r.dualSidePosition = &dualSidePosition
	return r
}

func (r TradeAPIUmfuturesCreatePositionSideDualV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesCreatePositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesCreatePositionSideDualV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesCreatePositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesCreatePositionSideDualV1Request) Execute() (*UmfuturesCreatePositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreatePositionSideDualV1Execute(r)
}

/*
UmfuturesCreatePositionSideDualV1 Change Position Mode(TRADE)

Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesCreatePositionSideDualV1Request
*/
func (a *TradeAPIService) UmfuturesCreatePositionSideDualV1(ctx context.Context) TradeAPIUmfuturesCreatePositionSideDualV1Request {
	return TradeAPIUmfuturesCreatePositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreatePositionSideDualV1Resp
func (a *TradeAPIService) UmfuturesCreatePositionSideDualV1Execute(r TradeAPIUmfuturesCreatePositionSideDualV1Request) (*UmfuturesCreatePositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreatePositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesCreatePositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dualSidePosition == nil {
		return localVarReturnValue, nil, reportError("dualSidePosition is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "dualSidePosition", r.dualSidePosition, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesDeleteAllOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPIUmfuturesDeleteAllOpenOrdersV1Request) Symbol(symbol string) TradeAPIUmfuturesDeleteAllOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesDeleteAllOpenOrdersV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesDeleteAllOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesDeleteAllOpenOrdersV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesDeleteAllOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesDeleteAllOpenOrdersV1Request) Execute() (*UmfuturesDeleteAllOpenOrdersV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesDeleteAllOpenOrdersV1Execute(r)
}

/*
UmfuturesDeleteAllOpenOrdersV1 Cancel All Open Orders (TRADE)

Cancel All Open Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesDeleteAllOpenOrdersV1Request
*/
func (a *TradeAPIService) UmfuturesDeleteAllOpenOrdersV1(ctx context.Context) TradeAPIUmfuturesDeleteAllOpenOrdersV1Request {
	return TradeAPIUmfuturesDeleteAllOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesDeleteAllOpenOrdersV1Resp
func (a *TradeAPIService) UmfuturesDeleteAllOpenOrdersV1Execute(r TradeAPIUmfuturesDeleteAllOpenOrdersV1Request) (*UmfuturesDeleteAllOpenOrdersV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesDeleteAllOpenOrdersV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesDeleteAllOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/allOpenOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesDeleteBatchOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderIdList *[]int64
	origClientOrderIdList *[]string
	recvWindow *int64
}

func (r TradeAPIUmfuturesDeleteBatchOrdersV1Request) Symbol(symbol string) TradeAPIUmfuturesDeleteBatchOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesDeleteBatchOrdersV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesDeleteBatchOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

// max length 10 &lt;br/&gt; e.g. [1234567,2345678]
func (r TradeAPIUmfuturesDeleteBatchOrdersV1Request) OrderIdList(orderIdList []int64) TradeAPIUmfuturesDeleteBatchOrdersV1Request {
	r.orderIdList = &orderIdList
	return r
}

// max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
func (r TradeAPIUmfuturesDeleteBatchOrdersV1Request) OrigClientOrderIdList(origClientOrderIdList []string) TradeAPIUmfuturesDeleteBatchOrdersV1Request {
	r.origClientOrderIdList = &origClientOrderIdList
	return r
}

func (r TradeAPIUmfuturesDeleteBatchOrdersV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesDeleteBatchOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesDeleteBatchOrdersV1Request) Execute() ([]UmfuturesDeleteBatchOrdersV1RespInner, *http.Response, error) {
	return r.ApiService.UmfuturesDeleteBatchOrdersV1Execute(r)
}

/*
UmfuturesDeleteBatchOrdersV1 Cancel Multiple Orders (TRADE)

Cancel Multiple Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesDeleteBatchOrdersV1Request
*/
func (a *TradeAPIService) UmfuturesDeleteBatchOrdersV1(ctx context.Context) TradeAPIUmfuturesDeleteBatchOrdersV1Request {
	return TradeAPIUmfuturesDeleteBatchOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesDeleteBatchOrdersV1RespInner
func (a *TradeAPIService) UmfuturesDeleteBatchOrdersV1Execute(r TradeAPIUmfuturesDeleteBatchOrdersV1Request) ([]UmfuturesDeleteBatchOrdersV1RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesDeleteBatchOrdersV1RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesDeleteBatchOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/batchOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderIdList != nil {
		t := *r.orderIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderIdList", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderIdList", t, "form", "multi")
		}
	}
	if r.origClientOrderIdList != nil {
		t := *r.origClientOrderIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderIdList", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderIdList", t, "form", "multi")
		}
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesDeleteOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r TradeAPIUmfuturesDeleteOrderV1Request) Symbol(symbol string) TradeAPIUmfuturesDeleteOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesDeleteOrderV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesDeleteOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesDeleteOrderV1Request) OrderId(orderId int64) TradeAPIUmfuturesDeleteOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIUmfuturesDeleteOrderV1Request) OrigClientOrderId(origClientOrderId string) TradeAPIUmfuturesDeleteOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r TradeAPIUmfuturesDeleteOrderV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesDeleteOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesDeleteOrderV1Request) Execute() (*UmfuturesDeleteOrderV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesDeleteOrderV1Execute(r)
}

/*
UmfuturesDeleteOrderV1 Cancel Order (TRADE)

Cancel an active order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesDeleteOrderV1Request
*/
func (a *TradeAPIService) UmfuturesDeleteOrderV1(ctx context.Context) TradeAPIUmfuturesDeleteOrderV1Request {
	return TradeAPIUmfuturesDeleteOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesDeleteOrderV1Resp
func (a *TradeAPIService) UmfuturesDeleteOrderV1Execute(r TradeAPIUmfuturesDeleteOrderV1Request) (*UmfuturesDeleteOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesDeleteOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesDeleteOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetAdlQuantileV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetAdlQuantileV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetAdlQuantileV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesGetAdlQuantileV1Request) Symbol(symbol string) TradeAPIUmfuturesGetAdlQuantileV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesGetAdlQuantileV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetAdlQuantileV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetAdlQuantileV1Request) Execute() ([]UmfuturesGetAdlQuantileV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetAdlQuantileV1Execute(r)
}

/*
UmfuturesGetAdlQuantileV1 Position ADL Quantile Estimation(USER_DATA)

Position ADL Quantile Estimation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetAdlQuantileV1Request
*/
func (a *TradeAPIService) UmfuturesGetAdlQuantileV1(ctx context.Context) TradeAPIUmfuturesGetAdlQuantileV1Request {
	return TradeAPIUmfuturesGetAdlQuantileV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetAdlQuantileV1RespItem
func (a *TradeAPIService) UmfuturesGetAdlQuantileV1Execute(r TradeAPIUmfuturesGetAdlQuantileV1Request) ([]UmfuturesGetAdlQuantileV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetAdlQuantileV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetAdlQuantileV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/adlQuantile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetAllOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetAllOrdersV1Request) Symbol(symbol string) TradeAPIUmfuturesGetAllOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesGetAllOrdersV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetAllOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesGetAllOrdersV1Request) OrderId(orderId int64) TradeAPIUmfuturesGetAllOrdersV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIUmfuturesGetAllOrdersV1Request) StartTime(startTime int64) TradeAPIUmfuturesGetAllOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPIUmfuturesGetAllOrdersV1Request) EndTime(endTime int64) TradeAPIUmfuturesGetAllOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r TradeAPIUmfuturesGetAllOrdersV1Request) Limit(limit int32) TradeAPIUmfuturesGetAllOrdersV1Request {
	r.limit = &limit
	return r
}

func (r TradeAPIUmfuturesGetAllOrdersV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetAllOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetAllOrdersV1Request) Execute() ([]UmfuturesGetAllOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetAllOrdersV1Execute(r)
}

/*
UmfuturesGetAllOrdersV1 All Orders (USER_DATA)

Get all account orders; active, canceled, or filled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetAllOrdersV1Request
*/
func (a *TradeAPIService) UmfuturesGetAllOrdersV1(ctx context.Context) TradeAPIUmfuturesGetAllOrdersV1Request {
	return TradeAPIUmfuturesGetAllOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetAllOrdersV1RespItem
func (a *TradeAPIService) UmfuturesGetAllOrdersV1Execute(r TradeAPIUmfuturesGetAllOrdersV1Request) ([]UmfuturesGetAllOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetAllOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetAllOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetForceOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	autoCloseType *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetForceOrdersV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetForceOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesGetForceOrdersV1Request) Symbol(symbol string) TradeAPIUmfuturesGetForceOrdersV1Request {
	r.symbol = &symbol
	return r
}

// &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
func (r TradeAPIUmfuturesGetForceOrdersV1Request) AutoCloseType(autoCloseType string) TradeAPIUmfuturesGetForceOrdersV1Request {
	r.autoCloseType = &autoCloseType
	return r
}

func (r TradeAPIUmfuturesGetForceOrdersV1Request) StartTime(startTime int64) TradeAPIUmfuturesGetForceOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPIUmfuturesGetForceOrdersV1Request) EndTime(endTime int64) TradeAPIUmfuturesGetForceOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 50; max 100.
func (r TradeAPIUmfuturesGetForceOrdersV1Request) Limit(limit int32) TradeAPIUmfuturesGetForceOrdersV1Request {
	r.limit = &limit
	return r
}

func (r TradeAPIUmfuturesGetForceOrdersV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetForceOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetForceOrdersV1Request) Execute() ([]UmfuturesGetForceOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetForceOrdersV1Execute(r)
}

/*
UmfuturesGetForceOrdersV1 User's Force Orders (USER_DATA)

Query user's Force Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetForceOrdersV1Request
*/
func (a *TradeAPIService) UmfuturesGetForceOrdersV1(ctx context.Context) TradeAPIUmfuturesGetForceOrdersV1Request {
	return TradeAPIUmfuturesGetForceOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetForceOrdersV1RespItem
func (a *TradeAPIService) UmfuturesGetForceOrdersV1Execute(r TradeAPIUmfuturesGetForceOrdersV1Request) ([]UmfuturesGetForceOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetForceOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetForceOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/forceOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.autoCloseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCloseType", r.autoCloseType, "form", "")
	} else {
		var defaultValue string = ""
		r.autoCloseType = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetOpenOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetOpenOrderV1Request) Symbol(symbol string) TradeAPIUmfuturesGetOpenOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesGetOpenOrderV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetOpenOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesGetOpenOrderV1Request) OrderId(orderId int64) TradeAPIUmfuturesGetOpenOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIUmfuturesGetOpenOrderV1Request) OrigClientOrderId(origClientOrderId string) TradeAPIUmfuturesGetOpenOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r TradeAPIUmfuturesGetOpenOrderV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetOpenOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetOpenOrderV1Request) Execute() (*UmfuturesGetOpenOrderV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetOpenOrderV1Execute(r)
}

/*
UmfuturesGetOpenOrderV1 Query Current Open Order (USER_DATA)

Query open order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetOpenOrderV1Request
*/
func (a *TradeAPIService) UmfuturesGetOpenOrderV1(ctx context.Context) TradeAPIUmfuturesGetOpenOrderV1Request {
	return TradeAPIUmfuturesGetOpenOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetOpenOrderV1Resp
func (a *TradeAPIService) UmfuturesGetOpenOrderV1Execute(r TradeAPIUmfuturesGetOpenOrderV1Request) (*UmfuturesGetOpenOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetOpenOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetOpenOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/openOrder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetOpenOrdersV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesGetOpenOrdersV1Request) Symbol(symbol string) TradeAPIUmfuturesGetOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesGetOpenOrdersV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetOpenOrdersV1Request) Execute() ([]UmfuturesGetOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetOpenOrdersV1Execute(r)
}

/*
UmfuturesGetOpenOrdersV1 Current All Open Orders (USER_DATA)

Get all open orders on a symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetOpenOrdersV1Request
*/
func (a *TradeAPIService) UmfuturesGetOpenOrdersV1(ctx context.Context) TradeAPIUmfuturesGetOpenOrdersV1Request {
	return TradeAPIUmfuturesGetOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetOpenOrdersV1RespItem
func (a *TradeAPIService) UmfuturesGetOpenOrdersV1Execute(r TradeAPIUmfuturesGetOpenOrdersV1Request) ([]UmfuturesGetOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetOrderAmendmentV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetOrderAmendmentV1Request) Symbol(symbol string) TradeAPIUmfuturesGetOrderAmendmentV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesGetOrderAmendmentV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetOrderAmendmentV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesGetOrderAmendmentV1Request) OrderId(orderId int64) TradeAPIUmfuturesGetOrderAmendmentV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIUmfuturesGetOrderAmendmentV1Request) OrigClientOrderId(origClientOrderId string) TradeAPIUmfuturesGetOrderAmendmentV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Timestamp in ms to get modification history from INCLUSIVE
func (r TradeAPIUmfuturesGetOrderAmendmentV1Request) StartTime(startTime int64) TradeAPIUmfuturesGetOrderAmendmentV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get modification history until INCLUSIVE
func (r TradeAPIUmfuturesGetOrderAmendmentV1Request) EndTime(endTime int64) TradeAPIUmfuturesGetOrderAmendmentV1Request {
	r.endTime = &endTime
	return r
}

// Default 50; max 100
func (r TradeAPIUmfuturesGetOrderAmendmentV1Request) Limit(limit int32) TradeAPIUmfuturesGetOrderAmendmentV1Request {
	r.limit = &limit
	return r
}

func (r TradeAPIUmfuturesGetOrderAmendmentV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetOrderAmendmentV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetOrderAmendmentV1Request) Execute() ([]UmfuturesGetOrderAmendmentV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetOrderAmendmentV1Execute(r)
}

/*
UmfuturesGetOrderAmendmentV1 Get Order Modify History (USER_DATA)

Get order modification history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetOrderAmendmentV1Request
*/
func (a *TradeAPIService) UmfuturesGetOrderAmendmentV1(ctx context.Context) TradeAPIUmfuturesGetOrderAmendmentV1Request {
	return TradeAPIUmfuturesGetOrderAmendmentV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetOrderAmendmentV1RespItem
func (a *TradeAPIService) UmfuturesGetOrderAmendmentV1Execute(r TradeAPIUmfuturesGetOrderAmendmentV1Request) ([]UmfuturesGetOrderAmendmentV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetOrderAmendmentV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetOrderAmendmentV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/orderAmendment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetOrderV1Request) Symbol(symbol string) TradeAPIUmfuturesGetOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesGetOrderV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesGetOrderV1Request) OrderId(orderId int64) TradeAPIUmfuturesGetOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIUmfuturesGetOrderV1Request) OrigClientOrderId(origClientOrderId string) TradeAPIUmfuturesGetOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r TradeAPIUmfuturesGetOrderV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetOrderV1Request) Execute() (*UmfuturesGetOrderV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetOrderV1Execute(r)
}

/*
UmfuturesGetOrderV1 Query Order (USER_DATA)

Check an order's status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetOrderV1Request
*/
func (a *TradeAPIService) UmfuturesGetOrderV1(ctx context.Context) TradeAPIUmfuturesGetOrderV1Request {
	return TradeAPIUmfuturesGetOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetOrderV1Resp
func (a *TradeAPIService) UmfuturesGetOrderV1Execute(r TradeAPIUmfuturesGetOrderV1Request) (*UmfuturesGetOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetPositionMarginHistoryV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	type_ *int32
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetPositionMarginHistoryV1Request) Symbol(symbol string) TradeAPIUmfuturesGetPositionMarginHistoryV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesGetPositionMarginHistoryV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetPositionMarginHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// 1: Add position margin2: Reduce position margin
func (r TradeAPIUmfuturesGetPositionMarginHistoryV1Request) Type_(type_ int32) TradeAPIUmfuturesGetPositionMarginHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r TradeAPIUmfuturesGetPositionMarginHistoryV1Request) StartTime(startTime int64) TradeAPIUmfuturesGetPositionMarginHistoryV1Request {
	r.startTime = &startTime
	return r
}

// Default current time if not pass
func (r TradeAPIUmfuturesGetPositionMarginHistoryV1Request) EndTime(endTime int64) TradeAPIUmfuturesGetPositionMarginHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default: 500
func (r TradeAPIUmfuturesGetPositionMarginHistoryV1Request) Limit(limit int32) TradeAPIUmfuturesGetPositionMarginHistoryV1Request {
	r.limit = &limit
	return r
}

func (r TradeAPIUmfuturesGetPositionMarginHistoryV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetPositionMarginHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetPositionMarginHistoryV1Request) Execute() ([]UmfuturesGetPositionMarginHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetPositionMarginHistoryV1Execute(r)
}

/*
UmfuturesGetPositionMarginHistoryV1 Get Position Margin Change History (TRADE)

Get Position Margin Change History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetPositionMarginHistoryV1Request
*/
func (a *TradeAPIService) UmfuturesGetPositionMarginHistoryV1(ctx context.Context) TradeAPIUmfuturesGetPositionMarginHistoryV1Request {
	return TradeAPIUmfuturesGetPositionMarginHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetPositionMarginHistoryV1RespItem
func (a *TradeAPIService) UmfuturesGetPositionMarginHistoryV1Execute(r TradeAPIUmfuturesGetPositionMarginHistoryV1Request) ([]UmfuturesGetPositionMarginHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetPositionMarginHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetPositionMarginHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/positionMargin/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetPositionRiskV2Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetPositionRiskV2Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetPositionRiskV2Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesGetPositionRiskV2Request) Symbol(symbol string) TradeAPIUmfuturesGetPositionRiskV2Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesGetPositionRiskV2Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetPositionRiskV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetPositionRiskV2Request) Execute() ([]UmfuturesGetPositionRiskV2RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetPositionRiskV2Execute(r)
}

/*
UmfuturesGetPositionRiskV2 Position Information V2 (USER_DATA)

Get current position information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetPositionRiskV2Request
*/
func (a *TradeAPIService) UmfuturesGetPositionRiskV2(ctx context.Context) TradeAPIUmfuturesGetPositionRiskV2Request {
	return TradeAPIUmfuturesGetPositionRiskV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetPositionRiskV2RespItem
func (a *TradeAPIService) UmfuturesGetPositionRiskV2Execute(r TradeAPIUmfuturesGetPositionRiskV2Request) ([]UmfuturesGetPositionRiskV2RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetPositionRiskV2RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetPositionRiskV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v2/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetPositionRiskV3Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetPositionRiskV3Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetPositionRiskV3Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesGetPositionRiskV3Request) Symbol(symbol string) TradeAPIUmfuturesGetPositionRiskV3Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesGetPositionRiskV3Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetPositionRiskV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetPositionRiskV3Request) Execute() ([]UmfuturesGetPositionRiskV3RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetPositionRiskV3Execute(r)
}

/*
UmfuturesGetPositionRiskV3 Position Information V3 (USER_DATA)

Get current position information(only symbol that has position or open orders will be returned).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetPositionRiskV3Request
*/
func (a *TradeAPIService) UmfuturesGetPositionRiskV3(ctx context.Context) TradeAPIUmfuturesGetPositionRiskV3Request {
	return TradeAPIUmfuturesGetPositionRiskV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetPositionRiskV3RespItem
func (a *TradeAPIService) UmfuturesGetPositionRiskV3Execute(r TradeAPIUmfuturesGetPositionRiskV3Request) ([]UmfuturesGetPositionRiskV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetPositionRiskV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetPositionRiskV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v3/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesGetUserTradesV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r TradeAPIUmfuturesGetUserTradesV1Request) Symbol(symbol string) TradeAPIUmfuturesGetUserTradesV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesGetUserTradesV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesGetUserTradesV1Request {
	r.timestamp = &timestamp
	return r
}

// This can only be used in combination with &#x60;symbol&#x60;
func (r TradeAPIUmfuturesGetUserTradesV1Request) OrderId(orderId int64) TradeAPIUmfuturesGetUserTradesV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIUmfuturesGetUserTradesV1Request) StartTime(startTime int64) TradeAPIUmfuturesGetUserTradesV1Request {
	r.startTime = &startTime
	return r
}

func (r TradeAPIUmfuturesGetUserTradesV1Request) EndTime(endTime int64) TradeAPIUmfuturesGetUserTradesV1Request {
	r.endTime = &endTime
	return r
}

// Trade id to fetch from. Default gets most recent trades.
func (r TradeAPIUmfuturesGetUserTradesV1Request) FromId(fromId int64) TradeAPIUmfuturesGetUserTradesV1Request {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r TradeAPIUmfuturesGetUserTradesV1Request) Limit(limit int32) TradeAPIUmfuturesGetUserTradesV1Request {
	r.limit = &limit
	return r
}

func (r TradeAPIUmfuturesGetUserTradesV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesGetUserTradesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesGetUserTradesV1Request) Execute() ([]UmfuturesGetUserTradesV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetUserTradesV1Execute(r)
}

/*
UmfuturesGetUserTradesV1 Account Trade List (USER_DATA)

Get trades for a specific account and symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesGetUserTradesV1Request
*/
func (a *TradeAPIService) UmfuturesGetUserTradesV1(ctx context.Context) TradeAPIUmfuturesGetUserTradesV1Request {
	return TradeAPIUmfuturesGetUserTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetUserTradesV1RespItem
func (a *TradeAPIService) UmfuturesGetUserTradesV1Execute(r TradeAPIUmfuturesGetUserTradesV1Request) ([]UmfuturesGetUserTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetUserTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesGetUserTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/userTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesUpdateBatchOrdersV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	batchOrders *[]UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem
	timestamp *int64
	recvWindow *int64
}

func (r TradeAPIUmfuturesUpdateBatchOrdersV1Request) BatchOrders(batchOrders []UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem) TradeAPIUmfuturesUpdateBatchOrdersV1Request {
	r.batchOrders = &batchOrders
	return r
}

func (r TradeAPIUmfuturesUpdateBatchOrdersV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesUpdateBatchOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesUpdateBatchOrdersV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesUpdateBatchOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesUpdateBatchOrdersV1Request) Execute() ([]UmfuturesUpdateBatchOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesUpdateBatchOrdersV1Execute(r)
}

/*
UmfuturesUpdateBatchOrdersV1 Modify Multiple Orders(TRADE)

Modify Multiple Orders (TRADE)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesUpdateBatchOrdersV1Request
*/
func (a *TradeAPIService) UmfuturesUpdateBatchOrdersV1(ctx context.Context) TradeAPIUmfuturesUpdateBatchOrdersV1Request {
	return TradeAPIUmfuturesUpdateBatchOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesUpdateBatchOrdersV1RespItem
func (a *TradeAPIService) UmfuturesUpdateBatchOrdersV1Execute(r TradeAPIUmfuturesUpdateBatchOrdersV1Request) ([]UmfuturesUpdateBatchOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesUpdateBatchOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesUpdateBatchOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/batchOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchOrders == nil {
		return localVarReturnValue, nil, reportError("batchOrders is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "batchOrders", r.batchOrders, "", "csv")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TradeAPIUmfuturesUpdateOrderV1Request struct {
	ctx context.Context
	ApiService *TradeAPIService
	price *string
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	priceMatch *string
	recvWindow *int64
}

func (r TradeAPIUmfuturesUpdateOrderV1Request) Price(price string) TradeAPIUmfuturesUpdateOrderV1Request {
	r.price = &price
	return r
}

func (r TradeAPIUmfuturesUpdateOrderV1Request) Quantity(quantity string) TradeAPIUmfuturesUpdateOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r TradeAPIUmfuturesUpdateOrderV1Request) Side(side string) TradeAPIUmfuturesUpdateOrderV1Request {
	r.side = &side
	return r
}

func (r TradeAPIUmfuturesUpdateOrderV1Request) Symbol(symbol string) TradeAPIUmfuturesUpdateOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r TradeAPIUmfuturesUpdateOrderV1Request) Timestamp(timestamp int64) TradeAPIUmfuturesUpdateOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r TradeAPIUmfuturesUpdateOrderV1Request) OrderId(orderId int64) TradeAPIUmfuturesUpdateOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r TradeAPIUmfuturesUpdateOrderV1Request) OrigClientOrderId(origClientOrderId string) TradeAPIUmfuturesUpdateOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r TradeAPIUmfuturesUpdateOrderV1Request) PriceMatch(priceMatch string) TradeAPIUmfuturesUpdateOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r TradeAPIUmfuturesUpdateOrderV1Request) RecvWindow(recvWindow int64) TradeAPIUmfuturesUpdateOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r TradeAPIUmfuturesUpdateOrderV1Request) Execute() (*UmfuturesUpdateOrderV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesUpdateOrderV1Execute(r)
}

/*
UmfuturesUpdateOrderV1 Modify Order (TRADE)

Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TradeAPIUmfuturesUpdateOrderV1Request
*/
func (a *TradeAPIService) UmfuturesUpdateOrderV1(ctx context.Context) TradeAPIUmfuturesUpdateOrderV1Request {
	return TradeAPIUmfuturesUpdateOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesUpdateOrderV1Resp
func (a *TradeAPIService) UmfuturesUpdateOrderV1Execute(r TradeAPIUmfuturesUpdateOrderV1Request) (*UmfuturesUpdateOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesUpdateOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeAPIService.UmfuturesUpdateOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "orderId", r.orderId, "", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "origClientOrderId", r.origClientOrderId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Binance Umfutures API

OpenAPI specification for Binance cryptocurrency exchange - Umfutures API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package umfutures

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// V1APIService V1API service
type V1APIService service

type V1APIUmfuturesCreateBatchOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	batchOrders *[]UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesCreateBatchOrdersV1Request) BatchOrders(batchOrders []UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem) V1APIUmfuturesCreateBatchOrdersV1Request {
	r.batchOrders = &batchOrders
	return r
}

func (r V1APIUmfuturesCreateBatchOrdersV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreateBatchOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreateBatchOrdersV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreateBatchOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreateBatchOrdersV1Request) Execute() ([]UmfuturesCreateBatchOrdersV1RespInner, *http.Response, error) {
	return r.ApiService.UmfuturesCreateBatchOrdersV1Execute(r)
}

/*
UmfuturesCreateBatchOrdersV1 Place Multiple Orders(TRADE)

Place Multiple Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateBatchOrdersV1Request
*/
func (a *V1APIService) UmfuturesCreateBatchOrdersV1(ctx context.Context) V1APIUmfuturesCreateBatchOrdersV1Request {
	return V1APIUmfuturesCreateBatchOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesCreateBatchOrdersV1RespInner
func (a *V1APIService) UmfuturesCreateBatchOrdersV1Execute(r V1APIUmfuturesCreateBatchOrdersV1Request) ([]UmfuturesCreateBatchOrdersV1RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesCreateBatchOrdersV1RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateBatchOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/batchOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchOrders == nil {
		return localVarReturnValue, nil, reportError("batchOrders is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "batchOrders", r.batchOrders, "", "csv")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreateConvertAcceptQuoteV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	quoteId *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesCreateConvertAcceptQuoteV1Request) QuoteId(quoteId string) V1APIUmfuturesCreateConvertAcceptQuoteV1Request {
	r.quoteId = &quoteId
	return r
}

func (r V1APIUmfuturesCreateConvertAcceptQuoteV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreateConvertAcceptQuoteV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreateConvertAcceptQuoteV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreateConvertAcceptQuoteV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreateConvertAcceptQuoteV1Request) Execute() (*UmfuturesCreateConvertAcceptQuoteV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateConvertAcceptQuoteV1Execute(r)
}

/*
UmfuturesCreateConvertAcceptQuoteV1 Accept the offered quote (USER_DATA)

Accept the offered quote by quote ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateConvertAcceptQuoteV1Request
*/
func (a *V1APIService) UmfuturesCreateConvertAcceptQuoteV1(ctx context.Context) V1APIUmfuturesCreateConvertAcceptQuoteV1Request {
	return V1APIUmfuturesCreateConvertAcceptQuoteV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateConvertAcceptQuoteV1Resp
func (a *V1APIService) UmfuturesCreateConvertAcceptQuoteV1Execute(r V1APIUmfuturesCreateConvertAcceptQuoteV1Request) (*UmfuturesCreateConvertAcceptQuoteV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateConvertAcceptQuoteV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateConvertAcceptQuoteV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/convert/acceptQuote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.quoteId == nil {
		return localVarReturnValue, nil, reportError("quoteId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quoteId", r.quoteId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreateConvertGetQuoteV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	fromAsset *string
	timestamp *int64
	toAsset *string
	fromAmount *string
	recvWindow *int64
	toAmount *string
	validTime *string
}

func (r V1APIUmfuturesCreateConvertGetQuoteV1Request) FromAsset(fromAsset string) V1APIUmfuturesCreateConvertGetQuoteV1Request {
	r.fromAsset = &fromAsset
	return r
}

func (r V1APIUmfuturesCreateConvertGetQuoteV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreateConvertGetQuoteV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreateConvertGetQuoteV1Request) ToAsset(toAsset string) V1APIUmfuturesCreateConvertGetQuoteV1Request {
	r.toAsset = &toAsset
	return r
}

func (r V1APIUmfuturesCreateConvertGetQuoteV1Request) FromAmount(fromAmount string) V1APIUmfuturesCreateConvertGetQuoteV1Request {
	r.fromAmount = &fromAmount
	return r
}

func (r V1APIUmfuturesCreateConvertGetQuoteV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreateConvertGetQuoteV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreateConvertGetQuoteV1Request) ToAmount(toAmount string) V1APIUmfuturesCreateConvertGetQuoteV1Request {
	r.toAmount = &toAmount
	return r
}

func (r V1APIUmfuturesCreateConvertGetQuoteV1Request) ValidTime(validTime string) V1APIUmfuturesCreateConvertGetQuoteV1Request {
	r.validTime = &validTime
	return r
}

func (r V1APIUmfuturesCreateConvertGetQuoteV1Request) Execute() (*UmfuturesCreateConvertGetQuoteV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateConvertGetQuoteV1Execute(r)
}

/*
UmfuturesCreateConvertGetQuoteV1 Send Quote Request(USER_DATA)

Request a quote for the requested token pairs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateConvertGetQuoteV1Request
*/
func (a *V1APIService) UmfuturesCreateConvertGetQuoteV1(ctx context.Context) V1APIUmfuturesCreateConvertGetQuoteV1Request {
	return V1APIUmfuturesCreateConvertGetQuoteV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateConvertGetQuoteV1Resp
func (a *V1APIService) UmfuturesCreateConvertGetQuoteV1Execute(r V1APIUmfuturesCreateConvertGetQuoteV1Request) (*UmfuturesCreateConvertGetQuoteV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateConvertGetQuoteV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateConvertGetQuoteV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/convert/getQuote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromAsset == nil {
		return localVarReturnValue, nil, reportError("fromAsset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toAsset == nil {
		return localVarReturnValue, nil, reportError("toAsset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.fromAmount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromAmount", r.fromAmount, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "fromAsset", r.fromAsset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.toAmount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toAmount", r.toAmount, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "toAsset", r.toAsset, "", "")
	if r.validTime != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "validTime", r.validTime, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreateCountdownCancelAllV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	umfuturesCreateCountdownCancelAllV1Req *UmfuturesCreateCountdownCancelAllV1Req
}

func (r V1APIUmfuturesCreateCountdownCancelAllV1Request) UmfuturesCreateCountdownCancelAllV1Req(umfuturesCreateCountdownCancelAllV1Req UmfuturesCreateCountdownCancelAllV1Req) V1APIUmfuturesCreateCountdownCancelAllV1Request {
	r.umfuturesCreateCountdownCancelAllV1Req = &umfuturesCreateCountdownCancelAllV1Req
	return r
}

func (r V1APIUmfuturesCreateCountdownCancelAllV1Request) Execute() (*UmfuturesCreateCountdownCancelAllV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateCountdownCancelAllV1Execute(r)
}

/*
UmfuturesCreateCountdownCancelAllV1 Auto-Cancel All Open Orders (TRADE)

Cancel all open orders of the specified symbol at the end of the specified countdown.
The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateCountdownCancelAllV1Request
*/
func (a *V1APIService) UmfuturesCreateCountdownCancelAllV1(ctx context.Context) V1APIUmfuturesCreateCountdownCancelAllV1Request {
	return V1APIUmfuturesCreateCountdownCancelAllV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateCountdownCancelAllV1Resp
func (a *V1APIService) UmfuturesCreateCountdownCancelAllV1Execute(r V1APIUmfuturesCreateCountdownCancelAllV1Request) (*UmfuturesCreateCountdownCancelAllV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateCountdownCancelAllV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateCountdownCancelAllV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/countdownCancelAll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.umfuturesCreateCountdownCancelAllV1Req
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreateFeeBurnV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	feeBurn *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesCreateFeeBurnV1Request) FeeBurn(feeBurn string) V1APIUmfuturesCreateFeeBurnV1Request {
	r.feeBurn = &feeBurn
	return r
}

func (r V1APIUmfuturesCreateFeeBurnV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreateFeeBurnV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreateFeeBurnV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreateFeeBurnV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreateFeeBurnV1Request) Execute() (*UmfuturesCreateFeeBurnV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateFeeBurnV1Execute(r)
}

/*
UmfuturesCreateFeeBurnV1 Toggle BNB Burn On Futures Trade (TRADE)

Change user's BNB Fee Discount (Fee Discount On or Fee Discount Off ) on EVERY symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateFeeBurnV1Request
*/
func (a *V1APIService) UmfuturesCreateFeeBurnV1(ctx context.Context) V1APIUmfuturesCreateFeeBurnV1Request {
	return V1APIUmfuturesCreateFeeBurnV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateFeeBurnV1Resp
func (a *V1APIService) UmfuturesCreateFeeBurnV1Execute(r V1APIUmfuturesCreateFeeBurnV1Request) (*UmfuturesCreateFeeBurnV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateFeeBurnV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateFeeBurnV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/feeBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.feeBurn == nil {
		return localVarReturnValue, nil, reportError("feeBurn is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "feeBurn", r.feeBurn, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreateLeverageV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	leverage *int32
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesCreateLeverageV1Request) Leverage(leverage int32) V1APIUmfuturesCreateLeverageV1Request {
	r.leverage = &leverage
	return r
}

func (r V1APIUmfuturesCreateLeverageV1Request) Symbol(symbol string) V1APIUmfuturesCreateLeverageV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesCreateLeverageV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreateLeverageV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreateLeverageV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreateLeverageV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreateLeverageV1Request) Execute() (*UmfuturesCreateLeverageV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateLeverageV1Execute(r)
}

/*
UmfuturesCreateLeverageV1 Change Initial Leverage(TRADE)

Change user's initial leverage of specific symbol market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateLeverageV1Request
*/
func (a *V1APIService) UmfuturesCreateLeverageV1(ctx context.Context) V1APIUmfuturesCreateLeverageV1Request {
	return V1APIUmfuturesCreateLeverageV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateLeverageV1Resp
func (a *V1APIService) UmfuturesCreateLeverageV1Execute(r V1APIUmfuturesCreateLeverageV1Request) (*UmfuturesCreateLeverageV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateLeverageV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateLeverageV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/leverage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.leverage == nil {
		return localVarReturnValue, nil, reportError("leverage is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "leverage", r.leverage, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreateListenKeyV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIUmfuturesCreateListenKeyV1Request) Execute() (*UmfuturesCreateListenKeyV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateListenKeyV1Execute(r)
}

/*
UmfuturesCreateListenKeyV1 Start User Data Stream (USER_STREAM)

Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateListenKeyV1Request
*/
func (a *V1APIService) UmfuturesCreateListenKeyV1(ctx context.Context) V1APIUmfuturesCreateListenKeyV1Request {
	return V1APIUmfuturesCreateListenKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateListenKeyV1Resp
func (a *V1APIService) UmfuturesCreateListenKeyV1Execute(r V1APIUmfuturesCreateListenKeyV1Request) (*UmfuturesCreateListenKeyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateListenKeyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateListenKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/listenKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreateMarginTypeV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	marginType *string
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesCreateMarginTypeV1Request) MarginType(marginType string) V1APIUmfuturesCreateMarginTypeV1Request {
	r.marginType = &marginType
	return r
}

func (r V1APIUmfuturesCreateMarginTypeV1Request) Symbol(symbol string) V1APIUmfuturesCreateMarginTypeV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesCreateMarginTypeV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreateMarginTypeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreateMarginTypeV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreateMarginTypeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreateMarginTypeV1Request) Execute() (*UmfuturesCreateMarginTypeV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateMarginTypeV1Execute(r)
}

/*
UmfuturesCreateMarginTypeV1 Change Margin Type(TRADE)

Change symbol level margin type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateMarginTypeV1Request
*/
func (a *V1APIService) UmfuturesCreateMarginTypeV1(ctx context.Context) V1APIUmfuturesCreateMarginTypeV1Request {
	return V1APIUmfuturesCreateMarginTypeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateMarginTypeV1Resp
func (a *V1APIService) UmfuturesCreateMarginTypeV1Execute(r V1APIUmfuturesCreateMarginTypeV1Request) (*UmfuturesCreateMarginTypeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateMarginTypeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateMarginTypeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/marginType"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.marginType == nil {
		return localVarReturnValue, nil, reportError("marginType is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "marginType", r.marginType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreateMultiAssetsMarginV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	multiAssetsMargin *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesCreateMultiAssetsMarginV1Request) MultiAssetsMargin(multiAssetsMargin string) V1APIUmfuturesCreateMultiAssetsMarginV1Request {
	r.multiAssetsMargin = &multiAssetsMargin
	return r
}

func (r V1APIUmfuturesCreateMultiAssetsMarginV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreateMultiAssetsMarginV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreateMultiAssetsMarginV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreateMultiAssetsMarginV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreateMultiAssetsMarginV1Request) Execute() (*UmfuturesCreateMultiAssetsMarginV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateMultiAssetsMarginV1Execute(r)
}

/*
UmfuturesCreateMultiAssetsMarginV1 Change Multi-Assets Mode (TRADE)

Change user's Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateMultiAssetsMarginV1Request
*/
func (a *V1APIService) UmfuturesCreateMultiAssetsMarginV1(ctx context.Context) V1APIUmfuturesCreateMultiAssetsMarginV1Request {
	return V1APIUmfuturesCreateMultiAssetsMarginV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateMultiAssetsMarginV1Resp
func (a *V1APIService) UmfuturesCreateMultiAssetsMarginV1Execute(r V1APIUmfuturesCreateMultiAssetsMarginV1Request) (*UmfuturesCreateMultiAssetsMarginV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateMultiAssetsMarginV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateMultiAssetsMarginV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/multiAssetsMargin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.multiAssetsMargin == nil {
		return localVarReturnValue, nil, reportError("multiAssetsMargin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "multiAssetsMargin", r.multiAssetsMargin, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreateOrderTestV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	activationPrice *string
	callbackRate *string
	closePosition *string
	goodTillDate *int64
	newClientOrderId *string
	newOrderRespType *string
	positionSide *string
	price *string
	priceMatch *string
	priceProtect *string
	quantity *string
	recvWindow *int64
	reduceOnly *string
	selfTradePreventionMode *string
	stopPrice *string
	timeInForce *string
	workingType *string
}

func (r V1APIUmfuturesCreateOrderTestV1Request) Side(side string) V1APIUmfuturesCreateOrderTestV1Request {
	r.side = &side
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) Symbol(symbol string) V1APIUmfuturesCreateOrderTestV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreateOrderTestV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) Type_(type_ string) V1APIUmfuturesCreateOrderTestV1Request {
	r.type_ = &type_
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) ActivationPrice(activationPrice string) V1APIUmfuturesCreateOrderTestV1Request {
	r.activationPrice = &activationPrice
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) CallbackRate(callbackRate string) V1APIUmfuturesCreateOrderTestV1Request {
	r.callbackRate = &callbackRate
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) ClosePosition(closePosition string) V1APIUmfuturesCreateOrderTestV1Request {
	r.closePosition = &closePosition
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) GoodTillDate(goodTillDate int64) V1APIUmfuturesCreateOrderTestV1Request {
	r.goodTillDate = &goodTillDate
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) NewClientOrderId(newClientOrderId string) V1APIUmfuturesCreateOrderTestV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) NewOrderRespType(newOrderRespType string) V1APIUmfuturesCreateOrderTestV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) PositionSide(positionSide string) V1APIUmfuturesCreateOrderTestV1Request {
	r.positionSide = &positionSide
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) Price(price string) V1APIUmfuturesCreateOrderTestV1Request {
	r.price = &price
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) PriceMatch(priceMatch string) V1APIUmfuturesCreateOrderTestV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) PriceProtect(priceProtect string) V1APIUmfuturesCreateOrderTestV1Request {
	r.priceProtect = &priceProtect
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) Quantity(quantity string) V1APIUmfuturesCreateOrderTestV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreateOrderTestV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) ReduceOnly(reduceOnly string) V1APIUmfuturesCreateOrderTestV1Request {
	r.reduceOnly = &reduceOnly
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) SelfTradePreventionMode(selfTradePreventionMode string) V1APIUmfuturesCreateOrderTestV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) StopPrice(stopPrice string) V1APIUmfuturesCreateOrderTestV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) TimeInForce(timeInForce string) V1APIUmfuturesCreateOrderTestV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) WorkingType(workingType string) V1APIUmfuturesCreateOrderTestV1Request {
	r.workingType = &workingType
	return r
}

func (r V1APIUmfuturesCreateOrderTestV1Request) Execute() (*UmfuturesCreateOrderTestV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateOrderTestV1Execute(r)
}

/*
UmfuturesCreateOrderTestV1 Test Order(TRADE)

Testing order request, this order will not be submitted to matching engine

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateOrderTestV1Request
*/
func (a *V1APIService) UmfuturesCreateOrderTestV1(ctx context.Context) V1APIUmfuturesCreateOrderTestV1Request {
	return V1APIUmfuturesCreateOrderTestV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateOrderTestV1Resp
func (a *V1APIService) UmfuturesCreateOrderTestV1Execute(r V1APIUmfuturesCreateOrderTestV1Request) (*UmfuturesCreateOrderTestV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateOrderTestV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateOrderTestV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.activationPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "activationPrice", r.activationPrice, "", "")
	}
	if r.callbackRate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callbackRate", r.callbackRate, "", "")
	}
	if r.closePosition != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "closePosition", r.closePosition, "", "")
	}
	if r.goodTillDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "goodTillDate", r.goodTillDate, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	if r.priceProtect != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceProtect", r.priceProtect, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.reduceOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reduceOnly", r.reduceOnly, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.workingType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreateOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	activationPrice *string
	callbackRate *string
	closePosition *string
	goodTillDate *int64
	newClientOrderId *string
	newOrderRespType *string
	positionSide *string
	price *string
	priceMatch *string
	priceProtect *string
	quantity *string
	recvWindow *int64
	reduceOnly *string
	selfTradePreventionMode *string
	stopPrice *string
	timeInForce *string
	workingType *string
}

func (r V1APIUmfuturesCreateOrderV1Request) Side(side string) V1APIUmfuturesCreateOrderV1Request {
	r.side = &side
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) Symbol(symbol string) V1APIUmfuturesCreateOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreateOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) Type_(type_ string) V1APIUmfuturesCreateOrderV1Request {
	r.type_ = &type_
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) ActivationPrice(activationPrice string) V1APIUmfuturesCreateOrderV1Request {
	r.activationPrice = &activationPrice
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) CallbackRate(callbackRate string) V1APIUmfuturesCreateOrderV1Request {
	r.callbackRate = &callbackRate
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) ClosePosition(closePosition string) V1APIUmfuturesCreateOrderV1Request {
	r.closePosition = &closePosition
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) GoodTillDate(goodTillDate int64) V1APIUmfuturesCreateOrderV1Request {
	r.goodTillDate = &goodTillDate
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) NewClientOrderId(newClientOrderId string) V1APIUmfuturesCreateOrderV1Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) NewOrderRespType(newOrderRespType string) V1APIUmfuturesCreateOrderV1Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) PositionSide(positionSide string) V1APIUmfuturesCreateOrderV1Request {
	r.positionSide = &positionSide
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) Price(price string) V1APIUmfuturesCreateOrderV1Request {
	r.price = &price
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) PriceMatch(priceMatch string) V1APIUmfuturesCreateOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) PriceProtect(priceProtect string) V1APIUmfuturesCreateOrderV1Request {
	r.priceProtect = &priceProtect
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) Quantity(quantity string) V1APIUmfuturesCreateOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreateOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) ReduceOnly(reduceOnly string) V1APIUmfuturesCreateOrderV1Request {
	r.reduceOnly = &reduceOnly
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) SelfTradePreventionMode(selfTradePreventionMode string) V1APIUmfuturesCreateOrderV1Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) StopPrice(stopPrice string) V1APIUmfuturesCreateOrderV1Request {
	r.stopPrice = &stopPrice
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) TimeInForce(timeInForce string) V1APIUmfuturesCreateOrderV1Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) WorkingType(workingType string) V1APIUmfuturesCreateOrderV1Request {
	r.workingType = &workingType
	return r
}

func (r V1APIUmfuturesCreateOrderV1Request) Execute() (*UmfuturesCreateOrderV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreateOrderV1Execute(r)
}

/*
UmfuturesCreateOrderV1 New Order(TRADE)

Send in a new order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreateOrderV1Request
*/
func (a *V1APIService) UmfuturesCreateOrderV1(ctx context.Context) V1APIUmfuturesCreateOrderV1Request {
	return V1APIUmfuturesCreateOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreateOrderV1Resp
func (a *V1APIService) UmfuturesCreateOrderV1Execute(r V1APIUmfuturesCreateOrderV1Request) (*UmfuturesCreateOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreateOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreateOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.activationPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "activationPrice", r.activationPrice, "", "")
	}
	if r.callbackRate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callbackRate", r.callbackRate, "", "")
	}
	if r.closePosition != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "closePosition", r.closePosition, "", "")
	}
	if r.goodTillDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "goodTillDate", r.goodTillDate, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	if r.priceProtect != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceProtect", r.priceProtect, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.reduceOnly != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reduceOnly", r.reduceOnly, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.workingType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreatePositionMarginV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	amount *string
	symbol *string
	timestamp *int64
	type_ *int32
	positionSide *string
	recvWindow *int64
}

func (r V1APIUmfuturesCreatePositionMarginV1Request) Amount(amount string) V1APIUmfuturesCreatePositionMarginV1Request {
	r.amount = &amount
	return r
}

func (r V1APIUmfuturesCreatePositionMarginV1Request) Symbol(symbol string) V1APIUmfuturesCreatePositionMarginV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesCreatePositionMarginV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreatePositionMarginV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreatePositionMarginV1Request) Type_(type_ int32) V1APIUmfuturesCreatePositionMarginV1Request {
	r.type_ = &type_
	return r
}

func (r V1APIUmfuturesCreatePositionMarginV1Request) PositionSide(positionSide string) V1APIUmfuturesCreatePositionMarginV1Request {
	r.positionSide = &positionSide
	return r
}

func (r V1APIUmfuturesCreatePositionMarginV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreatePositionMarginV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreatePositionMarginV1Request) Execute() (*UmfuturesCreatePositionMarginV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreatePositionMarginV1Execute(r)
}

/*
UmfuturesCreatePositionMarginV1 Modify Isolated Position Margin(TRADE)

Modify Isolated Position Margin

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreatePositionMarginV1Request
*/
func (a *V1APIService) UmfuturesCreatePositionMarginV1(ctx context.Context) V1APIUmfuturesCreatePositionMarginV1Request {
	return V1APIUmfuturesCreatePositionMarginV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreatePositionMarginV1Resp
func (a *V1APIService) UmfuturesCreatePositionMarginV1Execute(r V1APIUmfuturesCreatePositionMarginV1Request) (*UmfuturesCreatePositionMarginV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreatePositionMarginV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreatePositionMarginV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/positionMargin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.positionSide != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "positionSide", r.positionSide, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesCreatePositionSideDualV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	dualSidePosition *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesCreatePositionSideDualV1Request) DualSidePosition(dualSidePosition string) V1APIUmfuturesCreatePositionSideDualV1Request {
	r.dualSidePosition = &dualSidePosition
	return r
}

func (r V1APIUmfuturesCreatePositionSideDualV1Request) Timestamp(timestamp int64) V1APIUmfuturesCreatePositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesCreatePositionSideDualV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesCreatePositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesCreatePositionSideDualV1Request) Execute() (*UmfuturesCreatePositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesCreatePositionSideDualV1Execute(r)
}

/*
UmfuturesCreatePositionSideDualV1 Change Position Mode(TRADE)

Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesCreatePositionSideDualV1Request
*/
func (a *V1APIService) UmfuturesCreatePositionSideDualV1(ctx context.Context) V1APIUmfuturesCreatePositionSideDualV1Request {
	return V1APIUmfuturesCreatePositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesCreatePositionSideDualV1Resp
func (a *V1APIService) UmfuturesCreatePositionSideDualV1Execute(r V1APIUmfuturesCreatePositionSideDualV1Request) (*UmfuturesCreatePositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesCreatePositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesCreatePositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dualSidePosition == nil {
		return localVarReturnValue, nil, reportError("dualSidePosition is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "dualSidePosition", r.dualSidePosition, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesDeleteAllOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesDeleteAllOpenOrdersV1Request) Symbol(symbol string) V1APIUmfuturesDeleteAllOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesDeleteAllOpenOrdersV1Request) Timestamp(timestamp int64) V1APIUmfuturesDeleteAllOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesDeleteAllOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesDeleteAllOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesDeleteAllOpenOrdersV1Request) Execute() (*UmfuturesDeleteAllOpenOrdersV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesDeleteAllOpenOrdersV1Execute(r)
}

/*
UmfuturesDeleteAllOpenOrdersV1 Cancel All Open Orders (TRADE)

Cancel All Open Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesDeleteAllOpenOrdersV1Request
*/
func (a *V1APIService) UmfuturesDeleteAllOpenOrdersV1(ctx context.Context) V1APIUmfuturesDeleteAllOpenOrdersV1Request {
	return V1APIUmfuturesDeleteAllOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesDeleteAllOpenOrdersV1Resp
func (a *V1APIService) UmfuturesDeleteAllOpenOrdersV1Execute(r V1APIUmfuturesDeleteAllOpenOrdersV1Request) (*UmfuturesDeleteAllOpenOrdersV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesDeleteAllOpenOrdersV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesDeleteAllOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/allOpenOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesDeleteBatchOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderIdList *[]int64
	origClientOrderIdList *[]string
	recvWindow *int64
}

func (r V1APIUmfuturesDeleteBatchOrdersV1Request) Symbol(symbol string) V1APIUmfuturesDeleteBatchOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesDeleteBatchOrdersV1Request) Timestamp(timestamp int64) V1APIUmfuturesDeleteBatchOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

// max length 10 &lt;br/&gt; e.g. [1234567,2345678]
func (r V1APIUmfuturesDeleteBatchOrdersV1Request) OrderIdList(orderIdList []int64) V1APIUmfuturesDeleteBatchOrdersV1Request {
	r.orderIdList = &orderIdList
	return r
}

// max length 10&lt;br/&gt; e.g. [&amp;#34;my_id_1&amp;#34;,&amp;#34;my_id_2&amp;#34;], encode the double quotes. No space after comma.
func (r V1APIUmfuturesDeleteBatchOrdersV1Request) OrigClientOrderIdList(origClientOrderIdList []string) V1APIUmfuturesDeleteBatchOrdersV1Request {
	r.origClientOrderIdList = &origClientOrderIdList
	return r
}

func (r V1APIUmfuturesDeleteBatchOrdersV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesDeleteBatchOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesDeleteBatchOrdersV1Request) Execute() ([]UmfuturesDeleteBatchOrdersV1RespInner, *http.Response, error) {
	return r.ApiService.UmfuturesDeleteBatchOrdersV1Execute(r)
}

/*
UmfuturesDeleteBatchOrdersV1 Cancel Multiple Orders (TRADE)

Cancel Multiple Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesDeleteBatchOrdersV1Request
*/
func (a *V1APIService) UmfuturesDeleteBatchOrdersV1(ctx context.Context) V1APIUmfuturesDeleteBatchOrdersV1Request {
	return V1APIUmfuturesDeleteBatchOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesDeleteBatchOrdersV1RespInner
func (a *V1APIService) UmfuturesDeleteBatchOrdersV1Execute(r V1APIUmfuturesDeleteBatchOrdersV1Request) ([]UmfuturesDeleteBatchOrdersV1RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesDeleteBatchOrdersV1RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesDeleteBatchOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/batchOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderIdList != nil {
		t := *r.orderIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orderIdList", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orderIdList", t, "form", "multi")
		}
	}
	if r.origClientOrderIdList != nil {
		t := *r.origClientOrderIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderIdList", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderIdList", t, "form", "multi")
		}
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesDeleteListenKeyV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIUmfuturesDeleteListenKeyV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UmfuturesDeleteListenKeyV1Execute(r)
}

/*
UmfuturesDeleteListenKeyV1 Close User Data Stream (USER_STREAM)

Close out a user data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesDeleteListenKeyV1Request
*/
func (a *V1APIService) UmfuturesDeleteListenKeyV1(ctx context.Context) V1APIUmfuturesDeleteListenKeyV1Request {
	return V1APIUmfuturesDeleteListenKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V1APIService) UmfuturesDeleteListenKeyV1Execute(r V1APIUmfuturesDeleteListenKeyV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesDeleteListenKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/listenKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesDeleteOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIUmfuturesDeleteOrderV1Request) Symbol(symbol string) V1APIUmfuturesDeleteOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesDeleteOrderV1Request) Timestamp(timestamp int64) V1APIUmfuturesDeleteOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesDeleteOrderV1Request) OrderId(orderId int64) V1APIUmfuturesDeleteOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIUmfuturesDeleteOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIUmfuturesDeleteOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIUmfuturesDeleteOrderV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesDeleteOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesDeleteOrderV1Request) Execute() (*UmfuturesDeleteOrderV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesDeleteOrderV1Execute(r)
}

/*
UmfuturesDeleteOrderV1 Cancel Order (TRADE)

Cancel an active order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesDeleteOrderV1Request
*/
func (a *V1APIService) UmfuturesDeleteOrderV1(ctx context.Context) V1APIUmfuturesDeleteOrderV1Request {
	return V1APIUmfuturesDeleteOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesDeleteOrderV1Resp
func (a *V1APIService) UmfuturesDeleteOrderV1Execute(r V1APIUmfuturesDeleteOrderV1Request) (*UmfuturesDeleteOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesDeleteOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesDeleteOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetAccountConfigV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesGetAccountConfigV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetAccountConfigV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetAccountConfigV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetAccountConfigV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetAccountConfigV1Request) Execute() (*UmfuturesGetAccountConfigV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetAccountConfigV1Execute(r)
}

/*
UmfuturesGetAccountConfigV1 Futures Account Configuration(USER_DATA)

Query account configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetAccountConfigV1Request
*/
func (a *V1APIService) UmfuturesGetAccountConfigV1(ctx context.Context) V1APIUmfuturesGetAccountConfigV1Request {
	return V1APIUmfuturesGetAccountConfigV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetAccountConfigV1Resp
func (a *V1APIService) UmfuturesGetAccountConfigV1Execute(r V1APIUmfuturesGetAccountConfigV1Request) (*UmfuturesGetAccountConfigV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetAccountConfigV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetAccountConfigV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/accountConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetAdlQuantileV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIUmfuturesGetAdlQuantileV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetAdlQuantileV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetAdlQuantileV1Request) Symbol(symbol string) V1APIUmfuturesGetAdlQuantileV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetAdlQuantileV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetAdlQuantileV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetAdlQuantileV1Request) Execute() ([]UmfuturesGetAdlQuantileV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetAdlQuantileV1Execute(r)
}

/*
UmfuturesGetAdlQuantileV1 Position ADL Quantile Estimation(USER_DATA)

Position ADL Quantile Estimation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetAdlQuantileV1Request
*/
func (a *V1APIService) UmfuturesGetAdlQuantileV1(ctx context.Context) V1APIUmfuturesGetAdlQuantileV1Request {
	return V1APIUmfuturesGetAdlQuantileV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetAdlQuantileV1RespItem
func (a *V1APIService) UmfuturesGetAdlQuantileV1Execute(r V1APIUmfuturesGetAdlQuantileV1Request) ([]UmfuturesGetAdlQuantileV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetAdlQuantileV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetAdlQuantileV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/adlQuantile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetAggTradesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
}

func (r V1APIUmfuturesGetAggTradesV1Request) Symbol(symbol string) V1APIUmfuturesGetAggTradesV1Request {
	r.symbol = &symbol
	return r
}

// ID to get aggregate trades from INCLUSIVE.
func (r V1APIUmfuturesGetAggTradesV1Request) FromId(fromId int64) V1APIUmfuturesGetAggTradesV1Request {
	r.fromId = &fromId
	return r
}

// Timestamp in ms to get aggregate trades from INCLUSIVE.
func (r V1APIUmfuturesGetAggTradesV1Request) StartTime(startTime int64) V1APIUmfuturesGetAggTradesV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get aggregate trades until INCLUSIVE.
func (r V1APIUmfuturesGetAggTradesV1Request) EndTime(endTime int64) V1APIUmfuturesGetAggTradesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r V1APIUmfuturesGetAggTradesV1Request) Limit(limit int32) V1APIUmfuturesGetAggTradesV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetAggTradesV1Request) Execute() ([]UmfuturesGetAggTradesV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetAggTradesV1Execute(r)
}

/*
UmfuturesGetAggTradesV1 Compressed/Aggregate Trades List

Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetAggTradesV1Request
*/
func (a *V1APIService) UmfuturesGetAggTradesV1(ctx context.Context) V1APIUmfuturesGetAggTradesV1Request {
	return V1APIUmfuturesGetAggTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetAggTradesV1RespItem
func (a *V1APIService) UmfuturesGetAggTradesV1Execute(r V1APIUmfuturesGetAggTradesV1Request) ([]UmfuturesGetAggTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetAggTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetAggTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/aggTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetAllOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIUmfuturesGetAllOrdersV1Request) Symbol(symbol string) V1APIUmfuturesGetAllOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetAllOrdersV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetAllOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetAllOrdersV1Request) OrderId(orderId int64) V1APIUmfuturesGetAllOrdersV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIUmfuturesGetAllOrdersV1Request) StartTime(startTime int64) V1APIUmfuturesGetAllOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIUmfuturesGetAllOrdersV1Request) EndTime(endTime int64) V1APIUmfuturesGetAllOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r V1APIUmfuturesGetAllOrdersV1Request) Limit(limit int32) V1APIUmfuturesGetAllOrdersV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetAllOrdersV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetAllOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetAllOrdersV1Request) Execute() ([]UmfuturesGetAllOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetAllOrdersV1Execute(r)
}

/*
UmfuturesGetAllOrdersV1 All Orders (USER_DATA)

Get all account orders; active, canceled, or filled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetAllOrdersV1Request
*/
func (a *V1APIService) UmfuturesGetAllOrdersV1(ctx context.Context) V1APIUmfuturesGetAllOrdersV1Request {
	return V1APIUmfuturesGetAllOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetAllOrdersV1RespItem
func (a *V1APIService) UmfuturesGetAllOrdersV1Execute(r V1APIUmfuturesGetAllOrdersV1Request) ([]UmfuturesGetAllOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetAllOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetAllOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetApiTradingStatusV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIUmfuturesGetApiTradingStatusV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetApiTradingStatusV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetApiTradingStatusV1Request) Symbol(symbol string) V1APIUmfuturesGetApiTradingStatusV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetApiTradingStatusV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetApiTradingStatusV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetApiTradingStatusV1Request) Execute() (*UmfuturesGetApiTradingStatusV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetApiTradingStatusV1Execute(r)
}

/*
UmfuturesGetApiTradingStatusV1 Futures Trading Quantitative Rules Indicators (USER_DATA)

Futures trading quantitative rules indicators, for more information on this, please refer to the Futures Trading Quantitative Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetApiTradingStatusV1Request
*/
func (a *V1APIService) UmfuturesGetApiTradingStatusV1(ctx context.Context) V1APIUmfuturesGetApiTradingStatusV1Request {
	return V1APIUmfuturesGetApiTradingStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetApiTradingStatusV1Resp
func (a *V1APIService) UmfuturesGetApiTradingStatusV1Execute(r V1APIUmfuturesGetApiTradingStatusV1Request) (*UmfuturesGetApiTradingStatusV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetApiTradingStatusV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetApiTradingStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/apiTradingStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetAssetIndexV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
}

// Asset pair
func (r V1APIUmfuturesGetAssetIndexV1Request) Symbol(symbol string) V1APIUmfuturesGetAssetIndexV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetAssetIndexV1Request) Execute() (*UmfuturesGetAssetIndexV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetAssetIndexV1Execute(r)
}

/*
UmfuturesGetAssetIndexV1 Multi-Assets Mode Asset Index

asset index for Multi-Assets mode

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetAssetIndexV1Request
*/
func (a *V1APIService) UmfuturesGetAssetIndexV1(ctx context.Context) V1APIUmfuturesGetAssetIndexV1Request {
	return V1APIUmfuturesGetAssetIndexV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetAssetIndexV1Resp
func (a *V1APIService) UmfuturesGetAssetIndexV1Execute(r V1APIUmfuturesGetAssetIndexV1Request) (*UmfuturesGetAssetIndexV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetAssetIndexV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetAssetIndexV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/assetIndex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetCommissionRateV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesGetCommissionRateV1Request) Symbol(symbol string) V1APIUmfuturesGetCommissionRateV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetCommissionRateV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetCommissionRateV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetCommissionRateV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetCommissionRateV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetCommissionRateV1Request) Execute() (*UmfuturesGetCommissionRateV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetCommissionRateV1Execute(r)
}

/*
UmfuturesGetCommissionRateV1 User Commission Rate (USER_DATA)

Get User Commission Rate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetCommissionRateV1Request
*/
func (a *V1APIService) UmfuturesGetCommissionRateV1(ctx context.Context) V1APIUmfuturesGetCommissionRateV1Request {
	return V1APIUmfuturesGetCommissionRateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetCommissionRateV1Resp
func (a *V1APIService) UmfuturesGetCommissionRateV1Execute(r V1APIUmfuturesGetCommissionRateV1Request) (*UmfuturesGetCommissionRateV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetCommissionRateV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetCommissionRateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/commissionRate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetConstituentsV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
}

func (r V1APIUmfuturesGetConstituentsV1Request) Symbol(symbol string) V1APIUmfuturesGetConstituentsV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetConstituentsV1Request) Execute() (*UmfuturesGetConstituentsV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetConstituentsV1Execute(r)
}

/*
UmfuturesGetConstituentsV1 Query Index Price Constituents

Query index price constituents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetConstituentsV1Request
*/
func (a *V1APIService) UmfuturesGetConstituentsV1(ctx context.Context) V1APIUmfuturesGetConstituentsV1Request {
	return V1APIUmfuturesGetConstituentsV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetConstituentsV1Resp
func (a *V1APIService) UmfuturesGetConstituentsV1Execute(r V1APIUmfuturesGetConstituentsV1Request) (*UmfuturesGetConstituentsV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetConstituentsV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetConstituentsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/constituents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetContinuousKlinesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	pair *string
	contractType *string
	interval *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r V1APIUmfuturesGetContinuousKlinesV1Request) Pair(pair string) V1APIUmfuturesGetContinuousKlinesV1Request {
	r.pair = &pair
	return r
}

func (r V1APIUmfuturesGetContinuousKlinesV1Request) ContractType(contractType string) V1APIUmfuturesGetContinuousKlinesV1Request {
	r.contractType = &contractType
	return r
}

func (r V1APIUmfuturesGetContinuousKlinesV1Request) Interval(interval string) V1APIUmfuturesGetContinuousKlinesV1Request {
	r.interval = &interval
	return r
}

func (r V1APIUmfuturesGetContinuousKlinesV1Request) StartTime(startTime int64) V1APIUmfuturesGetContinuousKlinesV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIUmfuturesGetContinuousKlinesV1Request) EndTime(endTime int64) V1APIUmfuturesGetContinuousKlinesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1500.
func (r V1APIUmfuturesGetContinuousKlinesV1Request) Limit(limit int32) V1APIUmfuturesGetContinuousKlinesV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetContinuousKlinesV1Request) Execute() ([][]UmfuturesGetContinuousKlinesV1RespInnerInner, *http.Response, error) {
	return r.ApiService.UmfuturesGetContinuousKlinesV1Execute(r)
}

/*
UmfuturesGetContinuousKlinesV1 Continuous Contract Kline/Candlestick Data

Kline/candlestick bars for a specific contract type.
Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetContinuousKlinesV1Request
*/
func (a *V1APIService) UmfuturesGetContinuousKlinesV1(ctx context.Context) V1APIUmfuturesGetContinuousKlinesV1Request {
	return V1APIUmfuturesGetContinuousKlinesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]UmfuturesGetContinuousKlinesV1RespInnerInner
func (a *V1APIService) UmfuturesGetContinuousKlinesV1Execute(r V1APIUmfuturesGetContinuousKlinesV1Request) ([][]UmfuturesGetContinuousKlinesV1RespInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]UmfuturesGetContinuousKlinesV1RespInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetContinuousKlinesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/continuousKlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pair == nil {
		return localVarReturnValue, nil, reportError("pair is required and must be specified")
	}
	if r.contractType == nil {
		return localVarReturnValue, nil, reportError("contractType is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "contractType", r.contractType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetConvertExchangeInfoV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	fromAsset *string
	toAsset *string
}

// User spends coin
func (r V1APIUmfuturesGetConvertExchangeInfoV1Request) FromAsset(fromAsset string) V1APIUmfuturesGetConvertExchangeInfoV1Request {
	r.fromAsset = &fromAsset
	return r
}

// User receives coin
func (r V1APIUmfuturesGetConvertExchangeInfoV1Request) ToAsset(toAsset string) V1APIUmfuturesGetConvertExchangeInfoV1Request {
	r.toAsset = &toAsset
	return r
}

func (r V1APIUmfuturesGetConvertExchangeInfoV1Request) Execute() ([]UmfuturesGetConvertExchangeInfoV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetConvertExchangeInfoV1Execute(r)
}

/*
UmfuturesGetConvertExchangeInfoV1 List All Convert Pairs

Query for all convertible token pairs and the tokens’ respective upper/lower limits

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetConvertExchangeInfoV1Request
*/
func (a *V1APIService) UmfuturesGetConvertExchangeInfoV1(ctx context.Context) V1APIUmfuturesGetConvertExchangeInfoV1Request {
	return V1APIUmfuturesGetConvertExchangeInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetConvertExchangeInfoV1RespItem
func (a *V1APIService) UmfuturesGetConvertExchangeInfoV1Execute(r V1APIUmfuturesGetConvertExchangeInfoV1Request) ([]UmfuturesGetConvertExchangeInfoV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetConvertExchangeInfoV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetConvertExchangeInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/convert/exchangeInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromAsset", r.fromAsset, "form", "")
	} else {
		var defaultValue string = ""
		r.fromAsset = &defaultValue
	}
	if r.toAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toAsset", r.toAsset, "form", "")
	} else {
		var defaultValue string = ""
		r.toAsset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetConvertOrderStatusV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	orderId *string
	quoteId *string
}

// Either orderId or quoteId is required
func (r V1APIUmfuturesGetConvertOrderStatusV1Request) OrderId(orderId string) V1APIUmfuturesGetConvertOrderStatusV1Request {
	r.orderId = &orderId
	return r
}

// Either orderId or quoteId is required
func (r V1APIUmfuturesGetConvertOrderStatusV1Request) QuoteId(quoteId string) V1APIUmfuturesGetConvertOrderStatusV1Request {
	r.quoteId = &quoteId
	return r
}

func (r V1APIUmfuturesGetConvertOrderStatusV1Request) Execute() (*UmfuturesGetConvertOrderStatusV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetConvertOrderStatusV1Execute(r)
}

/*
UmfuturesGetConvertOrderStatusV1 Order status(USER_DATA)

Query order status by order ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetConvertOrderStatusV1Request
*/
func (a *V1APIService) UmfuturesGetConvertOrderStatusV1(ctx context.Context) V1APIUmfuturesGetConvertOrderStatusV1Request {
	return V1APIUmfuturesGetConvertOrderStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetConvertOrderStatusV1Resp
func (a *V1APIService) UmfuturesGetConvertOrderStatusV1Execute(r V1APIUmfuturesGetConvertOrderStatusV1Request) (*UmfuturesGetConvertOrderStatusV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetConvertOrderStatusV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetConvertOrderStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/convert/orderStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	} else {
		var defaultValue string = ""
		r.orderId = &defaultValue
	}
	if r.quoteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quoteId", r.quoteId, "form", "")
	} else {
		var defaultValue string = ""
		r.quoteId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetDepthV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	limit *int32
}

func (r V1APIUmfuturesGetDepthV1Request) Symbol(symbol string) V1APIUmfuturesGetDepthV1Request {
	r.symbol = &symbol
	return r
}

// Default 500; Valid limits:[5, 10, 20, 50, 100, 500, 1000]
func (r V1APIUmfuturesGetDepthV1Request) Limit(limit int32) V1APIUmfuturesGetDepthV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetDepthV1Request) Execute() (*UmfuturesGetDepthV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetDepthV1Execute(r)
}

/*
UmfuturesGetDepthV1 Order Book

Query symbol orderbook

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetDepthV1Request
*/
func (a *V1APIService) UmfuturesGetDepthV1(ctx context.Context) V1APIUmfuturesGetDepthV1Request {
	return V1APIUmfuturesGetDepthV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetDepthV1Resp
func (a *V1APIService) UmfuturesGetDepthV1Execute(r V1APIUmfuturesGetDepthV1Request) (*UmfuturesGetDepthV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetDepthV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetDepthV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetExchangeInfoV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIUmfuturesGetExchangeInfoV1Request) Execute() (*UmfuturesGetExchangeInfoV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetExchangeInfoV1Execute(r)
}

/*
UmfuturesGetExchangeInfoV1 Exchange Information

Current exchange trading rules and symbol information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetExchangeInfoV1Request
*/
func (a *V1APIService) UmfuturesGetExchangeInfoV1(ctx context.Context) V1APIUmfuturesGetExchangeInfoV1Request {
	return V1APIUmfuturesGetExchangeInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetExchangeInfoV1Resp
func (a *V1APIService) UmfuturesGetExchangeInfoV1Execute(r V1APIUmfuturesGetExchangeInfoV1Request) (*UmfuturesGetExchangeInfoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetExchangeInfoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetExchangeInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/exchangeInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetFeeBurnV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesGetFeeBurnV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetFeeBurnV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetFeeBurnV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetFeeBurnV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetFeeBurnV1Request) Execute() (*UmfuturesGetFeeBurnV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetFeeBurnV1Execute(r)
}

/*
UmfuturesGetFeeBurnV1 Get BNB Burn Status (USER_DATA)

Get user's BNB Fee Discount (Fee Discount On or Fee Discount Off )

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetFeeBurnV1Request
*/
func (a *V1APIService) UmfuturesGetFeeBurnV1(ctx context.Context) V1APIUmfuturesGetFeeBurnV1Request {
	return V1APIUmfuturesGetFeeBurnV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetFeeBurnV1Resp
func (a *V1APIService) UmfuturesGetFeeBurnV1Execute(r V1APIUmfuturesGetFeeBurnV1Request) (*UmfuturesGetFeeBurnV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetFeeBurnV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetFeeBurnV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/feeBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetForceOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	autoCloseType *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIUmfuturesGetForceOrdersV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetForceOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetForceOrdersV1Request) Symbol(symbol string) V1APIUmfuturesGetForceOrdersV1Request {
	r.symbol = &symbol
	return r
}

// &amp;#34;LIQUIDATION&amp;#34; for liquidation orders, &amp;#34;ADL&amp;#34; for ADL orders.
func (r V1APIUmfuturesGetForceOrdersV1Request) AutoCloseType(autoCloseType string) V1APIUmfuturesGetForceOrdersV1Request {
	r.autoCloseType = &autoCloseType
	return r
}

func (r V1APIUmfuturesGetForceOrdersV1Request) StartTime(startTime int64) V1APIUmfuturesGetForceOrdersV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIUmfuturesGetForceOrdersV1Request) EndTime(endTime int64) V1APIUmfuturesGetForceOrdersV1Request {
	r.endTime = &endTime
	return r
}

// Default 50; max 100.
func (r V1APIUmfuturesGetForceOrdersV1Request) Limit(limit int32) V1APIUmfuturesGetForceOrdersV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetForceOrdersV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetForceOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetForceOrdersV1Request) Execute() ([]UmfuturesGetForceOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetForceOrdersV1Execute(r)
}

/*
UmfuturesGetForceOrdersV1 User's Force Orders (USER_DATA)

Query user's Force Orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetForceOrdersV1Request
*/
func (a *V1APIService) UmfuturesGetForceOrdersV1(ctx context.Context) V1APIUmfuturesGetForceOrdersV1Request {
	return V1APIUmfuturesGetForceOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetForceOrdersV1RespItem
func (a *V1APIService) UmfuturesGetForceOrdersV1Execute(r V1APIUmfuturesGetForceOrdersV1Request) ([]UmfuturesGetForceOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetForceOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetForceOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/forceOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.autoCloseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCloseType", r.autoCloseType, "form", "")
	} else {
		var defaultValue string = ""
		r.autoCloseType = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetFundingInfoV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIUmfuturesGetFundingInfoV1Request) Execute() ([]UmfuturesGetFundingInfoV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetFundingInfoV1Execute(r)
}

/*
UmfuturesGetFundingInfoV1 Get Funding Rate Info

Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetFundingInfoV1Request
*/
func (a *V1APIService) UmfuturesGetFundingInfoV1(ctx context.Context) V1APIUmfuturesGetFundingInfoV1Request {
	return V1APIUmfuturesGetFundingInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetFundingInfoV1RespItem
func (a *V1APIService) UmfuturesGetFundingInfoV1Execute(r V1APIUmfuturesGetFundingInfoV1Request) ([]UmfuturesGetFundingInfoV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetFundingInfoV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetFundingInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/fundingInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetFundingRateV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r V1APIUmfuturesGetFundingRateV1Request) Symbol(symbol string) V1APIUmfuturesGetFundingRateV1Request {
	r.symbol = &symbol
	return r
}

// Timestamp in ms to get funding rate from INCLUSIVE.
func (r V1APIUmfuturesGetFundingRateV1Request) StartTime(startTime int64) V1APIUmfuturesGetFundingRateV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get funding rate  until INCLUSIVE.
func (r V1APIUmfuturesGetFundingRateV1Request) EndTime(endTime int64) V1APIUmfuturesGetFundingRateV1Request {
	r.endTime = &endTime
	return r
}

// Default 100; max 1000
func (r V1APIUmfuturesGetFundingRateV1Request) Limit(limit int32) V1APIUmfuturesGetFundingRateV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetFundingRateV1Request) Execute() ([]UmfuturesGetFundingRateV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetFundingRateV1Execute(r)
}

/*
UmfuturesGetFundingRateV1 Get Funding Rate History

Get Funding Rate History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetFundingRateV1Request
*/
func (a *V1APIService) UmfuturesGetFundingRateV1(ctx context.Context) V1APIUmfuturesGetFundingRateV1Request {
	return V1APIUmfuturesGetFundingRateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetFundingRateV1RespItem
func (a *V1APIService) UmfuturesGetFundingRateV1Execute(r V1APIUmfuturesGetFundingRateV1Request) ([]UmfuturesGetFundingRateV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetFundingRateV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetFundingRateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/fundingRate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetHistoricalTradesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	limit *int32
	fromId *int64
}

func (r V1APIUmfuturesGetHistoricalTradesV1Request) Symbol(symbol string) V1APIUmfuturesGetHistoricalTradesV1Request {
	r.symbol = &symbol
	return r
}

// Default 100; max 500.
func (r V1APIUmfuturesGetHistoricalTradesV1Request) Limit(limit int32) V1APIUmfuturesGetHistoricalTradesV1Request {
	r.limit = &limit
	return r
}

// TradeId to fetch from. Default gets most recent trades.
func (r V1APIUmfuturesGetHistoricalTradesV1Request) FromId(fromId int64) V1APIUmfuturesGetHistoricalTradesV1Request {
	r.fromId = &fromId
	return r
}

func (r V1APIUmfuturesGetHistoricalTradesV1Request) Execute() ([]UmfuturesGetHistoricalTradesV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetHistoricalTradesV1Execute(r)
}

/*
UmfuturesGetHistoricalTradesV1 Old Trades Lookup (MARKET_DATA)

Get older market historical trades.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetHistoricalTradesV1Request
*/
func (a *V1APIService) UmfuturesGetHistoricalTradesV1(ctx context.Context) V1APIUmfuturesGetHistoricalTradesV1Request {
	return V1APIUmfuturesGetHistoricalTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetHistoricalTradesV1RespItem
func (a *V1APIService) UmfuturesGetHistoricalTradesV1Execute(r V1APIUmfuturesGetHistoricalTradesV1Request) ([]UmfuturesGetHistoricalTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetHistoricalTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetHistoricalTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/historicalTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetIncomeAsynIdV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	downloadId *string
	timestamp *int64
	recvWindow *int64
}

// get by download id api
func (r V1APIUmfuturesGetIncomeAsynIdV1Request) DownloadId(downloadId string) V1APIUmfuturesGetIncomeAsynIdV1Request {
	r.downloadId = &downloadId
	return r
}

func (r V1APIUmfuturesGetIncomeAsynIdV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetIncomeAsynIdV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetIncomeAsynIdV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetIncomeAsynIdV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetIncomeAsynIdV1Request) Execute() (*UmfuturesGetIncomeAsynIdV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetIncomeAsynIdV1Execute(r)
}

/*
UmfuturesGetIncomeAsynIdV1 Get Futures Transaction History Download Link by Id (USER_DATA)

Get futures transaction history download link by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetIncomeAsynIdV1Request
*/
func (a *V1APIService) UmfuturesGetIncomeAsynIdV1(ctx context.Context) V1APIUmfuturesGetIncomeAsynIdV1Request {
	return V1APIUmfuturesGetIncomeAsynIdV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetIncomeAsynIdV1Resp
func (a *V1APIService) UmfuturesGetIncomeAsynIdV1Execute(r V1APIUmfuturesGetIncomeAsynIdV1Request) (*UmfuturesGetIncomeAsynIdV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetIncomeAsynIdV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetIncomeAsynIdV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/income/asyn/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadId == nil {
		return localVarReturnValue, nil, reportError("downloadId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "downloadId", r.downloadId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetIncomeAsynV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

// Timestamp in ms
func (r V1APIUmfuturesGetIncomeAsynV1Request) StartTime(startTime int64) V1APIUmfuturesGetIncomeAsynV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms
func (r V1APIUmfuturesGetIncomeAsynV1Request) EndTime(endTime int64) V1APIUmfuturesGetIncomeAsynV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APIUmfuturesGetIncomeAsynV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetIncomeAsynV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetIncomeAsynV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetIncomeAsynV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetIncomeAsynV1Request) Execute() (*UmfuturesGetIncomeAsynV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetIncomeAsynV1Execute(r)
}

/*
UmfuturesGetIncomeAsynV1 Get Download Id For Futures Transaction History(USER_DATA)

Get download id for futures transaction history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetIncomeAsynV1Request
*/
func (a *V1APIService) UmfuturesGetIncomeAsynV1(ctx context.Context) V1APIUmfuturesGetIncomeAsynV1Request {
	return V1APIUmfuturesGetIncomeAsynV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetIncomeAsynV1Resp
func (a *V1APIService) UmfuturesGetIncomeAsynV1Execute(r V1APIUmfuturesGetIncomeAsynV1Request) (*UmfuturesGetIncomeAsynV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetIncomeAsynV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetIncomeAsynV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/income/asyn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetIncomeV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	incomeType *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r V1APIUmfuturesGetIncomeV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetIncomeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetIncomeV1Request) Symbol(symbol string) V1APIUmfuturesGetIncomeV1Request {
	r.symbol = &symbol
	return r
}

// TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE, STRATEGY_UMFUTURES_TRANSFER，FEE_RETURN，BFUSD_REWARD
func (r V1APIUmfuturesGetIncomeV1Request) IncomeType(incomeType string) V1APIUmfuturesGetIncomeV1Request {
	r.incomeType = &incomeType
	return r
}

// Timestamp in ms to get funding from INCLUSIVE.
func (r V1APIUmfuturesGetIncomeV1Request) StartTime(startTime int64) V1APIUmfuturesGetIncomeV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get funding until INCLUSIVE.
func (r V1APIUmfuturesGetIncomeV1Request) EndTime(endTime int64) V1APIUmfuturesGetIncomeV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APIUmfuturesGetIncomeV1Request) Page(page int32) V1APIUmfuturesGetIncomeV1Request {
	r.page = &page
	return r
}

// Default 100; max 1000
func (r V1APIUmfuturesGetIncomeV1Request) Limit(limit int32) V1APIUmfuturesGetIncomeV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetIncomeV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetIncomeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetIncomeV1Request) Execute() ([]UmfuturesGetIncomeV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetIncomeV1Execute(r)
}

/*
UmfuturesGetIncomeV1 Get Income History (USER_DATA)

Query income history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetIncomeV1Request
*/
func (a *V1APIService) UmfuturesGetIncomeV1(ctx context.Context) V1APIUmfuturesGetIncomeV1Request {
	return V1APIUmfuturesGetIncomeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetIncomeV1RespItem
func (a *V1APIService) UmfuturesGetIncomeV1Execute(r V1APIUmfuturesGetIncomeV1Request) ([]UmfuturesGetIncomeV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetIncomeV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetIncomeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/income"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.incomeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "incomeType", r.incomeType, "form", "")
	} else {
		var defaultValue string = ""
		r.incomeType = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetIndexInfoV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
}

func (r V1APIUmfuturesGetIndexInfoV1Request) Symbol(symbol string) V1APIUmfuturesGetIndexInfoV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetIndexInfoV1Request) Execute() ([]UmfuturesGetIndexInfoV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetIndexInfoV1Execute(r)
}

/*
UmfuturesGetIndexInfoV1 Composite Index Symbol Information

Query composite index symbol information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetIndexInfoV1Request
*/
func (a *V1APIService) UmfuturesGetIndexInfoV1(ctx context.Context) V1APIUmfuturesGetIndexInfoV1Request {
	return V1APIUmfuturesGetIndexInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetIndexInfoV1RespItem
func (a *V1APIService) UmfuturesGetIndexInfoV1Execute(r V1APIUmfuturesGetIndexInfoV1Request) ([]UmfuturesGetIndexInfoV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetIndexInfoV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetIndexInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/indexInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetIndexPriceKlinesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	pair *string
	interval *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r V1APIUmfuturesGetIndexPriceKlinesV1Request) Pair(pair string) V1APIUmfuturesGetIndexPriceKlinesV1Request {
	r.pair = &pair
	return r
}

func (r V1APIUmfuturesGetIndexPriceKlinesV1Request) Interval(interval string) V1APIUmfuturesGetIndexPriceKlinesV1Request {
	r.interval = &interval
	return r
}

func (r V1APIUmfuturesGetIndexPriceKlinesV1Request) StartTime(startTime int64) V1APIUmfuturesGetIndexPriceKlinesV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIUmfuturesGetIndexPriceKlinesV1Request) EndTime(endTime int64) V1APIUmfuturesGetIndexPriceKlinesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1500.
func (r V1APIUmfuturesGetIndexPriceKlinesV1Request) Limit(limit int32) V1APIUmfuturesGetIndexPriceKlinesV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetIndexPriceKlinesV1Request) Execute() ([][]UmfuturesGetContinuousKlinesV1RespInnerInner, *http.Response, error) {
	return r.ApiService.UmfuturesGetIndexPriceKlinesV1Execute(r)
}

/*
UmfuturesGetIndexPriceKlinesV1 Index Price Kline/Candlestick Data

Kline/candlestick bars for the index price of a pair.
Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetIndexPriceKlinesV1Request
*/
func (a *V1APIService) UmfuturesGetIndexPriceKlinesV1(ctx context.Context) V1APIUmfuturesGetIndexPriceKlinesV1Request {
	return V1APIUmfuturesGetIndexPriceKlinesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]UmfuturesGetContinuousKlinesV1RespInnerInner
func (a *V1APIService) UmfuturesGetIndexPriceKlinesV1Execute(r V1APIUmfuturesGetIndexPriceKlinesV1Request) ([][]UmfuturesGetContinuousKlinesV1RespInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]UmfuturesGetContinuousKlinesV1RespInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetIndexPriceKlinesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/indexPriceKlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pair == nil {
		return localVarReturnValue, nil, reportError("pair is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetKlinesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	interval *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r V1APIUmfuturesGetKlinesV1Request) Symbol(symbol string) V1APIUmfuturesGetKlinesV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetKlinesV1Request) Interval(interval string) V1APIUmfuturesGetKlinesV1Request {
	r.interval = &interval
	return r
}

func (r V1APIUmfuturesGetKlinesV1Request) StartTime(startTime int64) V1APIUmfuturesGetKlinesV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIUmfuturesGetKlinesV1Request) EndTime(endTime int64) V1APIUmfuturesGetKlinesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1500.
func (r V1APIUmfuturesGetKlinesV1Request) Limit(limit int32) V1APIUmfuturesGetKlinesV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetKlinesV1Request) Execute() ([][]UmfuturesGetContinuousKlinesV1RespInnerInner, *http.Response, error) {
	return r.ApiService.UmfuturesGetKlinesV1Execute(r)
}

/*
UmfuturesGetKlinesV1 Kline/Candlestick Data

Kline/candlestick bars for a symbol.
Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetKlinesV1Request
*/
func (a *V1APIService) UmfuturesGetKlinesV1(ctx context.Context) V1APIUmfuturesGetKlinesV1Request {
	return V1APIUmfuturesGetKlinesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]UmfuturesGetContinuousKlinesV1RespInnerInner
func (a *V1APIService) UmfuturesGetKlinesV1Execute(r V1APIUmfuturesGetKlinesV1Request) ([][]UmfuturesGetContinuousKlinesV1RespInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]UmfuturesGetContinuousKlinesV1RespInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetKlinesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/klines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetLeverageBracketV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIUmfuturesGetLeverageBracketV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetLeverageBracketV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetLeverageBracketV1Request) Symbol(symbol string) V1APIUmfuturesGetLeverageBracketV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetLeverageBracketV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetLeverageBracketV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetLeverageBracketV1Request) Execute() (*UmfuturesGetLeverageBracketV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetLeverageBracketV1Execute(r)
}

/*
UmfuturesGetLeverageBracketV1 Notional and Leverage Brackets (USER_DATA)

Query user notional and leverage bracket on speicfic symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetLeverageBracketV1Request
*/
func (a *V1APIService) UmfuturesGetLeverageBracketV1(ctx context.Context) V1APIUmfuturesGetLeverageBracketV1Request {
	return V1APIUmfuturesGetLeverageBracketV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetLeverageBracketV1Resp
func (a *V1APIService) UmfuturesGetLeverageBracketV1Execute(r V1APIUmfuturesGetLeverageBracketV1Request) (*UmfuturesGetLeverageBracketV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetLeverageBracketV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetLeverageBracketV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/leverageBracket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetMarkPriceKlinesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	interval *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r V1APIUmfuturesGetMarkPriceKlinesV1Request) Symbol(symbol string) V1APIUmfuturesGetMarkPriceKlinesV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetMarkPriceKlinesV1Request) Interval(interval string) V1APIUmfuturesGetMarkPriceKlinesV1Request {
	r.interval = &interval
	return r
}

func (r V1APIUmfuturesGetMarkPriceKlinesV1Request) StartTime(startTime int64) V1APIUmfuturesGetMarkPriceKlinesV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIUmfuturesGetMarkPriceKlinesV1Request) EndTime(endTime int64) V1APIUmfuturesGetMarkPriceKlinesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1500.
func (r V1APIUmfuturesGetMarkPriceKlinesV1Request) Limit(limit int32) V1APIUmfuturesGetMarkPriceKlinesV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetMarkPriceKlinesV1Request) Execute() ([][]UmfuturesGetContinuousKlinesV1RespInnerInner, *http.Response, error) {
	return r.ApiService.UmfuturesGetMarkPriceKlinesV1Execute(r)
}

/*
UmfuturesGetMarkPriceKlinesV1 Mark Price Kline/Candlestick Data

Kline/candlestick bars for the mark price of a symbol.
Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetMarkPriceKlinesV1Request
*/
func (a *V1APIService) UmfuturesGetMarkPriceKlinesV1(ctx context.Context) V1APIUmfuturesGetMarkPriceKlinesV1Request {
	return V1APIUmfuturesGetMarkPriceKlinesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]UmfuturesGetContinuousKlinesV1RespInnerInner
func (a *V1APIService) UmfuturesGetMarkPriceKlinesV1Execute(r V1APIUmfuturesGetMarkPriceKlinesV1Request) ([][]UmfuturesGetContinuousKlinesV1RespInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]UmfuturesGetContinuousKlinesV1RespInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetMarkPriceKlinesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/markPriceKlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetMultiAssetsMarginV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesGetMultiAssetsMarginV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetMultiAssetsMarginV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetMultiAssetsMarginV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetMultiAssetsMarginV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetMultiAssetsMarginV1Request) Execute() (*UmfuturesGetMultiAssetsMarginV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetMultiAssetsMarginV1Execute(r)
}

/*
UmfuturesGetMultiAssetsMarginV1 Get Current Multi-Assets Mode (USER_DATA)

Get user's Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetMultiAssetsMarginV1Request
*/
func (a *V1APIService) UmfuturesGetMultiAssetsMarginV1(ctx context.Context) V1APIUmfuturesGetMultiAssetsMarginV1Request {
	return V1APIUmfuturesGetMultiAssetsMarginV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetMultiAssetsMarginV1Resp
func (a *V1APIService) UmfuturesGetMultiAssetsMarginV1Execute(r V1APIUmfuturesGetMultiAssetsMarginV1Request) (*UmfuturesGetMultiAssetsMarginV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetMultiAssetsMarginV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetMultiAssetsMarginV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/multiAssetsMargin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetOpenInterestV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
}

func (r V1APIUmfuturesGetOpenInterestV1Request) Symbol(symbol string) V1APIUmfuturesGetOpenInterestV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetOpenInterestV1Request) Execute() (*UmfuturesGetOpenInterestV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetOpenInterestV1Execute(r)
}

/*
UmfuturesGetOpenInterestV1 Open Interest

Get present open interest of a specific symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetOpenInterestV1Request
*/
func (a *V1APIService) UmfuturesGetOpenInterestV1(ctx context.Context) V1APIUmfuturesGetOpenInterestV1Request {
	return V1APIUmfuturesGetOpenInterestV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetOpenInterestV1Resp
func (a *V1APIService) UmfuturesGetOpenInterestV1Execute(r V1APIUmfuturesGetOpenInterestV1Request) (*UmfuturesGetOpenInterestV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetOpenInterestV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetOpenInterestV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/openInterest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetOpenOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIUmfuturesGetOpenOrderV1Request) Symbol(symbol string) V1APIUmfuturesGetOpenOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetOpenOrderV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetOpenOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetOpenOrderV1Request) OrderId(orderId int64) V1APIUmfuturesGetOpenOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIUmfuturesGetOpenOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIUmfuturesGetOpenOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIUmfuturesGetOpenOrderV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetOpenOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetOpenOrderV1Request) Execute() (*UmfuturesGetOpenOrderV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetOpenOrderV1Execute(r)
}

/*
UmfuturesGetOpenOrderV1 Query Current Open Order (USER_DATA)

Query open order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetOpenOrderV1Request
*/
func (a *V1APIService) UmfuturesGetOpenOrderV1(ctx context.Context) V1APIUmfuturesGetOpenOrderV1Request {
	return V1APIUmfuturesGetOpenOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetOpenOrderV1Resp
func (a *V1APIService) UmfuturesGetOpenOrderV1Execute(r V1APIUmfuturesGetOpenOrderV1Request) (*UmfuturesGetOpenOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetOpenOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetOpenOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/openOrder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetOpenOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIUmfuturesGetOpenOrdersV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetOpenOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetOpenOrdersV1Request) Symbol(symbol string) V1APIUmfuturesGetOpenOrdersV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetOpenOrdersV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetOpenOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetOpenOrdersV1Request) Execute() ([]UmfuturesGetOpenOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetOpenOrdersV1Execute(r)
}

/*
UmfuturesGetOpenOrdersV1 Current All Open Orders (USER_DATA)

Get all open orders on a symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetOpenOrdersV1Request
*/
func (a *V1APIService) UmfuturesGetOpenOrdersV1(ctx context.Context) V1APIUmfuturesGetOpenOrdersV1Request {
	return V1APIUmfuturesGetOpenOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetOpenOrdersV1RespItem
func (a *V1APIService) UmfuturesGetOpenOrdersV1Execute(r V1APIUmfuturesGetOpenOrdersV1Request) ([]UmfuturesGetOpenOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetOpenOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetOpenOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetOrderAmendmentV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIUmfuturesGetOrderAmendmentV1Request) Symbol(symbol string) V1APIUmfuturesGetOrderAmendmentV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetOrderAmendmentV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetOrderAmendmentV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetOrderAmendmentV1Request) OrderId(orderId int64) V1APIUmfuturesGetOrderAmendmentV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIUmfuturesGetOrderAmendmentV1Request) OrigClientOrderId(origClientOrderId string) V1APIUmfuturesGetOrderAmendmentV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Timestamp in ms to get modification history from INCLUSIVE
func (r V1APIUmfuturesGetOrderAmendmentV1Request) StartTime(startTime int64) V1APIUmfuturesGetOrderAmendmentV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get modification history until INCLUSIVE
func (r V1APIUmfuturesGetOrderAmendmentV1Request) EndTime(endTime int64) V1APIUmfuturesGetOrderAmendmentV1Request {
	r.endTime = &endTime
	return r
}

// Default 50; max 100
func (r V1APIUmfuturesGetOrderAmendmentV1Request) Limit(limit int32) V1APIUmfuturesGetOrderAmendmentV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetOrderAmendmentV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetOrderAmendmentV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetOrderAmendmentV1Request) Execute() ([]UmfuturesGetOrderAmendmentV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetOrderAmendmentV1Execute(r)
}

/*
UmfuturesGetOrderAmendmentV1 Get Order Modify History (USER_DATA)

Get order modification history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetOrderAmendmentV1Request
*/
func (a *V1APIService) UmfuturesGetOrderAmendmentV1(ctx context.Context) V1APIUmfuturesGetOrderAmendmentV1Request {
	return V1APIUmfuturesGetOrderAmendmentV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetOrderAmendmentV1RespItem
func (a *V1APIService) UmfuturesGetOrderAmendmentV1Execute(r V1APIUmfuturesGetOrderAmendmentV1Request) ([]UmfuturesGetOrderAmendmentV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetOrderAmendmentV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetOrderAmendmentV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/orderAmendment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetOrderAsynIdV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	downloadId *string
	timestamp *int64
	recvWindow *int64
}

// get by download id api
func (r V1APIUmfuturesGetOrderAsynIdV1Request) DownloadId(downloadId string) V1APIUmfuturesGetOrderAsynIdV1Request {
	r.downloadId = &downloadId
	return r
}

func (r V1APIUmfuturesGetOrderAsynIdV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetOrderAsynIdV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetOrderAsynIdV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetOrderAsynIdV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetOrderAsynIdV1Request) Execute() (*UmfuturesGetOrderAsynIdV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetOrderAsynIdV1Execute(r)
}

/*
UmfuturesGetOrderAsynIdV1 Get Futures Order History Download Link by Id (USER_DATA)

Get futures order history download link by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetOrderAsynIdV1Request
*/
func (a *V1APIService) UmfuturesGetOrderAsynIdV1(ctx context.Context) V1APIUmfuturesGetOrderAsynIdV1Request {
	return V1APIUmfuturesGetOrderAsynIdV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetOrderAsynIdV1Resp
func (a *V1APIService) UmfuturesGetOrderAsynIdV1Execute(r V1APIUmfuturesGetOrderAsynIdV1Request) (*UmfuturesGetOrderAsynIdV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetOrderAsynIdV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetOrderAsynIdV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order/asyn/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadId == nil {
		return localVarReturnValue, nil, reportError("downloadId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "downloadId", r.downloadId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetOrderAsynV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

// Timestamp in ms
func (r V1APIUmfuturesGetOrderAsynV1Request) StartTime(startTime int64) V1APIUmfuturesGetOrderAsynV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms
func (r V1APIUmfuturesGetOrderAsynV1Request) EndTime(endTime int64) V1APIUmfuturesGetOrderAsynV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APIUmfuturesGetOrderAsynV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetOrderAsynV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetOrderAsynV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetOrderAsynV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetOrderAsynV1Request) Execute() (*UmfuturesGetOrderAsynV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetOrderAsynV1Execute(r)
}

/*
UmfuturesGetOrderAsynV1 Get Download Id For Futures Order History (USER_DATA)

Get Download Id For Futures Order History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetOrderAsynV1Request
*/
func (a *V1APIService) UmfuturesGetOrderAsynV1(ctx context.Context) V1APIUmfuturesGetOrderAsynV1Request {
	return V1APIUmfuturesGetOrderAsynV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetOrderAsynV1Resp
func (a *V1APIService) UmfuturesGetOrderAsynV1Execute(r V1APIUmfuturesGetOrderAsynV1Request) (*UmfuturesGetOrderAsynV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetOrderAsynV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetOrderAsynV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order/asyn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V1APIUmfuturesGetOrderV1Request) Symbol(symbol string) V1APIUmfuturesGetOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetOrderV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetOrderV1Request) OrderId(orderId int64) V1APIUmfuturesGetOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIUmfuturesGetOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIUmfuturesGetOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIUmfuturesGetOrderV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetOrderV1Request) Execute() (*UmfuturesGetOrderV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetOrderV1Execute(r)
}

/*
UmfuturesGetOrderV1 Query Order (USER_DATA)

Check an order's status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetOrderV1Request
*/
func (a *V1APIService) UmfuturesGetOrderV1(ctx context.Context) V1APIUmfuturesGetOrderV1Request {
	return V1APIUmfuturesGetOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetOrderV1Resp
func (a *V1APIService) UmfuturesGetOrderV1Execute(r V1APIUmfuturesGetOrderV1Request) (*UmfuturesGetOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetPingV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIUmfuturesGetPingV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UmfuturesGetPingV1Execute(r)
}

/*
UmfuturesGetPingV1 Test Connectivity

Test connectivity to the Rest API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetPingV1Request
*/
func (a *V1APIService) UmfuturesGetPingV1(ctx context.Context) V1APIUmfuturesGetPingV1Request {
	return V1APIUmfuturesGetPingV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V1APIService) UmfuturesGetPingV1Execute(r V1APIUmfuturesGetPingV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetPingV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetPmAccountInfoV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesGetPmAccountInfoV1Request) Asset(asset string) V1APIUmfuturesGetPmAccountInfoV1Request {
	r.asset = &asset
	return r
}

func (r V1APIUmfuturesGetPmAccountInfoV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetPmAccountInfoV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetPmAccountInfoV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetPmAccountInfoV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetPmAccountInfoV1Request) Execute() (*UmfuturesGetPmAccountInfoV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetPmAccountInfoV1Execute(r)
}

/*
UmfuturesGetPmAccountInfoV1 Classic Portfolio Margin Account Information (USER_DATA)

Get Classic Portfolio Margin current account information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetPmAccountInfoV1Request
*/
func (a *V1APIService) UmfuturesGetPmAccountInfoV1(ctx context.Context) V1APIUmfuturesGetPmAccountInfoV1Request {
	return V1APIUmfuturesGetPmAccountInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetPmAccountInfoV1Resp
func (a *V1APIService) UmfuturesGetPmAccountInfoV1Execute(r V1APIUmfuturesGetPmAccountInfoV1Request) (*UmfuturesGetPmAccountInfoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetPmAccountInfoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetPmAccountInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/pmAccountInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetPositionMarginHistoryV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	type_ *int32
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIUmfuturesGetPositionMarginHistoryV1Request) Symbol(symbol string) V1APIUmfuturesGetPositionMarginHistoryV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetPositionMarginHistoryV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetPositionMarginHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// 1: Add position margin，2: Reduce position margin
func (r V1APIUmfuturesGetPositionMarginHistoryV1Request) Type_(type_ int32) V1APIUmfuturesGetPositionMarginHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r V1APIUmfuturesGetPositionMarginHistoryV1Request) StartTime(startTime int64) V1APIUmfuturesGetPositionMarginHistoryV1Request {
	r.startTime = &startTime
	return r
}

// Default current time if not pass
func (r V1APIUmfuturesGetPositionMarginHistoryV1Request) EndTime(endTime int64) V1APIUmfuturesGetPositionMarginHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default: 500
func (r V1APIUmfuturesGetPositionMarginHistoryV1Request) Limit(limit int32) V1APIUmfuturesGetPositionMarginHistoryV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetPositionMarginHistoryV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetPositionMarginHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetPositionMarginHistoryV1Request) Execute() ([]UmfuturesGetPositionMarginHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetPositionMarginHistoryV1Execute(r)
}

/*
UmfuturesGetPositionMarginHistoryV1 Get Position Margin Change History (TRADE)

Get Position Margin Change History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetPositionMarginHistoryV1Request
*/
func (a *V1APIService) UmfuturesGetPositionMarginHistoryV1(ctx context.Context) V1APIUmfuturesGetPositionMarginHistoryV1Request {
	return V1APIUmfuturesGetPositionMarginHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetPositionMarginHistoryV1RespItem
func (a *V1APIService) UmfuturesGetPositionMarginHistoryV1Execute(r V1APIUmfuturesGetPositionMarginHistoryV1Request) ([]UmfuturesGetPositionMarginHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetPositionMarginHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetPositionMarginHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/positionMargin/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetPositionSideDualV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesGetPositionSideDualV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetPositionSideDualV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetPositionSideDualV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetPositionSideDualV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetPositionSideDualV1Request) Execute() (*UmfuturesGetPositionSideDualV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetPositionSideDualV1Execute(r)
}

/*
UmfuturesGetPositionSideDualV1 Get Current Position Mode(USER_DATA)

Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetPositionSideDualV1Request
*/
func (a *V1APIService) UmfuturesGetPositionSideDualV1(ctx context.Context) V1APIUmfuturesGetPositionSideDualV1Request {
	return V1APIUmfuturesGetPositionSideDualV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetPositionSideDualV1Resp
func (a *V1APIService) UmfuturesGetPositionSideDualV1Execute(r V1APIUmfuturesGetPositionSideDualV1Request) (*UmfuturesGetPositionSideDualV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetPositionSideDualV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetPositionSideDualV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/positionSide/dual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetPremiumIndexKlinesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	interval *string
	startTime *int64
	endTime *int64
	limit *int32
}

func (r V1APIUmfuturesGetPremiumIndexKlinesV1Request) Symbol(symbol string) V1APIUmfuturesGetPremiumIndexKlinesV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetPremiumIndexKlinesV1Request) Interval(interval string) V1APIUmfuturesGetPremiumIndexKlinesV1Request {
	r.interval = &interval
	return r
}

func (r V1APIUmfuturesGetPremiumIndexKlinesV1Request) StartTime(startTime int64) V1APIUmfuturesGetPremiumIndexKlinesV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIUmfuturesGetPremiumIndexKlinesV1Request) EndTime(endTime int64) V1APIUmfuturesGetPremiumIndexKlinesV1Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1500.
func (r V1APIUmfuturesGetPremiumIndexKlinesV1Request) Limit(limit int32) V1APIUmfuturesGetPremiumIndexKlinesV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetPremiumIndexKlinesV1Request) Execute() ([][]UmfuturesGetContinuousKlinesV1RespInnerInner, *http.Response, error) {
	return r.ApiService.UmfuturesGetPremiumIndexKlinesV1Execute(r)
}

/*
UmfuturesGetPremiumIndexKlinesV1 Premium index Kline Data

Premium index kline bars of a symbol. Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetPremiumIndexKlinesV1Request
*/
func (a *V1APIService) UmfuturesGetPremiumIndexKlinesV1(ctx context.Context) V1APIUmfuturesGetPremiumIndexKlinesV1Request {
	return V1APIUmfuturesGetPremiumIndexKlinesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]UmfuturesGetContinuousKlinesV1RespInnerInner
func (a *V1APIService) UmfuturesGetPremiumIndexKlinesV1Execute(r V1APIUmfuturesGetPremiumIndexKlinesV1Request) ([][]UmfuturesGetContinuousKlinesV1RespInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]UmfuturesGetContinuousKlinesV1RespInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetPremiumIndexKlinesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/premiumIndexKlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetPremiumIndexV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
}

func (r V1APIUmfuturesGetPremiumIndexV1Request) Symbol(symbol string) V1APIUmfuturesGetPremiumIndexV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetPremiumIndexV1Request) Execute() (*UmfuturesGetPremiumIndexV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetPremiumIndexV1Execute(r)
}

/*
UmfuturesGetPremiumIndexV1 Mark Price

Mark Price and Funding Rate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetPremiumIndexV1Request
*/
func (a *V1APIService) UmfuturesGetPremiumIndexV1(ctx context.Context) V1APIUmfuturesGetPremiumIndexV1Request {
	return V1APIUmfuturesGetPremiumIndexV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetPremiumIndexV1Resp
func (a *V1APIService) UmfuturesGetPremiumIndexV1Execute(r V1APIUmfuturesGetPremiumIndexV1Request) (*UmfuturesGetPremiumIndexV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetPremiumIndexV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetPremiumIndexV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/premiumIndex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetRateLimitOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesGetRateLimitOrderV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetRateLimitOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetRateLimitOrderV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetRateLimitOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetRateLimitOrderV1Request) Execute() ([]UmfuturesGetRateLimitOrderV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetRateLimitOrderV1Execute(r)
}

/*
UmfuturesGetRateLimitOrderV1 Query User Rate Limit (USER_DATA)

Query User Rate Limit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetRateLimitOrderV1Request
*/
func (a *V1APIService) UmfuturesGetRateLimitOrderV1(ctx context.Context) V1APIUmfuturesGetRateLimitOrderV1Request {
	return V1APIUmfuturesGetRateLimitOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetRateLimitOrderV1RespItem
func (a *V1APIService) UmfuturesGetRateLimitOrderV1Execute(r V1APIUmfuturesGetRateLimitOrderV1Request) ([]UmfuturesGetRateLimitOrderV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetRateLimitOrderV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetRateLimitOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/rateLimit/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetSymbolConfigV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V1APIUmfuturesGetSymbolConfigV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetSymbolConfigV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetSymbolConfigV1Request) Symbol(symbol string) V1APIUmfuturesGetSymbolConfigV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetSymbolConfigV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetSymbolConfigV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetSymbolConfigV1Request) Execute() ([]UmfuturesGetSymbolConfigV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetSymbolConfigV1Execute(r)
}

/*
UmfuturesGetSymbolConfigV1 Symbol Configuration(USER_DATA)

Get current account symbol configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetSymbolConfigV1Request
*/
func (a *V1APIService) UmfuturesGetSymbolConfigV1(ctx context.Context) V1APIUmfuturesGetSymbolConfigV1Request {
	return V1APIUmfuturesGetSymbolConfigV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetSymbolConfigV1RespItem
func (a *V1APIService) UmfuturesGetSymbolConfigV1Execute(r V1APIUmfuturesGetSymbolConfigV1Request) ([]UmfuturesGetSymbolConfigV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetSymbolConfigV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetSymbolConfigV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/symbolConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetTicker24hrV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
}

func (r V1APIUmfuturesGetTicker24hrV1Request) Symbol(symbol string) V1APIUmfuturesGetTicker24hrV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetTicker24hrV1Request) Execute() (*UmfuturesGetTicker24hrV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetTicker24hrV1Execute(r)
}

/*
UmfuturesGetTicker24hrV1 24hr Ticker Price Change Statistics

24 hour rolling window price change statistics.
Careful when accessing this with no symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetTicker24hrV1Request
*/
func (a *V1APIService) UmfuturesGetTicker24hrV1(ctx context.Context) V1APIUmfuturesGetTicker24hrV1Request {
	return V1APIUmfuturesGetTicker24hrV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetTicker24hrV1Resp
func (a *V1APIService) UmfuturesGetTicker24hrV1Execute(r V1APIUmfuturesGetTicker24hrV1Request) (*UmfuturesGetTicker24hrV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetTicker24hrV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetTicker24hrV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/ticker/24hr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetTickerBookTickerV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
}

func (r V1APIUmfuturesGetTickerBookTickerV1Request) Symbol(symbol string) V1APIUmfuturesGetTickerBookTickerV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetTickerBookTickerV1Request) Execute() (*UmfuturesGetTickerBookTickerV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetTickerBookTickerV1Execute(r)
}

/*
UmfuturesGetTickerBookTickerV1 Symbol Order Book Ticker

Best price/qty on the order book for a symbol or symbols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetTickerBookTickerV1Request
*/
func (a *V1APIService) UmfuturesGetTickerBookTickerV1(ctx context.Context) V1APIUmfuturesGetTickerBookTickerV1Request {
	return V1APIUmfuturesGetTickerBookTickerV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetTickerBookTickerV1Resp
func (a *V1APIService) UmfuturesGetTickerBookTickerV1Execute(r V1APIUmfuturesGetTickerBookTickerV1Request) (*UmfuturesGetTickerBookTickerV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetTickerBookTickerV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetTickerBookTickerV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/ticker/bookTicker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetTickerPriceV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
}

func (r V1APIUmfuturesGetTickerPriceV1Request) Symbol(symbol string) V1APIUmfuturesGetTickerPriceV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetTickerPriceV1Request) Execute() (*UmfuturesGetTickerPriceV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetTickerPriceV1Execute(r)
}

/*
UmfuturesGetTickerPriceV1 Symbol Price Ticker

Latest price for a symbol or symbols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetTickerPriceV1Request
*/
func (a *V1APIService) UmfuturesGetTickerPriceV1(ctx context.Context) V1APIUmfuturesGetTickerPriceV1Request {
	return V1APIUmfuturesGetTickerPriceV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetTickerPriceV1Resp
func (a *V1APIService) UmfuturesGetTickerPriceV1Execute(r V1APIUmfuturesGetTickerPriceV1Request) (*UmfuturesGetTickerPriceV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetTickerPriceV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetTickerPriceV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/ticker/price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetTimeV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIUmfuturesGetTimeV1Request) Execute() (*UmfuturesGetTimeV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetTimeV1Execute(r)
}

/*
UmfuturesGetTimeV1 Check Server Time

Test connectivity to the Rest API and get the current server time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetTimeV1Request
*/
func (a *V1APIService) UmfuturesGetTimeV1(ctx context.Context) V1APIUmfuturesGetTimeV1Request {
	return V1APIUmfuturesGetTimeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetTimeV1Resp
func (a *V1APIService) UmfuturesGetTimeV1Execute(r V1APIUmfuturesGetTimeV1Request) (*UmfuturesGetTimeV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetTimeV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetTimeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetTradeAsynIdV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	downloadId *string
	timestamp *int64
	recvWindow *int64
}

// get by download id api
func (r V1APIUmfuturesGetTradeAsynIdV1Request) DownloadId(downloadId string) V1APIUmfuturesGetTradeAsynIdV1Request {
	r.downloadId = &downloadId
	return r
}

func (r V1APIUmfuturesGetTradeAsynIdV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetTradeAsynIdV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetTradeAsynIdV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetTradeAsynIdV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetTradeAsynIdV1Request) Execute() (*UmfuturesGetTradeAsynIdV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetTradeAsynIdV1Execute(r)
}

/*
UmfuturesGetTradeAsynIdV1 Get Futures Trade Download Link by Id(USER_DATA)

Get futures trade download link by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetTradeAsynIdV1Request
*/
func (a *V1APIService) UmfuturesGetTradeAsynIdV1(ctx context.Context) V1APIUmfuturesGetTradeAsynIdV1Request {
	return V1APIUmfuturesGetTradeAsynIdV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetTradeAsynIdV1Resp
func (a *V1APIService) UmfuturesGetTradeAsynIdV1Execute(r V1APIUmfuturesGetTradeAsynIdV1Request) (*UmfuturesGetTradeAsynIdV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetTradeAsynIdV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetTradeAsynIdV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/trade/asyn/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.downloadId == nil {
		return localVarReturnValue, nil, reportError("downloadId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "downloadId", r.downloadId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetTradeAsynV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	startTime *int64
	endTime *int64
	timestamp *int64
	recvWindow *int64
}

// Timestamp in ms
func (r V1APIUmfuturesGetTradeAsynV1Request) StartTime(startTime int64) V1APIUmfuturesGetTradeAsynV1Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms
func (r V1APIUmfuturesGetTradeAsynV1Request) EndTime(endTime int64) V1APIUmfuturesGetTradeAsynV1Request {
	r.endTime = &endTime
	return r
}

func (r V1APIUmfuturesGetTradeAsynV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetTradeAsynV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesGetTradeAsynV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetTradeAsynV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetTradeAsynV1Request) Execute() (*UmfuturesGetTradeAsynV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesGetTradeAsynV1Execute(r)
}

/*
UmfuturesGetTradeAsynV1 Get Download Id For Futures Trade History (USER_DATA)

Get download id for futures trade history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetTradeAsynV1Request
*/
func (a *V1APIService) UmfuturesGetTradeAsynV1(ctx context.Context) V1APIUmfuturesGetTradeAsynV1Request {
	return V1APIUmfuturesGetTradeAsynV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesGetTradeAsynV1Resp
func (a *V1APIService) UmfuturesGetTradeAsynV1Execute(r V1APIUmfuturesGetTradeAsynV1Request) (*UmfuturesGetTradeAsynV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesGetTradeAsynV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetTradeAsynV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/trade/asyn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetTradesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	limit *int32
}

func (r V1APIUmfuturesGetTradesV1Request) Symbol(symbol string) V1APIUmfuturesGetTradesV1Request {
	r.symbol = &symbol
	return r
}

// Default 500; max 1000.
func (r V1APIUmfuturesGetTradesV1Request) Limit(limit int32) V1APIUmfuturesGetTradesV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetTradesV1Request) Execute() ([]UmfuturesGetTradesV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetTradesV1Execute(r)
}

/*
UmfuturesGetTradesV1 Recent Trades List

Get recent market trades

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetTradesV1Request
*/
func (a *V1APIService) UmfuturesGetTradesV1(ctx context.Context) V1APIUmfuturesGetTradesV1Request {
	return V1APIUmfuturesGetTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetTradesV1RespItem
func (a *V1APIService) UmfuturesGetTradesV1Execute(r V1APIUmfuturesGetTradesV1Request) ([]UmfuturesGetTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesGetUserTradesV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r V1APIUmfuturesGetUserTradesV1Request) Symbol(symbol string) V1APIUmfuturesGetUserTradesV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesGetUserTradesV1Request) Timestamp(timestamp int64) V1APIUmfuturesGetUserTradesV1Request {
	r.timestamp = &timestamp
	return r
}

// This can only be used in combination with &#x60;symbol&#x60;
func (r V1APIUmfuturesGetUserTradesV1Request) OrderId(orderId int64) V1APIUmfuturesGetUserTradesV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIUmfuturesGetUserTradesV1Request) StartTime(startTime int64) V1APIUmfuturesGetUserTradesV1Request {
	r.startTime = &startTime
	return r
}

func (r V1APIUmfuturesGetUserTradesV1Request) EndTime(endTime int64) V1APIUmfuturesGetUserTradesV1Request {
	r.endTime = &endTime
	return r
}

// Trade id to fetch from. Default gets most recent trades.
func (r V1APIUmfuturesGetUserTradesV1Request) FromId(fromId int64) V1APIUmfuturesGetUserTradesV1Request {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r V1APIUmfuturesGetUserTradesV1Request) Limit(limit int32) V1APIUmfuturesGetUserTradesV1Request {
	r.limit = &limit
	return r
}

func (r V1APIUmfuturesGetUserTradesV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesGetUserTradesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesGetUserTradesV1Request) Execute() ([]UmfuturesGetUserTradesV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesGetUserTradesV1Execute(r)
}

/*
UmfuturesGetUserTradesV1 Account Trade List (USER_DATA)

Get trades for a specific account and symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesGetUserTradesV1Request
*/
func (a *V1APIService) UmfuturesGetUserTradesV1(ctx context.Context) V1APIUmfuturesGetUserTradesV1Request {
	return V1APIUmfuturesGetUserTradesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesGetUserTradesV1RespItem
func (a *V1APIService) UmfuturesGetUserTradesV1Execute(r V1APIUmfuturesGetUserTradesV1Request) ([]UmfuturesGetUserTradesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesGetUserTradesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesGetUserTradesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/userTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesUpdateBatchOrdersV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	batchOrders *[]UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem
	timestamp *int64
	recvWindow *int64
}

func (r V1APIUmfuturesUpdateBatchOrdersV1Request) BatchOrders(batchOrders []UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem) V1APIUmfuturesUpdateBatchOrdersV1Request {
	r.batchOrders = &batchOrders
	return r
}

func (r V1APIUmfuturesUpdateBatchOrdersV1Request) Timestamp(timestamp int64) V1APIUmfuturesUpdateBatchOrdersV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesUpdateBatchOrdersV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesUpdateBatchOrdersV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesUpdateBatchOrdersV1Request) Execute() ([]UmfuturesUpdateBatchOrdersV1RespItem, *http.Response, error) {
	return r.ApiService.UmfuturesUpdateBatchOrdersV1Execute(r)
}

/*
UmfuturesUpdateBatchOrdersV1 Modify Multiple Orders(TRADE)

Modify Multiple Orders (TRADE)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesUpdateBatchOrdersV1Request
*/
func (a *V1APIService) UmfuturesUpdateBatchOrdersV1(ctx context.Context) V1APIUmfuturesUpdateBatchOrdersV1Request {
	return V1APIUmfuturesUpdateBatchOrdersV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UmfuturesUpdateBatchOrdersV1RespItem
func (a *V1APIService) UmfuturesUpdateBatchOrdersV1Execute(r V1APIUmfuturesUpdateBatchOrdersV1Request) ([]UmfuturesUpdateBatchOrdersV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UmfuturesUpdateBatchOrdersV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesUpdateBatchOrdersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/batchOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchOrders == nil {
		return localVarReturnValue, nil, reportError("batchOrders is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "batchOrders", r.batchOrders, "", "csv")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesUpdateListenKeyV1Request struct {
	ctx context.Context
	ApiService *V1APIService
}

func (r V1APIUmfuturesUpdateListenKeyV1Request) Execute() (*UmfuturesUpdateListenKeyV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesUpdateListenKeyV1Execute(r)
}

/*
UmfuturesUpdateListenKeyV1 Keepalive User Data Stream (USER_STREAM)

Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 60 minutes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesUpdateListenKeyV1Request
*/
func (a *V1APIService) UmfuturesUpdateListenKeyV1(ctx context.Context) V1APIUmfuturesUpdateListenKeyV1Request {
	return V1APIUmfuturesUpdateListenKeyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesUpdateListenKeyV1Resp
func (a *V1APIService) UmfuturesUpdateListenKeyV1Execute(r V1APIUmfuturesUpdateListenKeyV1Request) (*UmfuturesUpdateListenKeyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesUpdateListenKeyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesUpdateListenKeyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/listenKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V1APIUmfuturesUpdateOrderV1Request struct {
	ctx context.Context
	ApiService *V1APIService
	price *string
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	priceMatch *string
	recvWindow *int64
}

func (r V1APIUmfuturesUpdateOrderV1Request) Price(price string) V1APIUmfuturesUpdateOrderV1Request {
	r.price = &price
	return r
}

func (r V1APIUmfuturesUpdateOrderV1Request) Quantity(quantity string) V1APIUmfuturesUpdateOrderV1Request {
	r.quantity = &quantity
	return r
}

func (r V1APIUmfuturesUpdateOrderV1Request) Side(side string) V1APIUmfuturesUpdateOrderV1Request {
	r.side = &side
	return r
}

func (r V1APIUmfuturesUpdateOrderV1Request) Symbol(symbol string) V1APIUmfuturesUpdateOrderV1Request {
	r.symbol = &symbol
	return r
}

func (r V1APIUmfuturesUpdateOrderV1Request) Timestamp(timestamp int64) V1APIUmfuturesUpdateOrderV1Request {
	r.timestamp = &timestamp
	return r
}

func (r V1APIUmfuturesUpdateOrderV1Request) OrderId(orderId int64) V1APIUmfuturesUpdateOrderV1Request {
	r.orderId = &orderId
	return r
}

func (r V1APIUmfuturesUpdateOrderV1Request) OrigClientOrderId(origClientOrderId string) V1APIUmfuturesUpdateOrderV1Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

func (r V1APIUmfuturesUpdateOrderV1Request) PriceMatch(priceMatch string) V1APIUmfuturesUpdateOrderV1Request {
	r.priceMatch = &priceMatch
	return r
}

func (r V1APIUmfuturesUpdateOrderV1Request) RecvWindow(recvWindow int64) V1APIUmfuturesUpdateOrderV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V1APIUmfuturesUpdateOrderV1Request) Execute() (*UmfuturesUpdateOrderV1Resp, *http.Response, error) {
	return r.ApiService.UmfuturesUpdateOrderV1Execute(r)
}

/*
UmfuturesUpdateOrderV1 Modify Order (TRADE)

Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V1APIUmfuturesUpdateOrderV1Request
*/
func (a *V1APIService) UmfuturesUpdateOrderV1(ctx context.Context) V1APIUmfuturesUpdateOrderV1Request {
	return V1APIUmfuturesUpdateOrderV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UmfuturesUpdateOrderV1Resp
func (a *V1APIService) UmfuturesUpdateOrderV1Execute(r V1APIUmfuturesUpdateOrderV1Request) (*UmfuturesUpdateOrderV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UmfuturesUpdateOrderV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V1APIService.UmfuturesUpdateOrderV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fapi/v1/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "orderId", r.orderId, "", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "origClientOrderId", r.origClientOrderId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	if r.priceMatch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "priceMatch", r.priceMatch, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

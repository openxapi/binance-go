/*
Binance Spot API

OpenAPI specification for Binance exchange - Spot API

API version: 0.2.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// SpotTradingAPIService SpotTradingAPI service
type SpotTradingAPIService service

type ApiCreateOrderCancelReplaceV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	cancelReplaceMode *string
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	cancelNewClientOrderId *string
	cancelOrderId *int64
	cancelOrigClientOrderId *string
	cancelRestrictions *string
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	orderRateLimitExceededMode *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopPrice *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
	trailingDelta *int64
}

func (r ApiCreateOrderCancelReplaceV3Request) CancelReplaceMode(cancelReplaceMode string) ApiCreateOrderCancelReplaceV3Request {
	r.cancelReplaceMode = &cancelReplaceMode
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) Side(side string) ApiCreateOrderCancelReplaceV3Request {
	r.side = &side
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) Symbol(symbol string) ApiCreateOrderCancelReplaceV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) Timestamp(timestamp int64) ApiCreateOrderCancelReplaceV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) Type_(type_ string) ApiCreateOrderCancelReplaceV3Request {
	r.type_ = &type_
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) CancelNewClientOrderId(cancelNewClientOrderId string) ApiCreateOrderCancelReplaceV3Request {
	r.cancelNewClientOrderId = &cancelNewClientOrderId
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) CancelOrderId(cancelOrderId int64) ApiCreateOrderCancelReplaceV3Request {
	r.cancelOrderId = &cancelOrderId
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) CancelOrigClientOrderId(cancelOrigClientOrderId string) ApiCreateOrderCancelReplaceV3Request {
	r.cancelOrigClientOrderId = &cancelOrigClientOrderId
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) CancelRestrictions(cancelRestrictions string) ApiCreateOrderCancelReplaceV3Request {
	r.cancelRestrictions = &cancelRestrictions
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) IcebergQty(icebergQty string) ApiCreateOrderCancelReplaceV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) NewClientOrderId(newClientOrderId string) ApiCreateOrderCancelReplaceV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) NewOrderRespType(newOrderRespType string) ApiCreateOrderCancelReplaceV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) OrderRateLimitExceededMode(orderRateLimitExceededMode string) ApiCreateOrderCancelReplaceV3Request {
	r.orderRateLimitExceededMode = &orderRateLimitExceededMode
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) Price(price string) ApiCreateOrderCancelReplaceV3Request {
	r.price = &price
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) Quantity(quantity string) ApiCreateOrderCancelReplaceV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) QuoteOrderQty(quoteOrderQty string) ApiCreateOrderCancelReplaceV3Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) RecvWindow(recvWindow int64) ApiCreateOrderCancelReplaceV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiCreateOrderCancelReplaceV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) StopPrice(stopPrice string) ApiCreateOrderCancelReplaceV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) StrategyId(strategyId int64) ApiCreateOrderCancelReplaceV3Request {
	r.strategyId = &strategyId
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) StrategyType(strategyType int32) ApiCreateOrderCancelReplaceV3Request {
	r.strategyType = &strategyType
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) TimeInForce(timeInForce string) ApiCreateOrderCancelReplaceV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) TrailingDelta(trailingDelta int64) ApiCreateOrderCancelReplaceV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r ApiCreateOrderCancelReplaceV3Request) Execute() (*SpotCreateOrderCancelReplaceV3Resp, *http.Response, error) {
	return r.ApiService.CreateOrderCancelReplaceV3Execute(r)
}

/*
CreateOrderCancelReplaceV3 Cancel an Existing Order and Send a New Order (TRADE)

Cancels an existing order and places a new order on the same symbol.
Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrderCancelReplaceV3Request
*/
func (a *SpotTradingAPIService) CreateOrderCancelReplaceV3(ctx context.Context) ApiCreateOrderCancelReplaceV3Request {
	return ApiCreateOrderCancelReplaceV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderCancelReplaceV3Resp
func (a *SpotTradingAPIService) CreateOrderCancelReplaceV3Execute(r ApiCreateOrderCancelReplaceV3Request) (*SpotCreateOrderCancelReplaceV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderCancelReplaceV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.CreateOrderCancelReplaceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/cancelReplace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cancelReplaceMode == nil {
		return localVarReturnValue, nil, reportError("cancelReplaceMode is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cancelNewClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelNewClientOrderId", r.cancelNewClientOrderId, "", "")
	}
	if r.cancelOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelOrderId", r.cancelOrderId, "", "")
	}
	if r.cancelOrigClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelOrigClientOrderId", r.cancelOrigClientOrderId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "cancelReplaceMode", r.cancelReplaceMode, "", "")
	if r.cancelRestrictions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelRestrictions", r.cancelRestrictions, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.orderRateLimitExceededMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "orderRateLimitExceededMode", r.orderRateLimitExceededMode, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrderListOcoV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	aboveType *string
	belowType *string
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	aboveClientOrderId *string
	aboveIcebergQty *int64
	abovePrice *string
	aboveStopPrice *string
	aboveStrategyId *int64
	aboveStrategyType *int32
	aboveTimeInForce *string
	aboveTrailingDelta *int64
	belowClientOrderId *string
	belowIcebergQty *int64
	belowPrice *string
	belowStopPrice *string
	belowStrategyId *int64
	belowStrategyType *int32
	belowTimeInForce *string
	belowTrailingDelta *int64
	listClientOrderId *string
	newOrderRespType *string
	recvWindow *int64
	selfTradePreventionMode *string
}

func (r ApiCreateOrderListOcoV3Request) AboveType(aboveType string) ApiCreateOrderListOcoV3Request {
	r.aboveType = &aboveType
	return r
}

func (r ApiCreateOrderListOcoV3Request) BelowType(belowType string) ApiCreateOrderListOcoV3Request {
	r.belowType = &belowType
	return r
}

func (r ApiCreateOrderListOcoV3Request) Quantity(quantity string) ApiCreateOrderListOcoV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiCreateOrderListOcoV3Request) Side(side string) ApiCreateOrderListOcoV3Request {
	r.side = &side
	return r
}

func (r ApiCreateOrderListOcoV3Request) Symbol(symbol string) ApiCreateOrderListOcoV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateOrderListOcoV3Request) Timestamp(timestamp int64) ApiCreateOrderListOcoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateOrderListOcoV3Request) AboveClientOrderId(aboveClientOrderId string) ApiCreateOrderListOcoV3Request {
	r.aboveClientOrderId = &aboveClientOrderId
	return r
}

func (r ApiCreateOrderListOcoV3Request) AboveIcebergQty(aboveIcebergQty int64) ApiCreateOrderListOcoV3Request {
	r.aboveIcebergQty = &aboveIcebergQty
	return r
}

func (r ApiCreateOrderListOcoV3Request) AbovePrice(abovePrice string) ApiCreateOrderListOcoV3Request {
	r.abovePrice = &abovePrice
	return r
}

func (r ApiCreateOrderListOcoV3Request) AboveStopPrice(aboveStopPrice string) ApiCreateOrderListOcoV3Request {
	r.aboveStopPrice = &aboveStopPrice
	return r
}

func (r ApiCreateOrderListOcoV3Request) AboveStrategyId(aboveStrategyId int64) ApiCreateOrderListOcoV3Request {
	r.aboveStrategyId = &aboveStrategyId
	return r
}

func (r ApiCreateOrderListOcoV3Request) AboveStrategyType(aboveStrategyType int32) ApiCreateOrderListOcoV3Request {
	r.aboveStrategyType = &aboveStrategyType
	return r
}

func (r ApiCreateOrderListOcoV3Request) AboveTimeInForce(aboveTimeInForce string) ApiCreateOrderListOcoV3Request {
	r.aboveTimeInForce = &aboveTimeInForce
	return r
}

func (r ApiCreateOrderListOcoV3Request) AboveTrailingDelta(aboveTrailingDelta int64) ApiCreateOrderListOcoV3Request {
	r.aboveTrailingDelta = &aboveTrailingDelta
	return r
}

func (r ApiCreateOrderListOcoV3Request) BelowClientOrderId(belowClientOrderId string) ApiCreateOrderListOcoV3Request {
	r.belowClientOrderId = &belowClientOrderId
	return r
}

func (r ApiCreateOrderListOcoV3Request) BelowIcebergQty(belowIcebergQty int64) ApiCreateOrderListOcoV3Request {
	r.belowIcebergQty = &belowIcebergQty
	return r
}

func (r ApiCreateOrderListOcoV3Request) BelowPrice(belowPrice string) ApiCreateOrderListOcoV3Request {
	r.belowPrice = &belowPrice
	return r
}

func (r ApiCreateOrderListOcoV3Request) BelowStopPrice(belowStopPrice string) ApiCreateOrderListOcoV3Request {
	r.belowStopPrice = &belowStopPrice
	return r
}

func (r ApiCreateOrderListOcoV3Request) BelowStrategyId(belowStrategyId int64) ApiCreateOrderListOcoV3Request {
	r.belowStrategyId = &belowStrategyId
	return r
}

func (r ApiCreateOrderListOcoV3Request) BelowStrategyType(belowStrategyType int32) ApiCreateOrderListOcoV3Request {
	r.belowStrategyType = &belowStrategyType
	return r
}

func (r ApiCreateOrderListOcoV3Request) BelowTimeInForce(belowTimeInForce string) ApiCreateOrderListOcoV3Request {
	r.belowTimeInForce = &belowTimeInForce
	return r
}

func (r ApiCreateOrderListOcoV3Request) BelowTrailingDelta(belowTrailingDelta int64) ApiCreateOrderListOcoV3Request {
	r.belowTrailingDelta = &belowTrailingDelta
	return r
}

func (r ApiCreateOrderListOcoV3Request) ListClientOrderId(listClientOrderId string) ApiCreateOrderListOcoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiCreateOrderListOcoV3Request) NewOrderRespType(newOrderRespType string) ApiCreateOrderListOcoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiCreateOrderListOcoV3Request) RecvWindow(recvWindow int64) ApiCreateOrderListOcoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateOrderListOcoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiCreateOrderListOcoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiCreateOrderListOcoV3Request) Execute() (*CreateOrderListOcoV3Resp, *http.Response, error) {
	return r.ApiService.CreateOrderListOcoV3Execute(r)
}

/*
CreateOrderListOcoV3 New Order list - OCO (TRADE)

Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
- An OCO has 2 orders called the above order and below order.
- One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order.
- Price restrictions

If the OCO is on the SELL side:

LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice
TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice


If the OCO is on the BUY side:

LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice
TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice
- OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrderListOcoV3Request
*/
func (a *SpotTradingAPIService) CreateOrderListOcoV3(ctx context.Context) ApiCreateOrderListOcoV3Request {
	return ApiCreateOrderListOcoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateOrderListOcoV3Resp
func (a *SpotTradingAPIService) CreateOrderListOcoV3Execute(r ApiCreateOrderListOcoV3Request) (*CreateOrderListOcoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOrderListOcoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.CreateOrderListOcoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aboveType == nil {
		return localVarReturnValue, nil, reportError("aboveType is required and must be specified")
	}
	if r.belowType == nil {
		return localVarReturnValue, nil, reportError("belowType is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.aboveClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveClientOrderId", r.aboveClientOrderId, "", "")
	}
	if r.aboveIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveIcebergQty", r.aboveIcebergQty, "", "")
	}
	if r.abovePrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "abovePrice", r.abovePrice, "", "")
	}
	if r.aboveStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveStopPrice", r.aboveStopPrice, "", "")
	}
	if r.aboveStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveStrategyId", r.aboveStrategyId, "", "")
	}
	if r.aboveStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveStrategyType", r.aboveStrategyType, "", "")
	}
	if r.aboveTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveTimeInForce", r.aboveTimeInForce, "", "")
	}
	if r.aboveTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveTrailingDelta", r.aboveTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "aboveType", r.aboveType, "", "")
	if r.belowClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowClientOrderId", r.belowClientOrderId, "", "")
	}
	if r.belowIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowIcebergQty", r.belowIcebergQty, "", "")
	}
	if r.belowPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowPrice", r.belowPrice, "", "")
	}
	if r.belowStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowStopPrice", r.belowStopPrice, "", "")
	}
	if r.belowStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowStrategyId", r.belowStrategyId, "", "")
	}
	if r.belowStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowStrategyType", r.belowStrategyType, "", "")
	}
	if r.belowTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowTimeInForce", r.belowTimeInForce, "", "")
	}
	if r.belowTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowTrailingDelta", r.belowTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "belowType", r.belowType, "", "")
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrderListOtoV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	pendingQuantity *string
	pendingSide *string
	pendingType *string
	symbol *string
	timestamp *int64
	workingPrice *string
	workingQuantity *string
	workingSide *string
	workingType *string
	listClientOrderId *string
	newOrderRespType *string
	pendingClientOrderId *string
	pendingIcebergQty *string
	pendingPrice *string
	pendingStopPrice *string
	pendingStrategyId *int64
	pendingStrategyType *int32
	pendingTimeInForce *string
	pendingTrailingDelta *string
	recvWindow *int64
	selfTradePreventionMode *string
	workingClientOrderId *string
	workingIcebergQty *string
	workingStrategyId *int64
	workingStrategyType *int32
	workingTimeInForce *string
}

func (r ApiCreateOrderListOtoV3Request) PendingQuantity(pendingQuantity string) ApiCreateOrderListOtoV3Request {
	r.pendingQuantity = &pendingQuantity
	return r
}

func (r ApiCreateOrderListOtoV3Request) PendingSide(pendingSide string) ApiCreateOrderListOtoV3Request {
	r.pendingSide = &pendingSide
	return r
}

func (r ApiCreateOrderListOtoV3Request) PendingType(pendingType string) ApiCreateOrderListOtoV3Request {
	r.pendingType = &pendingType
	return r
}

func (r ApiCreateOrderListOtoV3Request) Symbol(symbol string) ApiCreateOrderListOtoV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateOrderListOtoV3Request) Timestamp(timestamp int64) ApiCreateOrderListOtoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateOrderListOtoV3Request) WorkingPrice(workingPrice string) ApiCreateOrderListOtoV3Request {
	r.workingPrice = &workingPrice
	return r
}

func (r ApiCreateOrderListOtoV3Request) WorkingQuantity(workingQuantity string) ApiCreateOrderListOtoV3Request {
	r.workingQuantity = &workingQuantity
	return r
}

func (r ApiCreateOrderListOtoV3Request) WorkingSide(workingSide string) ApiCreateOrderListOtoV3Request {
	r.workingSide = &workingSide
	return r
}

func (r ApiCreateOrderListOtoV3Request) WorkingType(workingType string) ApiCreateOrderListOtoV3Request {
	r.workingType = &workingType
	return r
}

func (r ApiCreateOrderListOtoV3Request) ListClientOrderId(listClientOrderId string) ApiCreateOrderListOtoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiCreateOrderListOtoV3Request) NewOrderRespType(newOrderRespType string) ApiCreateOrderListOtoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiCreateOrderListOtoV3Request) PendingClientOrderId(pendingClientOrderId string) ApiCreateOrderListOtoV3Request {
	r.pendingClientOrderId = &pendingClientOrderId
	return r
}

func (r ApiCreateOrderListOtoV3Request) PendingIcebergQty(pendingIcebergQty string) ApiCreateOrderListOtoV3Request {
	r.pendingIcebergQty = &pendingIcebergQty
	return r
}

func (r ApiCreateOrderListOtoV3Request) PendingPrice(pendingPrice string) ApiCreateOrderListOtoV3Request {
	r.pendingPrice = &pendingPrice
	return r
}

func (r ApiCreateOrderListOtoV3Request) PendingStopPrice(pendingStopPrice string) ApiCreateOrderListOtoV3Request {
	r.pendingStopPrice = &pendingStopPrice
	return r
}

func (r ApiCreateOrderListOtoV3Request) PendingStrategyId(pendingStrategyId int64) ApiCreateOrderListOtoV3Request {
	r.pendingStrategyId = &pendingStrategyId
	return r
}

func (r ApiCreateOrderListOtoV3Request) PendingStrategyType(pendingStrategyType int32) ApiCreateOrderListOtoV3Request {
	r.pendingStrategyType = &pendingStrategyType
	return r
}

func (r ApiCreateOrderListOtoV3Request) PendingTimeInForce(pendingTimeInForce string) ApiCreateOrderListOtoV3Request {
	r.pendingTimeInForce = &pendingTimeInForce
	return r
}

func (r ApiCreateOrderListOtoV3Request) PendingTrailingDelta(pendingTrailingDelta string) ApiCreateOrderListOtoV3Request {
	r.pendingTrailingDelta = &pendingTrailingDelta
	return r
}

func (r ApiCreateOrderListOtoV3Request) RecvWindow(recvWindow int64) ApiCreateOrderListOtoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateOrderListOtoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiCreateOrderListOtoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiCreateOrderListOtoV3Request) WorkingClientOrderId(workingClientOrderId string) ApiCreateOrderListOtoV3Request {
	r.workingClientOrderId = &workingClientOrderId
	return r
}

func (r ApiCreateOrderListOtoV3Request) WorkingIcebergQty(workingIcebergQty string) ApiCreateOrderListOtoV3Request {
	r.workingIcebergQty = &workingIcebergQty
	return r
}

func (r ApiCreateOrderListOtoV3Request) WorkingStrategyId(workingStrategyId int64) ApiCreateOrderListOtoV3Request {
	r.workingStrategyId = &workingStrategyId
	return r
}

func (r ApiCreateOrderListOtoV3Request) WorkingStrategyType(workingStrategyType int32) ApiCreateOrderListOtoV3Request {
	r.workingStrategyType = &workingStrategyType
	return r
}

func (r ApiCreateOrderListOtoV3Request) WorkingTimeInForce(workingTimeInForce string) ApiCreateOrderListOtoV3Request {
	r.workingTimeInForce = &workingTimeInForce
	return r
}

func (r ApiCreateOrderListOtoV3Request) Execute() (*CreateOrderListOtoV3Resp, *http.Response, error) {
	return r.ApiService.CreateOrderListOtoV3Execute(r)
}

/*
CreateOrderListOtoV3 New Order list - OTO (TRADE)

Places an OTO.
- An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
- The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.
- The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled.
- If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
- When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status.
- OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrderListOtoV3Request
*/
func (a *SpotTradingAPIService) CreateOrderListOtoV3(ctx context.Context) ApiCreateOrderListOtoV3Request {
	return ApiCreateOrderListOtoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateOrderListOtoV3Resp
func (a *SpotTradingAPIService) CreateOrderListOtoV3Execute(r ApiCreateOrderListOtoV3Request) (*CreateOrderListOtoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOrderListOtoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.CreateOrderListOtoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList/oto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pendingQuantity == nil {
		return localVarReturnValue, nil, reportError("pendingQuantity is required and must be specified")
	}
	if r.pendingSide == nil {
		return localVarReturnValue, nil, reportError("pendingSide is required and must be specified")
	}
	if r.pendingType == nil {
		return localVarReturnValue, nil, reportError("pendingType is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.workingPrice == nil {
		return localVarReturnValue, nil, reportError("workingPrice is required and must be specified")
	}
	if r.workingQuantity == nil {
		return localVarReturnValue, nil, reportError("workingQuantity is required and must be specified")
	}
	if r.workingSide == nil {
		return localVarReturnValue, nil, reportError("workingSide is required and must be specified")
	}
	if r.workingType == nil {
		return localVarReturnValue, nil, reportError("workingType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.pendingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingClientOrderId", r.pendingClientOrderId, "", "")
	}
	if r.pendingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingIcebergQty", r.pendingIcebergQty, "", "")
	}
	if r.pendingPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingPrice", r.pendingPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingQuantity", r.pendingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingSide", r.pendingSide, "", "")
	if r.pendingStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStopPrice", r.pendingStopPrice, "", "")
	}
	if r.pendingStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStrategyId", r.pendingStrategyId, "", "")
	}
	if r.pendingStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStrategyType", r.pendingStrategyType, "", "")
	}
	if r.pendingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingTimeInForce", r.pendingTimeInForce, "", "")
	}
	if r.pendingTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingTrailingDelta", r.pendingTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingType", r.pendingType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.workingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingClientOrderId", r.workingClientOrderId, "", "")
	}
	if r.workingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingIcebergQty", r.workingIcebergQty, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingPrice", r.workingPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingQuantity", r.workingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingSide", r.workingSide, "", "")
	if r.workingStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyId", r.workingStrategyId, "", "")
	}
	if r.workingStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyType", r.workingStrategyType, "", "")
	}
	if r.workingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingTimeInForce", r.workingTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrderListOtocoV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	pendingAboveType *string
	pendingQuantity *string
	pendingSide *string
	symbol *string
	timestamp *int64
	workingPrice *string
	workingQuantity *string
	workingSide *string
	workingType *string
	listClientOrderId *string
	newOrderRespType *string
	pendingAboveClientOrderId *string
	pendingAboveIcebergQty *string
	pendingAbovePrice *string
	pendingAboveStopPrice *string
	pendingAboveStrategyId *int64
	pendingAboveStrategyType *int32
	pendingAboveTimeInForce *string
	pendingAboveTrailingDelta *string
	pendingBelowClientOrderId *string
	pendingBelowIcebergQty *string
	pendingBelowPrice *string
	pendingBelowStopPrice *string
	pendingBelowStrategyId *int64
	pendingBelowStrategyType *int32
	pendingBelowTimeInForce *string
	pendingBelowTrailingDelta *string
	pendingBelowType *string
	recvWindow *int64
	selfTradePreventionMode *string
	workingClientOrderId *string
	workingIcebergQty *string
	workingStrategyId *int64
	workingStrategyType *int32
	workingTimeInForce *string
}

func (r ApiCreateOrderListOtocoV3Request) PendingAboveType(pendingAboveType string) ApiCreateOrderListOtocoV3Request {
	r.pendingAboveType = &pendingAboveType
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingQuantity(pendingQuantity string) ApiCreateOrderListOtocoV3Request {
	r.pendingQuantity = &pendingQuantity
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingSide(pendingSide string) ApiCreateOrderListOtocoV3Request {
	r.pendingSide = &pendingSide
	return r
}

func (r ApiCreateOrderListOtocoV3Request) Symbol(symbol string) ApiCreateOrderListOtocoV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateOrderListOtocoV3Request) Timestamp(timestamp int64) ApiCreateOrderListOtocoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateOrderListOtocoV3Request) WorkingPrice(workingPrice string) ApiCreateOrderListOtocoV3Request {
	r.workingPrice = &workingPrice
	return r
}

func (r ApiCreateOrderListOtocoV3Request) WorkingQuantity(workingQuantity string) ApiCreateOrderListOtocoV3Request {
	r.workingQuantity = &workingQuantity
	return r
}

func (r ApiCreateOrderListOtocoV3Request) WorkingSide(workingSide string) ApiCreateOrderListOtocoV3Request {
	r.workingSide = &workingSide
	return r
}

func (r ApiCreateOrderListOtocoV3Request) WorkingType(workingType string) ApiCreateOrderListOtocoV3Request {
	r.workingType = &workingType
	return r
}

func (r ApiCreateOrderListOtocoV3Request) ListClientOrderId(listClientOrderId string) ApiCreateOrderListOtocoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiCreateOrderListOtocoV3Request) NewOrderRespType(newOrderRespType string) ApiCreateOrderListOtocoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingAboveClientOrderId(pendingAboveClientOrderId string) ApiCreateOrderListOtocoV3Request {
	r.pendingAboveClientOrderId = &pendingAboveClientOrderId
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingAboveIcebergQty(pendingAboveIcebergQty string) ApiCreateOrderListOtocoV3Request {
	r.pendingAboveIcebergQty = &pendingAboveIcebergQty
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingAbovePrice(pendingAbovePrice string) ApiCreateOrderListOtocoV3Request {
	r.pendingAbovePrice = &pendingAbovePrice
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingAboveStopPrice(pendingAboveStopPrice string) ApiCreateOrderListOtocoV3Request {
	r.pendingAboveStopPrice = &pendingAboveStopPrice
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingAboveStrategyId(pendingAboveStrategyId int64) ApiCreateOrderListOtocoV3Request {
	r.pendingAboveStrategyId = &pendingAboveStrategyId
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingAboveStrategyType(pendingAboveStrategyType int32) ApiCreateOrderListOtocoV3Request {
	r.pendingAboveStrategyType = &pendingAboveStrategyType
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingAboveTimeInForce(pendingAboveTimeInForce string) ApiCreateOrderListOtocoV3Request {
	r.pendingAboveTimeInForce = &pendingAboveTimeInForce
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingAboveTrailingDelta(pendingAboveTrailingDelta string) ApiCreateOrderListOtocoV3Request {
	r.pendingAboveTrailingDelta = &pendingAboveTrailingDelta
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingBelowClientOrderId(pendingBelowClientOrderId string) ApiCreateOrderListOtocoV3Request {
	r.pendingBelowClientOrderId = &pendingBelowClientOrderId
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingBelowIcebergQty(pendingBelowIcebergQty string) ApiCreateOrderListOtocoV3Request {
	r.pendingBelowIcebergQty = &pendingBelowIcebergQty
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingBelowPrice(pendingBelowPrice string) ApiCreateOrderListOtocoV3Request {
	r.pendingBelowPrice = &pendingBelowPrice
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingBelowStopPrice(pendingBelowStopPrice string) ApiCreateOrderListOtocoV3Request {
	r.pendingBelowStopPrice = &pendingBelowStopPrice
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingBelowStrategyId(pendingBelowStrategyId int64) ApiCreateOrderListOtocoV3Request {
	r.pendingBelowStrategyId = &pendingBelowStrategyId
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingBelowStrategyType(pendingBelowStrategyType int32) ApiCreateOrderListOtocoV3Request {
	r.pendingBelowStrategyType = &pendingBelowStrategyType
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingBelowTimeInForce(pendingBelowTimeInForce string) ApiCreateOrderListOtocoV3Request {
	r.pendingBelowTimeInForce = &pendingBelowTimeInForce
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingBelowTrailingDelta(pendingBelowTrailingDelta string) ApiCreateOrderListOtocoV3Request {
	r.pendingBelowTrailingDelta = &pendingBelowTrailingDelta
	return r
}

func (r ApiCreateOrderListOtocoV3Request) PendingBelowType(pendingBelowType string) ApiCreateOrderListOtocoV3Request {
	r.pendingBelowType = &pendingBelowType
	return r
}

func (r ApiCreateOrderListOtocoV3Request) RecvWindow(recvWindow int64) ApiCreateOrderListOtocoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateOrderListOtocoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiCreateOrderListOtocoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiCreateOrderListOtocoV3Request) WorkingClientOrderId(workingClientOrderId string) ApiCreateOrderListOtocoV3Request {
	r.workingClientOrderId = &workingClientOrderId
	return r
}

func (r ApiCreateOrderListOtocoV3Request) WorkingIcebergQty(workingIcebergQty string) ApiCreateOrderListOtocoV3Request {
	r.workingIcebergQty = &workingIcebergQty
	return r
}

func (r ApiCreateOrderListOtocoV3Request) WorkingStrategyId(workingStrategyId int64) ApiCreateOrderListOtocoV3Request {
	r.workingStrategyId = &workingStrategyId
	return r
}

func (r ApiCreateOrderListOtocoV3Request) WorkingStrategyType(workingStrategyType int32) ApiCreateOrderListOtocoV3Request {
	r.workingStrategyType = &workingStrategyType
	return r
}

func (r ApiCreateOrderListOtocoV3Request) WorkingTimeInForce(workingTimeInForce string) ApiCreateOrderListOtocoV3Request {
	r.workingTimeInForce = &workingTimeInForce
	return r
}

func (r ApiCreateOrderListOtocoV3Request) Execute() (*CreateOrderListOtocoV3Resp, *http.Response, error) {
	return r.ApiService.CreateOrderListOtocoV3Execute(r)
}

/*
CreateOrderListOtocoV3 New Order list - OTOCO (TRADE)

Place an OTOCO.
- An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
- The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.

The behavior of the working order is the same as the OTO.
- OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.

The rules of the pending above and pending below follow the same rules as the Order list OCO.
- OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrderListOtocoV3Request
*/
func (a *SpotTradingAPIService) CreateOrderListOtocoV3(ctx context.Context) ApiCreateOrderListOtocoV3Request {
	return ApiCreateOrderListOtocoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateOrderListOtocoV3Resp
func (a *SpotTradingAPIService) CreateOrderListOtocoV3Execute(r ApiCreateOrderListOtocoV3Request) (*CreateOrderListOtocoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOrderListOtocoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.CreateOrderListOtocoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList/otoco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pendingAboveType == nil {
		return localVarReturnValue, nil, reportError("pendingAboveType is required and must be specified")
	}
	if r.pendingQuantity == nil {
		return localVarReturnValue, nil, reportError("pendingQuantity is required and must be specified")
	}
	if r.pendingSide == nil {
		return localVarReturnValue, nil, reportError("pendingSide is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.workingPrice == nil {
		return localVarReturnValue, nil, reportError("workingPrice is required and must be specified")
	}
	if r.workingQuantity == nil {
		return localVarReturnValue, nil, reportError("workingQuantity is required and must be specified")
	}
	if r.workingSide == nil {
		return localVarReturnValue, nil, reportError("workingSide is required and must be specified")
	}
	if r.workingType == nil {
		return localVarReturnValue, nil, reportError("workingType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.pendingAboveClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveClientOrderId", r.pendingAboveClientOrderId, "", "")
	}
	if r.pendingAboveIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveIcebergQty", r.pendingAboveIcebergQty, "", "")
	}
	if r.pendingAbovePrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAbovePrice", r.pendingAbovePrice, "", "")
	}
	if r.pendingAboveStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStopPrice", r.pendingAboveStopPrice, "", "")
	}
	if r.pendingAboveStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStrategyId", r.pendingAboveStrategyId, "", "")
	}
	if r.pendingAboveStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStrategyType", r.pendingAboveStrategyType, "", "")
	}
	if r.pendingAboveTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveTimeInForce", r.pendingAboveTimeInForce, "", "")
	}
	if r.pendingAboveTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveTrailingDelta", r.pendingAboveTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveType", r.pendingAboveType, "", "")
	if r.pendingBelowClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowClientOrderId", r.pendingBelowClientOrderId, "", "")
	}
	if r.pendingBelowIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowIcebergQty", r.pendingBelowIcebergQty, "", "")
	}
	if r.pendingBelowPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowPrice", r.pendingBelowPrice, "", "")
	}
	if r.pendingBelowStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStopPrice", r.pendingBelowStopPrice, "", "")
	}
	if r.pendingBelowStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStrategyId", r.pendingBelowStrategyId, "", "")
	}
	if r.pendingBelowStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStrategyType", r.pendingBelowStrategyType, "", "")
	}
	if r.pendingBelowTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowTimeInForce", r.pendingBelowTimeInForce, "", "")
	}
	if r.pendingBelowTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowTrailingDelta", r.pendingBelowTrailingDelta, "", "")
	}
	if r.pendingBelowType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowType", r.pendingBelowType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingQuantity", r.pendingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingSide", r.pendingSide, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.workingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingClientOrderId", r.workingClientOrderId, "", "")
	}
	if r.workingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingIcebergQty", r.workingIcebergQty, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingPrice", r.workingPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingQuantity", r.workingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingSide", r.workingSide, "", "")
	if r.workingStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyId", r.workingStrategyId, "", "")
	}
	if r.workingStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyType", r.workingStrategyType, "", "")
	}
	if r.workingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingTimeInForce", r.workingTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrderOcoV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	price *string
	quantity *string
	side *string
	stopPrice *string
	symbol *string
	timestamp *int64
	limitClientOrderId *string
	limitIcebergQty *string
	limitStrategyId *int64
	limitStrategyType *int32
	listClientOrderId *string
	newOrderRespType *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopClientOrderId *string
	stopIcebergQty *string
	stopLimitPrice *string
	stopLimitTimeInForce *string
	stopStrategyId *int64
	stopStrategyType *int32
	trailingDelta *int64
}

func (r ApiCreateOrderOcoV3Request) Price(price string) ApiCreateOrderOcoV3Request {
	r.price = &price
	return r
}

func (r ApiCreateOrderOcoV3Request) Quantity(quantity string) ApiCreateOrderOcoV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiCreateOrderOcoV3Request) Side(side string) ApiCreateOrderOcoV3Request {
	r.side = &side
	return r
}

func (r ApiCreateOrderOcoV3Request) StopPrice(stopPrice string) ApiCreateOrderOcoV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r ApiCreateOrderOcoV3Request) Symbol(symbol string) ApiCreateOrderOcoV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateOrderOcoV3Request) Timestamp(timestamp int64) ApiCreateOrderOcoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateOrderOcoV3Request) LimitClientOrderId(limitClientOrderId string) ApiCreateOrderOcoV3Request {
	r.limitClientOrderId = &limitClientOrderId
	return r
}

func (r ApiCreateOrderOcoV3Request) LimitIcebergQty(limitIcebergQty string) ApiCreateOrderOcoV3Request {
	r.limitIcebergQty = &limitIcebergQty
	return r
}

func (r ApiCreateOrderOcoV3Request) LimitStrategyId(limitStrategyId int64) ApiCreateOrderOcoV3Request {
	r.limitStrategyId = &limitStrategyId
	return r
}

func (r ApiCreateOrderOcoV3Request) LimitStrategyType(limitStrategyType int32) ApiCreateOrderOcoV3Request {
	r.limitStrategyType = &limitStrategyType
	return r
}

func (r ApiCreateOrderOcoV3Request) ListClientOrderId(listClientOrderId string) ApiCreateOrderOcoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiCreateOrderOcoV3Request) NewOrderRespType(newOrderRespType string) ApiCreateOrderOcoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiCreateOrderOcoV3Request) RecvWindow(recvWindow int64) ApiCreateOrderOcoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateOrderOcoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiCreateOrderOcoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiCreateOrderOcoV3Request) StopClientOrderId(stopClientOrderId string) ApiCreateOrderOcoV3Request {
	r.stopClientOrderId = &stopClientOrderId
	return r
}

func (r ApiCreateOrderOcoV3Request) StopIcebergQty(stopIcebergQty string) ApiCreateOrderOcoV3Request {
	r.stopIcebergQty = &stopIcebergQty
	return r
}

func (r ApiCreateOrderOcoV3Request) StopLimitPrice(stopLimitPrice string) ApiCreateOrderOcoV3Request {
	r.stopLimitPrice = &stopLimitPrice
	return r
}

func (r ApiCreateOrderOcoV3Request) StopLimitTimeInForce(stopLimitTimeInForce string) ApiCreateOrderOcoV3Request {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}

func (r ApiCreateOrderOcoV3Request) StopStrategyId(stopStrategyId int64) ApiCreateOrderOcoV3Request {
	r.stopStrategyId = &stopStrategyId
	return r
}

func (r ApiCreateOrderOcoV3Request) StopStrategyType(stopStrategyType int32) ApiCreateOrderOcoV3Request {
	r.stopStrategyType = &stopStrategyType
	return r
}

func (r ApiCreateOrderOcoV3Request) TrailingDelta(trailingDelta int64) ApiCreateOrderOcoV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r ApiCreateOrderOcoV3Request) Execute() (*CreateOrderOcoV3Resp, *http.Response, error) {
	return r.ApiService.CreateOrderOcoV3Execute(r)
}

/*
CreateOrderOcoV3 New OCO - Deprecated (TRADE)

Send in a new OCO.
- Price Restrictions:

SELL: Limit Price > Last Price > Stop Price
BUY: Limit Price < Last Price < Stop Price
- Quantity Restrictions:

Both legs must have the same quantity.
ICEBERG quantities however do not have to be the same
- OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrderOcoV3Request
*/
func (a *SpotTradingAPIService) CreateOrderOcoV3(ctx context.Context) ApiCreateOrderOcoV3Request {
	return ApiCreateOrderOcoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateOrderOcoV3Resp
func (a *SpotTradingAPIService) CreateOrderOcoV3Execute(r ApiCreateOrderOcoV3Request) (*CreateOrderOcoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOrderOcoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.CreateOrderOcoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.limitClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitClientOrderId", r.limitClientOrderId, "", "")
	}
	if r.limitIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitIcebergQty", r.limitIcebergQty, "", "")
	}
	if r.limitStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitStrategyId", r.limitStrategyId, "", "")
	}
	if r.limitStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitStrategyType", r.limitStrategyType, "", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopClientOrderId", r.stopClientOrderId, "", "")
	}
	if r.stopIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopIcebergQty", r.stopIcebergQty, "", "")
	}
	if r.stopLimitPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitPrice", r.stopLimitPrice, "", "")
	}
	if r.stopLimitTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitTimeInForce", r.stopLimitTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	if r.stopStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopStrategyId", r.stopStrategyId, "", "")
	}
	if r.stopStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopStrategyType", r.stopStrategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrderTestV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	computeCommissionRates *bool
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopPrice *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
	trailingDelta *int64
}

func (r ApiCreateOrderTestV3Request) Side(side string) ApiCreateOrderTestV3Request {
	r.side = &side
	return r
}

func (r ApiCreateOrderTestV3Request) Symbol(symbol string) ApiCreateOrderTestV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateOrderTestV3Request) Timestamp(timestamp int64) ApiCreateOrderTestV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateOrderTestV3Request) Type_(type_ string) ApiCreateOrderTestV3Request {
	r.type_ = &type_
	return r
}

func (r ApiCreateOrderTestV3Request) ComputeCommissionRates(computeCommissionRates bool) ApiCreateOrderTestV3Request {
	r.computeCommissionRates = &computeCommissionRates
	return r
}

func (r ApiCreateOrderTestV3Request) IcebergQty(icebergQty string) ApiCreateOrderTestV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiCreateOrderTestV3Request) NewClientOrderId(newClientOrderId string) ApiCreateOrderTestV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiCreateOrderTestV3Request) NewOrderRespType(newOrderRespType string) ApiCreateOrderTestV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiCreateOrderTestV3Request) Price(price string) ApiCreateOrderTestV3Request {
	r.price = &price
	return r
}

func (r ApiCreateOrderTestV3Request) Quantity(quantity string) ApiCreateOrderTestV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiCreateOrderTestV3Request) QuoteOrderQty(quoteOrderQty string) ApiCreateOrderTestV3Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r ApiCreateOrderTestV3Request) RecvWindow(recvWindow int64) ApiCreateOrderTestV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateOrderTestV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiCreateOrderTestV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiCreateOrderTestV3Request) StopPrice(stopPrice string) ApiCreateOrderTestV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r ApiCreateOrderTestV3Request) StrategyId(strategyId int64) ApiCreateOrderTestV3Request {
	r.strategyId = &strategyId
	return r
}

func (r ApiCreateOrderTestV3Request) StrategyType(strategyType int32) ApiCreateOrderTestV3Request {
	r.strategyType = &strategyType
	return r
}

func (r ApiCreateOrderTestV3Request) TimeInForce(timeInForce string) ApiCreateOrderTestV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiCreateOrderTestV3Request) TrailingDelta(trailingDelta int64) ApiCreateOrderTestV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r ApiCreateOrderTestV3Request) Execute() (*SpotCreateOrderTestV3Resp, *http.Response, error) {
	return r.ApiService.CreateOrderTestV3Execute(r)
}

/*
CreateOrderTestV3 Test new order (TRADE)

Test new order creation and signature/recvWindow long.
Creates and validates a new order but does not send it into the matching engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrderTestV3Request
*/
func (a *SpotTradingAPIService) CreateOrderTestV3(ctx context.Context) ApiCreateOrderTestV3Request {
	return ApiCreateOrderTestV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderTestV3Resp
func (a *SpotTradingAPIService) CreateOrderTestV3Execute(r ApiCreateOrderTestV3Request) (*SpotCreateOrderTestV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderTestV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.CreateOrderTestV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.computeCommissionRates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "computeCommissionRates", r.computeCommissionRates, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrderV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopPrice *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
	trailingDelta *int64
}

func (r ApiCreateOrderV3Request) Side(side string) ApiCreateOrderV3Request {
	r.side = &side
	return r
}

func (r ApiCreateOrderV3Request) Symbol(symbol string) ApiCreateOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateOrderV3Request) Timestamp(timestamp int64) ApiCreateOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateOrderV3Request) Type_(type_ string) ApiCreateOrderV3Request {
	r.type_ = &type_
	return r
}

func (r ApiCreateOrderV3Request) IcebergQty(icebergQty string) ApiCreateOrderV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiCreateOrderV3Request) NewClientOrderId(newClientOrderId string) ApiCreateOrderV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiCreateOrderV3Request) NewOrderRespType(newOrderRespType string) ApiCreateOrderV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiCreateOrderV3Request) Price(price string) ApiCreateOrderV3Request {
	r.price = &price
	return r
}

func (r ApiCreateOrderV3Request) Quantity(quantity string) ApiCreateOrderV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiCreateOrderV3Request) QuoteOrderQty(quoteOrderQty string) ApiCreateOrderV3Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r ApiCreateOrderV3Request) RecvWindow(recvWindow int64) ApiCreateOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateOrderV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiCreateOrderV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiCreateOrderV3Request) StopPrice(stopPrice string) ApiCreateOrderV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r ApiCreateOrderV3Request) StrategyId(strategyId int64) ApiCreateOrderV3Request {
	r.strategyId = &strategyId
	return r
}

func (r ApiCreateOrderV3Request) StrategyType(strategyType int32) ApiCreateOrderV3Request {
	r.strategyType = &strategyType
	return r
}

func (r ApiCreateOrderV3Request) TimeInForce(timeInForce string) ApiCreateOrderV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiCreateOrderV3Request) TrailingDelta(trailingDelta int64) ApiCreateOrderV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r ApiCreateOrderV3Request) Execute() (*SpotCreateOrderV3Resp, *http.Response, error) {
	return r.ApiService.CreateOrderV3Execute(r)
}

/*
CreateOrderV3 New order (TRADE)

Send in a new order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrderV3Request
*/
func (a *SpotTradingAPIService) CreateOrderV3(ctx context.Context) ApiCreateOrderV3Request {
	return ApiCreateOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderV3Resp
func (a *SpotTradingAPIService) CreateOrderV3Execute(r ApiCreateOrderV3Request) (*SpotCreateOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.CreateOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSorOrderTestV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	computeCommissionRates *bool
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	recvWindow *int64
	selfTradePreventionMode *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
}

func (r ApiCreateSorOrderTestV3Request) Quantity(quantity string) ApiCreateSorOrderTestV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiCreateSorOrderTestV3Request) Side(side string) ApiCreateSorOrderTestV3Request {
	r.side = &side
	return r
}

func (r ApiCreateSorOrderTestV3Request) Symbol(symbol string) ApiCreateSorOrderTestV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateSorOrderTestV3Request) Timestamp(timestamp int64) ApiCreateSorOrderTestV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSorOrderTestV3Request) Type_(type_ string) ApiCreateSorOrderTestV3Request {
	r.type_ = &type_
	return r
}

func (r ApiCreateSorOrderTestV3Request) ComputeCommissionRates(computeCommissionRates bool) ApiCreateSorOrderTestV3Request {
	r.computeCommissionRates = &computeCommissionRates
	return r
}

func (r ApiCreateSorOrderTestV3Request) IcebergQty(icebergQty string) ApiCreateSorOrderTestV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiCreateSorOrderTestV3Request) NewClientOrderId(newClientOrderId string) ApiCreateSorOrderTestV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiCreateSorOrderTestV3Request) NewOrderRespType(newOrderRespType string) ApiCreateSorOrderTestV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiCreateSorOrderTestV3Request) Price(price string) ApiCreateSorOrderTestV3Request {
	r.price = &price
	return r
}

func (r ApiCreateSorOrderTestV3Request) RecvWindow(recvWindow int64) ApiCreateSorOrderTestV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSorOrderTestV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiCreateSorOrderTestV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiCreateSorOrderTestV3Request) StrategyId(strategyId int64) ApiCreateSorOrderTestV3Request {
	r.strategyId = &strategyId
	return r
}

func (r ApiCreateSorOrderTestV3Request) StrategyType(strategyType int32) ApiCreateSorOrderTestV3Request {
	r.strategyType = &strategyType
	return r
}

func (r ApiCreateSorOrderTestV3Request) TimeInForce(timeInForce string) ApiCreateSorOrderTestV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiCreateSorOrderTestV3Request) Execute() (*SpotCreateSorOrderTestV3Resp, *http.Response, error) {
	return r.ApiService.CreateSorOrderTestV3Execute(r)
}

/*
CreateSorOrderTestV3 Test new order using SOR (TRADE)

Test new order creation and signature/recvWindow using smart order routing (SOR).
Creates and validates a new order but does not send it into the matching engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSorOrderTestV3Request
*/
func (a *SpotTradingAPIService) CreateSorOrderTestV3(ctx context.Context) ApiCreateSorOrderTestV3Request {
	return ApiCreateSorOrderTestV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateSorOrderTestV3Resp
func (a *SpotTradingAPIService) CreateSorOrderTestV3Execute(r ApiCreateSorOrderTestV3Request) (*SpotCreateSorOrderTestV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateSorOrderTestV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.CreateSorOrderTestV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sor/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.computeCommissionRates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "computeCommissionRates", r.computeCommissionRates, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSorOrderV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	recvWindow *int64
	selfTradePreventionMode *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
}

func (r ApiCreateSorOrderV3Request) Quantity(quantity string) ApiCreateSorOrderV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiCreateSorOrderV3Request) Side(side string) ApiCreateSorOrderV3Request {
	r.side = &side
	return r
}

func (r ApiCreateSorOrderV3Request) Symbol(symbol string) ApiCreateSorOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateSorOrderV3Request) Timestamp(timestamp int64) ApiCreateSorOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSorOrderV3Request) Type_(type_ string) ApiCreateSorOrderV3Request {
	r.type_ = &type_
	return r
}

func (r ApiCreateSorOrderV3Request) IcebergQty(icebergQty string) ApiCreateSorOrderV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiCreateSorOrderV3Request) NewClientOrderId(newClientOrderId string) ApiCreateSorOrderV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiCreateSorOrderV3Request) NewOrderRespType(newOrderRespType string) ApiCreateSorOrderV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiCreateSorOrderV3Request) Price(price string) ApiCreateSorOrderV3Request {
	r.price = &price
	return r
}

func (r ApiCreateSorOrderV3Request) RecvWindow(recvWindow int64) ApiCreateSorOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSorOrderV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiCreateSorOrderV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiCreateSorOrderV3Request) StrategyId(strategyId int64) ApiCreateSorOrderV3Request {
	r.strategyId = &strategyId
	return r
}

func (r ApiCreateSorOrderV3Request) StrategyType(strategyType int32) ApiCreateSorOrderV3Request {
	r.strategyType = &strategyType
	return r
}

func (r ApiCreateSorOrderV3Request) TimeInForce(timeInForce string) ApiCreateSorOrderV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiCreateSorOrderV3Request) Execute() (*CreateSorOrderV3Resp, *http.Response, error) {
	return r.ApiService.CreateSorOrderV3Execute(r)
}

/*
CreateSorOrderV3 New order using SOR (TRADE)

Places an order using smart order routing (SOR).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSorOrderV3Request
*/
func (a *SpotTradingAPIService) CreateSorOrderV3(ctx context.Context) ApiCreateSorOrderV3Request {
	return ApiCreateSorOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSorOrderV3Resp
func (a *SpotTradingAPIService) CreateSorOrderV3Execute(r ApiCreateSorOrderV3Request) (*CreateSorOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSorOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.CreateSorOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sor/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserDataStreamV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
}

func (r ApiCreateUserDataStreamV3Request) Execute() (*CreateUserDataStreamV3Resp, *http.Response, error) {
	return r.ApiService.CreateUserDataStreamV3Execute(r)
}

/*
CreateUserDataStreamV3 Start user data stream (USER_STREAM)

Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateUserDataStreamV3Request
*/
func (a *SpotTradingAPIService) CreateUserDataStreamV3(ctx context.Context) ApiCreateUserDataStreamV3Request {
	return ApiCreateUserDataStreamV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateUserDataStreamV3Resp
func (a *SpotTradingAPIService) CreateUserDataStreamV3Execute(r ApiCreateUserDataStreamV3Request) (*CreateUserDataStreamV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUserDataStreamV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.CreateUserDataStreamV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/userDataStream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOpenOrdersV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiDeleteOpenOrdersV3Request) Symbol(symbol string) ApiDeleteOpenOrdersV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiDeleteOpenOrdersV3Request) Timestamp(timestamp int64) ApiDeleteOpenOrdersV3Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiDeleteOpenOrdersV3Request) RecvWindow(recvWindow int64) ApiDeleteOpenOrdersV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiDeleteOpenOrdersV3Request) Execute() ([][]SpotDeleteOpenOrdersV3RespInner, *http.Response, error) {
	return r.ApiService.DeleteOpenOrdersV3Execute(r)
}

/*
DeleteOpenOrdersV3 Cancel All Open Orders on a Symbol (TRADE)

Cancels all active orders on a symbol.
This includes orders that are part of an order list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteOpenOrdersV3Request
*/
func (a *SpotTradingAPIService) DeleteOpenOrdersV3(ctx context.Context) ApiDeleteOpenOrdersV3Request {
	return ApiDeleteOpenOrdersV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]SpotDeleteOpenOrdersV3RespInner
func (a *SpotTradingAPIService) DeleteOpenOrdersV3Execute(r ApiDeleteOpenOrdersV3Request) ([][]SpotDeleteOpenOrdersV3RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]SpotDeleteOpenOrdersV3RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.DeleteOpenOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrderListV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	timestamp *int64
	orderListId *int64
	listClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

func (r ApiDeleteOrderListV3Request) Symbol(symbol string) ApiDeleteOrderListV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiDeleteOrderListV3Request) Timestamp(timestamp int64) ApiDeleteOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r ApiDeleteOrderListV3Request) OrderListId(orderListId int64) ApiDeleteOrderListV3Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r ApiDeleteOrderListV3Request) ListClientOrderId(listClientOrderId string) ApiDeleteOrderListV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiDeleteOrderListV3Request) NewClientOrderId(newClientOrderId string) ApiDeleteOrderListV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiDeleteOrderListV3Request) RecvWindow(recvWindow int64) ApiDeleteOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiDeleteOrderListV3Request) Execute() (*DeleteOrderListV3Resp, *http.Response, error) {
	return r.ApiService.DeleteOrderListV3Execute(r)
}

/*
DeleteOrderListV3 Cancel Order list (TRADE)

Cancel an entire Order list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteOrderListV3Request
*/
func (a *SpotTradingAPIService) DeleteOrderListV3(ctx context.Context) ApiDeleteOrderListV3Request {
	return ApiDeleteOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteOrderListV3Resp
func (a *SpotTradingAPIService) DeleteOrderListV3Execute(r ApiDeleteOrderListV3Request) (*DeleteOrderListV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteOrderListV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.DeleteOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listClientOrderId", r.listClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.listClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrderV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	newClientOrderId *string
	cancelRestrictions *string
	recvWindow *int64
}

func (r ApiDeleteOrderV3Request) Symbol(symbol string) ApiDeleteOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiDeleteOrderV3Request) Timestamp(timestamp int64) ApiDeleteOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiDeleteOrderV3Request) OrderId(orderId int64) ApiDeleteOrderV3Request {
	r.orderId = &orderId
	return r
}

func (r ApiDeleteOrderV3Request) OrigClientOrderId(origClientOrderId string) ApiDeleteOrderV3Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default.
func (r ApiDeleteOrderV3Request) NewClientOrderId(newClientOrderId string) ApiDeleteOrderV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// Supported values: &lt;br/&gt;&#x60;ONLY_NEW&#x60; - Cancel will succeed if the order status is &#x60;NEW&#x60;.&lt;br/&gt; &#x60;ONLY_PARTIALLY_FILLED &#x60; - Cancel will succeed if order status is &#x60;PARTIALLY_FILLED&#x60;.
func (r ApiDeleteOrderV3Request) CancelRestrictions(cancelRestrictions string) ApiDeleteOrderV3Request {
	r.cancelRestrictions = &cancelRestrictions
	return r
}

// The value cannot be greater than &#x60;60000&#x60;.
func (r ApiDeleteOrderV3Request) RecvWindow(recvWindow int64) ApiDeleteOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiDeleteOrderV3Request) Execute() (*DeleteOrderV3Resp, *http.Response, error) {
	return r.ApiService.DeleteOrderV3Execute(r)
}

/*
DeleteOrderV3 Cancel order (TRADE)

Cancel an active order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteOrderV3Request
*/
func (a *SpotTradingAPIService) DeleteOrderV3(ctx context.Context) ApiDeleteOrderV3Request {
	return ApiDeleteOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteOrderV3Resp
func (a *SpotTradingAPIService) DeleteOrderV3Execute(r ApiDeleteOrderV3Request) (*DeleteOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.DeleteOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.cancelRestrictions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelRestrictions", r.cancelRestrictions, "form", "")
	} else {
		var defaultValue string = ""
		r.cancelRestrictions = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteUserDataStreamV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	listenKey *string
}

func (r ApiDeleteUserDataStreamV3Request) ListenKey(listenKey string) ApiDeleteUserDataStreamV3Request {
	r.listenKey = &listenKey
	return r
}

func (r ApiDeleteUserDataStreamV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteUserDataStreamV3Execute(r)
}

/*
DeleteUserDataStreamV3 Close user data stream (USER_STREAM)

Close out a user data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteUserDataStreamV3Request
*/
func (a *SpotTradingAPIService) DeleteUserDataStreamV3(ctx context.Context) ApiDeleteUserDataStreamV3Request {
	return ApiDeleteUserDataStreamV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SpotTradingAPIService) DeleteUserDataStreamV3Execute(r ApiDeleteUserDataStreamV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.DeleteUserDataStreamV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/userDataStream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listenKey == nil {
		return localVarReturnValue, nil, reportError("listenKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "listenKey", r.listenKey, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountCommissionV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
}

func (r ApiGetAccountCommissionV3Request) Symbol(symbol string) ApiGetAccountCommissionV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetAccountCommissionV3Request) Execute() (*GetAccountCommissionV3Resp, *http.Response, error) {
	return r.ApiService.GetAccountCommissionV3Execute(r)
}

/*
GetAccountCommissionV3 Query Commission Rates (USER_DATA)

Get current account commission rates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountCommissionV3Request
*/
func (a *SpotTradingAPIService) GetAccountCommissionV3(ctx context.Context) ApiGetAccountCommissionV3Request {
	return ApiGetAccountCommissionV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountCommissionV3Resp
func (a *SpotTradingAPIService) GetAccountCommissionV3Execute(r ApiGetAccountCommissionV3Request) (*GetAccountCommissionV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountCommissionV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetAccountCommissionV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account/commission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	timestamp *int64
	omitZeroBalances *bool
	recvWindow *int64
}

func (r ApiGetAccountV3Request) Timestamp(timestamp int64) ApiGetAccountV3Request {
	r.timestamp = &timestamp
	return r
}

// When set to &#x60;true&#x60;, emits only the non-zero balances of an account. &lt;br/&gt;Default value: &#x60;false&#x60;
func (r ApiGetAccountV3Request) OmitZeroBalances(omitZeroBalances bool) ApiGetAccountV3Request {
	r.omitZeroBalances = &omitZeroBalances
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetAccountV3Request) RecvWindow(recvWindow int64) ApiGetAccountV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAccountV3Request) Execute() (*GetAccountV3Resp, *http.Response, error) {
	return r.ApiService.GetAccountV3Execute(r)
}

/*
GetAccountV3 Account information (USER_DATA)

Get current account information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountV3Request
*/
func (a *SpotTradingAPIService) GetAccountV3(ctx context.Context) ApiGetAccountV3Request {
	return ApiGetAccountV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountV3Resp
func (a *SpotTradingAPIService) GetAccountV3Execute(r ApiGetAccountV3Request) (*GetAccountV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetAccountV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.omitZeroBalances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omitZeroBalances", r.omitZeroBalances, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAggTradesV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
}

func (r ApiGetAggTradesV3Request) Symbol(symbol string) ApiGetAggTradesV3Request {
	r.symbol = &symbol
	return r
}

// ID to get aggregate trades from INCLUSIVE.
func (r ApiGetAggTradesV3Request) FromId(fromId int64) ApiGetAggTradesV3Request {
	r.fromId = &fromId
	return r
}

// Timestamp in ms to get aggregate trades from INCLUSIVE.
func (r ApiGetAggTradesV3Request) StartTime(startTime int64) ApiGetAggTradesV3Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get aggregate trades until INCLUSIVE.
func (r ApiGetAggTradesV3Request) EndTime(endTime int64) ApiGetAggTradesV3Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r ApiGetAggTradesV3Request) Limit(limit int32) ApiGetAggTradesV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetAggTradesV3Request) Execute() ([]SpotGetAggTradesV3RespItem, *http.Response, error) {
	return r.ApiService.GetAggTradesV3Execute(r)
}

/*
GetAggTradesV3 Compressed/Aggregate trades list

Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAggTradesV3Request
*/
func (a *SpotTradingAPIService) GetAggTradesV3(ctx context.Context) ApiGetAggTradesV3Request {
	return ApiGetAggTradesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetAggTradesV3RespItem
func (a *SpotTradingAPIService) GetAggTradesV3Execute(r ApiGetAggTradesV3Request) ([]SpotGetAggTradesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetAggTradesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetAggTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/aggTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllOrderListV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	timestamp *int64
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiGetAllOrderListV3Request) Timestamp(timestamp int64) ApiGetAllOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
func (r ApiGetAllOrderListV3Request) FromId(fromId int64) ApiGetAllOrderListV3Request {
	r.fromId = &fromId
	return r
}

func (r ApiGetAllOrderListV3Request) StartTime(startTime int64) ApiGetAllOrderListV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetAllOrderListV3Request) EndTime(endTime int64) ApiGetAllOrderListV3Request {
	r.endTime = &endTime
	return r
}

// Default Value: 500; Max Value: 1000
func (r ApiGetAllOrderListV3Request) Limit(limit int32) ApiGetAllOrderListV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetAllOrderListV3Request) RecvWindow(recvWindow int64) ApiGetAllOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAllOrderListV3Request) Execute() ([]GetAllOrderListV3RespItem, *http.Response, error) {
	return r.ApiService.GetAllOrderListV3Execute(r)
}

/*
GetAllOrderListV3 Query all Order lists (USER_DATA)

Retrieves all order lists based on provided optional parameters.
Note that the time between startTime and endTime can't be longer than 24 hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllOrderListV3Request
*/
func (a *SpotTradingAPIService) GetAllOrderListV3(ctx context.Context) ApiGetAllOrderListV3Request {
	return ApiGetAllOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetAllOrderListV3RespItem
func (a *SpotTradingAPIService) GetAllOrderListV3Execute(r ApiGetAllOrderListV3Request) ([]GetAllOrderListV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetAllOrderListV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetAllOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllOrdersV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiGetAllOrdersV3Request) Symbol(symbol string) ApiGetAllOrdersV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetAllOrdersV3Request) Timestamp(timestamp int64) ApiGetAllOrdersV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAllOrdersV3Request) OrderId(orderId int64) ApiGetAllOrdersV3Request {
	r.orderId = &orderId
	return r
}

func (r ApiGetAllOrdersV3Request) StartTime(startTime int64) ApiGetAllOrdersV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetAllOrdersV3Request) EndTime(endTime int64) ApiGetAllOrdersV3Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r ApiGetAllOrdersV3Request) Limit(limit int32) ApiGetAllOrdersV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetAllOrdersV3Request) RecvWindow(recvWindow int64) ApiGetAllOrdersV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAllOrdersV3Request) Execute() ([]GetAllOrdersV3RespItem, *http.Response, error) {
	return r.ApiService.GetAllOrdersV3Execute(r)
}

/*
GetAllOrdersV3 All orders (USER_DATA)

Get all account orders; active, canceled, or filled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllOrdersV3Request
*/
func (a *SpotTradingAPIService) GetAllOrdersV3(ctx context.Context) ApiGetAllOrdersV3Request {
	return ApiGetAllOrdersV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetAllOrdersV3RespItem
func (a *SpotTradingAPIService) GetAllOrdersV3Execute(r ApiGetAllOrdersV3Request) ([]GetAllOrdersV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetAllOrdersV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetAllOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvgPriceV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
}

func (r ApiGetAvgPriceV3Request) Symbol(symbol string) ApiGetAvgPriceV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetAvgPriceV3Request) Execute() (*GetAvgPriceV3Resp, *http.Response, error) {
	return r.ApiService.GetAvgPriceV3Execute(r)
}

/*
GetAvgPriceV3 Current average price

Current average price for a symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAvgPriceV3Request
*/
func (a *SpotTradingAPIService) GetAvgPriceV3(ctx context.Context) ApiGetAvgPriceV3Request {
	return ApiGetAvgPriceV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAvgPriceV3Resp
func (a *SpotTradingAPIService) GetAvgPriceV3Execute(r ApiGetAvgPriceV3Request) (*GetAvgPriceV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAvgPriceV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetAvgPriceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/avgPrice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDepthV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	limit *int32
}

func (r ApiGetDepthV3Request) Symbol(symbol string) ApiGetDepthV3Request {
	r.symbol = &symbol
	return r
}

// Default 100; max 5000. &lt;br/&gt; If limit &amp;gt; 5000. then the response will truncate to 5000.
func (r ApiGetDepthV3Request) Limit(limit int32) ApiGetDepthV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetDepthV3Request) Execute() (*GetDepthV3Resp, *http.Response, error) {
	return r.ApiService.GetDepthV3Execute(r)
}

/*
GetDepthV3 Order book

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDepthV3Request
*/
func (a *SpotTradingAPIService) GetDepthV3(ctx context.Context) ApiGetDepthV3Request {
	return ApiGetDepthV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDepthV3Resp
func (a *SpotTradingAPIService) GetDepthV3Execute(r ApiGetDepthV3Request) (*GetDepthV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDepthV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetDepthV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExchangeInfoV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	symbols *[]string
	permissions *string
	showPermissionSets *bool
	symbolStatus *string
}

// Example: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbol&#x3D;BNBBTC\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbol&#x3D;BNBBTC&lt;/a&gt;&amp;#34;
func (r ApiGetExchangeInfoV3Request) Symbol(symbol string) ApiGetExchangeInfoV3Request {
	r.symbol = &symbol
	return r
}

// Examples: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BNBBTC%22,%22BTCUSDT%22%5D\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BNBBTC%22,%22BTCUSDT%22%5D&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -g -X  GET &amp;#39;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BTCUSDT%22,%22BNBBTC\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;[&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBBTC&lt;/a&gt;&amp;#34;]&amp;#39;
func (r ApiGetExchangeInfoV3Request) Symbols(symbols []string) ApiGetExchangeInfoV3Request {
	r.symbols = &symbols
	return r
}

// Examples: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;SPOT\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;SPOT&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22%2C%22LEVERAGED%22%5D&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -g -X GET &amp;#39;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22,%22LEVERAGED\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;[&amp;#34;MARGIN&amp;#34;,&amp;#34;LEVERAGED&lt;/a&gt;&amp;#34;]&amp;#39;
func (r ApiGetExchangeInfoV3Request) Permissions(permissions string) ApiGetExchangeInfoV3Request {
	r.permissions = &permissions
	return r
}

// Controls whether the content of the &#x60;permissionSets&#x60; field is populated or not. Defaults to &#x60;true&#x60;
func (r ApiGetExchangeInfoV3Request) ShowPermissionSets(showPermissionSets bool) ApiGetExchangeInfoV3Request {
	r.showPermissionSets = &showPermissionSets
	return r
}

// Filters symbols that have this &#x60;tradingStatus&#x60;. Valid values: &#x60;TRADING&#x60;, &#x60;HALT&#x60;, &#x60;BREAK&#x60; &lt;br/&gt; Cannot be used in combination with &#x60;symbols&#x60; or &#x60;symbol&#x60;.
func (r ApiGetExchangeInfoV3Request) SymbolStatus(symbolStatus string) ApiGetExchangeInfoV3Request {
	r.symbolStatus = &symbolStatus
	return r
}

func (r ApiGetExchangeInfoV3Request) Execute() (*SpotGetExchangeInfoV3Resp, *http.Response, error) {
	return r.ApiService.GetExchangeInfoV3Execute(r)
}

/*
GetExchangeInfoV3 Exchange information

Current exchange trading rules and symbol information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExchangeInfoV3Request
*/
func (a *SpotTradingAPIService) GetExchangeInfoV3(ctx context.Context) ApiGetExchangeInfoV3Request {
	return ApiGetExchangeInfoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetExchangeInfoV3Resp
func (a *SpotTradingAPIService) GetExchangeInfoV3Execute(r ApiGetExchangeInfoV3Request) (*SpotGetExchangeInfoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetExchangeInfoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetExchangeInfoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/exchangeInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.symbols != nil {
		t := *r.symbols
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", t, "form", "multi")
		}
	}
	if r.permissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissions", r.permissions, "form", "")
	} else {
		var defaultValue string = ""
		r.permissions = &defaultValue
	}
	if r.showPermissionSets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showPermissionSets", r.showPermissionSets, "form", "")
	}
	if r.symbolStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbolStatus", r.symbolStatus, "form", "")
	} else {
		var defaultValue string = ""
		r.symbolStatus = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoricalTradesV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	limit *int32
	fromId *int64
}

func (r ApiGetHistoricalTradesV3Request) Symbol(symbol string) ApiGetHistoricalTradesV3Request {
	r.symbol = &symbol
	return r
}

// Default 500; max 1000.
func (r ApiGetHistoricalTradesV3Request) Limit(limit int32) ApiGetHistoricalTradesV3Request {
	r.limit = &limit
	return r
}

// TradeId to fetch from. Default gets most recent trades.
func (r ApiGetHistoricalTradesV3Request) FromId(fromId int64) ApiGetHistoricalTradesV3Request {
	r.fromId = &fromId
	return r
}

func (r ApiGetHistoricalTradesV3Request) Execute() ([]GetHistoricalTradesV3RespItem, *http.Response, error) {
	return r.ApiService.GetHistoricalTradesV3Execute(r)
}

/*
GetHistoricalTradesV3 Old trade lookup

Get older trades.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHistoricalTradesV3Request
*/
func (a *SpotTradingAPIService) GetHistoricalTradesV3(ctx context.Context) ApiGetHistoricalTradesV3Request {
	return ApiGetHistoricalTradesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetHistoricalTradesV3RespItem
func (a *SpotTradingAPIService) GetHistoricalTradesV3Execute(r ApiGetHistoricalTradesV3Request) ([]GetHistoricalTradesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetHistoricalTradesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetHistoricalTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/historicalTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKlinesV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	interval *string
	startTime *int64
	endTime *int64
	timeZone *string
	limit *int32
}

func (r ApiGetKlinesV3Request) Symbol(symbol string) ApiGetKlinesV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetKlinesV3Request) Interval(interval string) ApiGetKlinesV3Request {
	r.interval = &interval
	return r
}

func (r ApiGetKlinesV3Request) StartTime(startTime int64) ApiGetKlinesV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetKlinesV3Request) EndTime(endTime int64) ApiGetKlinesV3Request {
	r.endTime = &endTime
	return r
}

// Default: 0 (UTC)
func (r ApiGetKlinesV3Request) TimeZone(timeZone string) ApiGetKlinesV3Request {
	r.timeZone = &timeZone
	return r
}

// Default 500; max 1000.
func (r ApiGetKlinesV3Request) Limit(limit int32) ApiGetKlinesV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetKlinesV3Request) Execute() ([][]GetKlinesV3200ResponseInnerInner, *http.Response, error) {
	return r.ApiService.GetKlinesV3Execute(r)
}

/*
GetKlinesV3 Kline/Candlestick data

Kline/candlestick bars for a symbol.
Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetKlinesV3Request
*/
func (a *SpotTradingAPIService) GetKlinesV3(ctx context.Context) ApiGetKlinesV3Request {
	return ApiGetKlinesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]GetKlinesV3200ResponseInnerInner
func (a *SpotTradingAPIService) GetKlinesV3Execute(r ApiGetKlinesV3Request) ([][]GetKlinesV3200ResponseInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]GetKlinesV3200ResponseInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetKlinesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/klines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.timeZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeZone", r.timeZone, "form", "")
	} else {
		var defaultValue string = "0"
		r.timeZone = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyAllocationsV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	startTime *int64
	endTime *int64
	fromAllocationId *int32
	limit *int32
	orderId *int64
	recvWindow *int64
	timestamp *int64
}

func (r ApiGetMyAllocationsV3Request) Symbol(symbol string) ApiGetMyAllocationsV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetMyAllocationsV3Request) StartTime(startTime int64) ApiGetMyAllocationsV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetMyAllocationsV3Request) EndTime(endTime int64) ApiGetMyAllocationsV3Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetMyAllocationsV3Request) FromAllocationId(fromAllocationId int32) ApiGetMyAllocationsV3Request {
	r.fromAllocationId = &fromAllocationId
	return r
}

// Default 500;Max 1000
func (r ApiGetMyAllocationsV3Request) Limit(limit int32) ApiGetMyAllocationsV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetMyAllocationsV3Request) OrderId(orderId int64) ApiGetMyAllocationsV3Request {
	r.orderId = &orderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;.
func (r ApiGetMyAllocationsV3Request) RecvWindow(recvWindow int64) ApiGetMyAllocationsV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMyAllocationsV3Request) Timestamp(timestamp int64) ApiGetMyAllocationsV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetMyAllocationsV3Request) Execute() ([]GetMyAllocationsV3RespItem, *http.Response, error) {
	return r.ApiService.GetMyAllocationsV3Execute(r)
}

/*
GetMyAllocationsV3 Query Allocations (USER_DATA)

Retrieves allocations resulting from SOR order placement.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyAllocationsV3Request
*/
func (a *SpotTradingAPIService) GetMyAllocationsV3(ctx context.Context) ApiGetMyAllocationsV3Request {
	return ApiGetMyAllocationsV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetMyAllocationsV3RespItem
func (a *SpotTradingAPIService) GetMyAllocationsV3Execute(r ApiGetMyAllocationsV3Request) ([]GetMyAllocationsV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetMyAllocationsV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetMyAllocationsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myAllocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromAllocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromAllocationId", r.fromAllocationId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	if r.timestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyPreventedMatchesV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	timestamp *int64
	preventedMatchId *int64
	orderId *int64
	fromPreventedMatchId *int64
	limit *int32
	recvWindow *int64
}

func (r ApiGetMyPreventedMatchesV3Request) Symbol(symbol string) ApiGetMyPreventedMatchesV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetMyPreventedMatchesV3Request) Timestamp(timestamp int64) ApiGetMyPreventedMatchesV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetMyPreventedMatchesV3Request) PreventedMatchId(preventedMatchId int64) ApiGetMyPreventedMatchesV3Request {
	r.preventedMatchId = &preventedMatchId
	return r
}

func (r ApiGetMyPreventedMatchesV3Request) OrderId(orderId int64) ApiGetMyPreventedMatchesV3Request {
	r.orderId = &orderId
	return r
}

func (r ApiGetMyPreventedMatchesV3Request) FromPreventedMatchId(fromPreventedMatchId int64) ApiGetMyPreventedMatchesV3Request {
	r.fromPreventedMatchId = &fromPreventedMatchId
	return r
}

// Default: &#x60;500&#x60;; Max: &#x60;1000&#x60;
func (r ApiGetMyPreventedMatchesV3Request) Limit(limit int32) ApiGetMyPreventedMatchesV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetMyPreventedMatchesV3Request) RecvWindow(recvWindow int64) ApiGetMyPreventedMatchesV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMyPreventedMatchesV3Request) Execute() ([]GetMyPreventedMatchesV3RespItem, *http.Response, error) {
	return r.ApiService.GetMyPreventedMatchesV3Execute(r)
}

/*
GetMyPreventedMatchesV3 Query Prevented Matches (USER_DATA)

Displays the list of orders that were expired due to STP.
These are the combinations supported:
- symbol + preventedMatchId
- symbol + orderId
- symbol + orderId + fromPreventedMatchId (limit will default to 500)
- symbol + orderId + fromPreventedMatchId + limit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyPreventedMatchesV3Request
*/
func (a *SpotTradingAPIService) GetMyPreventedMatchesV3(ctx context.Context) ApiGetMyPreventedMatchesV3Request {
	return ApiGetMyPreventedMatchesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetMyPreventedMatchesV3RespItem
func (a *SpotTradingAPIService) GetMyPreventedMatchesV3Execute(r ApiGetMyPreventedMatchesV3Request) ([]GetMyPreventedMatchesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetMyPreventedMatchesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetMyPreventedMatchesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myPreventedMatches"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.preventedMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preventedMatchId", r.preventedMatchId, "form", "")
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.fromPreventedMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromPreventedMatchId", r.fromPreventedMatchId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyTradesV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r ApiGetMyTradesV3Request) Symbol(symbol string) ApiGetMyTradesV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetMyTradesV3Request) Timestamp(timestamp int64) ApiGetMyTradesV3Request {
	r.timestamp = &timestamp
	return r
}

// This can only be used in combination with &#x60;symbol&#x60;.
func (r ApiGetMyTradesV3Request) OrderId(orderId int64) ApiGetMyTradesV3Request {
	r.orderId = &orderId
	return r
}

func (r ApiGetMyTradesV3Request) StartTime(startTime int64) ApiGetMyTradesV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetMyTradesV3Request) EndTime(endTime int64) ApiGetMyTradesV3Request {
	r.endTime = &endTime
	return r
}

// TradeId to fetch from. Default gets most recent trades.
func (r ApiGetMyTradesV3Request) FromId(fromId int64) ApiGetMyTradesV3Request {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r ApiGetMyTradesV3Request) Limit(limit int32) ApiGetMyTradesV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetMyTradesV3Request) RecvWindow(recvWindow int64) ApiGetMyTradesV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMyTradesV3Request) Execute() ([]GetMyTradesV3RespItem, *http.Response, error) {
	return r.ApiService.GetMyTradesV3Execute(r)
}

/*
GetMyTradesV3 Account trade list (USER_DATA)

Get trades for a specific account and symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyTradesV3Request
*/
func (a *SpotTradingAPIService) GetMyTradesV3(ctx context.Context) ApiGetMyTradesV3Request {
	return ApiGetMyTradesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetMyTradesV3RespItem
func (a *SpotTradingAPIService) GetMyTradesV3Execute(r ApiGetMyTradesV3Request) ([]GetMyTradesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetMyTradesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetMyTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOpenOrderListV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetOpenOrderListV3Request) Timestamp(timestamp int64) ApiGetOpenOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetOpenOrderListV3Request) RecvWindow(recvWindow int64) ApiGetOpenOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetOpenOrderListV3Request) Execute() ([]GetOpenOrderListV3RespItem, *http.Response, error) {
	return r.ApiService.GetOpenOrderListV3Execute(r)
}

/*
GetOpenOrderListV3 Query Open Order lists (USER_DATA)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOpenOrderListV3Request
*/
func (a *SpotTradingAPIService) GetOpenOrderListV3(ctx context.Context) ApiGetOpenOrderListV3Request {
	return ApiGetOpenOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetOpenOrderListV3RespItem
func (a *SpotTradingAPIService) GetOpenOrderListV3Execute(r ApiGetOpenOrderListV3Request) ([]GetOpenOrderListV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetOpenOrderListV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetOpenOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOpenOrdersV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiGetOpenOrdersV3Request) Timestamp(timestamp int64) ApiGetOpenOrdersV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetOpenOrdersV3Request) Symbol(symbol string) ApiGetOpenOrdersV3Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetOpenOrdersV3Request) RecvWindow(recvWindow int64) ApiGetOpenOrdersV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetOpenOrdersV3Request) Execute() ([]GetOpenOrdersV3RespItem, *http.Response, error) {
	return r.ApiService.GetOpenOrdersV3Execute(r)
}

/*
GetOpenOrdersV3 Current open orders (USER_DATA)

Get all open orders on a symbol. Careful when accessing this with no symbol.
Weight:
6 for a single symbol; 80 when the symbol parameter is omitted

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOpenOrdersV3Request
*/
func (a *SpotTradingAPIService) GetOpenOrdersV3(ctx context.Context) ApiGetOpenOrdersV3Request {
	return ApiGetOpenOrdersV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetOpenOrdersV3RespItem
func (a *SpotTradingAPIService) GetOpenOrdersV3Execute(r ApiGetOpenOrdersV3Request) ([]GetOpenOrdersV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetOpenOrdersV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetOpenOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderListV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	timestamp *int64
	orderListId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r ApiGetOrderListV3Request) Timestamp(timestamp int64) ApiGetOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r ApiGetOrderListV3Request) OrderListId(orderListId int64) ApiGetOrderListV3Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r ApiGetOrderListV3Request) OrigClientOrderId(origClientOrderId string) ApiGetOrderListV3Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetOrderListV3Request) RecvWindow(recvWindow int64) ApiGetOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetOrderListV3Request) Execute() (*GetOrderListV3Resp, *http.Response, error) {
	return r.ApiService.GetOrderListV3Execute(r)
}

/*
GetOrderListV3 Query Order list (USER_DATA)

Retrieves a specific order list based on provided optional parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrderListV3Request
*/
func (a *SpotTradingAPIService) GetOrderListV3(ctx context.Context) ApiGetOrderListV3Request {
	return ApiGetOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetOrderListV3Resp
func (a *SpotTradingAPIService) GetOrderListV3Execute(r ApiGetOrderListV3Request) (*GetOrderListV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrderListV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r ApiGetOrderV3Request) Symbol(symbol string) ApiGetOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetOrderV3Request) Timestamp(timestamp int64) ApiGetOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetOrderV3Request) OrderId(orderId int64) ApiGetOrderV3Request {
	r.orderId = &orderId
	return r
}

func (r ApiGetOrderV3Request) OrigClientOrderId(origClientOrderId string) ApiGetOrderV3Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetOrderV3Request) RecvWindow(recvWindow int64) ApiGetOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetOrderV3Request) Execute() (*GetOrderV3Resp, *http.Response, error) {
	return r.ApiService.GetOrderV3Execute(r)
}

/*
GetOrderV3 Query order (USER_DATA)

Check an order's status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrderV3Request
*/
func (a *SpotTradingAPIService) GetOrderV3(ctx context.Context) ApiGetOrderV3Request {
	return ApiGetOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetOrderV3Resp
func (a *SpotTradingAPIService) GetOrderV3Execute(r ApiGetOrderV3Request) (*GetOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPingV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
}

func (r ApiGetPingV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPingV3Execute(r)
}

/*
GetPingV3 Test connectivity

Test connectivity to the Rest API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPingV3Request
*/
func (a *SpotTradingAPIService) GetPingV3(ctx context.Context) ApiGetPingV3Request {
	return ApiGetPingV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SpotTradingAPIService) GetPingV3Execute(r ApiGetPingV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetPingV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRateLimitOrderV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetRateLimitOrderV3Request) Timestamp(timestamp int64) ApiGetRateLimitOrderV3Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiGetRateLimitOrderV3Request) RecvWindow(recvWindow int64) ApiGetRateLimitOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetRateLimitOrderV3Request) Execute() ([]GetRateLimitOrderV3RespItem, *http.Response, error) {
	return r.ApiService.GetRateLimitOrderV3Execute(r)
}

/*
GetRateLimitOrderV3 Query Unfilled Order Count (USER_DATA)

Displays the user's unfilled order count for all intervals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRateLimitOrderV3Request
*/
func (a *SpotTradingAPIService) GetRateLimitOrderV3(ctx context.Context) ApiGetRateLimitOrderV3Request {
	return ApiGetRateLimitOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetRateLimitOrderV3RespItem
func (a *SpotTradingAPIService) GetRateLimitOrderV3Execute(r ApiGetRateLimitOrderV3Request) ([]GetRateLimitOrderV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetRateLimitOrderV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetRateLimitOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/rateLimit/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTicker24hrV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	symbols *string
	type_ *string
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, tickers for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;          Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r ApiGetTicker24hrV3Request) Symbol(symbol string) ApiGetTicker24hrV3Request {
	r.symbol = &symbol
	return r
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, tickers for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;          Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r ApiGetTicker24hrV3Request) Symbols(symbols string) ApiGetTicker24hrV3Request {
	r.symbols = &symbols
	return r
}

// Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
func (r ApiGetTicker24hrV3Request) Type_(type_ string) ApiGetTicker24hrV3Request {
	r.type_ = &type_
	return r
}

func (r ApiGetTicker24hrV3Request) Execute() (*SpotGetTicker24hrV3Resp, *http.Response, error) {
	return r.ApiService.GetTicker24hrV3Execute(r)
}

/*
GetTicker24hrV3 24hr ticker price change statistics

24 hour rolling window price change statistics. Careful when accessing this with no symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTicker24hrV3Request
*/
func (a *SpotTradingAPIService) GetTicker24hrV3(ctx context.Context) ApiGetTicker24hrV3Request {
	return ApiGetTicker24hrV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTicker24hrV3Resp
func (a *SpotTradingAPIService) GetTicker24hrV3Execute(r ApiGetTicker24hrV3Request) (*SpotGetTicker24hrV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTicker24hrV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetTicker24hrV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker/24hr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.symbols != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "form", "")
	} else {
		var defaultValue string = ""
		r.symbols = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTickerBookTickerV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	symbols *string
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, bookTickers for all symbols will be returned in an array.          &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r ApiGetTickerBookTickerV3Request) Symbol(symbol string) ApiGetTickerBookTickerV3Request {
	r.symbol = &symbol
	return r
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, bookTickers for all symbols will be returned in an array.          &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r ApiGetTickerBookTickerV3Request) Symbols(symbols string) ApiGetTickerBookTickerV3Request {
	r.symbols = &symbols
	return r
}

func (r ApiGetTickerBookTickerV3Request) Execute() (*SpotGetTickerBookTickerV3Resp, *http.Response, error) {
	return r.ApiService.GetTickerBookTickerV3Execute(r)
}

/*
GetTickerBookTickerV3 Symbol order book ticker

Best price/qty on the order book for a symbol or symbols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTickerBookTickerV3Request
*/
func (a *SpotTradingAPIService) GetTickerBookTickerV3(ctx context.Context) ApiGetTickerBookTickerV3Request {
	return ApiGetTickerBookTickerV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTickerBookTickerV3Resp
func (a *SpotTradingAPIService) GetTickerBookTickerV3Execute(r ApiGetTickerBookTickerV3Request) (*SpotGetTickerBookTickerV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTickerBookTickerV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetTickerBookTickerV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker/bookTicker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.symbols != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "form", "")
	} else {
		var defaultValue string = ""
		r.symbols = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTickerPriceV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	symbols *string
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, prices for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r ApiGetTickerPriceV3Request) Symbol(symbol string) ApiGetTickerPriceV3Request {
	r.symbol = &symbol
	return r
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, prices for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r ApiGetTickerPriceV3Request) Symbols(symbols string) ApiGetTickerPriceV3Request {
	r.symbols = &symbols
	return r
}

func (r ApiGetTickerPriceV3Request) Execute() (*SpotGetTickerPriceV3Resp, *http.Response, error) {
	return r.ApiService.GetTickerPriceV3Execute(r)
}

/*
GetTickerPriceV3 Symbol price ticker

Latest price for a symbol or symbols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTickerPriceV3Request
*/
func (a *SpotTradingAPIService) GetTickerPriceV3(ctx context.Context) ApiGetTickerPriceV3Request {
	return ApiGetTickerPriceV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTickerPriceV3Resp
func (a *SpotTradingAPIService) GetTickerPriceV3Execute(r ApiGetTickerPriceV3Request) (*SpotGetTickerPriceV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTickerPriceV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetTickerPriceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker/price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.symbols != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "form", "")
	} else {
		var defaultValue string = ""
		r.symbols = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTickerTradingDayV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	symbols *string
	timeZone *string
	type_ *string
}

// Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
func (r ApiGetTickerTradingDayV3Request) Symbol(symbol string) ApiGetTickerTradingDayV3Request {
	r.symbol = &symbol
	return r
}

// Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
func (r ApiGetTickerTradingDayV3Request) Symbols(symbols string) ApiGetTickerTradingDayV3Request {
	r.symbols = &symbols
	return r
}

// Default: 0 (UTC)
func (r ApiGetTickerTradingDayV3Request) TimeZone(timeZone string) ApiGetTickerTradingDayV3Request {
	r.timeZone = &timeZone
	return r
}

// Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
func (r ApiGetTickerTradingDayV3Request) Type_(type_ string) ApiGetTickerTradingDayV3Request {
	r.type_ = &type_
	return r
}

func (r ApiGetTickerTradingDayV3Request) Execute() (*SpotGetTickerTradingDayV3Resp, *http.Response, error) {
	return r.ApiService.GetTickerTradingDayV3Execute(r)
}

/*
GetTickerTradingDayV3 Trading Day Ticker

Price change statistics for a trading day.
4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTickerTradingDayV3Request
*/
func (a *SpotTradingAPIService) GetTickerTradingDayV3(ctx context.Context) ApiGetTickerTradingDayV3Request {
	return ApiGetTickerTradingDayV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTickerTradingDayV3Resp
func (a *SpotTradingAPIService) GetTickerTradingDayV3Execute(r ApiGetTickerTradingDayV3Request) (*SpotGetTickerTradingDayV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTickerTradingDayV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetTickerTradingDayV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker/tradingDay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.symbols == nil {
		return localVarReturnValue, nil, reportError("symbols is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "form", "")
	if r.timeZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeZone", r.timeZone, "form", "")
	} else {
		var defaultValue string = "0"
		r.timeZone = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTickerV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	symbols *string
	windowSize *string
	type_ *string
}

// Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
func (r ApiGetTickerV3Request) Symbol(symbol string) ApiGetTickerV3Request {
	r.symbol = &symbol
	return r
}

// Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
func (r ApiGetTickerV3Request) Symbols(symbols string) ApiGetTickerV3Request {
	r.symbols = &symbols
	return r
}

// Defaults to &#x60;1d&#x60; if no parameter provided &lt;br/&gt; Supported &#x60;windowSize&#x60; values: &lt;br/&gt; &#x60;1m&#x60;,&#x60;2m&#x60;....&#x60;59m&#x60; for minutes &lt;br/&gt; &#x60;1h&#x60;, &#x60;2h&#x60;....&#x60;23h&#x60; - for hours &lt;br/&gt; &#x60;1d&#x60;...&#x60;7d&#x60; - for days &lt;br/&gt;&lt;br/&gt; Units cannot be combined (e.g. &#x60;1d2h&#x60; is not allowed)
func (r ApiGetTickerV3Request) WindowSize(windowSize string) ApiGetTickerV3Request {
	r.windowSize = &windowSize
	return r
}

// Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
func (r ApiGetTickerV3Request) Type_(type_ string) ApiGetTickerV3Request {
	r.type_ = &type_
	return r
}

func (r ApiGetTickerV3Request) Execute() (*SpotGetTickerV3Resp, *http.Response, error) {
	return r.ApiService.GetTickerV3Execute(r)
}

/*
GetTickerV3 Rolling window price change statistics

Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint.
The window used to compute statistics will be no more than 59999ms from the requested windowSize.
openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request.
As such, the effective window will be up to 59999ms wider than windowSize.
E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00)
4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTickerV3Request
*/
func (a *SpotTradingAPIService) GetTickerV3(ctx context.Context) ApiGetTickerV3Request {
	return ApiGetTickerV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTickerV3Resp
func (a *SpotTradingAPIService) GetTickerV3Execute(r ApiGetTickerV3Request) (*SpotGetTickerV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTickerV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetTickerV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.symbols == nil {
		return localVarReturnValue, nil, reportError("symbols is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "form", "")
	if r.windowSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "windowSize", r.windowSize, "form", "")
	} else {
		var defaultValue string = ""
		r.windowSize = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
}

func (r ApiGetTimeV3Request) Execute() (*GetTimeV3Resp, *http.Response, error) {
	return r.ApiService.GetTimeV3Execute(r)
}

/*
GetTimeV3 Check server time

Test connectivity to the Rest API and get the current server time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeV3Request
*/
func (a *SpotTradingAPIService) GetTimeV3(ctx context.Context) ApiGetTimeV3Request {
	return ApiGetTimeV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTimeV3Resp
func (a *SpotTradingAPIService) GetTimeV3Execute(r ApiGetTimeV3Request) (*GetTimeV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTimeV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetTimeV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradesV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	limit *int32
}

func (r ApiGetTradesV3Request) Symbol(symbol string) ApiGetTradesV3Request {
	r.symbol = &symbol
	return r
}

// Default 500; max 1000.
func (r ApiGetTradesV3Request) Limit(limit int32) ApiGetTradesV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetTradesV3Request) Execute() ([]GetTradesV3RespItem, *http.Response, error) {
	return r.ApiService.GetTradesV3Execute(r)
}

/*
GetTradesV3 Recent trades list

Get recent trades.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradesV3Request
*/
func (a *SpotTradingAPIService) GetTradesV3(ctx context.Context) ApiGetTradesV3Request {
	return ApiGetTradesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetTradesV3RespItem
func (a *SpotTradingAPIService) GetTradesV3Execute(r ApiGetTradesV3Request) ([]GetTradesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetTradesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUiKlinesV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	symbol *string
	interval *string
	startTime *int64
	endTime *int64
	timeZone *string
	limit *int32
}

func (r ApiGetUiKlinesV3Request) Symbol(symbol string) ApiGetUiKlinesV3Request {
	r.symbol = &symbol
	return r
}

// See &lt;a href&#x3D;\&quot;/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\&quot;&gt;&#x60;klines&#x60;&lt;/a&gt;
func (r ApiGetUiKlinesV3Request) Interval(interval string) ApiGetUiKlinesV3Request {
	r.interval = &interval
	return r
}

func (r ApiGetUiKlinesV3Request) StartTime(startTime int64) ApiGetUiKlinesV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetUiKlinesV3Request) EndTime(endTime int64) ApiGetUiKlinesV3Request {
	r.endTime = &endTime
	return r
}

// Default: 0 (UTC)
func (r ApiGetUiKlinesV3Request) TimeZone(timeZone string) ApiGetUiKlinesV3Request {
	r.timeZone = &timeZone
	return r
}

// Default 500; max 1000.
func (r ApiGetUiKlinesV3Request) Limit(limit int32) ApiGetUiKlinesV3Request {
	r.limit = &limit
	return r
}

func (r ApiGetUiKlinesV3Request) Execute() ([][]GetKlinesV3200ResponseInnerInner, *http.Response, error) {
	return r.ApiService.GetUiKlinesV3Execute(r)
}

/*
GetUiKlinesV3 UIKlines

The request is similar to klines having the same parameters and response.
uiKlines return modified kline data, optimized for presentation of candlestick charts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUiKlinesV3Request
*/
func (a *SpotTradingAPIService) GetUiKlinesV3(ctx context.Context) ApiGetUiKlinesV3Request {
	return ApiGetUiKlinesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]GetKlinesV3200ResponseInnerInner
func (a *SpotTradingAPIService) GetUiKlinesV3Execute(r ApiGetUiKlinesV3Request) ([][]GetKlinesV3200ResponseInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]GetKlinesV3200ResponseInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.GetUiKlinesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/uiKlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.timeZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeZone", r.timeZone, "form", "")
	} else {
		var defaultValue string = "0"
		r.timeZone = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserDataStreamV3Request struct {
	ctx context.Context
	ApiService *SpotTradingAPIService
	listenKey *string
}

func (r ApiUpdateUserDataStreamV3Request) ListenKey(listenKey string) ApiUpdateUserDataStreamV3Request {
	r.listenKey = &listenKey
	return r
}

func (r ApiUpdateUserDataStreamV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateUserDataStreamV3Execute(r)
}

/*
UpdateUserDataStreamV3 Keepalive user data stream (USER_STREAM)

Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateUserDataStreamV3Request
*/
func (a *SpotTradingAPIService) UpdateUserDataStreamV3(ctx context.Context) ApiUpdateUserDataStreamV3Request {
	return ApiUpdateUserDataStreamV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SpotTradingAPIService) UpdateUserDataStreamV3Execute(r ApiUpdateUserDataStreamV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpotTradingAPIService.UpdateUserDataStreamV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/userDataStream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listenKey == nil {
		return localVarReturnValue, nil, reportError("listenKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "listenKey", r.listenKey, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Binance Spot API

OpenAPI specification for Binance cryptocurrency exchange - Spot API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// V3APIService V3API service
type V3APIService service

type V3APISpotCreateOrderCancelReplaceV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	cancelReplaceMode *string
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	cancelNewClientOrderId *string
	cancelOrderId *int64
	cancelOrigClientOrderId *string
	cancelRestrictions *string
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	orderRateLimitExceededMode *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopPrice *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
	trailingDelta *int64
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) CancelReplaceMode(cancelReplaceMode string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.cancelReplaceMode = &cancelReplaceMode
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) Side(side string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.side = &side
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) Symbol(symbol string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) Timestamp(timestamp int64) V3APISpotCreateOrderCancelReplaceV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) Type_(type_ string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.type_ = &type_
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) CancelNewClientOrderId(cancelNewClientOrderId string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.cancelNewClientOrderId = &cancelNewClientOrderId
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) CancelOrderId(cancelOrderId int64) V3APISpotCreateOrderCancelReplaceV3Request {
	r.cancelOrderId = &cancelOrderId
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) CancelOrigClientOrderId(cancelOrigClientOrderId string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.cancelOrigClientOrderId = &cancelOrigClientOrderId
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) CancelRestrictions(cancelRestrictions string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.cancelRestrictions = &cancelRestrictions
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) IcebergQty(icebergQty string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) NewClientOrderId(newClientOrderId string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) NewOrderRespType(newOrderRespType string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) OrderRateLimitExceededMode(orderRateLimitExceededMode string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.orderRateLimitExceededMode = &orderRateLimitExceededMode
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) Price(price string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.price = &price
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) Quantity(quantity string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.quantity = &quantity
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) QuoteOrderQty(quoteOrderQty string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) RecvWindow(recvWindow int64) V3APISpotCreateOrderCancelReplaceV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) SelfTradePreventionMode(selfTradePreventionMode string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) StopPrice(stopPrice string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) StrategyId(strategyId int64) V3APISpotCreateOrderCancelReplaceV3Request {
	r.strategyId = &strategyId
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) StrategyType(strategyType int32) V3APISpotCreateOrderCancelReplaceV3Request {
	r.strategyType = &strategyType
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) TimeInForce(timeInForce string) V3APISpotCreateOrderCancelReplaceV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) TrailingDelta(trailingDelta int64) V3APISpotCreateOrderCancelReplaceV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r V3APISpotCreateOrderCancelReplaceV3Request) Execute() (*SpotCreateOrderCancelReplaceV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderCancelReplaceV3Execute(r)
}

/*
SpotCreateOrderCancelReplaceV3 Cancel an Existing Order and Send a New Order (TRADE)

Cancels an existing order and places a new order on the same symbol.
Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotCreateOrderCancelReplaceV3Request
*/
func (a *V3APIService) SpotCreateOrderCancelReplaceV3(ctx context.Context) V3APISpotCreateOrderCancelReplaceV3Request {
	return V3APISpotCreateOrderCancelReplaceV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderCancelReplaceV3Resp
func (a *V3APIService) SpotCreateOrderCancelReplaceV3Execute(r V3APISpotCreateOrderCancelReplaceV3Request) (*SpotCreateOrderCancelReplaceV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderCancelReplaceV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotCreateOrderCancelReplaceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/cancelReplace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cancelReplaceMode == nil {
		return localVarReturnValue, nil, reportError("cancelReplaceMode is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cancelNewClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelNewClientOrderId", r.cancelNewClientOrderId, "", "")
	}
	if r.cancelOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelOrderId", r.cancelOrderId, "", "")
	}
	if r.cancelOrigClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelOrigClientOrderId", r.cancelOrigClientOrderId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "cancelReplaceMode", r.cancelReplaceMode, "", "")
	if r.cancelRestrictions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelRestrictions", r.cancelRestrictions, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.orderRateLimitExceededMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "orderRateLimitExceededMode", r.orderRateLimitExceededMode, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotCreateOrderListOcoV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	aboveType *string
	belowType *string
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	aboveClientOrderId *string
	aboveIcebergQty *int64
	abovePrice *string
	aboveStopPrice *string
	aboveStrategyId *int64
	aboveStrategyType *int32
	aboveTimeInForce *string
	aboveTrailingDelta *int64
	belowClientOrderId *string
	belowIcebergQty *int64
	belowPrice *string
	belowStopPrice *string
	belowStrategyId *int64
	belowStrategyType *int32
	belowTimeInForce *string
	belowTrailingDelta *int64
	listClientOrderId *string
	newOrderRespType *string
	recvWindow *int64
	selfTradePreventionMode *string
}

func (r V3APISpotCreateOrderListOcoV3Request) AboveType(aboveType string) V3APISpotCreateOrderListOcoV3Request {
	r.aboveType = &aboveType
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) BelowType(belowType string) V3APISpotCreateOrderListOcoV3Request {
	r.belowType = &belowType
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) Quantity(quantity string) V3APISpotCreateOrderListOcoV3Request {
	r.quantity = &quantity
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) Side(side string) V3APISpotCreateOrderListOcoV3Request {
	r.side = &side
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) Symbol(symbol string) V3APISpotCreateOrderListOcoV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) Timestamp(timestamp int64) V3APISpotCreateOrderListOcoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) AboveClientOrderId(aboveClientOrderId string) V3APISpotCreateOrderListOcoV3Request {
	r.aboveClientOrderId = &aboveClientOrderId
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) AboveIcebergQty(aboveIcebergQty int64) V3APISpotCreateOrderListOcoV3Request {
	r.aboveIcebergQty = &aboveIcebergQty
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) AbovePrice(abovePrice string) V3APISpotCreateOrderListOcoV3Request {
	r.abovePrice = &abovePrice
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) AboveStopPrice(aboveStopPrice string) V3APISpotCreateOrderListOcoV3Request {
	r.aboveStopPrice = &aboveStopPrice
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) AboveStrategyId(aboveStrategyId int64) V3APISpotCreateOrderListOcoV3Request {
	r.aboveStrategyId = &aboveStrategyId
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) AboveStrategyType(aboveStrategyType int32) V3APISpotCreateOrderListOcoV3Request {
	r.aboveStrategyType = &aboveStrategyType
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) AboveTimeInForce(aboveTimeInForce string) V3APISpotCreateOrderListOcoV3Request {
	r.aboveTimeInForce = &aboveTimeInForce
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) AboveTrailingDelta(aboveTrailingDelta int64) V3APISpotCreateOrderListOcoV3Request {
	r.aboveTrailingDelta = &aboveTrailingDelta
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) BelowClientOrderId(belowClientOrderId string) V3APISpotCreateOrderListOcoV3Request {
	r.belowClientOrderId = &belowClientOrderId
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) BelowIcebergQty(belowIcebergQty int64) V3APISpotCreateOrderListOcoV3Request {
	r.belowIcebergQty = &belowIcebergQty
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) BelowPrice(belowPrice string) V3APISpotCreateOrderListOcoV3Request {
	r.belowPrice = &belowPrice
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) BelowStopPrice(belowStopPrice string) V3APISpotCreateOrderListOcoV3Request {
	r.belowStopPrice = &belowStopPrice
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) BelowStrategyId(belowStrategyId int64) V3APISpotCreateOrderListOcoV3Request {
	r.belowStrategyId = &belowStrategyId
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) BelowStrategyType(belowStrategyType int32) V3APISpotCreateOrderListOcoV3Request {
	r.belowStrategyType = &belowStrategyType
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) BelowTimeInForce(belowTimeInForce string) V3APISpotCreateOrderListOcoV3Request {
	r.belowTimeInForce = &belowTimeInForce
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) BelowTrailingDelta(belowTrailingDelta int64) V3APISpotCreateOrderListOcoV3Request {
	r.belowTrailingDelta = &belowTrailingDelta
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) ListClientOrderId(listClientOrderId string) V3APISpotCreateOrderListOcoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) NewOrderRespType(newOrderRespType string) V3APISpotCreateOrderListOcoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) RecvWindow(recvWindow int64) V3APISpotCreateOrderListOcoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) V3APISpotCreateOrderListOcoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V3APISpotCreateOrderListOcoV3Request) Execute() (*SpotCreateOrderListOcoV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderListOcoV3Execute(r)
}

/*
SpotCreateOrderListOcoV3 New Order list - OCO (TRADE)

Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
- An OCO has 2 orders called the above order and below order.
- One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order.
- Price restrictions

If the OCO is on the SELL side:

LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice
TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice


If the OCO is on the BUY side:

LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice
TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice
- OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotCreateOrderListOcoV3Request
*/
func (a *V3APIService) SpotCreateOrderListOcoV3(ctx context.Context) V3APISpotCreateOrderListOcoV3Request {
	return V3APISpotCreateOrderListOcoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderListOcoV3Resp
func (a *V3APIService) SpotCreateOrderListOcoV3Execute(r V3APISpotCreateOrderListOcoV3Request) (*SpotCreateOrderListOcoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderListOcoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotCreateOrderListOcoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aboveType == nil {
		return localVarReturnValue, nil, reportError("aboveType is required and must be specified")
	}
	if r.belowType == nil {
		return localVarReturnValue, nil, reportError("belowType is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.aboveClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveClientOrderId", r.aboveClientOrderId, "", "")
	}
	if r.aboveIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveIcebergQty", r.aboveIcebergQty, "", "")
	}
	if r.abovePrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "abovePrice", r.abovePrice, "", "")
	}
	if r.aboveStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveStopPrice", r.aboveStopPrice, "", "")
	}
	if r.aboveStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveStrategyId", r.aboveStrategyId, "", "")
	}
	if r.aboveStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveStrategyType", r.aboveStrategyType, "", "")
	}
	if r.aboveTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveTimeInForce", r.aboveTimeInForce, "", "")
	}
	if r.aboveTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveTrailingDelta", r.aboveTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "aboveType", r.aboveType, "", "")
	if r.belowClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowClientOrderId", r.belowClientOrderId, "", "")
	}
	if r.belowIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowIcebergQty", r.belowIcebergQty, "", "")
	}
	if r.belowPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowPrice", r.belowPrice, "", "")
	}
	if r.belowStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowStopPrice", r.belowStopPrice, "", "")
	}
	if r.belowStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowStrategyId", r.belowStrategyId, "", "")
	}
	if r.belowStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowStrategyType", r.belowStrategyType, "", "")
	}
	if r.belowTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowTimeInForce", r.belowTimeInForce, "", "")
	}
	if r.belowTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowTrailingDelta", r.belowTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "belowType", r.belowType, "", "")
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotCreateOrderListOtoV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	pendingQuantity *string
	pendingSide *string
	pendingType *string
	symbol *string
	timestamp *int64
	workingPrice *string
	workingQuantity *string
	workingSide *string
	workingType *string
	listClientOrderId *string
	newOrderRespType *string
	pendingClientOrderId *string
	pendingIcebergQty *string
	pendingPrice *string
	pendingStopPrice *string
	pendingStrategyId *int64
	pendingStrategyType *int32
	pendingTimeInForce *string
	pendingTrailingDelta *string
	recvWindow *int64
	selfTradePreventionMode *string
	workingClientOrderId *string
	workingIcebergQty *string
	workingStrategyId *int64
	workingStrategyType *int32
	workingTimeInForce *string
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingQuantity(pendingQuantity string) V3APISpotCreateOrderListOtoV3Request {
	r.pendingQuantity = &pendingQuantity
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingSide(pendingSide string) V3APISpotCreateOrderListOtoV3Request {
	r.pendingSide = &pendingSide
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingType(pendingType string) V3APISpotCreateOrderListOtoV3Request {
	r.pendingType = &pendingType
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) Symbol(symbol string) V3APISpotCreateOrderListOtoV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) Timestamp(timestamp int64) V3APISpotCreateOrderListOtoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) WorkingPrice(workingPrice string) V3APISpotCreateOrderListOtoV3Request {
	r.workingPrice = &workingPrice
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) WorkingQuantity(workingQuantity string) V3APISpotCreateOrderListOtoV3Request {
	r.workingQuantity = &workingQuantity
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) WorkingSide(workingSide string) V3APISpotCreateOrderListOtoV3Request {
	r.workingSide = &workingSide
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) WorkingType(workingType string) V3APISpotCreateOrderListOtoV3Request {
	r.workingType = &workingType
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) ListClientOrderId(listClientOrderId string) V3APISpotCreateOrderListOtoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) NewOrderRespType(newOrderRespType string) V3APISpotCreateOrderListOtoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingClientOrderId(pendingClientOrderId string) V3APISpotCreateOrderListOtoV3Request {
	r.pendingClientOrderId = &pendingClientOrderId
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingIcebergQty(pendingIcebergQty string) V3APISpotCreateOrderListOtoV3Request {
	r.pendingIcebergQty = &pendingIcebergQty
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingPrice(pendingPrice string) V3APISpotCreateOrderListOtoV3Request {
	r.pendingPrice = &pendingPrice
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingStopPrice(pendingStopPrice string) V3APISpotCreateOrderListOtoV3Request {
	r.pendingStopPrice = &pendingStopPrice
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingStrategyId(pendingStrategyId int64) V3APISpotCreateOrderListOtoV3Request {
	r.pendingStrategyId = &pendingStrategyId
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingStrategyType(pendingStrategyType int32) V3APISpotCreateOrderListOtoV3Request {
	r.pendingStrategyType = &pendingStrategyType
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingTimeInForce(pendingTimeInForce string) V3APISpotCreateOrderListOtoV3Request {
	r.pendingTimeInForce = &pendingTimeInForce
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) PendingTrailingDelta(pendingTrailingDelta string) V3APISpotCreateOrderListOtoV3Request {
	r.pendingTrailingDelta = &pendingTrailingDelta
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) RecvWindow(recvWindow int64) V3APISpotCreateOrderListOtoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) V3APISpotCreateOrderListOtoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) WorkingClientOrderId(workingClientOrderId string) V3APISpotCreateOrderListOtoV3Request {
	r.workingClientOrderId = &workingClientOrderId
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) WorkingIcebergQty(workingIcebergQty string) V3APISpotCreateOrderListOtoV3Request {
	r.workingIcebergQty = &workingIcebergQty
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) WorkingStrategyId(workingStrategyId int64) V3APISpotCreateOrderListOtoV3Request {
	r.workingStrategyId = &workingStrategyId
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) WorkingStrategyType(workingStrategyType int32) V3APISpotCreateOrderListOtoV3Request {
	r.workingStrategyType = &workingStrategyType
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) WorkingTimeInForce(workingTimeInForce string) V3APISpotCreateOrderListOtoV3Request {
	r.workingTimeInForce = &workingTimeInForce
	return r
}

func (r V3APISpotCreateOrderListOtoV3Request) Execute() (*SpotCreateOrderListOtoV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderListOtoV3Execute(r)
}

/*
SpotCreateOrderListOtoV3 New Order list - OTO (TRADE)

Places an OTO.
- An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
- The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.
- The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled.
- If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
- When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status.
- OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotCreateOrderListOtoV3Request
*/
func (a *V3APIService) SpotCreateOrderListOtoV3(ctx context.Context) V3APISpotCreateOrderListOtoV3Request {
	return V3APISpotCreateOrderListOtoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderListOtoV3Resp
func (a *V3APIService) SpotCreateOrderListOtoV3Execute(r V3APISpotCreateOrderListOtoV3Request) (*SpotCreateOrderListOtoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderListOtoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotCreateOrderListOtoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList/oto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pendingQuantity == nil {
		return localVarReturnValue, nil, reportError("pendingQuantity is required and must be specified")
	}
	if r.pendingSide == nil {
		return localVarReturnValue, nil, reportError("pendingSide is required and must be specified")
	}
	if r.pendingType == nil {
		return localVarReturnValue, nil, reportError("pendingType is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.workingPrice == nil {
		return localVarReturnValue, nil, reportError("workingPrice is required and must be specified")
	}
	if r.workingQuantity == nil {
		return localVarReturnValue, nil, reportError("workingQuantity is required and must be specified")
	}
	if r.workingSide == nil {
		return localVarReturnValue, nil, reportError("workingSide is required and must be specified")
	}
	if r.workingType == nil {
		return localVarReturnValue, nil, reportError("workingType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.pendingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingClientOrderId", r.pendingClientOrderId, "", "")
	}
	if r.pendingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingIcebergQty", r.pendingIcebergQty, "", "")
	}
	if r.pendingPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingPrice", r.pendingPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingQuantity", r.pendingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingSide", r.pendingSide, "", "")
	if r.pendingStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStopPrice", r.pendingStopPrice, "", "")
	}
	if r.pendingStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStrategyId", r.pendingStrategyId, "", "")
	}
	if r.pendingStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStrategyType", r.pendingStrategyType, "", "")
	}
	if r.pendingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingTimeInForce", r.pendingTimeInForce, "", "")
	}
	if r.pendingTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingTrailingDelta", r.pendingTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingType", r.pendingType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.workingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingClientOrderId", r.workingClientOrderId, "", "")
	}
	if r.workingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingIcebergQty", r.workingIcebergQty, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingPrice", r.workingPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingQuantity", r.workingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingSide", r.workingSide, "", "")
	if r.workingStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyId", r.workingStrategyId, "", "")
	}
	if r.workingStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyType", r.workingStrategyType, "", "")
	}
	if r.workingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingTimeInForce", r.workingTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotCreateOrderListOtocoV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	pendingAboveType *string
	pendingQuantity *string
	pendingSide *string
	symbol *string
	timestamp *int64
	workingPrice *string
	workingQuantity *string
	workingSide *string
	workingType *string
	listClientOrderId *string
	newOrderRespType *string
	pendingAboveClientOrderId *string
	pendingAboveIcebergQty *string
	pendingAbovePrice *string
	pendingAboveStopPrice *string
	pendingAboveStrategyId *int64
	pendingAboveStrategyType *int32
	pendingAboveTimeInForce *string
	pendingAboveTrailingDelta *string
	pendingBelowClientOrderId *string
	pendingBelowIcebergQty *string
	pendingBelowPrice *string
	pendingBelowStopPrice *string
	pendingBelowStrategyId *int64
	pendingBelowStrategyType *int32
	pendingBelowTimeInForce *string
	pendingBelowTrailingDelta *string
	pendingBelowType *string
	recvWindow *int64
	selfTradePreventionMode *string
	workingClientOrderId *string
	workingIcebergQty *string
	workingStrategyId *int64
	workingStrategyType *int32
	workingTimeInForce *string
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingAboveType(pendingAboveType string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingAboveType = &pendingAboveType
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingQuantity(pendingQuantity string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingQuantity = &pendingQuantity
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingSide(pendingSide string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingSide = &pendingSide
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) Symbol(symbol string) V3APISpotCreateOrderListOtocoV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) Timestamp(timestamp int64) V3APISpotCreateOrderListOtocoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) WorkingPrice(workingPrice string) V3APISpotCreateOrderListOtocoV3Request {
	r.workingPrice = &workingPrice
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) WorkingQuantity(workingQuantity string) V3APISpotCreateOrderListOtocoV3Request {
	r.workingQuantity = &workingQuantity
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) WorkingSide(workingSide string) V3APISpotCreateOrderListOtocoV3Request {
	r.workingSide = &workingSide
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) WorkingType(workingType string) V3APISpotCreateOrderListOtocoV3Request {
	r.workingType = &workingType
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) ListClientOrderId(listClientOrderId string) V3APISpotCreateOrderListOtocoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) NewOrderRespType(newOrderRespType string) V3APISpotCreateOrderListOtocoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingAboveClientOrderId(pendingAboveClientOrderId string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingAboveClientOrderId = &pendingAboveClientOrderId
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingAboveIcebergQty(pendingAboveIcebergQty string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingAboveIcebergQty = &pendingAboveIcebergQty
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingAbovePrice(pendingAbovePrice string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingAbovePrice = &pendingAbovePrice
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingAboveStopPrice(pendingAboveStopPrice string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingAboveStopPrice = &pendingAboveStopPrice
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingAboveStrategyId(pendingAboveStrategyId int64) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingAboveStrategyId = &pendingAboveStrategyId
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingAboveStrategyType(pendingAboveStrategyType int32) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingAboveStrategyType = &pendingAboveStrategyType
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingAboveTimeInForce(pendingAboveTimeInForce string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingAboveTimeInForce = &pendingAboveTimeInForce
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingAboveTrailingDelta(pendingAboveTrailingDelta string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingAboveTrailingDelta = &pendingAboveTrailingDelta
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingBelowClientOrderId(pendingBelowClientOrderId string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingBelowClientOrderId = &pendingBelowClientOrderId
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingBelowIcebergQty(pendingBelowIcebergQty string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingBelowIcebergQty = &pendingBelowIcebergQty
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingBelowPrice(pendingBelowPrice string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingBelowPrice = &pendingBelowPrice
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingBelowStopPrice(pendingBelowStopPrice string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingBelowStopPrice = &pendingBelowStopPrice
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingBelowStrategyId(pendingBelowStrategyId int64) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingBelowStrategyId = &pendingBelowStrategyId
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingBelowStrategyType(pendingBelowStrategyType int32) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingBelowStrategyType = &pendingBelowStrategyType
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingBelowTimeInForce(pendingBelowTimeInForce string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingBelowTimeInForce = &pendingBelowTimeInForce
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingBelowTrailingDelta(pendingBelowTrailingDelta string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingBelowTrailingDelta = &pendingBelowTrailingDelta
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) PendingBelowType(pendingBelowType string) V3APISpotCreateOrderListOtocoV3Request {
	r.pendingBelowType = &pendingBelowType
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) RecvWindow(recvWindow int64) V3APISpotCreateOrderListOtocoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) V3APISpotCreateOrderListOtocoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) WorkingClientOrderId(workingClientOrderId string) V3APISpotCreateOrderListOtocoV3Request {
	r.workingClientOrderId = &workingClientOrderId
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) WorkingIcebergQty(workingIcebergQty string) V3APISpotCreateOrderListOtocoV3Request {
	r.workingIcebergQty = &workingIcebergQty
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) WorkingStrategyId(workingStrategyId int64) V3APISpotCreateOrderListOtocoV3Request {
	r.workingStrategyId = &workingStrategyId
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) WorkingStrategyType(workingStrategyType int32) V3APISpotCreateOrderListOtocoV3Request {
	r.workingStrategyType = &workingStrategyType
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) WorkingTimeInForce(workingTimeInForce string) V3APISpotCreateOrderListOtocoV3Request {
	r.workingTimeInForce = &workingTimeInForce
	return r
}

func (r V3APISpotCreateOrderListOtocoV3Request) Execute() (*SpotCreateOrderListOtocoV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderListOtocoV3Execute(r)
}

/*
SpotCreateOrderListOtocoV3 New Order list - OTOCO (TRADE)

Place an OTOCO.
- An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
- The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.

The behavior of the working order is the same as the OTO.
- OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.

The rules of the pending above and pending below follow the same rules as the Order list OCO.
- OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotCreateOrderListOtocoV3Request
*/
func (a *V3APIService) SpotCreateOrderListOtocoV3(ctx context.Context) V3APISpotCreateOrderListOtocoV3Request {
	return V3APISpotCreateOrderListOtocoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderListOtocoV3Resp
func (a *V3APIService) SpotCreateOrderListOtocoV3Execute(r V3APISpotCreateOrderListOtocoV3Request) (*SpotCreateOrderListOtocoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderListOtocoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotCreateOrderListOtocoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList/otoco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pendingAboveType == nil {
		return localVarReturnValue, nil, reportError("pendingAboveType is required and must be specified")
	}
	if r.pendingQuantity == nil {
		return localVarReturnValue, nil, reportError("pendingQuantity is required and must be specified")
	}
	if r.pendingSide == nil {
		return localVarReturnValue, nil, reportError("pendingSide is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.workingPrice == nil {
		return localVarReturnValue, nil, reportError("workingPrice is required and must be specified")
	}
	if r.workingQuantity == nil {
		return localVarReturnValue, nil, reportError("workingQuantity is required and must be specified")
	}
	if r.workingSide == nil {
		return localVarReturnValue, nil, reportError("workingSide is required and must be specified")
	}
	if r.workingType == nil {
		return localVarReturnValue, nil, reportError("workingType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.pendingAboveClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveClientOrderId", r.pendingAboveClientOrderId, "", "")
	}
	if r.pendingAboveIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveIcebergQty", r.pendingAboveIcebergQty, "", "")
	}
	if r.pendingAbovePrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAbovePrice", r.pendingAbovePrice, "", "")
	}
	if r.pendingAboveStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStopPrice", r.pendingAboveStopPrice, "", "")
	}
	if r.pendingAboveStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStrategyId", r.pendingAboveStrategyId, "", "")
	}
	if r.pendingAboveStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStrategyType", r.pendingAboveStrategyType, "", "")
	}
	if r.pendingAboveTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveTimeInForce", r.pendingAboveTimeInForce, "", "")
	}
	if r.pendingAboveTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveTrailingDelta", r.pendingAboveTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveType", r.pendingAboveType, "", "")
	if r.pendingBelowClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowClientOrderId", r.pendingBelowClientOrderId, "", "")
	}
	if r.pendingBelowIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowIcebergQty", r.pendingBelowIcebergQty, "", "")
	}
	if r.pendingBelowPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowPrice", r.pendingBelowPrice, "", "")
	}
	if r.pendingBelowStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStopPrice", r.pendingBelowStopPrice, "", "")
	}
	if r.pendingBelowStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStrategyId", r.pendingBelowStrategyId, "", "")
	}
	if r.pendingBelowStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStrategyType", r.pendingBelowStrategyType, "", "")
	}
	if r.pendingBelowTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowTimeInForce", r.pendingBelowTimeInForce, "", "")
	}
	if r.pendingBelowTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowTrailingDelta", r.pendingBelowTrailingDelta, "", "")
	}
	if r.pendingBelowType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowType", r.pendingBelowType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingQuantity", r.pendingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingSide", r.pendingSide, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.workingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingClientOrderId", r.workingClientOrderId, "", "")
	}
	if r.workingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingIcebergQty", r.workingIcebergQty, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingPrice", r.workingPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingQuantity", r.workingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingSide", r.workingSide, "", "")
	if r.workingStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyId", r.workingStrategyId, "", "")
	}
	if r.workingStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyType", r.workingStrategyType, "", "")
	}
	if r.workingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingTimeInForce", r.workingTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotCreateOrderOcoV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	price *string
	quantity *string
	side *string
	stopPrice *string
	symbol *string
	timestamp *int64
	limitClientOrderId *string
	limitIcebergQty *string
	limitStrategyId *int64
	limitStrategyType *int32
	listClientOrderId *string
	newOrderRespType *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopClientOrderId *string
	stopIcebergQty *string
	stopLimitPrice *string
	stopLimitTimeInForce *string
	stopStrategyId *int64
	stopStrategyType *int32
	trailingDelta *int64
}

func (r V3APISpotCreateOrderOcoV3Request) Price(price string) V3APISpotCreateOrderOcoV3Request {
	r.price = &price
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) Quantity(quantity string) V3APISpotCreateOrderOcoV3Request {
	r.quantity = &quantity
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) Side(side string) V3APISpotCreateOrderOcoV3Request {
	r.side = &side
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) StopPrice(stopPrice string) V3APISpotCreateOrderOcoV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) Symbol(symbol string) V3APISpotCreateOrderOcoV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) Timestamp(timestamp int64) V3APISpotCreateOrderOcoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) LimitClientOrderId(limitClientOrderId string) V3APISpotCreateOrderOcoV3Request {
	r.limitClientOrderId = &limitClientOrderId
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) LimitIcebergQty(limitIcebergQty string) V3APISpotCreateOrderOcoV3Request {
	r.limitIcebergQty = &limitIcebergQty
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) LimitStrategyId(limitStrategyId int64) V3APISpotCreateOrderOcoV3Request {
	r.limitStrategyId = &limitStrategyId
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) LimitStrategyType(limitStrategyType int32) V3APISpotCreateOrderOcoV3Request {
	r.limitStrategyType = &limitStrategyType
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) ListClientOrderId(listClientOrderId string) V3APISpotCreateOrderOcoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) NewOrderRespType(newOrderRespType string) V3APISpotCreateOrderOcoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) RecvWindow(recvWindow int64) V3APISpotCreateOrderOcoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) V3APISpotCreateOrderOcoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) StopClientOrderId(stopClientOrderId string) V3APISpotCreateOrderOcoV3Request {
	r.stopClientOrderId = &stopClientOrderId
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) StopIcebergQty(stopIcebergQty string) V3APISpotCreateOrderOcoV3Request {
	r.stopIcebergQty = &stopIcebergQty
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) StopLimitPrice(stopLimitPrice string) V3APISpotCreateOrderOcoV3Request {
	r.stopLimitPrice = &stopLimitPrice
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) StopLimitTimeInForce(stopLimitTimeInForce string) V3APISpotCreateOrderOcoV3Request {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) StopStrategyId(stopStrategyId int64) V3APISpotCreateOrderOcoV3Request {
	r.stopStrategyId = &stopStrategyId
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) StopStrategyType(stopStrategyType int32) V3APISpotCreateOrderOcoV3Request {
	r.stopStrategyType = &stopStrategyType
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) TrailingDelta(trailingDelta int64) V3APISpotCreateOrderOcoV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r V3APISpotCreateOrderOcoV3Request) Execute() (*SpotCreateOrderOcoV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderOcoV3Execute(r)
}

/*
SpotCreateOrderOcoV3 New OCO - Deprecated (TRADE)

Send in a new OCO.
- Price Restrictions:

SELL: Limit Price > Last Price > Stop Price
BUY: Limit Price < Last Price < Stop Price
- Quantity Restrictions:

Both legs must have the same quantity.
ICEBERG quantities however do not have to be the same
- OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotCreateOrderOcoV3Request
*/
func (a *V3APIService) SpotCreateOrderOcoV3(ctx context.Context) V3APISpotCreateOrderOcoV3Request {
	return V3APISpotCreateOrderOcoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderOcoV3Resp
func (a *V3APIService) SpotCreateOrderOcoV3Execute(r V3APISpotCreateOrderOcoV3Request) (*SpotCreateOrderOcoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderOcoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotCreateOrderOcoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.limitClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitClientOrderId", r.limitClientOrderId, "", "")
	}
	if r.limitIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitIcebergQty", r.limitIcebergQty, "", "")
	}
	if r.limitStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitStrategyId", r.limitStrategyId, "", "")
	}
	if r.limitStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitStrategyType", r.limitStrategyType, "", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopClientOrderId", r.stopClientOrderId, "", "")
	}
	if r.stopIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopIcebergQty", r.stopIcebergQty, "", "")
	}
	if r.stopLimitPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitPrice", r.stopLimitPrice, "", "")
	}
	if r.stopLimitTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitTimeInForce", r.stopLimitTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	if r.stopStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopStrategyId", r.stopStrategyId, "", "")
	}
	if r.stopStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopStrategyType", r.stopStrategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotCreateOrderTestV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	computeCommissionRates *bool
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopPrice *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
	trailingDelta *int64
}

func (r V3APISpotCreateOrderTestV3Request) Side(side string) V3APISpotCreateOrderTestV3Request {
	r.side = &side
	return r
}

func (r V3APISpotCreateOrderTestV3Request) Symbol(symbol string) V3APISpotCreateOrderTestV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotCreateOrderTestV3Request) Timestamp(timestamp int64) V3APISpotCreateOrderTestV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotCreateOrderTestV3Request) Type_(type_ string) V3APISpotCreateOrderTestV3Request {
	r.type_ = &type_
	return r
}

func (r V3APISpotCreateOrderTestV3Request) ComputeCommissionRates(computeCommissionRates bool) V3APISpotCreateOrderTestV3Request {
	r.computeCommissionRates = &computeCommissionRates
	return r
}

func (r V3APISpotCreateOrderTestV3Request) IcebergQty(icebergQty string) V3APISpotCreateOrderTestV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r V3APISpotCreateOrderTestV3Request) NewClientOrderId(newClientOrderId string) V3APISpotCreateOrderTestV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r V3APISpotCreateOrderTestV3Request) NewOrderRespType(newOrderRespType string) V3APISpotCreateOrderTestV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V3APISpotCreateOrderTestV3Request) Price(price string) V3APISpotCreateOrderTestV3Request {
	r.price = &price
	return r
}

func (r V3APISpotCreateOrderTestV3Request) Quantity(quantity string) V3APISpotCreateOrderTestV3Request {
	r.quantity = &quantity
	return r
}

func (r V3APISpotCreateOrderTestV3Request) QuoteOrderQty(quoteOrderQty string) V3APISpotCreateOrderTestV3Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r V3APISpotCreateOrderTestV3Request) RecvWindow(recvWindow int64) V3APISpotCreateOrderTestV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotCreateOrderTestV3Request) SelfTradePreventionMode(selfTradePreventionMode string) V3APISpotCreateOrderTestV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V3APISpotCreateOrderTestV3Request) StopPrice(stopPrice string) V3APISpotCreateOrderTestV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r V3APISpotCreateOrderTestV3Request) StrategyId(strategyId int64) V3APISpotCreateOrderTestV3Request {
	r.strategyId = &strategyId
	return r
}

func (r V3APISpotCreateOrderTestV3Request) StrategyType(strategyType int32) V3APISpotCreateOrderTestV3Request {
	r.strategyType = &strategyType
	return r
}

func (r V3APISpotCreateOrderTestV3Request) TimeInForce(timeInForce string) V3APISpotCreateOrderTestV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V3APISpotCreateOrderTestV3Request) TrailingDelta(trailingDelta int64) V3APISpotCreateOrderTestV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r V3APISpotCreateOrderTestV3Request) Execute() (*SpotCreateOrderTestV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderTestV3Execute(r)
}

/*
SpotCreateOrderTestV3 Test new order (TRADE)

Test new order creation and signature/recvWindow long.
Creates and validates a new order but does not send it into the matching engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotCreateOrderTestV3Request
*/
func (a *V3APIService) SpotCreateOrderTestV3(ctx context.Context) V3APISpotCreateOrderTestV3Request {
	return V3APISpotCreateOrderTestV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderTestV3Resp
func (a *V3APIService) SpotCreateOrderTestV3Execute(r V3APISpotCreateOrderTestV3Request) (*SpotCreateOrderTestV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderTestV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotCreateOrderTestV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.computeCommissionRates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "computeCommissionRates", r.computeCommissionRates, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotCreateOrderV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopPrice *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
	trailingDelta *int64
}

func (r V3APISpotCreateOrderV3Request) Side(side string) V3APISpotCreateOrderV3Request {
	r.side = &side
	return r
}

func (r V3APISpotCreateOrderV3Request) Symbol(symbol string) V3APISpotCreateOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotCreateOrderV3Request) Timestamp(timestamp int64) V3APISpotCreateOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotCreateOrderV3Request) Type_(type_ string) V3APISpotCreateOrderV3Request {
	r.type_ = &type_
	return r
}

func (r V3APISpotCreateOrderV3Request) IcebergQty(icebergQty string) V3APISpotCreateOrderV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r V3APISpotCreateOrderV3Request) NewClientOrderId(newClientOrderId string) V3APISpotCreateOrderV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r V3APISpotCreateOrderV3Request) NewOrderRespType(newOrderRespType string) V3APISpotCreateOrderV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V3APISpotCreateOrderV3Request) Price(price string) V3APISpotCreateOrderV3Request {
	r.price = &price
	return r
}

func (r V3APISpotCreateOrderV3Request) Quantity(quantity string) V3APISpotCreateOrderV3Request {
	r.quantity = &quantity
	return r
}

func (r V3APISpotCreateOrderV3Request) QuoteOrderQty(quoteOrderQty string) V3APISpotCreateOrderV3Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r V3APISpotCreateOrderV3Request) RecvWindow(recvWindow int64) V3APISpotCreateOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotCreateOrderV3Request) SelfTradePreventionMode(selfTradePreventionMode string) V3APISpotCreateOrderV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V3APISpotCreateOrderV3Request) StopPrice(stopPrice string) V3APISpotCreateOrderV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r V3APISpotCreateOrderV3Request) StrategyId(strategyId int64) V3APISpotCreateOrderV3Request {
	r.strategyId = &strategyId
	return r
}

func (r V3APISpotCreateOrderV3Request) StrategyType(strategyType int32) V3APISpotCreateOrderV3Request {
	r.strategyType = &strategyType
	return r
}

func (r V3APISpotCreateOrderV3Request) TimeInForce(timeInForce string) V3APISpotCreateOrderV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V3APISpotCreateOrderV3Request) TrailingDelta(trailingDelta int64) V3APISpotCreateOrderV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r V3APISpotCreateOrderV3Request) Execute() (*SpotCreateOrderV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderV3Execute(r)
}

/*
SpotCreateOrderV3 New order (TRADE)

Send in a new order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotCreateOrderV3Request
*/
func (a *V3APIService) SpotCreateOrderV3(ctx context.Context) V3APISpotCreateOrderV3Request {
	return V3APISpotCreateOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderV3Resp
func (a *V3APIService) SpotCreateOrderV3Execute(r V3APISpotCreateOrderV3Request) (*SpotCreateOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotCreateOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotCreateSorOrderTestV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	computeCommissionRates *bool
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	recvWindow *int64
	selfTradePreventionMode *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
}

func (r V3APISpotCreateSorOrderTestV3Request) Quantity(quantity string) V3APISpotCreateSorOrderTestV3Request {
	r.quantity = &quantity
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) Side(side string) V3APISpotCreateSorOrderTestV3Request {
	r.side = &side
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) Symbol(symbol string) V3APISpotCreateSorOrderTestV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) Timestamp(timestamp int64) V3APISpotCreateSorOrderTestV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) Type_(type_ string) V3APISpotCreateSorOrderTestV3Request {
	r.type_ = &type_
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) ComputeCommissionRates(computeCommissionRates bool) V3APISpotCreateSorOrderTestV3Request {
	r.computeCommissionRates = &computeCommissionRates
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) IcebergQty(icebergQty string) V3APISpotCreateSorOrderTestV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) NewClientOrderId(newClientOrderId string) V3APISpotCreateSorOrderTestV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) NewOrderRespType(newOrderRespType string) V3APISpotCreateSorOrderTestV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) Price(price string) V3APISpotCreateSorOrderTestV3Request {
	r.price = &price
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) RecvWindow(recvWindow int64) V3APISpotCreateSorOrderTestV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) SelfTradePreventionMode(selfTradePreventionMode string) V3APISpotCreateSorOrderTestV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) StrategyId(strategyId int64) V3APISpotCreateSorOrderTestV3Request {
	r.strategyId = &strategyId
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) StrategyType(strategyType int32) V3APISpotCreateSorOrderTestV3Request {
	r.strategyType = &strategyType
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) TimeInForce(timeInForce string) V3APISpotCreateSorOrderTestV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V3APISpotCreateSorOrderTestV3Request) Execute() (*SpotCreateSorOrderTestV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateSorOrderTestV3Execute(r)
}

/*
SpotCreateSorOrderTestV3 Test new order using SOR (TRADE)

Test new order creation and signature/recvWindow using smart order routing (SOR).
Creates and validates a new order but does not send it into the matching engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotCreateSorOrderTestV3Request
*/
func (a *V3APIService) SpotCreateSorOrderTestV3(ctx context.Context) V3APISpotCreateSorOrderTestV3Request {
	return V3APISpotCreateSorOrderTestV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateSorOrderTestV3Resp
func (a *V3APIService) SpotCreateSorOrderTestV3Execute(r V3APISpotCreateSorOrderTestV3Request) (*SpotCreateSorOrderTestV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateSorOrderTestV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotCreateSorOrderTestV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sor/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.computeCommissionRates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "computeCommissionRates", r.computeCommissionRates, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotCreateSorOrderV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	recvWindow *int64
	selfTradePreventionMode *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
}

func (r V3APISpotCreateSorOrderV3Request) Quantity(quantity string) V3APISpotCreateSorOrderV3Request {
	r.quantity = &quantity
	return r
}

func (r V3APISpotCreateSorOrderV3Request) Side(side string) V3APISpotCreateSorOrderV3Request {
	r.side = &side
	return r
}

func (r V3APISpotCreateSorOrderV3Request) Symbol(symbol string) V3APISpotCreateSorOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotCreateSorOrderV3Request) Timestamp(timestamp int64) V3APISpotCreateSorOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotCreateSorOrderV3Request) Type_(type_ string) V3APISpotCreateSorOrderV3Request {
	r.type_ = &type_
	return r
}

func (r V3APISpotCreateSorOrderV3Request) IcebergQty(icebergQty string) V3APISpotCreateSorOrderV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r V3APISpotCreateSorOrderV3Request) NewClientOrderId(newClientOrderId string) V3APISpotCreateSorOrderV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r V3APISpotCreateSorOrderV3Request) NewOrderRespType(newOrderRespType string) V3APISpotCreateSorOrderV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r V3APISpotCreateSorOrderV3Request) Price(price string) V3APISpotCreateSorOrderV3Request {
	r.price = &price
	return r
}

func (r V3APISpotCreateSorOrderV3Request) RecvWindow(recvWindow int64) V3APISpotCreateSorOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotCreateSorOrderV3Request) SelfTradePreventionMode(selfTradePreventionMode string) V3APISpotCreateSorOrderV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r V3APISpotCreateSorOrderV3Request) StrategyId(strategyId int64) V3APISpotCreateSorOrderV3Request {
	r.strategyId = &strategyId
	return r
}

func (r V3APISpotCreateSorOrderV3Request) StrategyType(strategyType int32) V3APISpotCreateSorOrderV3Request {
	r.strategyType = &strategyType
	return r
}

func (r V3APISpotCreateSorOrderV3Request) TimeInForce(timeInForce string) V3APISpotCreateSorOrderV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r V3APISpotCreateSorOrderV3Request) Execute() (*SpotCreateSorOrderV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateSorOrderV3Execute(r)
}

/*
SpotCreateSorOrderV3 New order using SOR (TRADE)

Places an order using smart order routing (SOR).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotCreateSorOrderV3Request
*/
func (a *V3APIService) SpotCreateSorOrderV3(ctx context.Context) V3APISpotCreateSorOrderV3Request {
	return V3APISpotCreateSorOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateSorOrderV3Resp
func (a *V3APIService) SpotCreateSorOrderV3Execute(r V3APISpotCreateSorOrderV3Request) (*SpotCreateSorOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateSorOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotCreateSorOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sor/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotCreateUserDataStreamV3Request struct {
	ctx context.Context
	ApiService *V3APIService
}

func (r V3APISpotCreateUserDataStreamV3Request) Execute() (*SpotCreateUserDataStreamV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateUserDataStreamV3Execute(r)
}

/*
SpotCreateUserDataStreamV3 Start user data stream (USER_STREAM)

Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotCreateUserDataStreamV3Request
*/
func (a *V3APIService) SpotCreateUserDataStreamV3(ctx context.Context) V3APISpotCreateUserDataStreamV3Request {
	return V3APISpotCreateUserDataStreamV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateUserDataStreamV3Resp
func (a *V3APIService) SpotCreateUserDataStreamV3Execute(r V3APISpotCreateUserDataStreamV3Request) (*SpotCreateUserDataStreamV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateUserDataStreamV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotCreateUserDataStreamV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/userDataStream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotDeleteOpenOrdersV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r V3APISpotDeleteOpenOrdersV3Request) Symbol(symbol string) V3APISpotDeleteOpenOrdersV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotDeleteOpenOrdersV3Request) Timestamp(timestamp int64) V3APISpotDeleteOpenOrdersV3Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotDeleteOpenOrdersV3Request) RecvWindow(recvWindow int64) V3APISpotDeleteOpenOrdersV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotDeleteOpenOrdersV3Request) Execute() ([][]SpotDeleteOpenOrdersV3RespInner, *http.Response, error) {
	return r.ApiService.SpotDeleteOpenOrdersV3Execute(r)
}

/*
SpotDeleteOpenOrdersV3 Cancel All Open Orders on a Symbol (TRADE)

Cancels all active orders on a symbol.
This includes orders that are part of an order list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotDeleteOpenOrdersV3Request
*/
func (a *V3APIService) SpotDeleteOpenOrdersV3(ctx context.Context) V3APISpotDeleteOpenOrdersV3Request {
	return V3APISpotDeleteOpenOrdersV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]SpotDeleteOpenOrdersV3RespInner
func (a *V3APIService) SpotDeleteOpenOrdersV3Execute(r V3APISpotDeleteOpenOrdersV3Request) ([][]SpotDeleteOpenOrdersV3RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]SpotDeleteOpenOrdersV3RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotDeleteOpenOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotDeleteOrderListV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	timestamp *int64
	orderListId *int64
	listClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

func (r V3APISpotDeleteOrderListV3Request) Symbol(symbol string) V3APISpotDeleteOrderListV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotDeleteOrderListV3Request) Timestamp(timestamp int64) V3APISpotDeleteOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r V3APISpotDeleteOrderListV3Request) OrderListId(orderListId int64) V3APISpotDeleteOrderListV3Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r V3APISpotDeleteOrderListV3Request) ListClientOrderId(listClientOrderId string) V3APISpotDeleteOrderListV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r V3APISpotDeleteOrderListV3Request) NewClientOrderId(newClientOrderId string) V3APISpotDeleteOrderListV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotDeleteOrderListV3Request) RecvWindow(recvWindow int64) V3APISpotDeleteOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotDeleteOrderListV3Request) Execute() (*SpotDeleteOrderListV3Resp, *http.Response, error) {
	return r.ApiService.SpotDeleteOrderListV3Execute(r)
}

/*
SpotDeleteOrderListV3 Cancel Order list (TRADE)

Cancel an entire Order list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotDeleteOrderListV3Request
*/
func (a *V3APIService) SpotDeleteOrderListV3(ctx context.Context) V3APISpotDeleteOrderListV3Request {
	return V3APISpotDeleteOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotDeleteOrderListV3Resp
func (a *V3APIService) SpotDeleteOrderListV3Execute(r V3APISpotDeleteOrderListV3Request) (*SpotDeleteOrderListV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotDeleteOrderListV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotDeleteOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listClientOrderId", r.listClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.listClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotDeleteOrderV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	newClientOrderId *string
	cancelRestrictions *string
	recvWindow *int64
}

func (r V3APISpotDeleteOrderV3Request) Symbol(symbol string) V3APISpotDeleteOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotDeleteOrderV3Request) Timestamp(timestamp int64) V3APISpotDeleteOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotDeleteOrderV3Request) OrderId(orderId int64) V3APISpotDeleteOrderV3Request {
	r.orderId = &orderId
	return r
}

func (r V3APISpotDeleteOrderV3Request) OrigClientOrderId(origClientOrderId string) V3APISpotDeleteOrderV3Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default.
func (r V3APISpotDeleteOrderV3Request) NewClientOrderId(newClientOrderId string) V3APISpotDeleteOrderV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// Supported values: &lt;br/&gt;&#x60;ONLY_NEW&#x60; - Cancel will succeed if the order status is &#x60;NEW&#x60;.&lt;br/&gt; &#x60;ONLY_PARTIALLY_FILLED &#x60; - Cancel will succeed if order status is &#x60;PARTIALLY_FILLED&#x60;.
func (r V3APISpotDeleteOrderV3Request) CancelRestrictions(cancelRestrictions string) V3APISpotDeleteOrderV3Request {
	r.cancelRestrictions = &cancelRestrictions
	return r
}

// The value cannot be greater than &#x60;60000&#x60;.
func (r V3APISpotDeleteOrderV3Request) RecvWindow(recvWindow int64) V3APISpotDeleteOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotDeleteOrderV3Request) Execute() (*SpotDeleteOrderV3Resp, *http.Response, error) {
	return r.ApiService.SpotDeleteOrderV3Execute(r)
}

/*
SpotDeleteOrderV3 Cancel order (TRADE)

Cancel an active order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotDeleteOrderV3Request
*/
func (a *V3APIService) SpotDeleteOrderV3(ctx context.Context) V3APISpotDeleteOrderV3Request {
	return V3APISpotDeleteOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotDeleteOrderV3Resp
func (a *V3APIService) SpotDeleteOrderV3Execute(r V3APISpotDeleteOrderV3Request) (*SpotDeleteOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotDeleteOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotDeleteOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.cancelRestrictions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelRestrictions", r.cancelRestrictions, "form", "")
	} else {
		var defaultValue string = ""
		r.cancelRestrictions = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotDeleteUserDataStreamV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	listenKey *string
}

func (r V3APISpotDeleteUserDataStreamV3Request) ListenKey(listenKey string) V3APISpotDeleteUserDataStreamV3Request {
	r.listenKey = &listenKey
	return r
}

func (r V3APISpotDeleteUserDataStreamV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SpotDeleteUserDataStreamV3Execute(r)
}

/*
SpotDeleteUserDataStreamV3 Close user data stream (USER_STREAM)

Close out a user data stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotDeleteUserDataStreamV3Request
*/
func (a *V3APIService) SpotDeleteUserDataStreamV3(ctx context.Context) V3APISpotDeleteUserDataStreamV3Request {
	return V3APISpotDeleteUserDataStreamV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V3APIService) SpotDeleteUserDataStreamV3Execute(r V3APISpotDeleteUserDataStreamV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotDeleteUserDataStreamV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/userDataStream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listenKey == nil {
		return localVarReturnValue, nil, reportError("listenKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "listenKey", r.listenKey, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetAccountCommissionV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
}

func (r V3APISpotGetAccountCommissionV3Request) Symbol(symbol string) V3APISpotGetAccountCommissionV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotGetAccountCommissionV3Request) Execute() (*SpotGetAccountCommissionV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetAccountCommissionV3Execute(r)
}

/*
SpotGetAccountCommissionV3 Query Commission Rates (USER_DATA)

Get current account commission rates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetAccountCommissionV3Request
*/
func (a *V3APIService) SpotGetAccountCommissionV3(ctx context.Context) V3APISpotGetAccountCommissionV3Request {
	return V3APISpotGetAccountCommissionV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetAccountCommissionV3Resp
func (a *V3APIService) SpotGetAccountCommissionV3Execute(r V3APISpotGetAccountCommissionV3Request) (*SpotGetAccountCommissionV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetAccountCommissionV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetAccountCommissionV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account/commission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetAccountV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	timestamp *int64
	omitZeroBalances *bool
	recvWindow *int64
}

func (r V3APISpotGetAccountV3Request) Timestamp(timestamp int64) V3APISpotGetAccountV3Request {
	r.timestamp = &timestamp
	return r
}

// When set to &#x60;true&#x60;, emits only the non-zero balances of an account. &lt;br/&gt;Default value: &#x60;false&#x60;
func (r V3APISpotGetAccountV3Request) OmitZeroBalances(omitZeroBalances bool) V3APISpotGetAccountV3Request {
	r.omitZeroBalances = &omitZeroBalances
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotGetAccountV3Request) RecvWindow(recvWindow int64) V3APISpotGetAccountV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetAccountV3Request) Execute() (*SpotGetAccountV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetAccountV3Execute(r)
}

/*
SpotGetAccountV3 Account information (USER_DATA)

Get current account information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetAccountV3Request
*/
func (a *V3APIService) SpotGetAccountV3(ctx context.Context) V3APISpotGetAccountV3Request {
	return V3APISpotGetAccountV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetAccountV3Resp
func (a *V3APIService) SpotGetAccountV3Execute(r V3APISpotGetAccountV3Request) (*SpotGetAccountV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetAccountV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetAccountV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.omitZeroBalances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omitZeroBalances", r.omitZeroBalances, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetAggTradesV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
}

func (r V3APISpotGetAggTradesV3Request) Symbol(symbol string) V3APISpotGetAggTradesV3Request {
	r.symbol = &symbol
	return r
}

// ID to get aggregate trades from INCLUSIVE.
func (r V3APISpotGetAggTradesV3Request) FromId(fromId int64) V3APISpotGetAggTradesV3Request {
	r.fromId = &fromId
	return r
}

// Timestamp in ms to get aggregate trades from INCLUSIVE.
func (r V3APISpotGetAggTradesV3Request) StartTime(startTime int64) V3APISpotGetAggTradesV3Request {
	r.startTime = &startTime
	return r
}

// Timestamp in ms to get aggregate trades until INCLUSIVE.
func (r V3APISpotGetAggTradesV3Request) EndTime(endTime int64) V3APISpotGetAggTradesV3Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r V3APISpotGetAggTradesV3Request) Limit(limit int32) V3APISpotGetAggTradesV3Request {
	r.limit = &limit
	return r
}

func (r V3APISpotGetAggTradesV3Request) Execute() ([]SpotGetAggTradesV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetAggTradesV3Execute(r)
}

/*
SpotGetAggTradesV3 Compressed/Aggregate trades list

Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetAggTradesV3Request
*/
func (a *V3APIService) SpotGetAggTradesV3(ctx context.Context) V3APISpotGetAggTradesV3Request {
	return V3APISpotGetAggTradesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetAggTradesV3RespItem
func (a *V3APIService) SpotGetAggTradesV3Execute(r V3APISpotGetAggTradesV3Request) ([]SpotGetAggTradesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetAggTradesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetAggTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/aggTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetAllOrderListV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	timestamp *int64
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V3APISpotGetAllOrderListV3Request) Timestamp(timestamp int64) V3APISpotGetAllOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
func (r V3APISpotGetAllOrderListV3Request) FromId(fromId int64) V3APISpotGetAllOrderListV3Request {
	r.fromId = &fromId
	return r
}

func (r V3APISpotGetAllOrderListV3Request) StartTime(startTime int64) V3APISpotGetAllOrderListV3Request {
	r.startTime = &startTime
	return r
}

func (r V3APISpotGetAllOrderListV3Request) EndTime(endTime int64) V3APISpotGetAllOrderListV3Request {
	r.endTime = &endTime
	return r
}

// Default Value: 500; Max Value: 1000
func (r V3APISpotGetAllOrderListV3Request) Limit(limit int32) V3APISpotGetAllOrderListV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotGetAllOrderListV3Request) RecvWindow(recvWindow int64) V3APISpotGetAllOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetAllOrderListV3Request) Execute() ([]SpotGetAllOrderListV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetAllOrderListV3Execute(r)
}

/*
SpotGetAllOrderListV3 Query all Order lists (USER_DATA)

Retrieves all order lists based on provided optional parameters.
Note that the time between startTime and endTime can't be longer than 24 hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetAllOrderListV3Request
*/
func (a *V3APIService) SpotGetAllOrderListV3(ctx context.Context) V3APISpotGetAllOrderListV3Request {
	return V3APISpotGetAllOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetAllOrderListV3RespItem
func (a *V3APIService) SpotGetAllOrderListV3Execute(r V3APISpotGetAllOrderListV3Request) ([]SpotGetAllOrderListV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetAllOrderListV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetAllOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetAllOrdersV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r V3APISpotGetAllOrdersV3Request) Symbol(symbol string) V3APISpotGetAllOrdersV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotGetAllOrdersV3Request) Timestamp(timestamp int64) V3APISpotGetAllOrdersV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotGetAllOrdersV3Request) OrderId(orderId int64) V3APISpotGetAllOrdersV3Request {
	r.orderId = &orderId
	return r
}

func (r V3APISpotGetAllOrdersV3Request) StartTime(startTime int64) V3APISpotGetAllOrdersV3Request {
	r.startTime = &startTime
	return r
}

func (r V3APISpotGetAllOrdersV3Request) EndTime(endTime int64) V3APISpotGetAllOrdersV3Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r V3APISpotGetAllOrdersV3Request) Limit(limit int32) V3APISpotGetAllOrdersV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotGetAllOrdersV3Request) RecvWindow(recvWindow int64) V3APISpotGetAllOrdersV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetAllOrdersV3Request) Execute() ([]SpotGetAllOrdersV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetAllOrdersV3Execute(r)
}

/*
SpotGetAllOrdersV3 All orders (USER_DATA)

Get all account orders; active, canceled, or filled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetAllOrdersV3Request
*/
func (a *V3APIService) SpotGetAllOrdersV3(ctx context.Context) V3APISpotGetAllOrdersV3Request {
	return V3APISpotGetAllOrdersV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetAllOrdersV3RespItem
func (a *V3APIService) SpotGetAllOrdersV3Execute(r V3APISpotGetAllOrdersV3Request) ([]SpotGetAllOrdersV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetAllOrdersV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetAllOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetAvgPriceV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
}

func (r V3APISpotGetAvgPriceV3Request) Symbol(symbol string) V3APISpotGetAvgPriceV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotGetAvgPriceV3Request) Execute() (*SpotGetAvgPriceV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetAvgPriceV3Execute(r)
}

/*
SpotGetAvgPriceV3 Current average price

Current average price for a symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetAvgPriceV3Request
*/
func (a *V3APIService) SpotGetAvgPriceV3(ctx context.Context) V3APISpotGetAvgPriceV3Request {
	return V3APISpotGetAvgPriceV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetAvgPriceV3Resp
func (a *V3APIService) SpotGetAvgPriceV3Execute(r V3APISpotGetAvgPriceV3Request) (*SpotGetAvgPriceV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetAvgPriceV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetAvgPriceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/avgPrice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetDepthV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	limit *int32
}

func (r V3APISpotGetDepthV3Request) Symbol(symbol string) V3APISpotGetDepthV3Request {
	r.symbol = &symbol
	return r
}

// Default 100; max 5000. &lt;br/&gt; If limit &amp;gt; 5000. then the response will truncate to 5000.
func (r V3APISpotGetDepthV3Request) Limit(limit int32) V3APISpotGetDepthV3Request {
	r.limit = &limit
	return r
}

func (r V3APISpotGetDepthV3Request) Execute() (*SpotGetDepthV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetDepthV3Execute(r)
}

/*
SpotGetDepthV3 Order book

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetDepthV3Request
*/
func (a *V3APIService) SpotGetDepthV3(ctx context.Context) V3APISpotGetDepthV3Request {
	return V3APISpotGetDepthV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetDepthV3Resp
func (a *V3APIService) SpotGetDepthV3Execute(r V3APISpotGetDepthV3Request) (*SpotGetDepthV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetDepthV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetDepthV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetExchangeInfoV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	symbols *[]string
	permissions *string
	showPermissionSets *bool
	symbolStatus *string
}

// Example: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbol&#x3D;BNBBTC\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbol&#x3D;BNBBTC&lt;/a&gt;&amp;#34;
func (r V3APISpotGetExchangeInfoV3Request) Symbol(symbol string) V3APISpotGetExchangeInfoV3Request {
	r.symbol = &symbol
	return r
}

// Examples: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BNBBTC%22,%22BTCUSDT%22%5D\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BNBBTC%22,%22BTCUSDT%22%5D&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -g -X  GET &amp;#39;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;%5B%22BTCUSDT%22,%22BNBBTC\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?symbols&#x3D;[&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBBTC&lt;/a&gt;&amp;#34;]&amp;#39;
func (r V3APISpotGetExchangeInfoV3Request) Symbols(symbols []string) V3APISpotGetExchangeInfoV3Request {
	r.symbols = &symbols
	return r
}

// Examples: curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;SPOT\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;SPOT&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -X GET &amp;#34;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22%2C%22LEVERAGED%22%5D&lt;/a&gt;&amp;#34; &lt;br/&gt; or &lt;br/&gt; curl -g -X GET &amp;#39;&lt;a href&#x3D;\&quot;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;%5B%22MARGIN%22,%22LEVERAGED\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;https://api.binance.com/api/v3/exchangeInfo?permissions&#x3D;[&amp;#34;MARGIN&amp;#34;,&amp;#34;LEVERAGED&lt;/a&gt;&amp;#34;]&amp;#39;
func (r V3APISpotGetExchangeInfoV3Request) Permissions(permissions string) V3APISpotGetExchangeInfoV3Request {
	r.permissions = &permissions
	return r
}

// Controls whether the content of the &#x60;permissionSets&#x60; field is populated or not. Defaults to &#x60;true&#x60;
func (r V3APISpotGetExchangeInfoV3Request) ShowPermissionSets(showPermissionSets bool) V3APISpotGetExchangeInfoV3Request {
	r.showPermissionSets = &showPermissionSets
	return r
}

// Filters symbols that have this &#x60;tradingStatus&#x60;. Valid values: &#x60;TRADING&#x60;, &#x60;HALT&#x60;, &#x60;BREAK&#x60; &lt;br/&gt; Cannot be used in combination with &#x60;symbols&#x60; or &#x60;symbol&#x60;.
func (r V3APISpotGetExchangeInfoV3Request) SymbolStatus(symbolStatus string) V3APISpotGetExchangeInfoV3Request {
	r.symbolStatus = &symbolStatus
	return r
}

func (r V3APISpotGetExchangeInfoV3Request) Execute() (*SpotGetExchangeInfoV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetExchangeInfoV3Execute(r)
}

/*
SpotGetExchangeInfoV3 Exchange information

Current exchange trading rules and symbol information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetExchangeInfoV3Request
*/
func (a *V3APIService) SpotGetExchangeInfoV3(ctx context.Context) V3APISpotGetExchangeInfoV3Request {
	return V3APISpotGetExchangeInfoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetExchangeInfoV3Resp
func (a *V3APIService) SpotGetExchangeInfoV3Execute(r V3APISpotGetExchangeInfoV3Request) (*SpotGetExchangeInfoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetExchangeInfoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetExchangeInfoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/exchangeInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.symbols != nil {
		t := *r.symbols
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", t, "form", "multi")
		}
	}
	if r.permissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "permissions", r.permissions, "form", "")
	} else {
		var defaultValue string = ""
		r.permissions = &defaultValue
	}
	if r.showPermissionSets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showPermissionSets", r.showPermissionSets, "form", "")
	}
	if r.symbolStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbolStatus", r.symbolStatus, "form", "")
	} else {
		var defaultValue string = ""
		r.symbolStatus = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetHistoricalTradesV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	limit *int32
	fromId *int64
}

func (r V3APISpotGetHistoricalTradesV3Request) Symbol(symbol string) V3APISpotGetHistoricalTradesV3Request {
	r.symbol = &symbol
	return r
}

// Default 500; max 1000.
func (r V3APISpotGetHistoricalTradesV3Request) Limit(limit int32) V3APISpotGetHistoricalTradesV3Request {
	r.limit = &limit
	return r
}

// TradeId to fetch from. Default gets most recent trades.
func (r V3APISpotGetHistoricalTradesV3Request) FromId(fromId int64) V3APISpotGetHistoricalTradesV3Request {
	r.fromId = &fromId
	return r
}

func (r V3APISpotGetHistoricalTradesV3Request) Execute() ([]SpotGetHistoricalTradesV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetHistoricalTradesV3Execute(r)
}

/*
SpotGetHistoricalTradesV3 Old trade lookup

Get older trades.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetHistoricalTradesV3Request
*/
func (a *V3APIService) SpotGetHistoricalTradesV3(ctx context.Context) V3APISpotGetHistoricalTradesV3Request {
	return V3APISpotGetHistoricalTradesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetHistoricalTradesV3RespItem
func (a *V3APIService) SpotGetHistoricalTradesV3Execute(r V3APISpotGetHistoricalTradesV3Request) ([]SpotGetHistoricalTradesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetHistoricalTradesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetHistoricalTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/historicalTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetKlinesV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	interval *string
	startTime *int64
	endTime *int64
	timeZone *string
	limit *int32
}

func (r V3APISpotGetKlinesV3Request) Symbol(symbol string) V3APISpotGetKlinesV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotGetKlinesV3Request) Interval(interval string) V3APISpotGetKlinesV3Request {
	r.interval = &interval
	return r
}

func (r V3APISpotGetKlinesV3Request) StartTime(startTime int64) V3APISpotGetKlinesV3Request {
	r.startTime = &startTime
	return r
}

func (r V3APISpotGetKlinesV3Request) EndTime(endTime int64) V3APISpotGetKlinesV3Request {
	r.endTime = &endTime
	return r
}

// Default: 0 (UTC)
func (r V3APISpotGetKlinesV3Request) TimeZone(timeZone string) V3APISpotGetKlinesV3Request {
	r.timeZone = &timeZone
	return r
}

// Default 500; max 1000.
func (r V3APISpotGetKlinesV3Request) Limit(limit int32) V3APISpotGetKlinesV3Request {
	r.limit = &limit
	return r
}

func (r V3APISpotGetKlinesV3Request) Execute() ([][]SpotGetKlinesV3200ResponseInnerInner, *http.Response, error) {
	return r.ApiService.SpotGetKlinesV3Execute(r)
}

/*
SpotGetKlinesV3 Kline/Candlestick data

Kline/candlestick bars for a symbol.
Klines are uniquely identified by their open time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetKlinesV3Request
*/
func (a *V3APIService) SpotGetKlinesV3(ctx context.Context) V3APISpotGetKlinesV3Request {
	return V3APISpotGetKlinesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]SpotGetKlinesV3200ResponseInnerInner
func (a *V3APIService) SpotGetKlinesV3Execute(r V3APISpotGetKlinesV3Request) ([][]SpotGetKlinesV3200ResponseInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]SpotGetKlinesV3200ResponseInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetKlinesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/klines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.timeZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeZone", r.timeZone, "form", "")
	} else {
		var defaultValue string = "0"
		r.timeZone = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetMyAllocationsV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	startTime *int64
	endTime *int64
	fromAllocationId *int32
	limit *int32
	orderId *int64
	recvWindow *int64
	timestamp *int64
}

func (r V3APISpotGetMyAllocationsV3Request) Symbol(symbol string) V3APISpotGetMyAllocationsV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotGetMyAllocationsV3Request) StartTime(startTime int64) V3APISpotGetMyAllocationsV3Request {
	r.startTime = &startTime
	return r
}

func (r V3APISpotGetMyAllocationsV3Request) EndTime(endTime int64) V3APISpotGetMyAllocationsV3Request {
	r.endTime = &endTime
	return r
}

func (r V3APISpotGetMyAllocationsV3Request) FromAllocationId(fromAllocationId int32) V3APISpotGetMyAllocationsV3Request {
	r.fromAllocationId = &fromAllocationId
	return r
}

// Default 500;Max 1000
func (r V3APISpotGetMyAllocationsV3Request) Limit(limit int32) V3APISpotGetMyAllocationsV3Request {
	r.limit = &limit
	return r
}

func (r V3APISpotGetMyAllocationsV3Request) OrderId(orderId int64) V3APISpotGetMyAllocationsV3Request {
	r.orderId = &orderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;.
func (r V3APISpotGetMyAllocationsV3Request) RecvWindow(recvWindow int64) V3APISpotGetMyAllocationsV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetMyAllocationsV3Request) Timestamp(timestamp int64) V3APISpotGetMyAllocationsV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotGetMyAllocationsV3Request) Execute() ([]SpotGetMyAllocationsV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetMyAllocationsV3Execute(r)
}

/*
SpotGetMyAllocationsV3 Query Allocations (USER_DATA)

Retrieves allocations resulting from SOR order placement.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetMyAllocationsV3Request
*/
func (a *V3APIService) SpotGetMyAllocationsV3(ctx context.Context) V3APISpotGetMyAllocationsV3Request {
	return V3APISpotGetMyAllocationsV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetMyAllocationsV3RespItem
func (a *V3APIService) SpotGetMyAllocationsV3Execute(r V3APISpotGetMyAllocationsV3Request) ([]SpotGetMyAllocationsV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetMyAllocationsV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetMyAllocationsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myAllocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromAllocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromAllocationId", r.fromAllocationId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	if r.timestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetMyPreventedMatchesV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	timestamp *int64
	preventedMatchId *int64
	orderId *int64
	fromPreventedMatchId *int64
	limit *int32
	recvWindow *int64
}

func (r V3APISpotGetMyPreventedMatchesV3Request) Symbol(symbol string) V3APISpotGetMyPreventedMatchesV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotGetMyPreventedMatchesV3Request) Timestamp(timestamp int64) V3APISpotGetMyPreventedMatchesV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotGetMyPreventedMatchesV3Request) PreventedMatchId(preventedMatchId int64) V3APISpotGetMyPreventedMatchesV3Request {
	r.preventedMatchId = &preventedMatchId
	return r
}

func (r V3APISpotGetMyPreventedMatchesV3Request) OrderId(orderId int64) V3APISpotGetMyPreventedMatchesV3Request {
	r.orderId = &orderId
	return r
}

func (r V3APISpotGetMyPreventedMatchesV3Request) FromPreventedMatchId(fromPreventedMatchId int64) V3APISpotGetMyPreventedMatchesV3Request {
	r.fromPreventedMatchId = &fromPreventedMatchId
	return r
}

// Default: &#x60;500&#x60;; Max: &#x60;1000&#x60;
func (r V3APISpotGetMyPreventedMatchesV3Request) Limit(limit int32) V3APISpotGetMyPreventedMatchesV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotGetMyPreventedMatchesV3Request) RecvWindow(recvWindow int64) V3APISpotGetMyPreventedMatchesV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetMyPreventedMatchesV3Request) Execute() ([]SpotGetMyPreventedMatchesV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetMyPreventedMatchesV3Execute(r)
}

/*
SpotGetMyPreventedMatchesV3 Query Prevented Matches (USER_DATA)

Displays the list of orders that were expired due to STP.
These are the combinations supported:
- symbol + preventedMatchId
- symbol + orderId
- symbol + orderId + fromPreventedMatchId (limit will default to 500)
- symbol + orderId + fromPreventedMatchId + limit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetMyPreventedMatchesV3Request
*/
func (a *V3APIService) SpotGetMyPreventedMatchesV3(ctx context.Context) V3APISpotGetMyPreventedMatchesV3Request {
	return V3APISpotGetMyPreventedMatchesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetMyPreventedMatchesV3RespItem
func (a *V3APIService) SpotGetMyPreventedMatchesV3Execute(r V3APISpotGetMyPreventedMatchesV3Request) ([]SpotGetMyPreventedMatchesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetMyPreventedMatchesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetMyPreventedMatchesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myPreventedMatches"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.preventedMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preventedMatchId", r.preventedMatchId, "form", "")
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.fromPreventedMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromPreventedMatchId", r.fromPreventedMatchId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetMyTradesV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r V3APISpotGetMyTradesV3Request) Symbol(symbol string) V3APISpotGetMyTradesV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotGetMyTradesV3Request) Timestamp(timestamp int64) V3APISpotGetMyTradesV3Request {
	r.timestamp = &timestamp
	return r
}

// This can only be used in combination with &#x60;symbol&#x60;.
func (r V3APISpotGetMyTradesV3Request) OrderId(orderId int64) V3APISpotGetMyTradesV3Request {
	r.orderId = &orderId
	return r
}

func (r V3APISpotGetMyTradesV3Request) StartTime(startTime int64) V3APISpotGetMyTradesV3Request {
	r.startTime = &startTime
	return r
}

func (r V3APISpotGetMyTradesV3Request) EndTime(endTime int64) V3APISpotGetMyTradesV3Request {
	r.endTime = &endTime
	return r
}

// TradeId to fetch from. Default gets most recent trades.
func (r V3APISpotGetMyTradesV3Request) FromId(fromId int64) V3APISpotGetMyTradesV3Request {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r V3APISpotGetMyTradesV3Request) Limit(limit int32) V3APISpotGetMyTradesV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotGetMyTradesV3Request) RecvWindow(recvWindow int64) V3APISpotGetMyTradesV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetMyTradesV3Request) Execute() ([]SpotGetMyTradesV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetMyTradesV3Execute(r)
}

/*
SpotGetMyTradesV3 Account trade list (USER_DATA)

Get trades for a specific account and symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetMyTradesV3Request
*/
func (a *V3APIService) SpotGetMyTradesV3(ctx context.Context) V3APISpotGetMyTradesV3Request {
	return V3APISpotGetMyTradesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetMyTradesV3RespItem
func (a *V3APIService) SpotGetMyTradesV3Execute(r V3APISpotGetMyTradesV3Request) ([]SpotGetMyTradesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetMyTradesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetMyTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetOpenOrderListV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	timestamp *int64
	recvWindow *int64
}

func (r V3APISpotGetOpenOrderListV3Request) Timestamp(timestamp int64) V3APISpotGetOpenOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotGetOpenOrderListV3Request) RecvWindow(recvWindow int64) V3APISpotGetOpenOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetOpenOrderListV3Request) Execute() ([]SpotGetOpenOrderListV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetOpenOrderListV3Execute(r)
}

/*
SpotGetOpenOrderListV3 Query Open Order lists (USER_DATA)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetOpenOrderListV3Request
*/
func (a *V3APIService) SpotGetOpenOrderListV3(ctx context.Context) V3APISpotGetOpenOrderListV3Request {
	return V3APISpotGetOpenOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetOpenOrderListV3RespItem
func (a *V3APIService) SpotGetOpenOrderListV3Execute(r V3APISpotGetOpenOrderListV3Request) ([]SpotGetOpenOrderListV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetOpenOrderListV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetOpenOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetOpenOrdersV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r V3APISpotGetOpenOrdersV3Request) Timestamp(timestamp int64) V3APISpotGetOpenOrdersV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotGetOpenOrdersV3Request) Symbol(symbol string) V3APISpotGetOpenOrdersV3Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotGetOpenOrdersV3Request) RecvWindow(recvWindow int64) V3APISpotGetOpenOrdersV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetOpenOrdersV3Request) Execute() ([]SpotGetOpenOrdersV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetOpenOrdersV3Execute(r)
}

/*
SpotGetOpenOrdersV3 Current open orders (USER_DATA)

Get all open orders on a symbol. Careful when accessing this with no symbol.
Weight:
6 for a single symbol; 80 when the symbol parameter is omitted

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetOpenOrdersV3Request
*/
func (a *V3APIService) SpotGetOpenOrdersV3(ctx context.Context) V3APISpotGetOpenOrdersV3Request {
	return V3APISpotGetOpenOrdersV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetOpenOrdersV3RespItem
func (a *V3APIService) SpotGetOpenOrdersV3Execute(r V3APISpotGetOpenOrdersV3Request) ([]SpotGetOpenOrdersV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetOpenOrdersV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetOpenOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetOrderListV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	timestamp *int64
	orderListId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V3APISpotGetOrderListV3Request) Timestamp(timestamp int64) V3APISpotGetOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r V3APISpotGetOrderListV3Request) OrderListId(orderListId int64) V3APISpotGetOrderListV3Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r V3APISpotGetOrderListV3Request) OrigClientOrderId(origClientOrderId string) V3APISpotGetOrderListV3Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotGetOrderListV3Request) RecvWindow(recvWindow int64) V3APISpotGetOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetOrderListV3Request) Execute() (*SpotGetOrderListV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetOrderListV3Execute(r)
}

/*
SpotGetOrderListV3 Query Order list (USER_DATA)

Retrieves a specific order list based on provided optional parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetOrderListV3Request
*/
func (a *V3APIService) SpotGetOrderListV3(ctx context.Context) V3APISpotGetOrderListV3Request {
	return V3APISpotGetOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetOrderListV3Resp
func (a *V3APIService) SpotGetOrderListV3Execute(r V3APISpotGetOrderListV3Request) (*SpotGetOrderListV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetOrderListV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetOrderV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r V3APISpotGetOrderV3Request) Symbol(symbol string) V3APISpotGetOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r V3APISpotGetOrderV3Request) Timestamp(timestamp int64) V3APISpotGetOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r V3APISpotGetOrderV3Request) OrderId(orderId int64) V3APISpotGetOrderV3Request {
	r.orderId = &orderId
	return r
}

func (r V3APISpotGetOrderV3Request) OrigClientOrderId(origClientOrderId string) V3APISpotGetOrderV3Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotGetOrderV3Request) RecvWindow(recvWindow int64) V3APISpotGetOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetOrderV3Request) Execute() (*SpotGetOrderV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetOrderV3Execute(r)
}

/*
SpotGetOrderV3 Query order (USER_DATA)

Check an order's status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetOrderV3Request
*/
func (a *V3APIService) SpotGetOrderV3(ctx context.Context) V3APISpotGetOrderV3Request {
	return V3APISpotGetOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetOrderV3Resp
func (a *V3APIService) SpotGetOrderV3Execute(r V3APISpotGetOrderV3Request) (*SpotGetOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetPingV3Request struct {
	ctx context.Context
	ApiService *V3APIService
}

func (r V3APISpotGetPingV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SpotGetPingV3Execute(r)
}

/*
SpotGetPingV3 Test connectivity

Test connectivity to the Rest API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetPingV3Request
*/
func (a *V3APIService) SpotGetPingV3(ctx context.Context) V3APISpotGetPingV3Request {
	return V3APISpotGetPingV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V3APIService) SpotGetPingV3Execute(r V3APISpotGetPingV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetPingV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetRateLimitOrderV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	timestamp *int64
	recvWindow *int64
}

func (r V3APISpotGetRateLimitOrderV3Request) Timestamp(timestamp int64) V3APISpotGetRateLimitOrderV3Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r V3APISpotGetRateLimitOrderV3Request) RecvWindow(recvWindow int64) V3APISpotGetRateLimitOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r V3APISpotGetRateLimitOrderV3Request) Execute() ([]SpotGetRateLimitOrderV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetRateLimitOrderV3Execute(r)
}

/*
SpotGetRateLimitOrderV3 Query Unfilled Order Count (USER_DATA)

Displays the user's unfilled order count for all intervals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetRateLimitOrderV3Request
*/
func (a *V3APIService) SpotGetRateLimitOrderV3(ctx context.Context) V3APISpotGetRateLimitOrderV3Request {
	return V3APISpotGetRateLimitOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetRateLimitOrderV3RespItem
func (a *V3APIService) SpotGetRateLimitOrderV3Execute(r V3APISpotGetRateLimitOrderV3Request) ([]SpotGetRateLimitOrderV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetRateLimitOrderV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetRateLimitOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/rateLimit/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetTicker24hrV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	symbols *string
	type_ *string
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, tickers for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;          Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r V3APISpotGetTicker24hrV3Request) Symbol(symbol string) V3APISpotGetTicker24hrV3Request {
	r.symbol = &symbol
	return r
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, tickers for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;          Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r V3APISpotGetTicker24hrV3Request) Symbols(symbols string) V3APISpotGetTicker24hrV3Request {
	r.symbols = &symbols
	return r
}

// Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
func (r V3APISpotGetTicker24hrV3Request) Type_(type_ string) V3APISpotGetTicker24hrV3Request {
	r.type_ = &type_
	return r
}

func (r V3APISpotGetTicker24hrV3Request) Execute() (*SpotGetTicker24hrV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetTicker24hrV3Execute(r)
}

/*
SpotGetTicker24hrV3 24hr ticker price change statistics

24 hour rolling window price change statistics. Careful when accessing this with no symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetTicker24hrV3Request
*/
func (a *V3APIService) SpotGetTicker24hrV3(ctx context.Context) V3APISpotGetTicker24hrV3Request {
	return V3APISpotGetTicker24hrV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTicker24hrV3Resp
func (a *V3APIService) SpotGetTicker24hrV3Execute(r V3APISpotGetTicker24hrV3Request) (*SpotGetTicker24hrV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTicker24hrV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetTicker24hrV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker/24hr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.symbols != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "form", "")
	} else {
		var defaultValue string = ""
		r.symbols = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetTickerBookTickerV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	symbols *string
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, bookTickers for all symbols will be returned in an array.          &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r V3APISpotGetTickerBookTickerV3Request) Symbol(symbol string) V3APISpotGetTickerBookTickerV3Request {
	r.symbol = &symbol
	return r
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, bookTickers for all symbols will be returned in an array.          &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r V3APISpotGetTickerBookTickerV3Request) Symbols(symbols string) V3APISpotGetTickerBookTickerV3Request {
	r.symbols = &symbols
	return r
}

func (r V3APISpotGetTickerBookTickerV3Request) Execute() (*SpotGetTickerBookTickerV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetTickerBookTickerV3Execute(r)
}

/*
SpotGetTickerBookTickerV3 Symbol order book ticker

Best price/qty on the order book for a symbol or symbols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetTickerBookTickerV3Request
*/
func (a *V3APIService) SpotGetTickerBookTickerV3(ctx context.Context) V3APISpotGetTickerBookTickerV3Request {
	return V3APISpotGetTickerBookTickerV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTickerBookTickerV3Resp
func (a *V3APIService) SpotGetTickerBookTickerV3Execute(r V3APISpotGetTickerBookTickerV3Request) (*SpotGetTickerBookTickerV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTickerBookTickerV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetTickerBookTickerV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker/bookTicker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.symbols != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "form", "")
	} else {
		var defaultValue string = ""
		r.symbols = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetTickerPriceV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	symbols *string
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, prices for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r V3APISpotGetTickerPriceV3Request) Symbol(symbol string) V3APISpotGetTickerPriceV3Request {
	r.symbol = &symbol
	return r
}

// Parameter symbol and symbols cannot be used in combination. &lt;br/&gt; If neither parameter is sent, prices for all symbols will be returned in an array. &lt;br/&gt;&lt;br/&gt;         Examples of accepted format for the symbols parameter:          [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;          or &lt;br/&gt;          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
func (r V3APISpotGetTickerPriceV3Request) Symbols(symbols string) V3APISpotGetTickerPriceV3Request {
	r.symbols = &symbols
	return r
}

func (r V3APISpotGetTickerPriceV3Request) Execute() (*SpotGetTickerPriceV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetTickerPriceV3Execute(r)
}

/*
SpotGetTickerPriceV3 Symbol price ticker

Latest price for a symbol or symbols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetTickerPriceV3Request
*/
func (a *V3APIService) SpotGetTickerPriceV3(ctx context.Context) V3APISpotGetTickerPriceV3Request {
	return V3APISpotGetTickerPriceV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTickerPriceV3Resp
func (a *V3APIService) SpotGetTickerPriceV3Execute(r V3APISpotGetTickerPriceV3Request) (*SpotGetTickerPriceV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTickerPriceV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetTickerPriceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker/price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.symbols != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "form", "")
	} else {
		var defaultValue string = ""
		r.symbols = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetTickerTradingDayV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	symbols *string
	timeZone *string
	type_ *string
}

// Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
func (r V3APISpotGetTickerTradingDayV3Request) Symbol(symbol string) V3APISpotGetTickerTradingDayV3Request {
	r.symbol = &symbol
	return r
}

// Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
func (r V3APISpotGetTickerTradingDayV3Request) Symbols(symbols string) V3APISpotGetTickerTradingDayV3Request {
	r.symbols = &symbols
	return r
}

// Default: 0 (UTC)
func (r V3APISpotGetTickerTradingDayV3Request) TimeZone(timeZone string) V3APISpotGetTickerTradingDayV3Request {
	r.timeZone = &timeZone
	return r
}

// Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
func (r V3APISpotGetTickerTradingDayV3Request) Type_(type_ string) V3APISpotGetTickerTradingDayV3Request {
	r.type_ = &type_
	return r
}

func (r V3APISpotGetTickerTradingDayV3Request) Execute() (*SpotGetTickerTradingDayV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetTickerTradingDayV3Execute(r)
}

/*
SpotGetTickerTradingDayV3 Trading Day Ticker

Price change statistics for a trading day.
4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetTickerTradingDayV3Request
*/
func (a *V3APIService) SpotGetTickerTradingDayV3(ctx context.Context) V3APISpotGetTickerTradingDayV3Request {
	return V3APISpotGetTickerTradingDayV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTickerTradingDayV3Resp
func (a *V3APIService) SpotGetTickerTradingDayV3Execute(r V3APISpotGetTickerTradingDayV3Request) (*SpotGetTickerTradingDayV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTickerTradingDayV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetTickerTradingDayV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker/tradingDay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.symbols == nil {
		return localVarReturnValue, nil, reportError("symbols is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "form", "")
	if r.timeZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeZone", r.timeZone, "form", "")
	} else {
		var defaultValue string = "0"
		r.timeZone = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetTickerV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	symbols *string
	windowSize *string
	type_ *string
}

// Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
func (r V3APISpotGetTickerV3Request) Symbol(symbol string) V3APISpotGetTickerV3Request {
	r.symbol = &symbol
	return r
}

// Either &#x60;symbol&#x60; or &#x60;symbols&#x60; must be provided &lt;br/&gt;&lt;br/&gt; Examples of accepted format for the &#x60;symbols&#x60; parameter: &lt;br/&gt; [&amp;#34;BTCUSDT&amp;#34;,&amp;#34;BNBUSDT&amp;#34;] &lt;br/&gt;or &lt;br/&gt;%5B%22BTCUSDT%22,%22BNBUSDT%22%5D &lt;br/&gt;&lt;br/&gt; The maximum number of &#x60;symbols&#x60; allowed in a request is 100.
func (r V3APISpotGetTickerV3Request) Symbols(symbols string) V3APISpotGetTickerV3Request {
	r.symbols = &symbols
	return r
}

// Defaults to &#x60;1d&#x60; if no parameter provided &lt;br/&gt; Supported &#x60;windowSize&#x60; values: &lt;br/&gt; &#x60;1m&#x60;,&#x60;2m&#x60;....&#x60;59m&#x60; for minutes &lt;br/&gt; &#x60;1h&#x60;, &#x60;2h&#x60;....&#x60;23h&#x60; - for hours &lt;br/&gt; &#x60;1d&#x60;...&#x60;7d&#x60; - for days &lt;br/&gt;&lt;br/&gt; Units cannot be combined (e.g. &#x60;1d2h&#x60; is not allowed)
func (r V3APISpotGetTickerV3Request) WindowSize(windowSize string) V3APISpotGetTickerV3Request {
	r.windowSize = &windowSize
	return r
}

// Supported values: &#x60;FULL&#x60; or &#x60;MINI&#x60;. &lt;br/&gt;If none provided, the default is &#x60;FULL&#x60;
func (r V3APISpotGetTickerV3Request) Type_(type_ string) V3APISpotGetTickerV3Request {
	r.type_ = &type_
	return r
}

func (r V3APISpotGetTickerV3Request) Execute() (*SpotGetTickerV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetTickerV3Execute(r)
}

/*
SpotGetTickerV3 Rolling window price change statistics

Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint.
The window used to compute statistics will be no more than 59999ms from the requested windowSize.
openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request.
As such, the effective window will be up to 59999ms wider than windowSize.
E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00)
4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetTickerV3Request
*/
func (a *V3APIService) SpotGetTickerV3(ctx context.Context) V3APISpotGetTickerV3Request {
	return V3APISpotGetTickerV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTickerV3Resp
func (a *V3APIService) SpotGetTickerV3Execute(r V3APISpotGetTickerV3Request) (*SpotGetTickerV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTickerV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetTickerV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/ticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.symbols == nil {
		return localVarReturnValue, nil, reportError("symbols is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "symbols", r.symbols, "form", "")
	if r.windowSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "windowSize", r.windowSize, "form", "")
	} else {
		var defaultValue string = ""
		r.windowSize = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetTimeV3Request struct {
	ctx context.Context
	ApiService *V3APIService
}

func (r V3APISpotGetTimeV3Request) Execute() (*SpotGetTimeV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetTimeV3Execute(r)
}

/*
SpotGetTimeV3 Check server time

Test connectivity to the Rest API and get the current server time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetTimeV3Request
*/
func (a *V3APIService) SpotGetTimeV3(ctx context.Context) V3APISpotGetTimeV3Request {
	return V3APISpotGetTimeV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetTimeV3Resp
func (a *V3APIService) SpotGetTimeV3Execute(r V3APISpotGetTimeV3Request) (*SpotGetTimeV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetTimeV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetTimeV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetTradesV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	limit *int32
}

func (r V3APISpotGetTradesV3Request) Symbol(symbol string) V3APISpotGetTradesV3Request {
	r.symbol = &symbol
	return r
}

// Default 500; max 1000.
func (r V3APISpotGetTradesV3Request) Limit(limit int32) V3APISpotGetTradesV3Request {
	r.limit = &limit
	return r
}

func (r V3APISpotGetTradesV3Request) Execute() ([]SpotGetTradesV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetTradesV3Execute(r)
}

/*
SpotGetTradesV3 Recent trades list

Get recent trades.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetTradesV3Request
*/
func (a *V3APIService) SpotGetTradesV3(ctx context.Context) V3APISpotGetTradesV3Request {
	return V3APISpotGetTradesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetTradesV3RespItem
func (a *V3APIService) SpotGetTradesV3Execute(r V3APISpotGetTradesV3Request) ([]SpotGetTradesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetTradesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotGetUiKlinesV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	symbol *string
	interval *string
	startTime *int64
	endTime *int64
	timeZone *string
	limit *int32
}

func (r V3APISpotGetUiKlinesV3Request) Symbol(symbol string) V3APISpotGetUiKlinesV3Request {
	r.symbol = &symbol
	return r
}

// See &lt;a href&#x3D;\&quot;/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\&quot;&gt;&#x60;klines&#x60;&lt;/a&gt;
func (r V3APISpotGetUiKlinesV3Request) Interval(interval string) V3APISpotGetUiKlinesV3Request {
	r.interval = &interval
	return r
}

func (r V3APISpotGetUiKlinesV3Request) StartTime(startTime int64) V3APISpotGetUiKlinesV3Request {
	r.startTime = &startTime
	return r
}

func (r V3APISpotGetUiKlinesV3Request) EndTime(endTime int64) V3APISpotGetUiKlinesV3Request {
	r.endTime = &endTime
	return r
}

// Default: 0 (UTC)
func (r V3APISpotGetUiKlinesV3Request) TimeZone(timeZone string) V3APISpotGetUiKlinesV3Request {
	r.timeZone = &timeZone
	return r
}

// Default 500; max 1000.
func (r V3APISpotGetUiKlinesV3Request) Limit(limit int32) V3APISpotGetUiKlinesV3Request {
	r.limit = &limit
	return r
}

func (r V3APISpotGetUiKlinesV3Request) Execute() ([][]SpotGetKlinesV3200ResponseInnerInner, *http.Response, error) {
	return r.ApiService.SpotGetUiKlinesV3Execute(r)
}

/*
SpotGetUiKlinesV3 UIKlines

The request is similar to klines having the same parameters and response.
uiKlines return modified kline data, optimized for presentation of candlestick charts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotGetUiKlinesV3Request
*/
func (a *V3APIService) SpotGetUiKlinesV3(ctx context.Context) V3APISpotGetUiKlinesV3Request {
	return V3APISpotGetUiKlinesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]SpotGetKlinesV3200ResponseInnerInner
func (a *V3APIService) SpotGetUiKlinesV3Execute(r V3APISpotGetUiKlinesV3Request) ([][]SpotGetKlinesV3200ResponseInnerInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]SpotGetKlinesV3200ResponseInnerInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotGetUiKlinesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/uiKlines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.timeZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeZone", r.timeZone, "form", "")
	} else {
		var defaultValue string = "0"
		r.timeZone = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type V3APISpotUpdateUserDataStreamV3Request struct {
	ctx context.Context
	ApiService *V3APIService
	listenKey *string
}

func (r V3APISpotUpdateUserDataStreamV3Request) ListenKey(listenKey string) V3APISpotUpdateUserDataStreamV3Request {
	r.listenKey = &listenKey
	return r
}

func (r V3APISpotUpdateUserDataStreamV3Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SpotUpdateUserDataStreamV3Execute(r)
}

/*
SpotUpdateUserDataStreamV3 Keepalive user data stream (USER_STREAM)

Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return V3APISpotUpdateUserDataStreamV3Request
*/
func (a *V3APIService) SpotUpdateUserDataStreamV3(ctx context.Context) V3APISpotUpdateUserDataStreamV3Request {
	return V3APISpotUpdateUserDataStreamV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *V3APIService) SpotUpdateUserDataStreamV3Execute(r V3APISpotUpdateUserDataStreamV3Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V3APIService.SpotUpdateUserDataStreamV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/userDataStream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listenKey == nil {
		return localVarReturnValue, nil, reportError("listenKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "listenKey", r.listenKey, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

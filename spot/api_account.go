/*
Binance Spot API

OpenAPI specification for Binance cryptocurrency exchange - Spot API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AccountAPIService AccountAPI service
type AccountAPIService service

type AccountAPISpotGetAccountCommissionV3Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	symbol *string
}

func (r AccountAPISpotGetAccountCommissionV3Request) Symbol(symbol string) AccountAPISpotGetAccountCommissionV3Request {
	r.symbol = &symbol
	return r
}

func (r AccountAPISpotGetAccountCommissionV3Request) Execute() (*SpotGetAccountCommissionV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetAccountCommissionV3Execute(r)
}

/*
SpotGetAccountCommissionV3 Query Commission Rates (USER_DATA)

Get current account commission rates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountAPISpotGetAccountCommissionV3Request
*/
func (a *AccountAPIService) SpotGetAccountCommissionV3(ctx context.Context) AccountAPISpotGetAccountCommissionV3Request {
	return AccountAPISpotGetAccountCommissionV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetAccountCommissionV3Resp
func (a *AccountAPIService) SpotGetAccountCommissionV3Execute(r AccountAPISpotGetAccountCommissionV3Request) (*SpotGetAccountCommissionV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetAccountCommissionV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.SpotGetAccountCommissionV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account/commission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountAPISpotGetAccountV3Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	omitZeroBalances *bool
	recvWindow *int64
}

func (r AccountAPISpotGetAccountV3Request) Timestamp(timestamp int64) AccountAPISpotGetAccountV3Request {
	r.timestamp = &timestamp
	return r
}

// When set to &#x60;true&#x60;, emits only the non-zero balances of an account. &lt;br/&gt;Default value: &#x60;false&#x60;
func (r AccountAPISpotGetAccountV3Request) OmitZeroBalances(omitZeroBalances bool) AccountAPISpotGetAccountV3Request {
	r.omitZeroBalances = &omitZeroBalances
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r AccountAPISpotGetAccountV3Request) RecvWindow(recvWindow int64) AccountAPISpotGetAccountV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AccountAPISpotGetAccountV3Request) Execute() (*SpotGetAccountV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetAccountV3Execute(r)
}

/*
SpotGetAccountV3 Account information (USER_DATA)

Get current account information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountAPISpotGetAccountV3Request
*/
func (a *AccountAPIService) SpotGetAccountV3(ctx context.Context) AccountAPISpotGetAccountV3Request {
	return AccountAPISpotGetAccountV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetAccountV3Resp
func (a *AccountAPIService) SpotGetAccountV3Execute(r AccountAPISpotGetAccountV3Request) (*SpotGetAccountV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetAccountV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.SpotGetAccountV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.omitZeroBalances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "omitZeroBalances", r.omitZeroBalances, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountAPISpotGetMyAllocationsV3Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	symbol *string
	startTime *int64
	endTime *int64
	fromAllocationId *int32
	limit *int32
	orderId *int64
	recvWindow *int64
	timestamp *int64
}

func (r AccountAPISpotGetMyAllocationsV3Request) Symbol(symbol string) AccountAPISpotGetMyAllocationsV3Request {
	r.symbol = &symbol
	return r
}

func (r AccountAPISpotGetMyAllocationsV3Request) StartTime(startTime int64) AccountAPISpotGetMyAllocationsV3Request {
	r.startTime = &startTime
	return r
}

func (r AccountAPISpotGetMyAllocationsV3Request) EndTime(endTime int64) AccountAPISpotGetMyAllocationsV3Request {
	r.endTime = &endTime
	return r
}

func (r AccountAPISpotGetMyAllocationsV3Request) FromAllocationId(fromAllocationId int32) AccountAPISpotGetMyAllocationsV3Request {
	r.fromAllocationId = &fromAllocationId
	return r
}

// Default 500;Max 1000
func (r AccountAPISpotGetMyAllocationsV3Request) Limit(limit int32) AccountAPISpotGetMyAllocationsV3Request {
	r.limit = &limit
	return r
}

func (r AccountAPISpotGetMyAllocationsV3Request) OrderId(orderId int64) AccountAPISpotGetMyAllocationsV3Request {
	r.orderId = &orderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;.
func (r AccountAPISpotGetMyAllocationsV3Request) RecvWindow(recvWindow int64) AccountAPISpotGetMyAllocationsV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AccountAPISpotGetMyAllocationsV3Request) Timestamp(timestamp int64) AccountAPISpotGetMyAllocationsV3Request {
	r.timestamp = &timestamp
	return r
}

func (r AccountAPISpotGetMyAllocationsV3Request) Execute() ([]SpotGetMyAllocationsV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetMyAllocationsV3Execute(r)
}

/*
SpotGetMyAllocationsV3 Query Allocations (USER_DATA)

Retrieves allocations resulting from SOR order placement.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountAPISpotGetMyAllocationsV3Request
*/
func (a *AccountAPIService) SpotGetMyAllocationsV3(ctx context.Context) AccountAPISpotGetMyAllocationsV3Request {
	return AccountAPISpotGetMyAllocationsV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetMyAllocationsV3RespItem
func (a *AccountAPIService) SpotGetMyAllocationsV3Execute(r AccountAPISpotGetMyAllocationsV3Request) ([]SpotGetMyAllocationsV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetMyAllocationsV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.SpotGetMyAllocationsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myAllocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromAllocationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromAllocationId", r.fromAllocationId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	if r.timestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountAPISpotGetMyPreventedMatchesV3Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	symbol *string
	timestamp *int64
	preventedMatchId *int64
	orderId *int64
	fromPreventedMatchId *int64
	limit *int32
	recvWindow *int64
}

func (r AccountAPISpotGetMyPreventedMatchesV3Request) Symbol(symbol string) AccountAPISpotGetMyPreventedMatchesV3Request {
	r.symbol = &symbol
	return r
}

func (r AccountAPISpotGetMyPreventedMatchesV3Request) Timestamp(timestamp int64) AccountAPISpotGetMyPreventedMatchesV3Request {
	r.timestamp = &timestamp
	return r
}

func (r AccountAPISpotGetMyPreventedMatchesV3Request) PreventedMatchId(preventedMatchId int64) AccountAPISpotGetMyPreventedMatchesV3Request {
	r.preventedMatchId = &preventedMatchId
	return r
}

func (r AccountAPISpotGetMyPreventedMatchesV3Request) OrderId(orderId int64) AccountAPISpotGetMyPreventedMatchesV3Request {
	r.orderId = &orderId
	return r
}

func (r AccountAPISpotGetMyPreventedMatchesV3Request) FromPreventedMatchId(fromPreventedMatchId int64) AccountAPISpotGetMyPreventedMatchesV3Request {
	r.fromPreventedMatchId = &fromPreventedMatchId
	return r
}

// Default: &#x60;500&#x60;; Max: &#x60;1000&#x60;
func (r AccountAPISpotGetMyPreventedMatchesV3Request) Limit(limit int32) AccountAPISpotGetMyPreventedMatchesV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r AccountAPISpotGetMyPreventedMatchesV3Request) RecvWindow(recvWindow int64) AccountAPISpotGetMyPreventedMatchesV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AccountAPISpotGetMyPreventedMatchesV3Request) Execute() ([]SpotGetMyPreventedMatchesV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetMyPreventedMatchesV3Execute(r)
}

/*
SpotGetMyPreventedMatchesV3 Query Prevented Matches (USER_DATA)

Displays the list of orders that were expired due to STP.
These are the combinations supported:
- symbol + preventedMatchId
- symbol + orderId
- symbol + orderId + fromPreventedMatchId (limit will default to 500)
- symbol + orderId + fromPreventedMatchId + limit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountAPISpotGetMyPreventedMatchesV3Request
*/
func (a *AccountAPIService) SpotGetMyPreventedMatchesV3(ctx context.Context) AccountAPISpotGetMyPreventedMatchesV3Request {
	return AccountAPISpotGetMyPreventedMatchesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetMyPreventedMatchesV3RespItem
func (a *AccountAPIService) SpotGetMyPreventedMatchesV3Execute(r AccountAPISpotGetMyPreventedMatchesV3Request) ([]SpotGetMyPreventedMatchesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetMyPreventedMatchesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.SpotGetMyPreventedMatchesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myPreventedMatches"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.preventedMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preventedMatchId", r.preventedMatchId, "form", "")
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.fromPreventedMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromPreventedMatchId", r.fromPreventedMatchId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountAPISpotGetMyTradesV3Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

func (r AccountAPISpotGetMyTradesV3Request) Symbol(symbol string) AccountAPISpotGetMyTradesV3Request {
	r.symbol = &symbol
	return r
}

func (r AccountAPISpotGetMyTradesV3Request) Timestamp(timestamp int64) AccountAPISpotGetMyTradesV3Request {
	r.timestamp = &timestamp
	return r
}

// This can only be used in combination with &#x60;symbol&#x60;.
func (r AccountAPISpotGetMyTradesV3Request) OrderId(orderId int64) AccountAPISpotGetMyTradesV3Request {
	r.orderId = &orderId
	return r
}

func (r AccountAPISpotGetMyTradesV3Request) StartTime(startTime int64) AccountAPISpotGetMyTradesV3Request {
	r.startTime = &startTime
	return r
}

func (r AccountAPISpotGetMyTradesV3Request) EndTime(endTime int64) AccountAPISpotGetMyTradesV3Request {
	r.endTime = &endTime
	return r
}

// TradeId to fetch from. Default gets most recent trades.
func (r AccountAPISpotGetMyTradesV3Request) FromId(fromId int64) AccountAPISpotGetMyTradesV3Request {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r AccountAPISpotGetMyTradesV3Request) Limit(limit int32) AccountAPISpotGetMyTradesV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r AccountAPISpotGetMyTradesV3Request) RecvWindow(recvWindow int64) AccountAPISpotGetMyTradesV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AccountAPISpotGetMyTradesV3Request) Execute() ([]SpotGetMyTradesV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetMyTradesV3Execute(r)
}

/*
SpotGetMyTradesV3 Account trade list (USER_DATA)

Get trades for a specific account and symbol.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountAPISpotGetMyTradesV3Request
*/
func (a *AccountAPIService) SpotGetMyTradesV3(ctx context.Context) AccountAPISpotGetMyTradesV3Request {
	return AccountAPISpotGetMyTradesV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetMyTradesV3RespItem
func (a *AccountAPIService) SpotGetMyTradesV3Execute(r AccountAPISpotGetMyTradesV3Request) ([]SpotGetMyTradesV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetMyTradesV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.SpotGetMyTradesV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccountAPISpotGetRateLimitOrderV3Request struct {
	ctx context.Context
	ApiService *AccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r AccountAPISpotGetRateLimitOrderV3Request) Timestamp(timestamp int64) AccountAPISpotGetRateLimitOrderV3Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r AccountAPISpotGetRateLimitOrderV3Request) RecvWindow(recvWindow int64) AccountAPISpotGetRateLimitOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AccountAPISpotGetRateLimitOrderV3Request) Execute() ([]SpotGetRateLimitOrderV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetRateLimitOrderV3Execute(r)
}

/*
SpotGetRateLimitOrderV3 Query Unfilled Order Count (USER_DATA)

Displays the user's unfilled order count for all intervals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AccountAPISpotGetRateLimitOrderV3Request
*/
func (a *AccountAPIService) SpotGetRateLimitOrderV3(ctx context.Context) AccountAPISpotGetRateLimitOrderV3Request {
	return AccountAPISpotGetRateLimitOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetRateLimitOrderV3RespItem
func (a *AccountAPIService) SpotGetRateLimitOrderV3Execute(r AccountAPISpotGetRateLimitOrderV3Request) ([]SpotGetRateLimitOrderV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetRateLimitOrderV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.SpotGetRateLimitOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/rateLimit/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

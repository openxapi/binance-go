/*
Binance Spot API

OpenAPI specification for Binance exchange - Spot API

API version: 0.2.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SubAccountAPIService SubAccountAPI service
type SubAccountAPIService service

type ApiCreateManagedSubaccountDepositV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	amount *string
	asset *string
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r ApiCreateManagedSubaccountDepositV1Request) Amount(amount string) ApiCreateManagedSubaccountDepositV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateManagedSubaccountDepositV1Request) Asset(asset string) ApiCreateManagedSubaccountDepositV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateManagedSubaccountDepositV1Request) Timestamp(timestamp int64) ApiCreateManagedSubaccountDepositV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateManagedSubaccountDepositV1Request) ToEmail(toEmail string) ApiCreateManagedSubaccountDepositV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiCreateManagedSubaccountDepositV1Request) RecvWindow(recvWindow int64) ApiCreateManagedSubaccountDepositV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateManagedSubaccountDepositV1Request) Execute() (*CreateManagedSubaccountDepositV1Resp, *http.Response, error) {
	return r.ApiService.CreateManagedSubaccountDepositV1Execute(r)
}

/*
CreateManagedSubaccountDepositV1 Deposit Assets Into The Managed Sub-account(For Investor Master Account)

Deposit Assets Into The Managed Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateManagedSubaccountDepositV1Request
*/
func (a *SubAccountAPIService) CreateManagedSubaccountDepositV1(ctx context.Context) ApiCreateManagedSubaccountDepositV1Request {
	return ApiCreateManagedSubaccountDepositV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateManagedSubaccountDepositV1Resp
func (a *SubAccountAPIService) CreateManagedSubaccountDepositV1Execute(r ApiCreateManagedSubaccountDepositV1Request) (*CreateManagedSubaccountDepositV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateManagedSubaccountDepositV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateManagedSubaccountDepositV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/deposit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateManagedSubaccountWithdrawV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	amount *string
	asset *string
	fromEmail *string
	timestamp *int64
	recvWindow *int64
	transferDate *int64
}

func (r ApiCreateManagedSubaccountWithdrawV1Request) Amount(amount string) ApiCreateManagedSubaccountWithdrawV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateManagedSubaccountWithdrawV1Request) Asset(asset string) ApiCreateManagedSubaccountWithdrawV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateManagedSubaccountWithdrawV1Request) FromEmail(fromEmail string) ApiCreateManagedSubaccountWithdrawV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r ApiCreateManagedSubaccountWithdrawV1Request) Timestamp(timestamp int64) ApiCreateManagedSubaccountWithdrawV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateManagedSubaccountWithdrawV1Request) RecvWindow(recvWindow int64) ApiCreateManagedSubaccountWithdrawV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateManagedSubaccountWithdrawV1Request) TransferDate(transferDate int64) ApiCreateManagedSubaccountWithdrawV1Request {
	r.transferDate = &transferDate
	return r
}

func (r ApiCreateManagedSubaccountWithdrawV1Request) Execute() (*CreateManagedSubaccountWithdrawV1Resp, *http.Response, error) {
	return r.ApiService.CreateManagedSubaccountWithdrawV1Execute(r)
}

/*
CreateManagedSubaccountWithdrawV1 Withdrawl Assets From The Managed Sub-account(For Investor Master Account)

Withdrawl Assets From The Managed Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateManagedSubaccountWithdrawV1Request
*/
func (a *SubAccountAPIService) CreateManagedSubaccountWithdrawV1(ctx context.Context) ApiCreateManagedSubaccountWithdrawV1Request {
	return ApiCreateManagedSubaccountWithdrawV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateManagedSubaccountWithdrawV1Resp
func (a *SubAccountAPIService) CreateManagedSubaccountWithdrawV1Execute(r ApiCreateManagedSubaccountWithdrawV1Request) (*CreateManagedSubaccountWithdrawV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateManagedSubaccountWithdrawV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateManagedSubaccountWithdrawV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/withdraw"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.transferDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transferDate", r.transferDate, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountBlvtEnableV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	enableBlvt *bool
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSubAccountBlvtEnableV1Request) Email(email string) ApiCreateSubAccountBlvtEnableV1Request {
	r.email = &email
	return r
}

func (r ApiCreateSubAccountBlvtEnableV1Request) EnableBlvt(enableBlvt bool) ApiCreateSubAccountBlvtEnableV1Request {
	r.enableBlvt = &enableBlvt
	return r
}

func (r ApiCreateSubAccountBlvtEnableV1Request) Timestamp(timestamp int64) ApiCreateSubAccountBlvtEnableV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountBlvtEnableV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountBlvtEnableV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountBlvtEnableV1Request) Execute() (*CreateSubAccountBlvtEnableV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountBlvtEnableV1Execute(r)
}

/*
CreateSubAccountBlvtEnableV1 Enable Leverage Token for Sub-account(For Master Account)

Enable Leverage Token for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountBlvtEnableV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountBlvtEnableV1(ctx context.Context) ApiCreateSubAccountBlvtEnableV1Request {
	return ApiCreateSubAccountBlvtEnableV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountBlvtEnableV1Resp
func (a *SubAccountAPIService) CreateSubAccountBlvtEnableV1Execute(r ApiCreateSubAccountBlvtEnableV1Request) (*CreateSubAccountBlvtEnableV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountBlvtEnableV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountBlvtEnableV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/blvt/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.enableBlvt == nil {
		return localVarReturnValue, nil, reportError("enableBlvt is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "enableBlvt", r.enableBlvt, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountEoptionsEnableV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSubAccountEoptionsEnableV1Request) Email(email string) ApiCreateSubAccountEoptionsEnableV1Request {
	r.email = &email
	return r
}

func (r ApiCreateSubAccountEoptionsEnableV1Request) Timestamp(timestamp int64) ApiCreateSubAccountEoptionsEnableV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountEoptionsEnableV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountEoptionsEnableV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountEoptionsEnableV1Request) Execute() (*CreateSubAccountEoptionsEnableV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountEoptionsEnableV1Execute(r)
}

/*
CreateSubAccountEoptionsEnableV1 Enable Options for Sub-account(For Master Account)(USER_DATA)

Enable Options for Sub-account (For Master Account).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountEoptionsEnableV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountEoptionsEnableV1(ctx context.Context) ApiCreateSubAccountEoptionsEnableV1Request {
	return ApiCreateSubAccountEoptionsEnableV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountEoptionsEnableV1Resp
func (a *SubAccountAPIService) CreateSubAccountEoptionsEnableV1Execute(r ApiCreateSubAccountEoptionsEnableV1Request) (*CreateSubAccountEoptionsEnableV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountEoptionsEnableV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountEoptionsEnableV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/eoptions/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountFuturesEnableV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSubAccountFuturesEnableV1Request) Email(email string) ApiCreateSubAccountFuturesEnableV1Request {
	r.email = &email
	return r
}

func (r ApiCreateSubAccountFuturesEnableV1Request) Timestamp(timestamp int64) ApiCreateSubAccountFuturesEnableV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountFuturesEnableV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountFuturesEnableV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountFuturesEnableV1Request) Execute() (*CreateSubAccountFuturesEnableV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountFuturesEnableV1Execute(r)
}

/*
CreateSubAccountFuturesEnableV1 Enable Futures for Sub-account(For Master Account)

Enable Futures for Sub-account for Master Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountFuturesEnableV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountFuturesEnableV1(ctx context.Context) ApiCreateSubAccountFuturesEnableV1Request {
	return ApiCreateSubAccountFuturesEnableV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountFuturesEnableV1Resp
func (a *SubAccountAPIService) CreateSubAccountFuturesEnableV1Execute(r ApiCreateSubAccountFuturesEnableV1Request) (*CreateSubAccountFuturesEnableV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountFuturesEnableV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountFuturesEnableV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountFuturesInternalTransferV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	amount *string
	asset *string
	fromEmail *string
	futuresType *int64
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r ApiCreateSubAccountFuturesInternalTransferV1Request) Amount(amount string) ApiCreateSubAccountFuturesInternalTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSubAccountFuturesInternalTransferV1Request) Asset(asset string) ApiCreateSubAccountFuturesInternalTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateSubAccountFuturesInternalTransferV1Request) FromEmail(fromEmail string) ApiCreateSubAccountFuturesInternalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r ApiCreateSubAccountFuturesInternalTransferV1Request) FuturesType(futuresType int64) ApiCreateSubAccountFuturesInternalTransferV1Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiCreateSubAccountFuturesInternalTransferV1Request) Timestamp(timestamp int64) ApiCreateSubAccountFuturesInternalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountFuturesInternalTransferV1Request) ToEmail(toEmail string) ApiCreateSubAccountFuturesInternalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiCreateSubAccountFuturesInternalTransferV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountFuturesInternalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountFuturesInternalTransferV1Request) Execute() (*CreateSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountFuturesInternalTransferV1Execute(r)
}

/*
CreateSubAccountFuturesInternalTransferV1 Sub-account Futures Asset Transfer(For Master Account)

Sub-account Futures Asset Transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountFuturesInternalTransferV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountFuturesInternalTransferV1(ctx context.Context) ApiCreateSubAccountFuturesInternalTransferV1Request {
	return ApiCreateSubAccountFuturesInternalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountFuturesInternalTransferV1Resp
func (a *SubAccountAPIService) CreateSubAccountFuturesInternalTransferV1Execute(r ApiCreateSubAccountFuturesInternalTransferV1Request) (*CreateSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountFuturesInternalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountFuturesInternalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "futuresType", r.futuresType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountFuturesMovePositionV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	fromUserEmail *string
	orderArgs *[]map[string]interface{}
	productType *string
	timestamp *int64
	toUserEmail *string
	recvWindow *int64
}

func (r ApiCreateSubAccountFuturesMovePositionV1Request) FromUserEmail(fromUserEmail string) ApiCreateSubAccountFuturesMovePositionV1Request {
	r.fromUserEmail = &fromUserEmail
	return r
}

func (r ApiCreateSubAccountFuturesMovePositionV1Request) OrderArgs(orderArgs []map[string]interface{}) ApiCreateSubAccountFuturesMovePositionV1Request {
	r.orderArgs = &orderArgs
	return r
}

func (r ApiCreateSubAccountFuturesMovePositionV1Request) ProductType(productType string) ApiCreateSubAccountFuturesMovePositionV1Request {
	r.productType = &productType
	return r
}

func (r ApiCreateSubAccountFuturesMovePositionV1Request) Timestamp(timestamp int64) ApiCreateSubAccountFuturesMovePositionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountFuturesMovePositionV1Request) ToUserEmail(toUserEmail string) ApiCreateSubAccountFuturesMovePositionV1Request {
	r.toUserEmail = &toUserEmail
	return r
}

func (r ApiCreateSubAccountFuturesMovePositionV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountFuturesMovePositionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountFuturesMovePositionV1Request) Execute() (*CreateSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountFuturesMovePositionV1Execute(r)
}

/*
CreateSubAccountFuturesMovePositionV1 Move Position for Sub-account (For Master Account)

Move position between sub-master, master-sub, or sub-sub accounts when necessary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountFuturesMovePositionV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountFuturesMovePositionV1(ctx context.Context) ApiCreateSubAccountFuturesMovePositionV1Request {
	return ApiCreateSubAccountFuturesMovePositionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountFuturesMovePositionV1Resp
func (a *SubAccountAPIService) CreateSubAccountFuturesMovePositionV1Execute(r ApiCreateSubAccountFuturesMovePositionV1Request) (*CreateSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountFuturesMovePositionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountFuturesMovePositionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/move-position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromUserEmail == nil {
		return localVarReturnValue, nil, reportError("fromUserEmail is required and must be specified")
	}
	if r.orderArgs == nil {
		return localVarReturnValue, nil, reportError("orderArgs is required and must be specified")
	}
	if r.productType == nil {
		return localVarReturnValue, nil, reportError("productType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toUserEmail == nil {
		return localVarReturnValue, nil, reportError("toUserEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "fromUserEmail", r.fromUserEmail, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "orderArgs", r.orderArgs, "", "csv")
	parameterAddToHeaderOrQuery(localVarFormParams, "productType", r.productType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toUserEmail", r.toUserEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountFuturesTransferV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	amount *string
	asset *string
	email *string
	timestamp *int64
	type_ *int32
	recvWindow *int64
}

func (r ApiCreateSubAccountFuturesTransferV1Request) Amount(amount string) ApiCreateSubAccountFuturesTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSubAccountFuturesTransferV1Request) Asset(asset string) ApiCreateSubAccountFuturesTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateSubAccountFuturesTransferV1Request) Email(email string) ApiCreateSubAccountFuturesTransferV1Request {
	r.email = &email
	return r
}

func (r ApiCreateSubAccountFuturesTransferV1Request) Timestamp(timestamp int64) ApiCreateSubAccountFuturesTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountFuturesTransferV1Request) Type_(type_ int32) ApiCreateSubAccountFuturesTransferV1Request {
	r.type_ = &type_
	return r
}

func (r ApiCreateSubAccountFuturesTransferV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountFuturesTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountFuturesTransferV1Request) Execute() (*CreateSubAccountFuturesTransferV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountFuturesTransferV1Execute(r)
}

/*
CreateSubAccountFuturesTransferV1 Futures Transfer for Sub-account(For Master Account)

Futures Transfer for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountFuturesTransferV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountFuturesTransferV1(ctx context.Context) ApiCreateSubAccountFuturesTransferV1Request {
	return ApiCreateSubAccountFuturesTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountFuturesTransferV1Resp
func (a *SubAccountAPIService) CreateSubAccountFuturesTransferV1Execute(r ApiCreateSubAccountFuturesTransferV1Request) (*CreateSubAccountFuturesTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountFuturesTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountFuturesTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountMarginEnableV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSubAccountMarginEnableV1Request) Email(email string) ApiCreateSubAccountMarginEnableV1Request {
	r.email = &email
	return r
}

func (r ApiCreateSubAccountMarginEnableV1Request) Timestamp(timestamp int64) ApiCreateSubAccountMarginEnableV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountMarginEnableV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountMarginEnableV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountMarginEnableV1Request) Execute() (*CreateSubAccountMarginEnableV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountMarginEnableV1Execute(r)
}

/*
CreateSubAccountMarginEnableV1 Enable Margin for Sub-account(For Master Account)

Enable Margin for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountMarginEnableV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountMarginEnableV1(ctx context.Context) ApiCreateSubAccountMarginEnableV1Request {
	return ApiCreateSubAccountMarginEnableV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountMarginEnableV1Resp
func (a *SubAccountAPIService) CreateSubAccountMarginEnableV1Execute(r ApiCreateSubAccountMarginEnableV1Request) (*CreateSubAccountMarginEnableV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountMarginEnableV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountMarginEnableV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountMarginTransferV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	amount *string
	asset *string
	email *string
	timestamp *int64
	type_ *int32
	recvWindow *int64
}

func (r ApiCreateSubAccountMarginTransferV1Request) Amount(amount string) ApiCreateSubAccountMarginTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSubAccountMarginTransferV1Request) Asset(asset string) ApiCreateSubAccountMarginTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateSubAccountMarginTransferV1Request) Email(email string) ApiCreateSubAccountMarginTransferV1Request {
	r.email = &email
	return r
}

func (r ApiCreateSubAccountMarginTransferV1Request) Timestamp(timestamp int64) ApiCreateSubAccountMarginTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountMarginTransferV1Request) Type_(type_ int32) ApiCreateSubAccountMarginTransferV1Request {
	r.type_ = &type_
	return r
}

func (r ApiCreateSubAccountMarginTransferV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountMarginTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountMarginTransferV1Request) Execute() (*CreateSubAccountMarginTransferV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountMarginTransferV1Execute(r)
}

/*
CreateSubAccountMarginTransferV1 Margin Transfer for Sub-account(For Master Account)

Margin Transfer for Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountMarginTransferV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountMarginTransferV1(ctx context.Context) ApiCreateSubAccountMarginTransferV1Request {
	return ApiCreateSubAccountMarginTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountMarginTransferV1Resp
func (a *SubAccountAPIService) CreateSubAccountMarginTransferV1Execute(r ApiCreateSubAccountMarginTransferV1Request) (*CreateSubAccountMarginTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountMarginTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountMarginTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountSubAccountApiIpRestrictionV2Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	status *string
	subAccountApiKey *string
	timestamp *int64
	ipAddress *string
	recvWindow *int64
}

func (r ApiCreateSubAccountSubAccountApiIpRestrictionV2Request) Email(email string) ApiCreateSubAccountSubAccountApiIpRestrictionV2Request {
	r.email = &email
	return r
}

func (r ApiCreateSubAccountSubAccountApiIpRestrictionV2Request) Status(status string) ApiCreateSubAccountSubAccountApiIpRestrictionV2Request {
	r.status = &status
	return r
}

func (r ApiCreateSubAccountSubAccountApiIpRestrictionV2Request) SubAccountApiKey(subAccountApiKey string) ApiCreateSubAccountSubAccountApiIpRestrictionV2Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r ApiCreateSubAccountSubAccountApiIpRestrictionV2Request) Timestamp(timestamp int64) ApiCreateSubAccountSubAccountApiIpRestrictionV2Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountSubAccountApiIpRestrictionV2Request) IpAddress(ipAddress string) ApiCreateSubAccountSubAccountApiIpRestrictionV2Request {
	r.ipAddress = &ipAddress
	return r
}

func (r ApiCreateSubAccountSubAccountApiIpRestrictionV2Request) RecvWindow(recvWindow int64) ApiCreateSubAccountSubAccountApiIpRestrictionV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountSubAccountApiIpRestrictionV2Request) Execute() (*CreateSubAccountSubAccountApiIpRestrictionV2Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountSubAccountApiIpRestrictionV2Execute(r)
}

/*
CreateSubAccountSubAccountApiIpRestrictionV2 Add IP Restriction for Sub-Account API key(For Master Account)

Add IP Restriction for Sub-Account API key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountSubAccountApiIpRestrictionV2Request
*/
func (a *SubAccountAPIService) CreateSubAccountSubAccountApiIpRestrictionV2(ctx context.Context) ApiCreateSubAccountSubAccountApiIpRestrictionV2Request {
	return ApiCreateSubAccountSubAccountApiIpRestrictionV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountSubAccountApiIpRestrictionV2Resp
func (a *SubAccountAPIService) CreateSubAccountSubAccountApiIpRestrictionV2Execute(r ApiCreateSubAccountSubAccountApiIpRestrictionV2Request) (*CreateSubAccountSubAccountApiIpRestrictionV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountSubAccountApiIpRestrictionV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountSubAccountApiIpRestrictionV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/subAccountApi/ipRestriction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ipAddress", r.ipAddress, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "status", r.status, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountApiKey", r.subAccountApiKey, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountTransferSubToMasterV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	amount *string
	asset *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSubAccountTransferSubToMasterV1Request) Amount(amount string) ApiCreateSubAccountTransferSubToMasterV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSubAccountTransferSubToMasterV1Request) Asset(asset string) ApiCreateSubAccountTransferSubToMasterV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateSubAccountTransferSubToMasterV1Request) Timestamp(timestamp int64) ApiCreateSubAccountTransferSubToMasterV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountTransferSubToMasterV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountTransferSubToMasterV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountTransferSubToMasterV1Request) Execute() (*CreateSubAccountTransferSubToMasterV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountTransferSubToMasterV1Execute(r)
}

/*
CreateSubAccountTransferSubToMasterV1 Transfer to Master(For Sub-account)

Transfer to Master

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountTransferSubToMasterV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountTransferSubToMasterV1(ctx context.Context) ApiCreateSubAccountTransferSubToMasterV1Request {
	return ApiCreateSubAccountTransferSubToMasterV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountTransferSubToMasterV1Resp
func (a *SubAccountAPIService) CreateSubAccountTransferSubToMasterV1Execute(r ApiCreateSubAccountTransferSubToMasterV1Request) (*CreateSubAccountTransferSubToMasterV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountTransferSubToMasterV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountTransferSubToMasterV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToMaster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountTransferSubToSubV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	amount *string
	asset *string
	timestamp *int64
	toEmail *string
	recvWindow *int64
}

func (r ApiCreateSubAccountTransferSubToSubV1Request) Amount(amount string) ApiCreateSubAccountTransferSubToSubV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSubAccountTransferSubToSubV1Request) Asset(asset string) ApiCreateSubAccountTransferSubToSubV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateSubAccountTransferSubToSubV1Request) Timestamp(timestamp int64) ApiCreateSubAccountTransferSubToSubV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountTransferSubToSubV1Request) ToEmail(toEmail string) ApiCreateSubAccountTransferSubToSubV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiCreateSubAccountTransferSubToSubV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountTransferSubToSubV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountTransferSubToSubV1Request) Execute() (*CreateSubAccountTransferSubToSubV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountTransferSubToSubV1Execute(r)
}

/*
CreateSubAccountTransferSubToSubV1 Transfer to Sub-account of Same Master(For Sub-account)

Transfer to Sub-account of Same Master

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountTransferSubToSubV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountTransferSubToSubV1(ctx context.Context) ApiCreateSubAccountTransferSubToSubV1Request {
	return ApiCreateSubAccountTransferSubToSubV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountTransferSubToSubV1Resp
func (a *SubAccountAPIService) CreateSubAccountTransferSubToSubV1Execute(r ApiCreateSubAccountTransferSubToSubV1Request) (*CreateSubAccountTransferSubToSubV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountTransferSubToSubV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountTransferSubToSubV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToSub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	amount *string
	asset *string
	fromAccountType *string
	timestamp *int64
	toAccountType *string
	clientTranId *string
	fromEmail *string
	recvWindow *int64
	symbol *string
	toEmail *string
}

func (r ApiCreateSubAccountUniversalTransferV1Request) Amount(amount string) ApiCreateSubAccountUniversalTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateSubAccountUniversalTransferV1Request) Asset(asset string) ApiCreateSubAccountUniversalTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateSubAccountUniversalTransferV1Request) FromAccountType(fromAccountType string) ApiCreateSubAccountUniversalTransferV1Request {
	r.fromAccountType = &fromAccountType
	return r
}

func (r ApiCreateSubAccountUniversalTransferV1Request) Timestamp(timestamp int64) ApiCreateSubAccountUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountUniversalTransferV1Request) ToAccountType(toAccountType string) ApiCreateSubAccountUniversalTransferV1Request {
	r.toAccountType = &toAccountType
	return r
}

func (r ApiCreateSubAccountUniversalTransferV1Request) ClientTranId(clientTranId string) ApiCreateSubAccountUniversalTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r ApiCreateSubAccountUniversalTransferV1Request) FromEmail(fromEmail string) ApiCreateSubAccountUniversalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r ApiCreateSubAccountUniversalTransferV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountUniversalTransferV1Request) Symbol(symbol string) ApiCreateSubAccountUniversalTransferV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateSubAccountUniversalTransferV1Request) ToEmail(toEmail string) ApiCreateSubAccountUniversalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiCreateSubAccountUniversalTransferV1Request) Execute() (*CreateSubAccountUniversalTransferV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountUniversalTransferV1Execute(r)
}

/*
CreateSubAccountUniversalTransferV1 Universal Transfer(For Master Account)

Universal Transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountUniversalTransferV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountUniversalTransferV1(ctx context.Context) ApiCreateSubAccountUniversalTransferV1Request {
	return ApiCreateSubAccountUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountUniversalTransferV1Resp
func (a *SubAccountAPIService) CreateSubAccountUniversalTransferV1Execute(r ApiCreateSubAccountUniversalTransferV1Request) (*CreateSubAccountUniversalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountUniversalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromAccountType == nil {
		return localVarReturnValue, nil, reportError("fromAccountType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toAccountType == nil {
		return localVarReturnValue, nil, reportError("toAccountType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "clientTranId", r.clientTranId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "fromAccountType", r.fromAccountType, "", "")
	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromEmail", r.fromEmail, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toAccountType", r.toAccountType, "", "")
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toEmail", r.toEmail, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubAccountVirtualSubAccountV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	subAccountString *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateSubAccountVirtualSubAccountV1Request) SubAccountString(subAccountString string) ApiCreateSubAccountVirtualSubAccountV1Request {
	r.subAccountString = &subAccountString
	return r
}

func (r ApiCreateSubAccountVirtualSubAccountV1Request) Timestamp(timestamp int64) ApiCreateSubAccountVirtualSubAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateSubAccountVirtualSubAccountV1Request) RecvWindow(recvWindow int64) ApiCreateSubAccountVirtualSubAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateSubAccountVirtualSubAccountV1Request) Execute() (*CreateSubAccountVirtualSubAccountV1Resp, *http.Response, error) {
	return r.ApiService.CreateSubAccountVirtualSubAccountV1Execute(r)
}

/*
CreateSubAccountVirtualSubAccountV1 Create a Virtual Sub-account(For Master Account)

Create a Virtual Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubAccountVirtualSubAccountV1Request
*/
func (a *SubAccountAPIService) CreateSubAccountVirtualSubAccountV1(ctx context.Context) ApiCreateSubAccountVirtualSubAccountV1Request {
	return ApiCreateSubAccountVirtualSubAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateSubAccountVirtualSubAccountV1Resp
func (a *SubAccountAPIService) CreateSubAccountVirtualSubAccountV1Execute(r ApiCreateSubAccountVirtualSubAccountV1Request) (*CreateSubAccountVirtualSubAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSubAccountVirtualSubAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.CreateSubAccountVirtualSubAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/virtualSubAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountString == nil {
		return localVarReturnValue, nil, reportError("subAccountString is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountString", r.subAccountString, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	subAccountApiKey *string
	timestamp *int64
	ipAddress *string
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/api-management/Delete-IP-List-For-a-Sub-account-API-Key#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) Email(email string) ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	r.email = &email
	return r
}

func (r ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) SubAccountApiKey(subAccountApiKey string) ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) Timestamp(timestamp int64) ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	r.timestamp = &timestamp
	return r
}

// Can be added in batches, separated by commas
func (r ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) IpAddress(ipAddress string) ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	r.ipAddress = &ipAddress
	return r
}

func (r ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) RecvWindow(recvWindow int64) ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) Execute() (*DeleteSubAccountSubAccountApiIpRestrictionIpListV1Resp, *http.Response, error) {
	return r.ApiService.DeleteSubAccountSubAccountApiIpRestrictionIpListV1Execute(r)
}

/*
DeleteSubAccountSubAccountApiIpRestrictionIpListV1 Delete IP List For a Sub-account API Key(For Master Account)

Delete IP List For a Sub-account API Key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request
*/
func (a *SubAccountAPIService) DeleteSubAccountSubAccountApiIpRestrictionIpListV1(ctx context.Context) ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request {
	return ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteSubAccountSubAccountApiIpRestrictionIpListV1Resp
func (a *SubAccountAPIService) DeleteSubAccountSubAccountApiIpRestrictionIpListV1Execute(r ApiDeleteSubAccountSubAccountApiIpRestrictionIpListV1Request) (*DeleteSubAccountSubAccountApiIpRestrictionIpListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteSubAccountSubAccountApiIpRestrictionIpListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.DeleteSubAccountSubAccountApiIpRestrictionIpListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/subAccountApi/ipRestriction/ipList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountApiKey", r.subAccountApiKey, "form", "")
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipAddress", r.ipAddress, "form", "")
	} else {
		var defaultValue string = ""
		r.ipAddress = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCapitalDepositSubAddressV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	coin *string
	timestamp *int64
	network *string
	amount *string
	recvWindow *int64
}

// Sub account email
func (r ApiGetCapitalDepositSubAddressV1Request) Email(email string) ApiGetCapitalDepositSubAddressV1Request {
	r.email = &email
	return r
}

func (r ApiGetCapitalDepositSubAddressV1Request) Coin(coin string) ApiGetCapitalDepositSubAddressV1Request {
	r.coin = &coin
	return r
}

func (r ApiGetCapitalDepositSubAddressV1Request) Timestamp(timestamp int64) ApiGetCapitalDepositSubAddressV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetCapitalDepositSubAddressV1Request) Network(network string) ApiGetCapitalDepositSubAddressV1Request {
	r.network = &network
	return r
}

func (r ApiGetCapitalDepositSubAddressV1Request) Amount(amount string) ApiGetCapitalDepositSubAddressV1Request {
	r.amount = &amount
	return r
}

func (r ApiGetCapitalDepositSubAddressV1Request) RecvWindow(recvWindow int64) ApiGetCapitalDepositSubAddressV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetCapitalDepositSubAddressV1Request) Execute() (*GetCapitalDepositSubAddressV1Resp, *http.Response, error) {
	return r.ApiService.GetCapitalDepositSubAddressV1Execute(r)
}

/*
GetCapitalDepositSubAddressV1 Get Sub-account Deposit Address(For Master Account)

Fetch sub-account deposit address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCapitalDepositSubAddressV1Request
*/
func (a *SubAccountAPIService) GetCapitalDepositSubAddressV1(ctx context.Context) ApiGetCapitalDepositSubAddressV1Request {
	return ApiGetCapitalDepositSubAddressV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCapitalDepositSubAddressV1Resp
func (a *SubAccountAPIService) GetCapitalDepositSubAddressV1Execute(r ApiGetCapitalDepositSubAddressV1Request) (*GetCapitalDepositSubAddressV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCapitalDepositSubAddressV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetCapitalDepositSubAddressV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	} else {
		var defaultValue string = ""
		r.amount = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCapitalDepositSubHisrecV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	coin *string
	status *int32
	startTime *int64
	endTime *int64
	limit *int32
	offset *int32
	recvWindow *int64
	txId *string
}

// Sub account email
func (r ApiGetCapitalDepositSubHisrecV1Request) Email(email string) ApiGetCapitalDepositSubHisrecV1Request {
	r.email = &email
	return r
}

func (r ApiGetCapitalDepositSubHisrecV1Request) Timestamp(timestamp int64) ApiGetCapitalDepositSubHisrecV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetCapitalDepositSubHisrecV1Request) Coin(coin string) ApiGetCapitalDepositSubHisrecV1Request {
	r.coin = &coin
	return r
}

// 0(0:pending,6: credited but cannot withdraw,7:Wrong Deposit,8:Waiting User confirm,1:success)
func (r ApiGetCapitalDepositSubHisrecV1Request) Status(status int32) ApiGetCapitalDepositSubHisrecV1Request {
	r.status = &status
	return r
}

func (r ApiGetCapitalDepositSubHisrecV1Request) StartTime(startTime int64) ApiGetCapitalDepositSubHisrecV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetCapitalDepositSubHisrecV1Request) EndTime(endTime int64) ApiGetCapitalDepositSubHisrecV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetCapitalDepositSubHisrecV1Request) Limit(limit int32) ApiGetCapitalDepositSubHisrecV1Request {
	r.limit = &limit
	return r
}

// default:0
func (r ApiGetCapitalDepositSubHisrecV1Request) Offset(offset int32) ApiGetCapitalDepositSubHisrecV1Request {
	r.offset = &offset
	return r
}

func (r ApiGetCapitalDepositSubHisrecV1Request) RecvWindow(recvWindow int64) ApiGetCapitalDepositSubHisrecV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetCapitalDepositSubHisrecV1Request) TxId(txId string) ApiGetCapitalDepositSubHisrecV1Request {
	r.txId = &txId
	return r
}

func (r ApiGetCapitalDepositSubHisrecV1Request) Execute() ([]GetCapitalDepositSubHisrecV1RespItem, *http.Response, error) {
	return r.ApiService.GetCapitalDepositSubHisrecV1Execute(r)
}

/*
GetCapitalDepositSubHisrecV1 Get Sub-account Deposit History(For Master Account)

Fetch sub-account deposit history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCapitalDepositSubHisrecV1Request
*/
func (a *SubAccountAPIService) GetCapitalDepositSubHisrecV1(ctx context.Context) ApiGetCapitalDepositSubHisrecV1Request {
	return ApiGetCapitalDepositSubHisrecV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetCapitalDepositSubHisrecV1RespItem
func (a *SubAccountAPIService) GetCapitalDepositSubHisrecV1Execute(r ApiGetCapitalDepositSubHisrecV1Request) ([]GetCapitalDepositSubHisrecV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetCapitalDepositSubHisrecV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetCapitalDepositSubHisrecV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subHisrec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedSubaccountAccountSnapshotV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	type_ *string
	timestamp *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiGetManagedSubaccountAccountSnapshotV1Request) Email(email string) ApiGetManagedSubaccountAccountSnapshotV1Request {
	r.email = &email
	return r
}

// &amp;#34;SPOT&amp;#34;, &amp;#34;MARGIN&amp;#34;cross, &amp;#34;FUTURES&amp;#34;UM
func (r ApiGetManagedSubaccountAccountSnapshotV1Request) Type_(type_ string) ApiGetManagedSubaccountAccountSnapshotV1Request {
	r.type_ = &type_
	return r
}

func (r ApiGetManagedSubaccountAccountSnapshotV1Request) Timestamp(timestamp int64) ApiGetManagedSubaccountAccountSnapshotV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetManagedSubaccountAccountSnapshotV1Request) StartTime(startTime int64) ApiGetManagedSubaccountAccountSnapshotV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetManagedSubaccountAccountSnapshotV1Request) EndTime(endTime int64) ApiGetManagedSubaccountAccountSnapshotV1Request {
	r.endTime = &endTime
	return r
}

// min 7, max 30, default 7
func (r ApiGetManagedSubaccountAccountSnapshotV1Request) Limit(limit int32) ApiGetManagedSubaccountAccountSnapshotV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetManagedSubaccountAccountSnapshotV1Request) RecvWindow(recvWindow int64) ApiGetManagedSubaccountAccountSnapshotV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetManagedSubaccountAccountSnapshotV1Request) Execute() (*GetManagedSubaccountAccountSnapshotV1Resp, *http.Response, error) {
	return r.ApiService.GetManagedSubaccountAccountSnapshotV1Execute(r)
}

/*
GetManagedSubaccountAccountSnapshotV1 Query Managed Sub-account Snapshot(For Investor Master Account)

Query Managed Sub-account Snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManagedSubaccountAccountSnapshotV1Request
*/
func (a *SubAccountAPIService) GetManagedSubaccountAccountSnapshotV1(ctx context.Context) ApiGetManagedSubaccountAccountSnapshotV1Request {
	return ApiGetManagedSubaccountAccountSnapshotV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetManagedSubaccountAccountSnapshotV1Resp
func (a *SubAccountAPIService) GetManagedSubaccountAccountSnapshotV1Execute(r ApiGetManagedSubaccountAccountSnapshotV1Request) (*GetManagedSubaccountAccountSnapshotV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetManagedSubaccountAccountSnapshotV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetManagedSubaccountAccountSnapshotV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/accountSnapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 7
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedSubaccountAssetV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetManagedSubaccountAssetV1Request) Email(email string) ApiGetManagedSubaccountAssetV1Request {
	r.email = &email
	return r
}

func (r ApiGetManagedSubaccountAssetV1Request) Timestamp(timestamp int64) ApiGetManagedSubaccountAssetV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetManagedSubaccountAssetV1Request) RecvWindow(recvWindow int64) ApiGetManagedSubaccountAssetV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetManagedSubaccountAssetV1Request) Execute() ([]GetManagedSubaccountAssetV1RespItem, *http.Response, error) {
	return r.ApiService.GetManagedSubaccountAssetV1Execute(r)
}

/*
GetManagedSubaccountAssetV1 Query Managed Sub-account Asset Details(For Investor Master Account)

Query Managed Sub-account Asset Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManagedSubaccountAssetV1Request
*/
func (a *SubAccountAPIService) GetManagedSubaccountAssetV1(ctx context.Context) ApiGetManagedSubaccountAssetV1Request {
	return ApiGetManagedSubaccountAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetManagedSubaccountAssetV1RespItem
func (a *SubAccountAPIService) GetManagedSubaccountAssetV1Execute(r ApiGetManagedSubaccountAssetV1Request) ([]GetManagedSubaccountAssetV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetManagedSubaccountAssetV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetManagedSubaccountAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedSubaccountDepositAddressV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	coin *string
	timestamp *int64
	network *string
	amount *string
	recvWindow *int64
}

// Sub user email
func (r ApiGetManagedSubaccountDepositAddressV1Request) Email(email string) ApiGetManagedSubaccountDepositAddressV1Request {
	r.email = &email
	return r
}

func (r ApiGetManagedSubaccountDepositAddressV1Request) Coin(coin string) ApiGetManagedSubaccountDepositAddressV1Request {
	r.coin = &coin
	return r
}

func (r ApiGetManagedSubaccountDepositAddressV1Request) Timestamp(timestamp int64) ApiGetManagedSubaccountDepositAddressV1Request {
	r.timestamp = &timestamp
	return r
}

// networks can be found in &#x60;GET /sapi/v1/capital/deposit/address&#x60;
func (r ApiGetManagedSubaccountDepositAddressV1Request) Network(network string) ApiGetManagedSubaccountDepositAddressV1Request {
	r.network = &network
	return r
}

func (r ApiGetManagedSubaccountDepositAddressV1Request) Amount(amount string) ApiGetManagedSubaccountDepositAddressV1Request {
	r.amount = &amount
	return r
}

func (r ApiGetManagedSubaccountDepositAddressV1Request) RecvWindow(recvWindow int64) ApiGetManagedSubaccountDepositAddressV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetManagedSubaccountDepositAddressV1Request) Execute() (*GetManagedSubaccountDepositAddressV1Resp, *http.Response, error) {
	return r.ApiService.GetManagedSubaccountDepositAddressV1Execute(r)
}

/*
GetManagedSubaccountDepositAddressV1 Get Managed Sub-account Deposit Address (For Investor Master Account)(USER_DATA)

Get investor's managed sub-account deposit address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManagedSubaccountDepositAddressV1Request
*/
func (a *SubAccountAPIService) GetManagedSubaccountDepositAddressV1(ctx context.Context) ApiGetManagedSubaccountDepositAddressV1Request {
	return ApiGetManagedSubaccountDepositAddressV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetManagedSubaccountDepositAddressV1Resp
func (a *SubAccountAPIService) GetManagedSubaccountDepositAddressV1Execute(r ApiGetManagedSubaccountDepositAddressV1Request) (*GetManagedSubaccountDepositAddressV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetManagedSubaccountDepositAddressV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetManagedSubaccountDepositAddressV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/deposit/address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	} else {
		var defaultValue string = ""
		r.amount = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedSubaccountFetchFutureAssetV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	accountType *string
}

// Managed Sub Account Email
func (r ApiGetManagedSubaccountFetchFutureAssetV1Request) Email(email string) ApiGetManagedSubaccountFetchFutureAssetV1Request {
	r.email = &email
	return r
}

// No input or input &amp;#34;USDT_FUTURE&amp;#34; to get UM Futures account details. Input &amp;#34;COIN_FUTURE&amp;#34; to get CM Futures account details.
func (r ApiGetManagedSubaccountFetchFutureAssetV1Request) AccountType(accountType string) ApiGetManagedSubaccountFetchFutureAssetV1Request {
	r.accountType = &accountType
	return r
}

func (r ApiGetManagedSubaccountFetchFutureAssetV1Request) Execute() (*GetManagedSubaccountFetchFutureAssetV1Resp, *http.Response, error) {
	return r.ApiService.GetManagedSubaccountFetchFutureAssetV1Execute(r)
}

/*
GetManagedSubaccountFetchFutureAssetV1 Query Managed Sub-account Futures Asset Details(For Investor Master Account)(USER_DATA)

Investor can use this api to query managed sub account futures asset details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManagedSubaccountFetchFutureAssetV1Request
*/
func (a *SubAccountAPIService) GetManagedSubaccountFetchFutureAssetV1(ctx context.Context) ApiGetManagedSubaccountFetchFutureAssetV1Request {
	return ApiGetManagedSubaccountFetchFutureAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetManagedSubaccountFetchFutureAssetV1Resp
func (a *SubAccountAPIService) GetManagedSubaccountFetchFutureAssetV1Execute(r ApiGetManagedSubaccountFetchFutureAssetV1Request) (*GetManagedSubaccountFetchFutureAssetV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetManagedSubaccountFetchFutureAssetV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetManagedSubaccountFetchFutureAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/fetch-future-asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "form", "")
	} else {
		var defaultValue string = ""
		r.accountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedSubaccountInfoV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	timestamp *int64
	email *string
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ApiGetManagedSubaccountInfoV1Request) Timestamp(timestamp int64) ApiGetManagedSubaccountInfoV1Request {
	r.timestamp = &timestamp
	return r
}

// Managed sub-account email
func (r ApiGetManagedSubaccountInfoV1Request) Email(email string) ApiGetManagedSubaccountInfoV1Request {
	r.email = &email
	return r
}

// Default value: 1
func (r ApiGetManagedSubaccountInfoV1Request) Page(page int32) ApiGetManagedSubaccountInfoV1Request {
	r.page = &page
	return r
}

// Default value: 20, Max value: 20
func (r ApiGetManagedSubaccountInfoV1Request) Limit(limit int32) ApiGetManagedSubaccountInfoV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetManagedSubaccountInfoV1Request) RecvWindow(recvWindow int64) ApiGetManagedSubaccountInfoV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetManagedSubaccountInfoV1Request) Execute() (*GetManagedSubaccountInfoV1Resp, *http.Response, error) {
	return r.ApiService.GetManagedSubaccountInfoV1Execute(r)
}

/*
GetManagedSubaccountInfoV1 Query Managed Sub-account List(For Investor)(USER_DATA)

Get investor's managed sub-account list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManagedSubaccountInfoV1Request
*/
func (a *SubAccountAPIService) GetManagedSubaccountInfoV1(ctx context.Context) ApiGetManagedSubaccountInfoV1Request {
	return ApiGetManagedSubaccountInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetManagedSubaccountInfoV1Resp
func (a *SubAccountAPIService) GetManagedSubaccountInfoV1Execute(r ApiGetManagedSubaccountInfoV1Request) (*GetManagedSubaccountInfoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetManagedSubaccountInfoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetManagedSubaccountInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedSubaccountMarginAssetV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	accountType *string
}

// Managed Sub Account Email
func (r ApiGetManagedSubaccountMarginAssetV1Request) Email(email string) ApiGetManagedSubaccountMarginAssetV1Request {
	r.email = &email
	return r
}

// No input or input &amp;#34;MARGIN&amp;#34; to get Cross Margin account details. Input &amp;#34;ISOLATED_MARGIN&amp;#34; to get Isolated Margin account details.
func (r ApiGetManagedSubaccountMarginAssetV1Request) AccountType(accountType string) ApiGetManagedSubaccountMarginAssetV1Request {
	r.accountType = &accountType
	return r
}

func (r ApiGetManagedSubaccountMarginAssetV1Request) Execute() (*GetManagedSubaccountMarginAssetV1Resp, *http.Response, error) {
	return r.ApiService.GetManagedSubaccountMarginAssetV1Execute(r)
}

/*
GetManagedSubaccountMarginAssetV1 Query Managed Sub-account Margin Asset Details(For Investor Master Account)(USER_DATA)

Investor can use this api to query managed sub account margin asset details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManagedSubaccountMarginAssetV1Request
*/
func (a *SubAccountAPIService) GetManagedSubaccountMarginAssetV1(ctx context.Context) ApiGetManagedSubaccountMarginAssetV1Request {
	return ApiGetManagedSubaccountMarginAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetManagedSubaccountMarginAssetV1Resp
func (a *SubAccountAPIService) GetManagedSubaccountMarginAssetV1Execute(r ApiGetManagedSubaccountMarginAssetV1Request) (*GetManagedSubaccountMarginAssetV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetManagedSubaccountMarginAssetV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetManagedSubaccountMarginAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/marginAsset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "form", "")
	} else {
		var defaultValue string = ""
		r.accountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedSubaccountQueryTransLogForInvestorV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	transfers *string
	transferFunctionAccountType *string
}

// Managed Sub Account Email
func (r ApiGetManagedSubaccountQueryTransLogForInvestorV1Request) Email(email string) ApiGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.email = &email
	return r
}

// Start Time
func (r ApiGetManagedSubaccountQueryTransLogForInvestorV1Request) StartTime(startTime int64) ApiGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.startTime = &startTime
	return r
}

// End Time (The start time and end time interval cannot exceed half a year)
func (r ApiGetManagedSubaccountQueryTransLogForInvestorV1Request) EndTime(endTime int64) ApiGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.endTime = &endTime
	return r
}

// Page
func (r ApiGetManagedSubaccountQueryTransLogForInvestorV1Request) Page(page int32) ApiGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.page = &page
	return r
}

// Limit (Max: 500)
func (r ApiGetManagedSubaccountQueryTransLogForInvestorV1Request) Limit(limit int32) ApiGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.limit = &limit
	return r
}

// Transfer Direction (FROM/TO)
func (r ApiGetManagedSubaccountQueryTransLogForInvestorV1Request) Transfers(transfers string) ApiGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.transfers = &transfers
	return r
}

// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
func (r ApiGetManagedSubaccountQueryTransLogForInvestorV1Request) TransferFunctionAccountType(transferFunctionAccountType string) ApiGetManagedSubaccountQueryTransLogForInvestorV1Request {
	r.transferFunctionAccountType = &transferFunctionAccountType
	return r
}

func (r ApiGetManagedSubaccountQueryTransLogForInvestorV1Request) Execute() (*GetManagedSubaccountQueryTransLogForInvestorV1Resp, *http.Response, error) {
	return r.ApiService.GetManagedSubaccountQueryTransLogForInvestorV1Execute(r)
}

/*
GetManagedSubaccountQueryTransLogForInvestorV1 Query Managed Sub Account Transfer Log(For Investor Master Account)(USER_DATA)

Investor can use this api to query managed sub account transfer log. This endpoint is available for investor of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team.
Please refer to link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManagedSubaccountQueryTransLogForInvestorV1Request
*/
func (a *SubAccountAPIService) GetManagedSubaccountQueryTransLogForInvestorV1(ctx context.Context) ApiGetManagedSubaccountQueryTransLogForInvestorV1Request {
	return ApiGetManagedSubaccountQueryTransLogForInvestorV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetManagedSubaccountQueryTransLogForInvestorV1Resp
func (a *SubAccountAPIService) GetManagedSubaccountQueryTransLogForInvestorV1Execute(r ApiGetManagedSubaccountQueryTransLogForInvestorV1Request) (*GetManagedSubaccountQueryTransLogForInvestorV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetManagedSubaccountQueryTransLogForInvestorV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetManagedSubaccountQueryTransLogForInvestorV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/queryTransLogForInvestor"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.transfers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transfers", r.transfers, "form", "")
	} else {
		var defaultValue string = ""
		r.transfers = &defaultValue
	}
	if r.transferFunctionAccountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferFunctionAccountType", r.transferFunctionAccountType, "form", "")
	} else {
		var defaultValue string = ""
		r.transferFunctionAccountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	transfers *string
	transferFunctionAccountType *string
}

// Managed Sub Account Email
func (r ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request) Email(email string) ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.email = &email
	return r
}

// Start Time
func (r ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request) StartTime(startTime int64) ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.startTime = &startTime
	return r
}

// End Time (The start time and end time interval cannot exceed half a year)
func (r ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request) EndTime(endTime int64) ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.endTime = &endTime
	return r
}

// Page
func (r ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request) Page(page int32) ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.page = &page
	return r
}

// Limit (Max: 500)
func (r ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request) Limit(limit int32) ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.limit = &limit
	return r
}

// Transfer Direction (FROM/TO)
func (r ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request) Transfers(transfers string) ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.transfers = &transfers
	return r
}

// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
func (r ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request) TransferFunctionAccountType(transferFunctionAccountType string) ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	r.transferFunctionAccountType = &transferFunctionAccountType
	return r
}

func (r ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request) Execute() (*GetManagedSubaccountQueryTransLogForTradeParentV1Resp, *http.Response, error) {
	return r.ApiService.GetManagedSubaccountQueryTransLogForTradeParentV1Execute(r)
}

/*
GetManagedSubaccountQueryTransLogForTradeParentV1 Query Managed Sub Account Transfer Log(For Trading Team Master Account)(USER_DATA)

Trading team can use this api to query managed sub account transfer log. This endpoint is available for trading team of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team.
Please refer to link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request
*/
func (a *SubAccountAPIService) GetManagedSubaccountQueryTransLogForTradeParentV1(ctx context.Context) ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request {
	return ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetManagedSubaccountQueryTransLogForTradeParentV1Resp
func (a *SubAccountAPIService) GetManagedSubaccountQueryTransLogForTradeParentV1Execute(r ApiGetManagedSubaccountQueryTransLogForTradeParentV1Request) (*GetManagedSubaccountQueryTransLogForTradeParentV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetManagedSubaccountQueryTransLogForTradeParentV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetManagedSubaccountQueryTransLogForTradeParentV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/queryTransLogForTradeParent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.transfers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transfers", r.transfers, "form", "")
	} else {
		var defaultValue string = ""
		r.transfers = &defaultValue
	}
	if r.transferFunctionAccountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferFunctionAccountType", r.transferFunctionAccountType, "form", "")
	} else {
		var defaultValue string = ""
		r.transferFunctionAccountType = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagedSubaccountQueryTransLogV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	timestamp *int64
	transfers *string
	transferFunctionAccountType *string
	recvWindow *int64
}

// Start Time
func (r ApiGetManagedSubaccountQueryTransLogV1Request) StartTime(startTime int64) ApiGetManagedSubaccountQueryTransLogV1Request {
	r.startTime = &startTime
	return r
}

// End Time (The start time and end time interval cannot exceed half a year)
func (r ApiGetManagedSubaccountQueryTransLogV1Request) EndTime(endTime int64) ApiGetManagedSubaccountQueryTransLogV1Request {
	r.endTime = &endTime
	return r
}

// Page
func (r ApiGetManagedSubaccountQueryTransLogV1Request) Page(page int32) ApiGetManagedSubaccountQueryTransLogV1Request {
	r.page = &page
	return r
}

// Limit (Max: 500)
func (r ApiGetManagedSubaccountQueryTransLogV1Request) Limit(limit int32) ApiGetManagedSubaccountQueryTransLogV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetManagedSubaccountQueryTransLogV1Request) Timestamp(timestamp int64) ApiGetManagedSubaccountQueryTransLogV1Request {
	r.timestamp = &timestamp
	return r
}

// Transfer Direction (FROM/TO)
func (r ApiGetManagedSubaccountQueryTransLogV1Request) Transfers(transfers string) ApiGetManagedSubaccountQueryTransLogV1Request {
	r.transfers = &transfers
	return r
}

// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
func (r ApiGetManagedSubaccountQueryTransLogV1Request) TransferFunctionAccountType(transferFunctionAccountType string) ApiGetManagedSubaccountQueryTransLogV1Request {
	r.transferFunctionAccountType = &transferFunctionAccountType
	return r
}

func (r ApiGetManagedSubaccountQueryTransLogV1Request) RecvWindow(recvWindow int64) ApiGetManagedSubaccountQueryTransLogV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetManagedSubaccountQueryTransLogV1Request) Execute() (*GetManagedSubaccountQueryTransLogV1Resp, *http.Response, error) {
	return r.ApiService.GetManagedSubaccountQueryTransLogV1Execute(r)
}

/*
GetManagedSubaccountQueryTransLogV1 Query Managed Sub Account Transfer Log (For Trading Team Sub Account)(USER_DATA)

Query Managed Sub Account Transfer Log (For Trading Team Sub Account)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManagedSubaccountQueryTransLogV1Request
*/
func (a *SubAccountAPIService) GetManagedSubaccountQueryTransLogV1(ctx context.Context) ApiGetManagedSubaccountQueryTransLogV1Request {
	return ApiGetManagedSubaccountQueryTransLogV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetManagedSubaccountQueryTransLogV1Resp
func (a *SubAccountAPIService) GetManagedSubaccountQueryTransLogV1Execute(r ApiGetManagedSubaccountQueryTransLogV1Request) (*GetManagedSubaccountQueryTransLogV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetManagedSubaccountQueryTransLogV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetManagedSubaccountQueryTransLogV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/query-trans-log"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.transfers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transfers", r.transfers, "form", "")
	} else {
		var defaultValue string = ""
		r.transfers = &defaultValue
	}
	if r.transferFunctionAccountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transferFunctionAccountType", r.transferFunctionAccountType, "form", "")
	} else {
		var defaultValue string = ""
		r.transferFunctionAccountType = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountAssetsV3Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// Sub account email
func (r ApiGetSubAccountAssetsV3Request) Email(email string) ApiGetSubAccountAssetsV3Request {
	r.email = &email
	return r
}

func (r ApiGetSubAccountAssetsV3Request) Timestamp(timestamp int64) ApiGetSubAccountAssetsV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountAssetsV3Request) RecvWindow(recvWindow int64) ApiGetSubAccountAssetsV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountAssetsV3Request) Execute() (*GetSubAccountAssetsV3Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountAssetsV3Execute(r)
}

/*
GetSubAccountAssetsV3 Query Sub-account Assets(For Master Account)

Fetch sub-account assets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountAssetsV3Request
*/
func (a *SubAccountAPIService) GetSubAccountAssetsV3(ctx context.Context) ApiGetSubAccountAssetsV3Request {
	return ApiGetSubAccountAssetsV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountAssetsV3Resp
func (a *SubAccountAPIService) GetSubAccountAssetsV3Execute(r ApiGetSubAccountAssetsV3Request) (*GetSubAccountAssetsV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountAssetsV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountAssetsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v3/sub-account/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountAssetsV4Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// Sub Account Email
func (r ApiGetSubAccountAssetsV4Request) Email(email string) ApiGetSubAccountAssetsV4Request {
	r.email = &email
	return r
}

func (r ApiGetSubAccountAssetsV4Request) Timestamp(timestamp int64) ApiGetSubAccountAssetsV4Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountAssetsV4Request) RecvWindow(recvWindow int64) ApiGetSubAccountAssetsV4Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountAssetsV4Request) Execute() (*GetSubAccountAssetsV4Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountAssetsV4Execute(r)
}

/*
GetSubAccountAssetsV4 Query Sub-account Assets (For Master Account)(USER_DATA)

Fetch sub-account assets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountAssetsV4Request
*/
func (a *SubAccountAPIService) GetSubAccountAssetsV4(ctx context.Context) ApiGetSubAccountAssetsV4Request {
	return ApiGetSubAccountAssetsV4Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountAssetsV4Resp
func (a *SubAccountAPIService) GetSubAccountAssetsV4Execute(r ApiGetSubAccountAssetsV4Request) (*GetSubAccountAssetsV4Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountAssetsV4Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountAssetsV4")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v4/sub-account/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountFuturesAccountSummaryV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetSubAccountFuturesAccountSummaryV1Request) Timestamp(timestamp int64) ApiGetSubAccountFuturesAccountSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountFuturesAccountSummaryV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountFuturesAccountSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountFuturesAccountSummaryV1Request) Execute() (*GetSubAccountFuturesAccountSummaryV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountFuturesAccountSummaryV1Execute(r)
}

/*
GetSubAccountFuturesAccountSummaryV1 Get Summary of Sub-account's Futures Account(For Master Account)

Get Summary of Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountFuturesAccountSummaryV1Request
*/
func (a *SubAccountAPIService) GetSubAccountFuturesAccountSummaryV1(ctx context.Context) ApiGetSubAccountFuturesAccountSummaryV1Request {
	return ApiGetSubAccountFuturesAccountSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountFuturesAccountSummaryV1Resp
func (a *SubAccountAPIService) GetSubAccountFuturesAccountSummaryV1Execute(r ApiGetSubAccountFuturesAccountSummaryV1Request) (*GetSubAccountFuturesAccountSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountFuturesAccountSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountFuturesAccountSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountFuturesAccountSummaryV2Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	futuresType *int32
	timestamp *int64
	page *int32
	limit *int32
	recvWindow *int64
}

// 1:USDT Margined Futures, 2:COIN Margined Futures
func (r ApiGetSubAccountFuturesAccountSummaryV2Request) FuturesType(futuresType int32) ApiGetSubAccountFuturesAccountSummaryV2Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiGetSubAccountFuturesAccountSummaryV2Request) Timestamp(timestamp int64) ApiGetSubAccountFuturesAccountSummaryV2Request {
	r.timestamp = &timestamp
	return r
}

// default:1
func (r ApiGetSubAccountFuturesAccountSummaryV2Request) Page(page int32) ApiGetSubAccountFuturesAccountSummaryV2Request {
	r.page = &page
	return r
}

// default:10, max:20
func (r ApiGetSubAccountFuturesAccountSummaryV2Request) Limit(limit int32) ApiGetSubAccountFuturesAccountSummaryV2Request {
	r.limit = &limit
	return r
}

func (r ApiGetSubAccountFuturesAccountSummaryV2Request) RecvWindow(recvWindow int64) ApiGetSubAccountFuturesAccountSummaryV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountFuturesAccountSummaryV2Request) Execute() (*GetSubAccountFuturesAccountSummaryV2Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountFuturesAccountSummaryV2Execute(r)
}

/*
GetSubAccountFuturesAccountSummaryV2 Get Summary of Sub-account's Futures Account V2(For Master Account)

Get Summary of Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountFuturesAccountSummaryV2Request
*/
func (a *SubAccountAPIService) GetSubAccountFuturesAccountSummaryV2(ctx context.Context) ApiGetSubAccountFuturesAccountSummaryV2Request {
	return ApiGetSubAccountFuturesAccountSummaryV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountFuturesAccountSummaryV2Resp
func (a *SubAccountAPIService) GetSubAccountFuturesAccountSummaryV2Execute(r ApiGetSubAccountFuturesAccountSummaryV2Request) (*GetSubAccountFuturesAccountSummaryV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountFuturesAccountSummaryV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountFuturesAccountSummaryV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountFuturesAccountV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Futures-Account#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiGetSubAccountFuturesAccountV1Request) Email(email string) ApiGetSubAccountFuturesAccountV1Request {
	r.email = &email
	return r
}

func (r ApiGetSubAccountFuturesAccountV1Request) Timestamp(timestamp int64) ApiGetSubAccountFuturesAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountFuturesAccountV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountFuturesAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountFuturesAccountV1Request) Execute() (*GetSubAccountFuturesAccountV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountFuturesAccountV1Execute(r)
}

/*
GetSubAccountFuturesAccountV1 Get Detail on Sub-account's Futures Account(For Master Account)

Get Detail on Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountFuturesAccountV1Request
*/
func (a *SubAccountAPIService) GetSubAccountFuturesAccountV1(ctx context.Context) ApiGetSubAccountFuturesAccountV1Request {
	return ApiGetSubAccountFuturesAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountFuturesAccountV1Resp
func (a *SubAccountAPIService) GetSubAccountFuturesAccountV1Execute(r ApiGetSubAccountFuturesAccountV1Request) (*GetSubAccountFuturesAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountFuturesAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountFuturesAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountFuturesAccountV2Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	futuresType *int32
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Futures-Account-V2#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiGetSubAccountFuturesAccountV2Request) Email(email string) ApiGetSubAccountFuturesAccountV2Request {
	r.email = &email
	return r
}

// 1:USDT Margined Futures, 2:COIN Margined Futures
func (r ApiGetSubAccountFuturesAccountV2Request) FuturesType(futuresType int32) ApiGetSubAccountFuturesAccountV2Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiGetSubAccountFuturesAccountV2Request) Timestamp(timestamp int64) ApiGetSubAccountFuturesAccountV2Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountFuturesAccountV2Request) RecvWindow(recvWindow int64) ApiGetSubAccountFuturesAccountV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountFuturesAccountV2Request) Execute() (*GetSubAccountFuturesAccountV2Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountFuturesAccountV2Execute(r)
}

/*
GetSubAccountFuturesAccountV2 Get Detail on Sub-account's Futures Account V2(For Master Account)

Get Detail on Sub-account's Futures Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountFuturesAccountV2Request
*/
func (a *SubAccountAPIService) GetSubAccountFuturesAccountV2(ctx context.Context) ApiGetSubAccountFuturesAccountV2Request {
	return ApiGetSubAccountFuturesAccountV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountFuturesAccountV2Resp
func (a *SubAccountAPIService) GetSubAccountFuturesAccountV2Execute(r ApiGetSubAccountFuturesAccountV2Request) (*GetSubAccountFuturesAccountV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountFuturesAccountV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountFuturesAccountV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountFuturesInternalTransferV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	futuresType *int64
	timestamp *int64
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Query-Sub-account-Futures-Asset-Transfer-History#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiGetSubAccountFuturesInternalTransferV1Request) Email(email string) ApiGetSubAccountFuturesInternalTransferV1Request {
	r.email = &email
	return r
}

// 1:USDT-margined Futures2: Coin-margined Futures
func (r ApiGetSubAccountFuturesInternalTransferV1Request) FuturesType(futuresType int64) ApiGetSubAccountFuturesInternalTransferV1Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiGetSubAccountFuturesInternalTransferV1Request) Timestamp(timestamp int64) ApiGetSubAccountFuturesInternalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

// Cannot be earlier than 1 month ago
func (r ApiGetSubAccountFuturesInternalTransferV1Request) StartTime(startTime int64) ApiGetSubAccountFuturesInternalTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSubAccountFuturesInternalTransferV1Request) EndTime(endTime int64) ApiGetSubAccountFuturesInternalTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default value: 1
func (r ApiGetSubAccountFuturesInternalTransferV1Request) Page(page int32) ApiGetSubAccountFuturesInternalTransferV1Request {
	r.page = &page
	return r
}

// Default value: 50, Max value: 500
func (r ApiGetSubAccountFuturesInternalTransferV1Request) Limit(limit int32) ApiGetSubAccountFuturesInternalTransferV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetSubAccountFuturesInternalTransferV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountFuturesInternalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountFuturesInternalTransferV1Request) Execute() (*GetSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountFuturesInternalTransferV1Execute(r)
}

/*
GetSubAccountFuturesInternalTransferV1 Query Sub-account Futures Asset Transfer History(For Master Account)

Query Sub-account Futures Asset Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountFuturesInternalTransferV1Request
*/
func (a *SubAccountAPIService) GetSubAccountFuturesInternalTransferV1(ctx context.Context) ApiGetSubAccountFuturesInternalTransferV1Request {
	return ApiGetSubAccountFuturesInternalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountFuturesInternalTransferV1Resp
func (a *SubAccountAPIService) GetSubAccountFuturesInternalTransferV1Execute(r ApiGetSubAccountFuturesInternalTransferV1Request) (*GetSubAccountFuturesInternalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountFuturesInternalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountFuturesInternalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountFuturesMovePositionV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	symbol *string
	page *int32
	row *int32
	timestamp *int64
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r ApiGetSubAccountFuturesMovePositionV1Request) Symbol(symbol string) ApiGetSubAccountFuturesMovePositionV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetSubAccountFuturesMovePositionV1Request) Page(page int32) ApiGetSubAccountFuturesMovePositionV1Request {
	r.page = &page
	return r
}

func (r ApiGetSubAccountFuturesMovePositionV1Request) Row(row int32) ApiGetSubAccountFuturesMovePositionV1Request {
	r.row = &row
	return r
}

func (r ApiGetSubAccountFuturesMovePositionV1Request) Timestamp(timestamp int64) ApiGetSubAccountFuturesMovePositionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountFuturesMovePositionV1Request) StartTime(startTime int64) ApiGetSubAccountFuturesMovePositionV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSubAccountFuturesMovePositionV1Request) EndTime(endTime int64) ApiGetSubAccountFuturesMovePositionV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetSubAccountFuturesMovePositionV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountFuturesMovePositionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountFuturesMovePositionV1Request) Execute() (*GetSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountFuturesMovePositionV1Execute(r)
}

/*
GetSubAccountFuturesMovePositionV1 Get Move Position History for Sub-account (For Master Account)

Query move position history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountFuturesMovePositionV1Request
*/
func (a *SubAccountAPIService) GetSubAccountFuturesMovePositionV1(ctx context.Context) ApiGetSubAccountFuturesMovePositionV1Request {
	return ApiGetSubAccountFuturesMovePositionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountFuturesMovePositionV1Resp
func (a *SubAccountAPIService) GetSubAccountFuturesMovePositionV1Execute(r ApiGetSubAccountFuturesMovePositionV1Request) (*GetSubAccountFuturesMovePositionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountFuturesMovePositionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountFuturesMovePositionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/move-position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.row == nil {
		return localVarReturnValue, nil, reportError("row is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "row", r.row, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountFuturesPositionRiskV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/account-management/Get-Futures-Position-Risk-of-Sub-account#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiGetSubAccountFuturesPositionRiskV1Request) Email(email string) ApiGetSubAccountFuturesPositionRiskV1Request {
	r.email = &email
	return r
}

func (r ApiGetSubAccountFuturesPositionRiskV1Request) Timestamp(timestamp int64) ApiGetSubAccountFuturesPositionRiskV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountFuturesPositionRiskV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountFuturesPositionRiskV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountFuturesPositionRiskV1Request) Execute() ([]GetSubAccountFuturesPositionRiskV1RespItem, *http.Response, error) {
	return r.ApiService.GetSubAccountFuturesPositionRiskV1Execute(r)
}

/*
GetSubAccountFuturesPositionRiskV1 Get Futures Position-Risk of Sub-account(For Master Account)

Get Futures Position-Risk of Sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountFuturesPositionRiskV1Request
*/
func (a *SubAccountAPIService) GetSubAccountFuturesPositionRiskV1(ctx context.Context) ApiGetSubAccountFuturesPositionRiskV1Request {
	return ApiGetSubAccountFuturesPositionRiskV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetSubAccountFuturesPositionRiskV1RespItem
func (a *SubAccountAPIService) GetSubAccountFuturesPositionRiskV1Execute(r ApiGetSubAccountFuturesPositionRiskV1Request) ([]GetSubAccountFuturesPositionRiskV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetSubAccountFuturesPositionRiskV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountFuturesPositionRiskV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountFuturesPositionRiskV2Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	futuresType *int32
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/account-management/Get-Futures-Position-Risk-of-Sub-account-V2#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiGetSubAccountFuturesPositionRiskV2Request) Email(email string) ApiGetSubAccountFuturesPositionRiskV2Request {
	r.email = &email
	return r
}

// 1:USDT Margined Futures, 2:COIN Margined Futures
func (r ApiGetSubAccountFuturesPositionRiskV2Request) FuturesType(futuresType int32) ApiGetSubAccountFuturesPositionRiskV2Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiGetSubAccountFuturesPositionRiskV2Request) Timestamp(timestamp int64) ApiGetSubAccountFuturesPositionRiskV2Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountFuturesPositionRiskV2Request) RecvWindow(recvWindow int64) ApiGetSubAccountFuturesPositionRiskV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountFuturesPositionRiskV2Request) Execute() (*GetSubAccountFuturesPositionRiskV2Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountFuturesPositionRiskV2Execute(r)
}

/*
GetSubAccountFuturesPositionRiskV2 Get Futures Position-Risk of Sub-account V2(For Master Account)

Get Futures Position-Risk of Sub-account V2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountFuturesPositionRiskV2Request
*/
func (a *SubAccountAPIService) GetSubAccountFuturesPositionRiskV2(ctx context.Context) ApiGetSubAccountFuturesPositionRiskV2Request {
	return ApiGetSubAccountFuturesPositionRiskV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountFuturesPositionRiskV2Resp
func (a *SubAccountAPIService) GetSubAccountFuturesPositionRiskV2Execute(r ApiGetSubAccountFuturesPositionRiskV2Request) (*GetSubAccountFuturesPositionRiskV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountFuturesPositionRiskV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountFuturesPositionRiskV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountListV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	timestamp *int64
	email *string
	isFreeze *string
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ApiGetSubAccountListV1Request) Timestamp(timestamp int64) ApiGetSubAccountListV1Request {
	r.timestamp = &timestamp
	return r
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/account-management/Query-Sub-account-List#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiGetSubAccountListV1Request) Email(email string) ApiGetSubAccountListV1Request {
	r.email = &email
	return r
}

// true or false
func (r ApiGetSubAccountListV1Request) IsFreeze(isFreeze string) ApiGetSubAccountListV1Request {
	r.isFreeze = &isFreeze
	return r
}

// Default value: 1
func (r ApiGetSubAccountListV1Request) Page(page int32) ApiGetSubAccountListV1Request {
	r.page = &page
	return r
}

// Default value: 1, Max value: 200
func (r ApiGetSubAccountListV1Request) Limit(limit int32) ApiGetSubAccountListV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetSubAccountListV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountListV1Request) Execute() (*GetSubAccountListV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountListV1Execute(r)
}

/*
GetSubAccountListV1 Query Sub-account List(For Master Account)

Query Sub-account List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountListV1Request
*/
func (a *SubAccountAPIService) GetSubAccountListV1(ctx context.Context) ApiGetSubAccountListV1Request {
	return ApiGetSubAccountListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountListV1Resp
func (a *SubAccountAPIService) GetSubAccountListV1Execute(r ApiGetSubAccountListV1Request) (*GetSubAccountListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.isFreeze != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isFreeze", r.isFreeze, "form", "")
	} else {
		var defaultValue string = ""
		r.isFreeze = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountMarginAccountSummaryV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetSubAccountMarginAccountSummaryV1Request) Timestamp(timestamp int64) ApiGetSubAccountMarginAccountSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountMarginAccountSummaryV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountMarginAccountSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountMarginAccountSummaryV1Request) Execute() (*GetSubAccountMarginAccountSummaryV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountMarginAccountSummaryV1Execute(r)
}

/*
GetSubAccountMarginAccountSummaryV1 Get Summary of Sub-account's Margin Account(For Master Account)

Get Summary of Sub-account's Margin Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountMarginAccountSummaryV1Request
*/
func (a *SubAccountAPIService) GetSubAccountMarginAccountSummaryV1(ctx context.Context) ApiGetSubAccountMarginAccountSummaryV1Request {
	return ApiGetSubAccountMarginAccountSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountMarginAccountSummaryV1Resp
func (a *SubAccountAPIService) GetSubAccountMarginAccountSummaryV1Execute(r ApiGetSubAccountMarginAccountSummaryV1Request) (*GetSubAccountMarginAccountSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountMarginAccountSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountMarginAccountSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountMarginAccountV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/asset-management/Get-Detail-on-Sub-accounts-Margin-Account#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiGetSubAccountMarginAccountV1Request) Email(email string) ApiGetSubAccountMarginAccountV1Request {
	r.email = &email
	return r
}

func (r ApiGetSubAccountMarginAccountV1Request) Timestamp(timestamp int64) ApiGetSubAccountMarginAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountMarginAccountV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountMarginAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountMarginAccountV1Request) Execute() (*GetSubAccountMarginAccountV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountMarginAccountV1Execute(r)
}

/*
GetSubAccountMarginAccountV1 Get Detail on Sub-account's Margin Account(For Master Account)

Get Detail on Sub-account's Margin Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountMarginAccountV1Request
*/
func (a *SubAccountAPIService) GetSubAccountMarginAccountV1(ctx context.Context) ApiGetSubAccountMarginAccountV1Request {
	return ApiGetSubAccountMarginAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountMarginAccountV1Resp
func (a *SubAccountAPIService) GetSubAccountMarginAccountV1Execute(r ApiGetSubAccountMarginAccountV1Request) (*GetSubAccountMarginAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountMarginAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountMarginAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountSpotSummaryV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	timestamp *int64
	email *string
	page *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetSubAccountSpotSummaryV1Request) Timestamp(timestamp int64) ApiGetSubAccountSpotSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

// Sub account email
func (r ApiGetSubAccountSpotSummaryV1Request) Email(email string) ApiGetSubAccountSpotSummaryV1Request {
	r.email = &email
	return r
}

// default 1
func (r ApiGetSubAccountSpotSummaryV1Request) Page(page int64) ApiGetSubAccountSpotSummaryV1Request {
	r.page = &page
	return r
}

// default 10, max 20
func (r ApiGetSubAccountSpotSummaryV1Request) Size(size int64) ApiGetSubAccountSpotSummaryV1Request {
	r.size = &size
	return r
}

func (r ApiGetSubAccountSpotSummaryV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountSpotSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountSpotSummaryV1Request) Execute() (*GetSubAccountSpotSummaryV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountSpotSummaryV1Execute(r)
}

/*
GetSubAccountSpotSummaryV1 Query Sub-account Spot Assets Summary(For Master Account)

Get BTC valued asset summary of subaccounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountSpotSummaryV1Request
*/
func (a *SubAccountAPIService) GetSubAccountSpotSummaryV1(ctx context.Context) ApiGetSubAccountSpotSummaryV1Request {
	return ApiGetSubAccountSpotSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountSpotSummaryV1Resp
func (a *SubAccountAPIService) GetSubAccountSpotSummaryV1Execute(r ApiGetSubAccountSpotSummaryV1Request) (*GetSubAccountSpotSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountSpotSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountSpotSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/spotSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountStatusV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	timestamp *int64
	email *string
	recvWindow *int64
}

func (r ApiGetSubAccountStatusV1Request) Timestamp(timestamp int64) ApiGetSubAccountStatusV1Request {
	r.timestamp = &timestamp
	return r
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/account-management/Get-Sub-accounts-Status-on-Margin-Or-Futures#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiGetSubAccountStatusV1Request) Email(email string) ApiGetSubAccountStatusV1Request {
	r.email = &email
	return r
}

func (r ApiGetSubAccountStatusV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountStatusV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountStatusV1Request) Execute() ([]GetSubAccountStatusV1RespItem, *http.Response, error) {
	return r.ApiService.GetSubAccountStatusV1Execute(r)
}

/*
GetSubAccountStatusV1 Get Sub-account's Status on Margin Or Futures(For Master Account)

Get Sub-account's Status on Margin Or Futures

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountStatusV1Request
*/
func (a *SubAccountAPIService) GetSubAccountStatusV1(ctx context.Context) ApiGetSubAccountStatusV1Request {
	return ApiGetSubAccountStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetSubAccountStatusV1RespItem
func (a *SubAccountAPIService) GetSubAccountStatusV1Execute(r ApiGetSubAccountStatusV1Request) ([]GetSubAccountStatusV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetSubAccountStatusV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountSubAccountApiIpRestrictionV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	subAccountApiKey *string
	timestamp *int64
	recvWindow *int64
}

// &lt;a href&#x3D;\&quot;/docs/sub_account/api-management#email-address\&quot;&gt;Sub-account email&lt;/a&gt;
func (r ApiGetSubAccountSubAccountApiIpRestrictionV1Request) Email(email string) ApiGetSubAccountSubAccountApiIpRestrictionV1Request {
	r.email = &email
	return r
}

func (r ApiGetSubAccountSubAccountApiIpRestrictionV1Request) SubAccountApiKey(subAccountApiKey string) ApiGetSubAccountSubAccountApiIpRestrictionV1Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r ApiGetSubAccountSubAccountApiIpRestrictionV1Request) Timestamp(timestamp int64) ApiGetSubAccountSubAccountApiIpRestrictionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountSubAccountApiIpRestrictionV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountSubAccountApiIpRestrictionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountSubAccountApiIpRestrictionV1Request) Execute() (*GetSubAccountSubAccountApiIpRestrictionV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountSubAccountApiIpRestrictionV1Execute(r)
}

/*
GetSubAccountSubAccountApiIpRestrictionV1 Get IP Restriction for a Sub-account API Key(For Master Account)

Get IP Restriction for a Sub-account API Key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountSubAccountApiIpRestrictionV1Request
*/
func (a *SubAccountAPIService) GetSubAccountSubAccountApiIpRestrictionV1(ctx context.Context) ApiGetSubAccountSubAccountApiIpRestrictionV1Request {
	return ApiGetSubAccountSubAccountApiIpRestrictionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountSubAccountApiIpRestrictionV1Resp
func (a *SubAccountAPIService) GetSubAccountSubAccountApiIpRestrictionV1Execute(r ApiGetSubAccountSubAccountApiIpRestrictionV1Request) (*GetSubAccountSubAccountApiIpRestrictionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountSubAccountApiIpRestrictionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountSubAccountApiIpRestrictionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/subAccountApi/ipRestriction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountApiKey", r.subAccountApiKey, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountSubTransferHistoryV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	timestamp *int64
	fromEmail *string
	toEmail *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ApiGetSubAccountSubTransferHistoryV1Request) Timestamp(timestamp int64) ApiGetSubAccountSubTransferHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountSubTransferHistoryV1Request) FromEmail(fromEmail string) ApiGetSubAccountSubTransferHistoryV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r ApiGetSubAccountSubTransferHistoryV1Request) ToEmail(toEmail string) ApiGetSubAccountSubTransferHistoryV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiGetSubAccountSubTransferHistoryV1Request) StartTime(startTime int64) ApiGetSubAccountSubTransferHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSubAccountSubTransferHistoryV1Request) EndTime(endTime int64) ApiGetSubAccountSubTransferHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default value: 1
func (r ApiGetSubAccountSubTransferHistoryV1Request) Page(page int32) ApiGetSubAccountSubTransferHistoryV1Request {
	r.page = &page
	return r
}

// Default value: 500
func (r ApiGetSubAccountSubTransferHistoryV1Request) Limit(limit int32) ApiGetSubAccountSubTransferHistoryV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetSubAccountSubTransferHistoryV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountSubTransferHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountSubTransferHistoryV1Request) Execute() ([]GetSubAccountSubTransferHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.GetSubAccountSubTransferHistoryV1Execute(r)
}

/*
GetSubAccountSubTransferHistoryV1 Query Sub-account Spot Asset Transfer History(For Master Account)

Query Sub-account Spot Asset Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountSubTransferHistoryV1Request
*/
func (a *SubAccountAPIService) GetSubAccountSubTransferHistoryV1(ctx context.Context) ApiGetSubAccountSubTransferHistoryV1Request {
	return ApiGetSubAccountSubTransferHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetSubAccountSubTransferHistoryV1RespItem
func (a *SubAccountAPIService) GetSubAccountSubTransferHistoryV1Execute(r ApiGetSubAccountSubTransferHistoryV1Request) ([]GetSubAccountSubTransferHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetSubAccountSubTransferHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountSubTransferHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/sub/transfer/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromEmail", r.fromEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.fromEmail = &defaultValue
	}
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toEmail", r.toEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.toEmail = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountTransactionStatisticsV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	email *string
	timestamp *int64
	recvWindow *int64
}

// Sub user email
func (r ApiGetSubAccountTransactionStatisticsV1Request) Email(email string) ApiGetSubAccountTransactionStatisticsV1Request {
	r.email = &email
	return r
}

func (r ApiGetSubAccountTransactionStatisticsV1Request) Timestamp(timestamp int64) ApiGetSubAccountTransactionStatisticsV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountTransactionStatisticsV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountTransactionStatisticsV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountTransactionStatisticsV1Request) Execute() (*SubaccountGetSubAccountTransactionStatisticsV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountTransactionStatisticsV1Execute(r)
}

/*
GetSubAccountTransactionStatisticsV1 Query Sub-account Transaction Statistics(For Master Account)(USER_DATA)

Query Sub-account Transaction statistics (For Master Account).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountTransactionStatisticsV1Request
*/
func (a *SubAccountAPIService) GetSubAccountTransactionStatisticsV1(ctx context.Context) ApiGetSubAccountTransactionStatisticsV1Request {
	return ApiGetSubAccountTransactionStatisticsV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountGetSubAccountTransactionStatisticsV1Resp
func (a *SubAccountAPIService) GetSubAccountTransactionStatisticsV1Execute(r ApiGetSubAccountTransactionStatisticsV1Request) (*SubaccountGetSubAccountTransactionStatisticsV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountGetSubAccountTransactionStatisticsV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountTransactionStatisticsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transaction-statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountTransferSubUserHistoryV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	timestamp *int64
	asset *string
	type_ *int32
	startTime *int64
	endTime *int64
	limit *int32
	returnFailHistory *bool
	recvWindow *int64
}

func (r ApiGetSubAccountTransferSubUserHistoryV1Request) Timestamp(timestamp int64) ApiGetSubAccountTransferSubUserHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// If not sent, result of all assets will be returned
func (r ApiGetSubAccountTransferSubUserHistoryV1Request) Asset(asset string) ApiGetSubAccountTransferSubUserHistoryV1Request {
	r.asset = &asset
	return r
}

// 1: transfer in, 2: transfer out
func (r ApiGetSubAccountTransferSubUserHistoryV1Request) Type_(type_ int32) ApiGetSubAccountTransferSubUserHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r ApiGetSubAccountTransferSubUserHistoryV1Request) StartTime(startTime int64) ApiGetSubAccountTransferSubUserHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSubAccountTransferSubUserHistoryV1Request) EndTime(endTime int64) ApiGetSubAccountTransferSubUserHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default 500
func (r ApiGetSubAccountTransferSubUserHistoryV1Request) Limit(limit int32) ApiGetSubAccountTransferSubUserHistoryV1Request {
	r.limit = &limit
	return r
}

// Default &#x60;False&#x60;, return PROCESS and SUCCESS status history; If &#x60;True&#x60;,return PROCESS and SUCCESS and FAILURE status history
func (r ApiGetSubAccountTransferSubUserHistoryV1Request) ReturnFailHistory(returnFailHistory bool) ApiGetSubAccountTransferSubUserHistoryV1Request {
	r.returnFailHistory = &returnFailHistory
	return r
}

func (r ApiGetSubAccountTransferSubUserHistoryV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountTransferSubUserHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountTransferSubUserHistoryV1Request) Execute() ([]GetSubAccountTransferSubUserHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.GetSubAccountTransferSubUserHistoryV1Execute(r)
}

/*
GetSubAccountTransferSubUserHistoryV1 Sub-account Transfer History(For Sub-account)

Sub-account Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountTransferSubUserHistoryV1Request
*/
func (a *SubAccountAPIService) GetSubAccountTransferSubUserHistoryV1(ctx context.Context) ApiGetSubAccountTransferSubUserHistoryV1Request {
	return ApiGetSubAccountTransferSubUserHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetSubAccountTransferSubUserHistoryV1RespItem
func (a *SubAccountAPIService) GetSubAccountTransferSubUserHistoryV1Execute(r ApiGetSubAccountTransferSubUserHistoryV1Request) ([]GetSubAccountTransferSubUserHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetSubAccountTransferSubUserHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountTransferSubUserHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subUserHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.returnFailHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnFailHistory", r.returnFailHistory, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubAccountUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *SubAccountAPIService
	timestamp *int64
	fromEmail *string
	toEmail *string
	clientTranId *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ApiGetSubAccountUniversalTransferV1Request) Timestamp(timestamp int64) ApiGetSubAccountUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSubAccountUniversalTransferV1Request) FromEmail(fromEmail string) ApiGetSubAccountUniversalTransferV1Request {
	r.fromEmail = &fromEmail
	return r
}

func (r ApiGetSubAccountUniversalTransferV1Request) ToEmail(toEmail string) ApiGetSubAccountUniversalTransferV1Request {
	r.toEmail = &toEmail
	return r
}

func (r ApiGetSubAccountUniversalTransferV1Request) ClientTranId(clientTranId string) ApiGetSubAccountUniversalTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r ApiGetSubAccountUniversalTransferV1Request) StartTime(startTime int64) ApiGetSubAccountUniversalTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetSubAccountUniversalTransferV1Request) EndTime(endTime int64) ApiGetSubAccountUniversalTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default 1
func (r ApiGetSubAccountUniversalTransferV1Request) Page(page int32) ApiGetSubAccountUniversalTransferV1Request {
	r.page = &page
	return r
}

// Default 500, Max 500
func (r ApiGetSubAccountUniversalTransferV1Request) Limit(limit int32) ApiGetSubAccountUniversalTransferV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetSubAccountUniversalTransferV1Request) RecvWindow(recvWindow int64) ApiGetSubAccountUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSubAccountUniversalTransferV1Request) Execute() (*GetSubAccountUniversalTransferV1Resp, *http.Response, error) {
	return r.ApiService.GetSubAccountUniversalTransferV1Execute(r)
}

/*
GetSubAccountUniversalTransferV1 Query Universal Transfer History(For Master Account)

Query Universal Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubAccountUniversalTransferV1Request
*/
func (a *SubAccountAPIService) GetSubAccountUniversalTransferV1(ctx context.Context) ApiGetSubAccountUniversalTransferV1Request {
	return ApiGetSubAccountUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSubAccountUniversalTransferV1Resp
func (a *SubAccountAPIService) GetSubAccountUniversalTransferV1Execute(r ApiGetSubAccountUniversalTransferV1Request) (*GetSubAccountUniversalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSubAccountUniversalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountAPIService.GetSubAccountUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromEmail", r.fromEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.fromEmail = &defaultValue
	}
	if r.toEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toEmail", r.toEmail, "form", "")
	} else {
		var defaultValue string = ""
		r.toEmail = &defaultValue
	}
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientTranId", r.clientTranId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientTranId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

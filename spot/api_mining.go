/*
Binance Spot API

OpenAPI specification for Binance exchange - Spot API

API version: 0.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// MiningAPIService MiningAPI service
type MiningAPIService service

type ApiCreateMiningHashTransferConfigCancelV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	configId *int32
	timestamp *int64
	userName *string
	recvWindow *int64
}

func (r ApiCreateMiningHashTransferConfigCancelV1Request) ConfigId(configId int32) ApiCreateMiningHashTransferConfigCancelV1Request {
	r.configId = &configId
	return r
}

func (r ApiCreateMiningHashTransferConfigCancelV1Request) Timestamp(timestamp int64) ApiCreateMiningHashTransferConfigCancelV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateMiningHashTransferConfigCancelV1Request) UserName(userName string) ApiCreateMiningHashTransferConfigCancelV1Request {
	r.userName = &userName
	return r
}

func (r ApiCreateMiningHashTransferConfigCancelV1Request) RecvWindow(recvWindow int64) ApiCreateMiningHashTransferConfigCancelV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateMiningHashTransferConfigCancelV1Request) Execute() (*CreateMiningHashTransferConfigCancelV1Resp, *http.Response, error) {
	return r.ApiService.CreateMiningHashTransferConfigCancelV1Execute(r)
}

/*
CreateMiningHashTransferConfigCancelV1 Cancel hashrate resale configuration(USER_DATA)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMiningHashTransferConfigCancelV1Request
*/
func (a *MiningAPIService) CreateMiningHashTransferConfigCancelV1(ctx context.Context) ApiCreateMiningHashTransferConfigCancelV1Request {
	return ApiCreateMiningHashTransferConfigCancelV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateMiningHashTransferConfigCancelV1Resp
func (a *MiningAPIService) CreateMiningHashTransferConfigCancelV1Execute(r ApiCreateMiningHashTransferConfigCancelV1Request) (*CreateMiningHashTransferConfigCancelV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateMiningHashTransferConfigCancelV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.CreateMiningHashTransferConfigCancelV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/config/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configId == nil {
		return localVarReturnValue, nil, reportError("configId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "configId", r.configId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "userName", r.userName, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMiningHashTransferConfigV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	algo *string
	endDate *int64
	hashRate *int64
	startDate *int64
	timestamp *int64
	toPoolUser *string
	userName *string
	recvWindow *int64
}

func (r ApiCreateMiningHashTransferConfigV1Request) Algo(algo string) ApiCreateMiningHashTransferConfigV1Request {
	r.algo = &algo
	return r
}

func (r ApiCreateMiningHashTransferConfigV1Request) EndDate(endDate int64) ApiCreateMiningHashTransferConfigV1Request {
	r.endDate = &endDate
	return r
}

func (r ApiCreateMiningHashTransferConfigV1Request) HashRate(hashRate int64) ApiCreateMiningHashTransferConfigV1Request {
	r.hashRate = &hashRate
	return r
}

func (r ApiCreateMiningHashTransferConfigV1Request) StartDate(startDate int64) ApiCreateMiningHashTransferConfigV1Request {
	r.startDate = &startDate
	return r
}

func (r ApiCreateMiningHashTransferConfigV1Request) Timestamp(timestamp int64) ApiCreateMiningHashTransferConfigV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateMiningHashTransferConfigV1Request) ToPoolUser(toPoolUser string) ApiCreateMiningHashTransferConfigV1Request {
	r.toPoolUser = &toPoolUser
	return r
}

func (r ApiCreateMiningHashTransferConfigV1Request) UserName(userName string) ApiCreateMiningHashTransferConfigV1Request {
	r.userName = &userName
	return r
}

func (r ApiCreateMiningHashTransferConfigV1Request) RecvWindow(recvWindow int64) ApiCreateMiningHashTransferConfigV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateMiningHashTransferConfigV1Request) Execute() (*CreateMiningHashTransferConfigV1Resp, *http.Response, error) {
	return r.ApiService.CreateMiningHashTransferConfigV1Execute(r)
}

/*
CreateMiningHashTransferConfigV1 Hashrate Resale Request(USER_DATA)

Hashrate Resale Request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMiningHashTransferConfigV1Request
*/
func (a *MiningAPIService) CreateMiningHashTransferConfigV1(ctx context.Context) ApiCreateMiningHashTransferConfigV1Request {
	return ApiCreateMiningHashTransferConfigV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateMiningHashTransferConfigV1Resp
func (a *MiningAPIService) CreateMiningHashTransferConfigV1Execute(r ApiCreateMiningHashTransferConfigV1Request) (*CreateMiningHashTransferConfigV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateMiningHashTransferConfigV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.CreateMiningHashTransferConfigV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}
	if r.hashRate == nil {
		return localVarReturnValue, nil, reportError("hashRate is required and must be specified")
	}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toPoolUser == nil {
		return localVarReturnValue, nil, reportError("toPoolUser is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "algo", r.algo, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "endDate", r.endDate, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "hashRate", r.hashRate, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "startDate", r.startDate, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toPoolUser", r.toPoolUser, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "userName", r.userName, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningHashTransferConfigDetailsListV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	timestamp *int64
	pageIndex *int32
	pageSize *int32
	recvWindow *int64
}

func (r ApiGetMiningHashTransferConfigDetailsListV1Request) Timestamp(timestamp int64) ApiGetMiningHashTransferConfigDetailsListV1Request {
	r.timestamp = &timestamp
	return r
}

// Page number, empty default first page, starting from 1
func (r ApiGetMiningHashTransferConfigDetailsListV1Request) PageIndex(pageIndex int32) ApiGetMiningHashTransferConfigDetailsListV1Request {
	r.pageIndex = &pageIndex
	return r
}

// Number of pages, minimum 10, maximum 200
func (r ApiGetMiningHashTransferConfigDetailsListV1Request) PageSize(pageSize int32) ApiGetMiningHashTransferConfigDetailsListV1Request {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetMiningHashTransferConfigDetailsListV1Request) RecvWindow(recvWindow int64) ApiGetMiningHashTransferConfigDetailsListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMiningHashTransferConfigDetailsListV1Request) Execute() (*GetMiningHashTransferConfigDetailsListV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningHashTransferConfigDetailsListV1Execute(r)
}

/*
GetMiningHashTransferConfigDetailsListV1 Hashrate Resale List (USER_DATA)

Hashrate Resale List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningHashTransferConfigDetailsListV1Request
*/
func (a *MiningAPIService) GetMiningHashTransferConfigDetailsListV1(ctx context.Context) ApiGetMiningHashTransferConfigDetailsListV1Request {
	return ApiGetMiningHashTransferConfigDetailsListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningHashTransferConfigDetailsListV1Resp
func (a *MiningAPIService) GetMiningHashTransferConfigDetailsListV1Execute(r ApiGetMiningHashTransferConfigDetailsListV1Request) (*GetMiningHashTransferConfigDetailsListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningHashTransferConfigDetailsListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningHashTransferConfigDetailsListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/config/details/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningHashTransferProfitDetailsV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	configId *int32
	userName *string
	timestamp *int64
	pageIndex *int32
	pageSize *int32
	recvWindow *int64
}

// Mining ID
func (r ApiGetMiningHashTransferProfitDetailsV1Request) ConfigId(configId int32) ApiGetMiningHashTransferProfitDetailsV1Request {
	r.configId = &configId
	return r
}

// Mining Account
func (r ApiGetMiningHashTransferProfitDetailsV1Request) UserName(userName string) ApiGetMiningHashTransferProfitDetailsV1Request {
	r.userName = &userName
	return r
}

func (r ApiGetMiningHashTransferProfitDetailsV1Request) Timestamp(timestamp int64) ApiGetMiningHashTransferProfitDetailsV1Request {
	r.timestamp = &timestamp
	return r
}

// Page number, empty default first page, starting from 1
func (r ApiGetMiningHashTransferProfitDetailsV1Request) PageIndex(pageIndex int32) ApiGetMiningHashTransferProfitDetailsV1Request {
	r.pageIndex = &pageIndex
	return r
}

// Number of pages, minimum 10, maximum 200
func (r ApiGetMiningHashTransferProfitDetailsV1Request) PageSize(pageSize int32) ApiGetMiningHashTransferProfitDetailsV1Request {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetMiningHashTransferProfitDetailsV1Request) RecvWindow(recvWindow int64) ApiGetMiningHashTransferProfitDetailsV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMiningHashTransferProfitDetailsV1Request) Execute() (*GetMiningHashTransferProfitDetailsV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningHashTransferProfitDetailsV1Execute(r)
}

/*
GetMiningHashTransferProfitDetailsV1 Hashrate Resale Detail(USER_DATA)

Hashrate Resale Detail(USER_DATA)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningHashTransferProfitDetailsV1Request
*/
func (a *MiningAPIService) GetMiningHashTransferProfitDetailsV1(ctx context.Context) ApiGetMiningHashTransferProfitDetailsV1Request {
	return ApiGetMiningHashTransferProfitDetailsV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningHashTransferProfitDetailsV1Resp
func (a *MiningAPIService) GetMiningHashTransferProfitDetailsV1Execute(r ApiGetMiningHashTransferProfitDetailsV1Request) (*GetMiningHashTransferProfitDetailsV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningHashTransferProfitDetailsV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningHashTransferProfitDetailsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/profit/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configId == nil {
		return localVarReturnValue, nil, reportError("configId is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "configId", r.configId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "form", "")
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningPaymentListV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	algo *string
	userName *string
	timestamp *int64
	coin *string
	startDate *int64
	endDate *int64
	pageIndex *int32
	pageSize *int32
	recvWindow *int64
}

// Transfer algorithm(sha256)
func (r ApiGetMiningPaymentListV1Request) Algo(algo string) ApiGetMiningPaymentListV1Request {
	r.algo = &algo
	return r
}

// Mining account
func (r ApiGetMiningPaymentListV1Request) UserName(userName string) ApiGetMiningPaymentListV1Request {
	r.userName = &userName
	return r
}

func (r ApiGetMiningPaymentListV1Request) Timestamp(timestamp int64) ApiGetMiningPaymentListV1Request {
	r.timestamp = &timestamp
	return r
}

// Coin name
func (r ApiGetMiningPaymentListV1Request) Coin(coin string) ApiGetMiningPaymentListV1Request {
	r.coin = &coin
	return r
}

// Search date, millisecond timestamp, while empty query all
func (r ApiGetMiningPaymentListV1Request) StartDate(startDate int64) ApiGetMiningPaymentListV1Request {
	r.startDate = &startDate
	return r
}

// Search date, millisecond timestamp, while empty query all
func (r ApiGetMiningPaymentListV1Request) EndDate(endDate int64) ApiGetMiningPaymentListV1Request {
	r.endDate = &endDate
	return r
}

// Page number, empty default first page, starting from 1
func (r ApiGetMiningPaymentListV1Request) PageIndex(pageIndex int32) ApiGetMiningPaymentListV1Request {
	r.pageIndex = &pageIndex
	return r
}

// Number of pages, minimum 10, maximum 200
func (r ApiGetMiningPaymentListV1Request) PageSize(pageSize int32) ApiGetMiningPaymentListV1Request {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetMiningPaymentListV1Request) RecvWindow(recvWindow int64) ApiGetMiningPaymentListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMiningPaymentListV1Request) Execute() (*GetMiningPaymentListV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningPaymentListV1Execute(r)
}

/*
GetMiningPaymentListV1 Earnings List(USER_DATA)

Query Earnings List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningPaymentListV1Request
*/
func (a *MiningAPIService) GetMiningPaymentListV1(ctx context.Context) ApiGetMiningPaymentListV1Request {
	return ApiGetMiningPaymentListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningPaymentListV1Resp
func (a *MiningAPIService) GetMiningPaymentListV1Execute(r ApiGetMiningPaymentListV1Request) (*GetMiningPaymentListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningPaymentListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningPaymentListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/payment/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algo", r.algo, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "form", "")
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningPaymentOtherV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	algo *string
	userName *string
	timestamp *int64
	coin *string
	startDate *int64
	endDate *int64
	pageIndex *int32
	pageSize *int32
	recvWindow *int64
}

// Transfer algorithm(sha256)
func (r ApiGetMiningPaymentOtherV1Request) Algo(algo string) ApiGetMiningPaymentOtherV1Request {
	r.algo = &algo
	return r
}

// Mining Account
func (r ApiGetMiningPaymentOtherV1Request) UserName(userName string) ApiGetMiningPaymentOtherV1Request {
	r.userName = &userName
	return r
}

func (r ApiGetMiningPaymentOtherV1Request) Timestamp(timestamp int64) ApiGetMiningPaymentOtherV1Request {
	r.timestamp = &timestamp
	return r
}

// Coin Name
func (r ApiGetMiningPaymentOtherV1Request) Coin(coin string) ApiGetMiningPaymentOtherV1Request {
	r.coin = &coin
	return r
}

// Search date, millisecond timestamp, while empty query all
func (r ApiGetMiningPaymentOtherV1Request) StartDate(startDate int64) ApiGetMiningPaymentOtherV1Request {
	r.startDate = &startDate
	return r
}

// Search date, millisecond timestamp, while empty query all
func (r ApiGetMiningPaymentOtherV1Request) EndDate(endDate int64) ApiGetMiningPaymentOtherV1Request {
	r.endDate = &endDate
	return r
}

// Page number, empty default first page, starting from 1
func (r ApiGetMiningPaymentOtherV1Request) PageIndex(pageIndex int32) ApiGetMiningPaymentOtherV1Request {
	r.pageIndex = &pageIndex
	return r
}

// Number of pages, minimum 10, maximum 200
func (r ApiGetMiningPaymentOtherV1Request) PageSize(pageSize int32) ApiGetMiningPaymentOtherV1Request {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetMiningPaymentOtherV1Request) RecvWindow(recvWindow int64) ApiGetMiningPaymentOtherV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMiningPaymentOtherV1Request) Execute() (*GetMiningPaymentOtherV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningPaymentOtherV1Execute(r)
}

/*
GetMiningPaymentOtherV1 Extra Bonus List(USER_DATA)

Extra Bonus List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningPaymentOtherV1Request
*/
func (a *MiningAPIService) GetMiningPaymentOtherV1(ctx context.Context) ApiGetMiningPaymentOtherV1Request {
	return ApiGetMiningPaymentOtherV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningPaymentOtherV1Resp
func (a *MiningAPIService) GetMiningPaymentOtherV1Execute(r ApiGetMiningPaymentOtherV1Request) (*GetMiningPaymentOtherV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningPaymentOtherV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningPaymentOtherV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/payment/other"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algo", r.algo, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "form", "")
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningPaymentUidV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	algo *string
	timestamp *int64
	startDate *int64
	endDate *int64
	pageIndex *int32
	pageSize *int32
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiGetMiningPaymentUidV1Request) Algo(algo string) ApiGetMiningPaymentUidV1Request {
	r.algo = &algo
	return r
}

func (r ApiGetMiningPaymentUidV1Request) Timestamp(timestamp int64) ApiGetMiningPaymentUidV1Request {
	r.timestamp = &timestamp
	return r
}

// Millisecond timestamp
func (r ApiGetMiningPaymentUidV1Request) StartDate(startDate int64) ApiGetMiningPaymentUidV1Request {
	r.startDate = &startDate
	return r
}

// Millisecond timestamp
func (r ApiGetMiningPaymentUidV1Request) EndDate(endDate int64) ApiGetMiningPaymentUidV1Request {
	r.endDate = &endDate
	return r
}

// Default 1
func (r ApiGetMiningPaymentUidV1Request) PageIndex(pageIndex int32) ApiGetMiningPaymentUidV1Request {
	r.pageIndex = &pageIndex
	return r
}

// Min 10,Max 200
func (r ApiGetMiningPaymentUidV1Request) PageSize(pageSize int32) ApiGetMiningPaymentUidV1Request {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetMiningPaymentUidV1Request) RecvWindow(recvWindow int64) ApiGetMiningPaymentUidV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMiningPaymentUidV1Request) Execute() (*GetMiningPaymentUidV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningPaymentUidV1Execute(r)
}

/*
GetMiningPaymentUidV1 Mining Account Earning(USER_DATA)

Mining Account Earning

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningPaymentUidV1Request
*/
func (a *MiningAPIService) GetMiningPaymentUidV1(ctx context.Context) ApiGetMiningPaymentUidV1Request {
	return ApiGetMiningPaymentUidV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningPaymentUidV1Resp
func (a *MiningAPIService) GetMiningPaymentUidV1Execute(r ApiGetMiningPaymentUidV1Request) (*GetMiningPaymentUidV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningPaymentUidV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningPaymentUidV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/payment/uid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algo", r.algo, "form", "")
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageIndex = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningPubAlgoListV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
}

func (r ApiGetMiningPubAlgoListV1Request) Execute() (*GetMiningPubAlgoListV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningPubAlgoListV1Execute(r)
}

/*
GetMiningPubAlgoListV1 Acquiring Algorithm(MARKET_DATA)

Acquiring Algorithm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningPubAlgoListV1Request
*/
func (a *MiningAPIService) GetMiningPubAlgoListV1(ctx context.Context) ApiGetMiningPubAlgoListV1Request {
	return ApiGetMiningPubAlgoListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningPubAlgoListV1Resp
func (a *MiningAPIService) GetMiningPubAlgoListV1Execute(r ApiGetMiningPubAlgoListV1Request) (*GetMiningPubAlgoListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningPubAlgoListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningPubAlgoListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/pub/algoList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningPubCoinListV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
}

func (r ApiGetMiningPubCoinListV1Request) Execute() (*GetMiningPubCoinListV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningPubCoinListV1Execute(r)
}

/*
GetMiningPubCoinListV1 Acquiring CoinName(MARKET_DATA)

Acquiring CoinName

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningPubCoinListV1Request
*/
func (a *MiningAPIService) GetMiningPubCoinListV1(ctx context.Context) ApiGetMiningPubCoinListV1Request {
	return ApiGetMiningPubCoinListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningPubCoinListV1Resp
func (a *MiningAPIService) GetMiningPubCoinListV1Execute(r ApiGetMiningPubCoinListV1Request) (*GetMiningPubCoinListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningPubCoinListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningPubCoinListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/pub/coinList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningStatisticsUserListV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	algo *string
	userName *string
	timestamp *int64
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiGetMiningStatisticsUserListV1Request) Algo(algo string) ApiGetMiningStatisticsUserListV1Request {
	r.algo = &algo
	return r
}

// Mining account
func (r ApiGetMiningStatisticsUserListV1Request) UserName(userName string) ApiGetMiningStatisticsUserListV1Request {
	r.userName = &userName
	return r
}

func (r ApiGetMiningStatisticsUserListV1Request) Timestamp(timestamp int64) ApiGetMiningStatisticsUserListV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetMiningStatisticsUserListV1Request) RecvWindow(recvWindow int64) ApiGetMiningStatisticsUserListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMiningStatisticsUserListV1Request) Execute() (*GetMiningStatisticsUserListV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningStatisticsUserListV1Execute(r)
}

/*
GetMiningStatisticsUserListV1 Account List(USER_DATA)

Query Account List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningStatisticsUserListV1Request
*/
func (a *MiningAPIService) GetMiningStatisticsUserListV1(ctx context.Context) ApiGetMiningStatisticsUserListV1Request {
	return ApiGetMiningStatisticsUserListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningStatisticsUserListV1Resp
func (a *MiningAPIService) GetMiningStatisticsUserListV1Execute(r ApiGetMiningStatisticsUserListV1Request) (*GetMiningStatisticsUserListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningStatisticsUserListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningStatisticsUserListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/statistics/user/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algo", r.algo, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningStatisticsUserStatusV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	algo *string
	userName *string
	timestamp *int64
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiGetMiningStatisticsUserStatusV1Request) Algo(algo string) ApiGetMiningStatisticsUserStatusV1Request {
	r.algo = &algo
	return r
}

// Mining account
func (r ApiGetMiningStatisticsUserStatusV1Request) UserName(userName string) ApiGetMiningStatisticsUserStatusV1Request {
	r.userName = &userName
	return r
}

func (r ApiGetMiningStatisticsUserStatusV1Request) Timestamp(timestamp int64) ApiGetMiningStatisticsUserStatusV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetMiningStatisticsUserStatusV1Request) RecvWindow(recvWindow int64) ApiGetMiningStatisticsUserStatusV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMiningStatisticsUserStatusV1Request) Execute() (*GetMiningStatisticsUserStatusV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningStatisticsUserStatusV1Execute(r)
}

/*
GetMiningStatisticsUserStatusV1 Statistic List(USER_DATA)

Statistic List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningStatisticsUserStatusV1Request
*/
func (a *MiningAPIService) GetMiningStatisticsUserStatusV1(ctx context.Context) ApiGetMiningStatisticsUserStatusV1Request {
	return ApiGetMiningStatisticsUserStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningStatisticsUserStatusV1Resp
func (a *MiningAPIService) GetMiningStatisticsUserStatusV1Execute(r ApiGetMiningStatisticsUserStatusV1Request) (*GetMiningStatisticsUserStatusV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningStatisticsUserStatusV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningStatisticsUserStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/statistics/user/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algo", r.algo, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningWorkerDetailV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	algo *string
	userName *string
	workerName *string
	timestamp *int64
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiGetMiningWorkerDetailV1Request) Algo(algo string) ApiGetMiningWorkerDetailV1Request {
	r.algo = &algo
	return r
}

// Mining account
func (r ApiGetMiningWorkerDetailV1Request) UserName(userName string) ApiGetMiningWorkerDetailV1Request {
	r.userName = &userName
	return r
}

// Miner’s name(required)
func (r ApiGetMiningWorkerDetailV1Request) WorkerName(workerName string) ApiGetMiningWorkerDetailV1Request {
	r.workerName = &workerName
	return r
}

func (r ApiGetMiningWorkerDetailV1Request) Timestamp(timestamp int64) ApiGetMiningWorkerDetailV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetMiningWorkerDetailV1Request) RecvWindow(recvWindow int64) ApiGetMiningWorkerDetailV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMiningWorkerDetailV1Request) Execute() (*GetMiningWorkerDetailV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningWorkerDetailV1Execute(r)
}

/*
GetMiningWorkerDetailV1 Request for Detail Miner List(USER_DATA)

Request for Detail Miner List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningWorkerDetailV1Request
*/
func (a *MiningAPIService) GetMiningWorkerDetailV1(ctx context.Context) ApiGetMiningWorkerDetailV1Request {
	return ApiGetMiningWorkerDetailV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningWorkerDetailV1Resp
func (a *MiningAPIService) GetMiningWorkerDetailV1Execute(r ApiGetMiningWorkerDetailV1Request) (*GetMiningWorkerDetailV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningWorkerDetailV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningWorkerDetailV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/worker/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.workerName == nil {
		return localVarReturnValue, nil, reportError("workerName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algo", r.algo, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "workerName", r.workerName, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiningWorkerListV1Request struct {
	ctx context.Context
	ApiService *MiningAPIService
	algo *string
	userName *string
	timestamp *int64
	pageIndex *int32
	sort *int32
	sortColumn *int32
	workerStatus *int32
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiGetMiningWorkerListV1Request) Algo(algo string) ApiGetMiningWorkerListV1Request {
	r.algo = &algo
	return r
}

// Mining account
func (r ApiGetMiningWorkerListV1Request) UserName(userName string) ApiGetMiningWorkerListV1Request {
	r.userName = &userName
	return r
}

func (r ApiGetMiningWorkerListV1Request) Timestamp(timestamp int64) ApiGetMiningWorkerListV1Request {
	r.timestamp = &timestamp
	return r
}

// Page number，default is first page，start form 1
func (r ApiGetMiningWorkerListV1Request) PageIndex(pageIndex int32) ApiGetMiningWorkerListV1Request {
	r.pageIndex = &pageIndex
	return r
}

// sort sequence(default&#x3D;0)0 positive sequence，1 negative sequence
func (r ApiGetMiningWorkerListV1Request) Sort(sort int32) ApiGetMiningWorkerListV1Request {
	r.sort = &sort
	return r
}

// Sort by( default 1): &lt;br/&gt;&lt;br/&gt;1: miner name, &lt;br/&gt;&lt;br/&gt;2: real-time computing power, &lt;br/&gt;&lt;br/&gt;3: daily average computing power, &lt;br/&gt;&lt;br/&gt;4: real-time rejection rate, &lt;br/&gt;&lt;br/&gt;5: last submission time
func (r ApiGetMiningWorkerListV1Request) SortColumn(sortColumn int32) ApiGetMiningWorkerListV1Request {
	r.sortColumn = &sortColumn
	return r
}

// miners status(default&#x3D;0),0 all，1 valid，2 invalid，3 failure
func (r ApiGetMiningWorkerListV1Request) WorkerStatus(workerStatus int32) ApiGetMiningWorkerListV1Request {
	r.workerStatus = &workerStatus
	return r
}

func (r ApiGetMiningWorkerListV1Request) RecvWindow(recvWindow int64) ApiGetMiningWorkerListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetMiningWorkerListV1Request) Execute() (*GetMiningWorkerListV1Resp, *http.Response, error) {
	return r.ApiService.GetMiningWorkerListV1Execute(r)
}

/*
GetMiningWorkerListV1 Request for Miner List(USER_DATA)

Request for Miner List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiningWorkerListV1Request
*/
func (a *MiningAPIService) GetMiningWorkerListV1(ctx context.Context) ApiGetMiningWorkerListV1Request {
	return ApiGetMiningWorkerListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiningWorkerListV1Resp
func (a *MiningAPIService) GetMiningWorkerListV1Execute(r ApiGetMiningWorkerListV1Request) (*GetMiningWorkerListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiningWorkerListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningAPIService.GetMiningWorkerListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/worker/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "algo", r.algo, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "form", "")
	if r.pageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageIndex", r.pageIndex, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.sortColumn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortColumn", r.sortColumn, "form", "")
	} else {
		var defaultValue int32 = 1
		r.sortColumn = &defaultValue
	}
	if r.workerStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workerStatus", r.workerStatus, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

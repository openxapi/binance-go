/*
Binance Spot API

OpenAPI specification for Binance exchange - Spot API

API version: 0.2.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// WalletAPIService WalletAPI service
type WalletAPIService service

type ApiCreateAccountDisableFastWithdrawSwitchV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateAccountDisableFastWithdrawSwitchV1Request) Timestamp(timestamp int64) ApiCreateAccountDisableFastWithdrawSwitchV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateAccountDisableFastWithdrawSwitchV1Request) RecvWindow(recvWindow int64) ApiCreateAccountDisableFastWithdrawSwitchV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateAccountDisableFastWithdrawSwitchV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateAccountDisableFastWithdrawSwitchV1Execute(r)
}

/*
CreateAccountDisableFastWithdrawSwitchV1 Disable Fast Withdraw Switch (USER_DATA)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountDisableFastWithdrawSwitchV1Request
*/
func (a *WalletAPIService) CreateAccountDisableFastWithdrawSwitchV1(ctx context.Context) ApiCreateAccountDisableFastWithdrawSwitchV1Request {
	return ApiCreateAccountDisableFastWithdrawSwitchV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *WalletAPIService) CreateAccountDisableFastWithdrawSwitchV1Execute(r ApiCreateAccountDisableFastWithdrawSwitchV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateAccountDisableFastWithdrawSwitchV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/disableFastWithdrawSwitch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountEnableFastWithdrawSwitchV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateAccountEnableFastWithdrawSwitchV1Request) Timestamp(timestamp int64) ApiCreateAccountEnableFastWithdrawSwitchV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateAccountEnableFastWithdrawSwitchV1Request) RecvWindow(recvWindow int64) ApiCreateAccountEnableFastWithdrawSwitchV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateAccountEnableFastWithdrawSwitchV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateAccountEnableFastWithdrawSwitchV1Execute(r)
}

/*
CreateAccountEnableFastWithdrawSwitchV1 Enable Fast Withdraw Switch (USER_DATA)

Enable Fast Withdraw Switch (USER_DATA)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountEnableFastWithdrawSwitchV1Request
*/
func (a *WalletAPIService) CreateAccountEnableFastWithdrawSwitchV1(ctx context.Context) ApiCreateAccountEnableFastWithdrawSwitchV1Request {
	return ApiCreateAccountEnableFastWithdrawSwitchV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *WalletAPIService) CreateAccountEnableFastWithdrawSwitchV1Execute(r ApiCreateAccountEnableFastWithdrawSwitchV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateAccountEnableFastWithdrawSwitchV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/enableFastWithdrawSwitch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetDustBtcV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	accountType *string
	recvWindow *int64
}

func (r ApiCreateAssetDustBtcV1Request) Timestamp(timestamp int64) ApiCreateAssetDustBtcV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateAssetDustBtcV1Request) AccountType(accountType string) ApiCreateAssetDustBtcV1Request {
	r.accountType = &accountType
	return r
}

func (r ApiCreateAssetDustBtcV1Request) RecvWindow(recvWindow int64) ApiCreateAssetDustBtcV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateAssetDustBtcV1Request) Execute() (*CreateAssetDustBtcV1Resp, *http.Response, error) {
	return r.ApiService.CreateAssetDustBtcV1Execute(r)
}

/*
CreateAssetDustBtcV1 Get Assets That Can Be Converted Into BNB (USER_DATA)

Get Assets That Can Be Converted Into BNB

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetDustBtcV1Request
*/
func (a *WalletAPIService) CreateAssetDustBtcV1(ctx context.Context) ApiCreateAssetDustBtcV1Request {
	return ApiCreateAssetDustBtcV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAssetDustBtcV1Resp
func (a *WalletAPIService) CreateAssetDustBtcV1Execute(r ApiCreateAssetDustBtcV1Request) (*CreateAssetDustBtcV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAssetDustBtcV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateAssetDustBtcV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dust-btc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "accountType", r.accountType, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetDustV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	asset *[]string
	timestamp *int64
	accountType *string
	recvWindow *int64
}

func (r ApiCreateAssetDustV1Request) Asset(asset []string) ApiCreateAssetDustV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateAssetDustV1Request) Timestamp(timestamp int64) ApiCreateAssetDustV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateAssetDustV1Request) AccountType(accountType string) ApiCreateAssetDustV1Request {
	r.accountType = &accountType
	return r
}

func (r ApiCreateAssetDustV1Request) RecvWindow(recvWindow int64) ApiCreateAssetDustV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateAssetDustV1Request) Execute() (*CreateAssetDustV1Resp, *http.Response, error) {
	return r.ApiService.CreateAssetDustV1Execute(r)
}

/*
CreateAssetDustV1 Dust Transfer (USER_DATA)

Convert dust assets to BNB.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetDustV1Request
*/
func (a *WalletAPIService) CreateAssetDustV1(ctx context.Context) ApiCreateAssetDustV1Request {
	return ApiCreateAssetDustV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAssetDustV1Resp
func (a *WalletAPIService) CreateAssetDustV1Execute(r ApiCreateAssetDustV1Request) (*CreateAssetDustV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAssetDustV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateAssetDustV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dust"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "accountType", r.accountType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "csv")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetGetFundingAssetV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	asset *string
	needBtcValuation *string
	recvWindow *int64
}

func (r ApiCreateAssetGetFundingAssetV1Request) Timestamp(timestamp int64) ApiCreateAssetGetFundingAssetV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateAssetGetFundingAssetV1Request) Asset(asset string) ApiCreateAssetGetFundingAssetV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateAssetGetFundingAssetV1Request) NeedBtcValuation(needBtcValuation string) ApiCreateAssetGetFundingAssetV1Request {
	r.needBtcValuation = &needBtcValuation
	return r
}

func (r ApiCreateAssetGetFundingAssetV1Request) RecvWindow(recvWindow int64) ApiCreateAssetGetFundingAssetV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateAssetGetFundingAssetV1Request) Execute() ([]CreateAssetGetFundingAssetV1RespItem, *http.Response, error) {
	return r.ApiService.CreateAssetGetFundingAssetV1Execute(r)
}

/*
CreateAssetGetFundingAssetV1 Funding Wallet (USER_DATA)

Query Funding Wallet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetGetFundingAssetV1Request
*/
func (a *WalletAPIService) CreateAssetGetFundingAssetV1(ctx context.Context) ApiCreateAssetGetFundingAssetV1Request {
	return ApiCreateAssetGetFundingAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CreateAssetGetFundingAssetV1RespItem
func (a *WalletAPIService) CreateAssetGetFundingAssetV1Execute(r ApiCreateAssetGetFundingAssetV1Request) ([]CreateAssetGetFundingAssetV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CreateAssetGetFundingAssetV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateAssetGetFundingAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/get-funding-asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	}
	if r.needBtcValuation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "needBtcValuation", r.needBtcValuation, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetGetUserAssetV3Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	asset *string
	needBtcValuation *bool
	recvWindow *int64
}

func (r ApiCreateAssetGetUserAssetV3Request) Timestamp(timestamp int64) ApiCreateAssetGetUserAssetV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateAssetGetUserAssetV3Request) Asset(asset string) ApiCreateAssetGetUserAssetV3Request {
	r.asset = &asset
	return r
}

func (r ApiCreateAssetGetUserAssetV3Request) NeedBtcValuation(needBtcValuation bool) ApiCreateAssetGetUserAssetV3Request {
	r.needBtcValuation = &needBtcValuation
	return r
}

func (r ApiCreateAssetGetUserAssetV3Request) RecvWindow(recvWindow int64) ApiCreateAssetGetUserAssetV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateAssetGetUserAssetV3Request) Execute() ([]CreateAssetGetUserAssetV3RespItem, *http.Response, error) {
	return r.ApiService.CreateAssetGetUserAssetV3Execute(r)
}

/*
CreateAssetGetUserAssetV3 User Asset (USER_DATA)

Get user assets, just for positive data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetGetUserAssetV3Request
*/
func (a *WalletAPIService) CreateAssetGetUserAssetV3(ctx context.Context) ApiCreateAssetGetUserAssetV3Request {
	return ApiCreateAssetGetUserAssetV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CreateAssetGetUserAssetV3RespItem
func (a *WalletAPIService) CreateAssetGetUserAssetV3Execute(r ApiCreateAssetGetUserAssetV3Request) ([]CreateAssetGetUserAssetV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CreateAssetGetUserAssetV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateAssetGetUserAssetV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v3/asset/getUserAsset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	}
	if r.needBtcValuation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "needBtcValuation", r.needBtcValuation, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetTransferV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	amount *string
	asset *string
	timestamp *int64
	type_ *string
	fromSymbol *string
	recvWindow *int64
	toSymbol *string
}

func (r ApiCreateAssetTransferV1Request) Amount(amount string) ApiCreateAssetTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateAssetTransferV1Request) Asset(asset string) ApiCreateAssetTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateAssetTransferV1Request) Timestamp(timestamp int64) ApiCreateAssetTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateAssetTransferV1Request) Type_(type_ string) ApiCreateAssetTransferV1Request {
	r.type_ = &type_
	return r
}

func (r ApiCreateAssetTransferV1Request) FromSymbol(fromSymbol string) ApiCreateAssetTransferV1Request {
	r.fromSymbol = &fromSymbol
	return r
}

func (r ApiCreateAssetTransferV1Request) RecvWindow(recvWindow int64) ApiCreateAssetTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateAssetTransferV1Request) ToSymbol(toSymbol string) ApiCreateAssetTransferV1Request {
	r.toSymbol = &toSymbol
	return r
}

func (r ApiCreateAssetTransferV1Request) Execute() (*CreateAssetTransferV1Resp, *http.Response, error) {
	return r.ApiService.CreateAssetTransferV1Execute(r)
}

/*
CreateAssetTransferV1 User Universal Transfer (USER_DATA)

user universal transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAssetTransferV1Request
*/
func (a *WalletAPIService) CreateAssetTransferV1(ctx context.Context) ApiCreateAssetTransferV1Request {
	return ApiCreateAssetTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAssetTransferV1Resp
func (a *WalletAPIService) CreateAssetTransferV1Execute(r ApiCreateAssetTransferV1Request) (*CreateAssetTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAssetTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateAssetTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.fromSymbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromSymbol", r.fromSymbol, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.toSymbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toSymbol", r.toSymbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBnbBurnV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	interestBNBBurn *string
	recvWindow *int64
	spotBNBBurn *string
}

func (r ApiCreateBnbBurnV1Request) Timestamp(timestamp int64) ApiCreateBnbBurnV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBnbBurnV1Request) InterestBNBBurn(interestBNBBurn string) ApiCreateBnbBurnV1Request {
	r.interestBNBBurn = &interestBNBBurn
	return r
}

func (r ApiCreateBnbBurnV1Request) RecvWindow(recvWindow int64) ApiCreateBnbBurnV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBnbBurnV1Request) SpotBNBBurn(spotBNBBurn string) ApiCreateBnbBurnV1Request {
	r.spotBNBBurn = &spotBNBBurn
	return r
}

func (r ApiCreateBnbBurnV1Request) Execute() (*CreateBnbBurnV1Resp, *http.Response, error) {
	return r.ApiService.CreateBnbBurnV1Execute(r)
}

/*
CreateBnbBurnV1 Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)

Toggle BNB Burn On Spot Trade And Margin Interest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBnbBurnV1Request
*/
func (a *WalletAPIService) CreateBnbBurnV1(ctx context.Context) ApiCreateBnbBurnV1Request {
	return ApiCreateBnbBurnV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBnbBurnV1Resp
func (a *WalletAPIService) CreateBnbBurnV1Execute(r ApiCreateBnbBurnV1Request) (*CreateBnbBurnV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBnbBurnV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateBnbBurnV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bnbBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.interestBNBBurn != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "interestBNBBurn", r.interestBNBBurn, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.spotBNBBurn != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "spotBNBBurn", r.spotBNBBurn, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCapitalDepositCreditApplyV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	depositId *int64
	subAccountId *int64
	subUserId *int64
	txId *string
}

func (r ApiCreateCapitalDepositCreditApplyV1Request) DepositId(depositId int64) ApiCreateCapitalDepositCreditApplyV1Request {
	r.depositId = &depositId
	return r
}

func (r ApiCreateCapitalDepositCreditApplyV1Request) SubAccountId(subAccountId int64) ApiCreateCapitalDepositCreditApplyV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateCapitalDepositCreditApplyV1Request) SubUserId(subUserId int64) ApiCreateCapitalDepositCreditApplyV1Request {
	r.subUserId = &subUserId
	return r
}

func (r ApiCreateCapitalDepositCreditApplyV1Request) TxId(txId string) ApiCreateCapitalDepositCreditApplyV1Request {
	r.txId = &txId
	return r
}

func (r ApiCreateCapitalDepositCreditApplyV1Request) Execute() (*CreateCapitalDepositCreditApplyV1Resp, *http.Response, error) {
	return r.ApiService.CreateCapitalDepositCreditApplyV1Execute(r)
}

/*
CreateCapitalDepositCreditApplyV1 One click arrival deposit apply (for expired address deposit) (USER_DATA)

Apply deposit credit for expired address (One click arrival)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCapitalDepositCreditApplyV1Request
*/
func (a *WalletAPIService) CreateCapitalDepositCreditApplyV1(ctx context.Context) ApiCreateCapitalDepositCreditApplyV1Request {
	return ApiCreateCapitalDepositCreditApplyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCapitalDepositCreditApplyV1Resp
func (a *WalletAPIService) CreateCapitalDepositCreditApplyV1Execute(r ApiCreateCapitalDepositCreditApplyV1Request) (*CreateCapitalDepositCreditApplyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCapitalDepositCreditApplyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateCapitalDepositCreditApplyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/credit-apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.depositId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "depositId", r.depositId, "", "")
	}
	if r.subAccountId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	}
	if r.subUserId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "subUserId", r.subUserId, "", "")
	}
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "txId", r.txId, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCapitalWithdrawApplyV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	address *string
	amount *string
	coin *string
	timestamp *int64
	addressTag *string
	name *string
	network *string
	recvWindow *int64
	transactionFeeFlag *bool
	walletType *int32
	withdrawOrderId *string
}

func (r ApiCreateCapitalWithdrawApplyV1Request) Address(address string) ApiCreateCapitalWithdrawApplyV1Request {
	r.address = &address
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) Amount(amount string) ApiCreateCapitalWithdrawApplyV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) Coin(coin string) ApiCreateCapitalWithdrawApplyV1Request {
	r.coin = &coin
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) Timestamp(timestamp int64) ApiCreateCapitalWithdrawApplyV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) AddressTag(addressTag string) ApiCreateCapitalWithdrawApplyV1Request {
	r.addressTag = &addressTag
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) Name(name string) ApiCreateCapitalWithdrawApplyV1Request {
	r.name = &name
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) Network(network string) ApiCreateCapitalWithdrawApplyV1Request {
	r.network = &network
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) RecvWindow(recvWindow int64) ApiCreateCapitalWithdrawApplyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) TransactionFeeFlag(transactionFeeFlag bool) ApiCreateCapitalWithdrawApplyV1Request {
	r.transactionFeeFlag = &transactionFeeFlag
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) WalletType(walletType int32) ApiCreateCapitalWithdrawApplyV1Request {
	r.walletType = &walletType
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) WithdrawOrderId(withdrawOrderId string) ApiCreateCapitalWithdrawApplyV1Request {
	r.withdrawOrderId = &withdrawOrderId
	return r
}

func (r ApiCreateCapitalWithdrawApplyV1Request) Execute() (*CreateCapitalWithdrawApplyV1Resp, *http.Response, error) {
	return r.ApiService.CreateCapitalWithdrawApplyV1Execute(r)
}

/*
CreateCapitalWithdrawApplyV1 Withdraw(USER_DATA)

Submit a withdraw request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCapitalWithdrawApplyV1Request
*/
func (a *WalletAPIService) CreateCapitalWithdrawApplyV1(ctx context.Context) ApiCreateCapitalWithdrawApplyV1Request {
	return ApiCreateCapitalWithdrawApplyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCapitalWithdrawApplyV1Resp
func (a *WalletAPIService) CreateCapitalWithdrawApplyV1Execute(r ApiCreateCapitalWithdrawApplyV1Request) (*CreateCapitalWithdrawApplyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCapitalWithdrawApplyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateCapitalWithdrawApplyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/withdraw/apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.address == nil {
		return localVarReturnValue, nil, reportError("address is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "address", r.address, "", "")
	if r.addressTag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "addressTag", r.addressTag, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "coin", r.coin, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "network", r.network, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.transactionFeeFlag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transactionFeeFlag", r.transactionFeeFlag, "", "")
	}
	if r.walletType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "walletType", r.walletType, "", "")
	}
	if r.withdrawOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "withdrawOrderId", r.withdrawOrderId, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLocalentityBrokerWithdrawApplyV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	address *string
	amount *string
	coin *string
	originatorPii *string
	questionnaire *string
	signature *string
	subAccountId *string
	timestamp *int64
	withdrawOrderId *string
	addressName *string
	addressTag *string
	network *string
	transactionFeeFlag *bool
	walletType *int32
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) Address(address string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.address = &address
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) Amount(amount string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) Coin(coin string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.coin = &coin
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) OriginatorPii(originatorPii string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.originatorPii = &originatorPii
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) Questionnaire(questionnaire string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.questionnaire = &questionnaire
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) Signature(signature string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.signature = &signature
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) SubAccountId(subAccountId string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) Timestamp(timestamp int64) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) WithdrawOrderId(withdrawOrderId string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.withdrawOrderId = &withdrawOrderId
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) AddressName(addressName string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.addressName = &addressName
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) AddressTag(addressTag string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.addressTag = &addressTag
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) Network(network string) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.network = &network
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) TransactionFeeFlag(transactionFeeFlag bool) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.transactionFeeFlag = &transactionFeeFlag
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) WalletType(walletType int32) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	r.walletType = &walletType
	return r
}

func (r ApiCreateLocalentityBrokerWithdrawApplyV1Request) Execute() (*CreateLocalentityBrokerWithdrawApplyV1Resp, *http.Response, error) {
	return r.ApiService.CreateLocalentityBrokerWithdrawApplyV1Execute(r)
}

/*
CreateLocalentityBrokerWithdrawApplyV1 Broker Withdraw (for brokers of local entities that require travel rule) (USER_DATA)

Submit a withdrawal request for brokers of local entities that required travel rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateLocalentityBrokerWithdrawApplyV1Request
*/
func (a *WalletAPIService) CreateLocalentityBrokerWithdrawApplyV1(ctx context.Context) ApiCreateLocalentityBrokerWithdrawApplyV1Request {
	return ApiCreateLocalentityBrokerWithdrawApplyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateLocalentityBrokerWithdrawApplyV1Resp
func (a *WalletAPIService) CreateLocalentityBrokerWithdrawApplyV1Execute(r ApiCreateLocalentityBrokerWithdrawApplyV1Request) (*CreateLocalentityBrokerWithdrawApplyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLocalentityBrokerWithdrawApplyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateLocalentityBrokerWithdrawApplyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/localentity/broker/withdraw/apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.address == nil {
		return localVarReturnValue, nil, reportError("address is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.originatorPii == nil {
		return localVarReturnValue, nil, reportError("originatorPii is required and must be specified")
	}
	if r.questionnaire == nil {
		return localVarReturnValue, nil, reportError("questionnaire is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.withdrawOrderId == nil {
		return localVarReturnValue, nil, reportError("withdrawOrderId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "address", r.address, "", "")
	if r.addressName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "addressName", r.addressName, "", "")
	}
	if r.addressTag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "addressTag", r.addressTag, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "coin", r.coin, "", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "network", r.network, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "originatorPii", r.originatorPii, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "questionnaire", r.questionnaire, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "signature", r.signature, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.transactionFeeFlag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transactionFeeFlag", r.transactionFeeFlag, "", "")
	}
	if r.walletType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "walletType", r.walletType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "withdrawOrderId", r.withdrawOrderId, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLocalentityWithdrawApplyV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	address *string
	amount *string
	coin *string
	questionnaire *string
	timestamp *int64
	addressTag *string
	name *string
	network *string
	recvWindow *int64
	transactionFeeFlag *bool
	walletType *int32
	withdrawOrderId *string
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) Address(address string) ApiCreateLocalentityWithdrawApplyV1Request {
	r.address = &address
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) Amount(amount string) ApiCreateLocalentityWithdrawApplyV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) Coin(coin string) ApiCreateLocalentityWithdrawApplyV1Request {
	r.coin = &coin
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) Questionnaire(questionnaire string) ApiCreateLocalentityWithdrawApplyV1Request {
	r.questionnaire = &questionnaire
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) Timestamp(timestamp int64) ApiCreateLocalentityWithdrawApplyV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) AddressTag(addressTag string) ApiCreateLocalentityWithdrawApplyV1Request {
	r.addressTag = &addressTag
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) Name(name string) ApiCreateLocalentityWithdrawApplyV1Request {
	r.name = &name
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) Network(network string) ApiCreateLocalentityWithdrawApplyV1Request {
	r.network = &network
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) RecvWindow(recvWindow int64) ApiCreateLocalentityWithdrawApplyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) TransactionFeeFlag(transactionFeeFlag bool) ApiCreateLocalentityWithdrawApplyV1Request {
	r.transactionFeeFlag = &transactionFeeFlag
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) WalletType(walletType int32) ApiCreateLocalentityWithdrawApplyV1Request {
	r.walletType = &walletType
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) WithdrawOrderId(withdrawOrderId string) ApiCreateLocalentityWithdrawApplyV1Request {
	r.withdrawOrderId = &withdrawOrderId
	return r
}

func (r ApiCreateLocalentityWithdrawApplyV1Request) Execute() (*CreateLocalentityWithdrawApplyV1Resp, *http.Response, error) {
	return r.ApiService.CreateLocalentityWithdrawApplyV1Execute(r)
}

/*
CreateLocalentityWithdrawApplyV1 Withdraw (for local entities that require travel rule) (USER_DATA)

Submit a withdrawal request for local entities that required travel rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateLocalentityWithdrawApplyV1Request
*/
func (a *WalletAPIService) CreateLocalentityWithdrawApplyV1(ctx context.Context) ApiCreateLocalentityWithdrawApplyV1Request {
	return ApiCreateLocalentityWithdrawApplyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateLocalentityWithdrawApplyV1Resp
func (a *WalletAPIService) CreateLocalentityWithdrawApplyV1Execute(r ApiCreateLocalentityWithdrawApplyV1Request) (*CreateLocalentityWithdrawApplyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateLocalentityWithdrawApplyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.CreateLocalentityWithdrawApplyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/localentity/withdraw/apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.address == nil {
		return localVarReturnValue, nil, reportError("address is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.questionnaire == nil {
		return localVarReturnValue, nil, reportError("questionnaire is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "address", r.address, "", "")
	if r.addressTag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "addressTag", r.addressTag, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "coin", r.coin, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "network", r.network, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "questionnaire", r.questionnaire, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.transactionFeeFlag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transactionFeeFlag", r.transactionFeeFlag, "", "")
	}
	if r.walletType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "walletType", r.walletType, "", "")
	}
	if r.withdrawOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "withdrawOrderId", r.withdrawOrderId, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountApiRestrictionsV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetAccountApiRestrictionsV1Request) Timestamp(timestamp int64) ApiGetAccountApiRestrictionsV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAccountApiRestrictionsV1Request) RecvWindow(recvWindow int64) ApiGetAccountApiRestrictionsV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAccountApiRestrictionsV1Request) Execute() (*GetAccountApiRestrictionsV1Resp, *http.Response, error) {
	return r.ApiService.GetAccountApiRestrictionsV1Execute(r)
}

/*
GetAccountApiRestrictionsV1 Get API Key Permission (USER_DATA)

Get API Key Permission

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountApiRestrictionsV1Request
*/
func (a *WalletAPIService) GetAccountApiRestrictionsV1(ctx context.Context) ApiGetAccountApiRestrictionsV1Request {
	return ApiGetAccountApiRestrictionsV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountApiRestrictionsV1Resp
func (a *WalletAPIService) GetAccountApiRestrictionsV1Execute(r ApiGetAccountApiRestrictionsV1Request) (*GetAccountApiRestrictionsV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountApiRestrictionsV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAccountApiRestrictionsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/apiRestrictions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountApiTradingStatusV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetAccountApiTradingStatusV1Request) Timestamp(timestamp int64) ApiGetAccountApiTradingStatusV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAccountApiTradingStatusV1Request) RecvWindow(recvWindow int64) ApiGetAccountApiTradingStatusV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAccountApiTradingStatusV1Request) Execute() (*GetAccountApiTradingStatusV1Resp, *http.Response, error) {
	return r.ApiService.GetAccountApiTradingStatusV1Execute(r)
}

/*
GetAccountApiTradingStatusV1 Account API Trading Status (USER_DATA)

Fetch account api trading status detail.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountApiTradingStatusV1Request
*/
func (a *WalletAPIService) GetAccountApiTradingStatusV1(ctx context.Context) ApiGetAccountApiTradingStatusV1Request {
	return ApiGetAccountApiTradingStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountApiTradingStatusV1Resp
func (a *WalletAPIService) GetAccountApiTradingStatusV1Execute(r ApiGetAccountApiTradingStatusV1Request) (*GetAccountApiTradingStatusV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountApiTradingStatusV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAccountApiTradingStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/apiTradingStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountInfoV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetAccountInfoV1Request) Timestamp(timestamp int64) ApiGetAccountInfoV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAccountInfoV1Request) RecvWindow(recvWindow int64) ApiGetAccountInfoV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAccountInfoV1Request) Execute() (*GetAccountInfoV1Resp, *http.Response, error) {
	return r.ApiService.GetAccountInfoV1Execute(r)
}

/*
GetAccountInfoV1 Account info (USER_DATA)

Fetch account info detail.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountInfoV1Request
*/
func (a *WalletAPIService) GetAccountInfoV1(ctx context.Context) ApiGetAccountInfoV1Request {
	return ApiGetAccountInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountInfoV1Resp
func (a *WalletAPIService) GetAccountInfoV1Execute(r ApiGetAccountInfoV1Request) (*GetAccountInfoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountInfoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAccountInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountSnapshotV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	type_ *string
	timestamp *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

// &amp;#34;SPOT&amp;#34;, &amp;#34;MARGIN&amp;#34;, &amp;#34;FUTURES&amp;#34;
func (r ApiGetAccountSnapshotV1Request) Type_(type_ string) ApiGetAccountSnapshotV1Request {
	r.type_ = &type_
	return r
}

func (r ApiGetAccountSnapshotV1Request) Timestamp(timestamp int64) ApiGetAccountSnapshotV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAccountSnapshotV1Request) StartTime(startTime int64) ApiGetAccountSnapshotV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetAccountSnapshotV1Request) EndTime(endTime int64) ApiGetAccountSnapshotV1Request {
	r.endTime = &endTime
	return r
}

// min 7, max 30, default 7
func (r ApiGetAccountSnapshotV1Request) Limit(limit int32) ApiGetAccountSnapshotV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetAccountSnapshotV1Request) RecvWindow(recvWindow int64) ApiGetAccountSnapshotV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAccountSnapshotV1Request) Execute() (*GetAccountSnapshotV1Resp, *http.Response, error) {
	return r.ApiService.GetAccountSnapshotV1Execute(r)
}

/*
GetAccountSnapshotV1 Daily Account Snapshot (USER_DATA)

Daily account snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountSnapshotV1Request
*/
func (a *WalletAPIService) GetAccountSnapshotV1(ctx context.Context) ApiGetAccountSnapshotV1Request {
	return ApiGetAccountSnapshotV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountSnapshotV1Resp
func (a *WalletAPIService) GetAccountSnapshotV1Execute(r ApiGetAccountSnapshotV1Request) (*GetAccountSnapshotV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountSnapshotV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAccountSnapshotV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/accountSnapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 7
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountStatusV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetAccountStatusV1Request) Timestamp(timestamp int64) ApiGetAccountStatusV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAccountStatusV1Request) RecvWindow(recvWindow int64) ApiGetAccountStatusV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAccountStatusV1Request) Execute() (*GetAccountStatusV1Resp, *http.Response, error) {
	return r.ApiService.GetAccountStatusV1Execute(r)
}

/*
GetAccountStatusV1 Account Status (USER_DATA)

Fetch account status detail.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountStatusV1Request
*/
func (a *WalletAPIService) GetAccountStatusV1(ctx context.Context) ApiGetAccountStatusV1Request {
	return ApiGetAccountStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccountStatusV1Resp
func (a *WalletAPIService) GetAccountStatusV1Execute(r ApiGetAccountStatusV1Request) (*GetAccountStatusV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountStatusV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAccountStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetAssetDetailV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetAssetAssetDetailV1Request) Timestamp(timestamp int64) ApiGetAssetAssetDetailV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAssetAssetDetailV1Request) RecvWindow(recvWindow int64) ApiGetAssetAssetDetailV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAssetAssetDetailV1Request) Execute() (*map[string]WalletGetAssetAssetDetailV1RespValue, *http.Response, error) {
	return r.ApiService.GetAssetAssetDetailV1Execute(r)
}

/*
GetAssetAssetDetailV1 Asset Detail (USER_DATA)

Fetch details of assets supported on Binance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetAssetDetailV1Request
*/
func (a *WalletAPIService) GetAssetAssetDetailV1(ctx context.Context) ApiGetAssetAssetDetailV1Request {
	return ApiGetAssetAssetDetailV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]WalletGetAssetAssetDetailV1RespValue
func (a *WalletAPIService) GetAssetAssetDetailV1Execute(r ApiGetAssetAssetDetailV1Request) (*map[string]WalletGetAssetAssetDetailV1RespValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]WalletGetAssetAssetDetailV1RespValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAssetAssetDetailV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/assetDetail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetAssetDividendV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	asset *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiGetAssetAssetDividendV1Request) Timestamp(timestamp int64) ApiGetAssetAssetDividendV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAssetAssetDividendV1Request) Asset(asset string) ApiGetAssetAssetDividendV1Request {
	r.asset = &asset
	return r
}

func (r ApiGetAssetAssetDividendV1Request) StartTime(startTime int64) ApiGetAssetAssetDividendV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetAssetAssetDividendV1Request) EndTime(endTime int64) ApiGetAssetAssetDividendV1Request {
	r.endTime = &endTime
	return r
}

// Default 20, max 500
func (r ApiGetAssetAssetDividendV1Request) Limit(limit int32) ApiGetAssetAssetDividendV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetAssetAssetDividendV1Request) RecvWindow(recvWindow int64) ApiGetAssetAssetDividendV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAssetAssetDividendV1Request) Execute() (*GetAssetAssetDividendV1Resp, *http.Response, error) {
	return r.ApiService.GetAssetAssetDividendV1Execute(r)
}

/*
GetAssetAssetDividendV1 Asset Dividend Record (USER_DATA)

Query asset dividend record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetAssetDividendV1Request
*/
func (a *WalletAPIService) GetAssetAssetDividendV1(ctx context.Context) ApiGetAssetAssetDividendV1Request {
	return ApiGetAssetAssetDividendV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetAssetDividendV1Resp
func (a *WalletAPIService) GetAssetAssetDividendV1Execute(r ApiGetAssetAssetDividendV1Request) (*GetAssetAssetDividendV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetAssetDividendV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAssetAssetDividendV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/assetDividend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetCustodyTransferHistoryV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	email *string
	startTime *int64
	endTime *int64
	timestamp *int64
	type_ *string
	asset *string
	current *int32
	size *int32
	recvWindow *int64
}

func (r ApiGetAssetCustodyTransferHistoryV1Request) Email(email string) ApiGetAssetCustodyTransferHistoryV1Request {
	r.email = &email
	return r
}

func (r ApiGetAssetCustodyTransferHistoryV1Request) StartTime(startTime int64) ApiGetAssetCustodyTransferHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetAssetCustodyTransferHistoryV1Request) EndTime(endTime int64) ApiGetAssetCustodyTransferHistoryV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetAssetCustodyTransferHistoryV1Request) Timestamp(timestamp int64) ApiGetAssetCustodyTransferHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// Delegate/Undelegate
func (r ApiGetAssetCustodyTransferHistoryV1Request) Type_(type_ string) ApiGetAssetCustodyTransferHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r ApiGetAssetCustodyTransferHistoryV1Request) Asset(asset string) ApiGetAssetCustodyTransferHistoryV1Request {
	r.asset = &asset
	return r
}

// default 1
func (r ApiGetAssetCustodyTransferHistoryV1Request) Current(current int32) ApiGetAssetCustodyTransferHistoryV1Request {
	r.current = &current
	return r
}

// default 10, max 100
func (r ApiGetAssetCustodyTransferHistoryV1Request) Size(size int32) ApiGetAssetCustodyTransferHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiGetAssetCustodyTransferHistoryV1Request) RecvWindow(recvWindow int64) ApiGetAssetCustodyTransferHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAssetCustodyTransferHistoryV1Request) Execute() (*GetAssetCustodyTransferHistoryV1Resp, *http.Response, error) {
	return r.ApiService.GetAssetCustodyTransferHistoryV1Execute(r)
}

/*
GetAssetCustodyTransferHistoryV1 Query User Delegation History(For Master Account)(USER_DATA)

Query User Delegation History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetCustodyTransferHistoryV1Request
*/
func (a *WalletAPIService) GetAssetCustodyTransferHistoryV1(ctx context.Context) ApiGetAssetCustodyTransferHistoryV1Request {
	return ApiGetAssetCustodyTransferHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetCustodyTransferHistoryV1Resp
func (a *WalletAPIService) GetAssetCustodyTransferHistoryV1Execute(r ApiGetAssetCustodyTransferHistoryV1Request) (*GetAssetCustodyTransferHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetCustodyTransferHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAssetCustodyTransferHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/custody/transfer-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int32 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetDribbletV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r ApiGetAssetDribbletV1Request) Timestamp(timestamp int64) ApiGetAssetDribbletV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAssetDribbletV1Request) StartTime(startTime int64) ApiGetAssetDribbletV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetAssetDribbletV1Request) EndTime(endTime int64) ApiGetAssetDribbletV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetAssetDribbletV1Request) RecvWindow(recvWindow int64) ApiGetAssetDribbletV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAssetDribbletV1Request) Execute() (*GetAssetDribbletV1Resp, *http.Response, error) {
	return r.ApiService.GetAssetDribbletV1Execute(r)
}

/*
GetAssetDribbletV1 DustLog(USER_DATA)

Dustlog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetDribbletV1Request
*/
func (a *WalletAPIService) GetAssetDribbletV1(ctx context.Context) ApiGetAssetDribbletV1Request {
	return ApiGetAssetDribbletV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetDribbletV1Resp
func (a *WalletAPIService) GetAssetDribbletV1Execute(r ApiGetAssetDribbletV1Request) (*GetAssetDribbletV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetDribbletV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAssetDribbletV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dribblet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	startTime *int64
	endTime *int64
	tranId *int64
	clientTranId *string
	asset *string
	current *int32
	size *int32
}

// inclusive, unit: ms
func (r ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request) StartTime(startTime int64) ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.startTime = &startTime
	return r
}

// exclusive, unit: ms
func (r ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request) EndTime(endTime int64) ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.endTime = &endTime
	return r
}

// The transaction id
func (r ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request) TranId(tranId int64) ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.tranId = &tranId
	return r
}

// The unique flag
func (r ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request) ClientTranId(clientTranId string) ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.clientTranId = &clientTranId
	return r
}

// If it is blank, we will query all assets
func (r ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Asset(asset string) ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.asset = &asset
	return r
}

// current page, default 1, the min value is 1
func (r ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Current(current int32) ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.current = &current
	return r
}

// page size, default 10, the max value is 100
func (r ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Size(size int32) ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.size = &size
	return r
}

func (r ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Execute() (*GetAssetLedgerTransferCloudMiningQueryByPageV1Resp, *http.Response, error) {
	return r.ApiService.GetAssetLedgerTransferCloudMiningQueryByPageV1Execute(r)
}

/*
GetAssetLedgerTransferCloudMiningQueryByPageV1 Get Cloud-Mining payment and refund history (USER_DATA)

The query of Cloud-Mining payment and refund history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request
*/
func (a *WalletAPIService) GetAssetLedgerTransferCloudMiningQueryByPageV1(ctx context.Context) ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	return ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetLedgerTransferCloudMiningQueryByPageV1Resp
func (a *WalletAPIService) GetAssetLedgerTransferCloudMiningQueryByPageV1Execute(r ApiGetAssetLedgerTransferCloudMiningQueryByPageV1Request) (*GetAssetLedgerTransferCloudMiningQueryByPageV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetLedgerTransferCloudMiningQueryByPageV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAssetLedgerTransferCloudMiningQueryByPageV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}

	if r.tranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tranId", r.tranId, "form", "")
	}
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientTranId", r.clientTranId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientTranId = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int32 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetTradeFeeV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiGetAssetTradeFeeV1Request) Timestamp(timestamp int64) ApiGetAssetTradeFeeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAssetTradeFeeV1Request) Symbol(symbol string) ApiGetAssetTradeFeeV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetAssetTradeFeeV1Request) RecvWindow(recvWindow int64) ApiGetAssetTradeFeeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAssetTradeFeeV1Request) Execute() ([]GetAssetTradeFeeV1RespItem, *http.Response, error) {
	return r.ApiService.GetAssetTradeFeeV1Execute(r)
}

/*
GetAssetTradeFeeV1 Trade Fee (USER_DATA)

Fetch trade fee

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetTradeFeeV1Request
*/
func (a *WalletAPIService) GetAssetTradeFeeV1(ctx context.Context) ApiGetAssetTradeFeeV1Request {
	return ApiGetAssetTradeFeeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetAssetTradeFeeV1RespItem
func (a *WalletAPIService) GetAssetTradeFeeV1Execute(r ApiGetAssetTradeFeeV1Request) ([]GetAssetTradeFeeV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetAssetTradeFeeV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAssetTradeFeeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/tradeFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetTransferV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	type_ *string
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	fromSymbol *string
	toSymbol *string
	recvWindow *int64
}

func (r ApiGetAssetTransferV1Request) Type_(type_ string) ApiGetAssetTransferV1Request {
	r.type_ = &type_
	return r
}

func (r ApiGetAssetTransferV1Request) Timestamp(timestamp int64) ApiGetAssetTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAssetTransferV1Request) StartTime(startTime int64) ApiGetAssetTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetAssetTransferV1Request) EndTime(endTime int64) ApiGetAssetTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default 1
func (r ApiGetAssetTransferV1Request) Current(current int32) ApiGetAssetTransferV1Request {
	r.current = &current
	return r
}

// Default 10, Max 100
func (r ApiGetAssetTransferV1Request) Size(size int32) ApiGetAssetTransferV1Request {
	r.size = &size
	return r
}

func (r ApiGetAssetTransferV1Request) FromSymbol(fromSymbol string) ApiGetAssetTransferV1Request {
	r.fromSymbol = &fromSymbol
	return r
}

func (r ApiGetAssetTransferV1Request) ToSymbol(toSymbol string) ApiGetAssetTransferV1Request {
	r.toSymbol = &toSymbol
	return r
}

func (r ApiGetAssetTransferV1Request) RecvWindow(recvWindow int64) ApiGetAssetTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAssetTransferV1Request) Execute() (*GetAssetTransferV1Resp, *http.Response, error) {
	return r.ApiService.GetAssetTransferV1Execute(r)
}

/*
GetAssetTransferV1 Query User Universal Transfer History(USER_DATA)

Query User Universal Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetTransferV1Request
*/
func (a *WalletAPIService) GetAssetTransferV1(ctx context.Context) ApiGetAssetTransferV1Request {
	return ApiGetAssetTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAssetTransferV1Resp
func (a *WalletAPIService) GetAssetTransferV1Execute(r ApiGetAssetTransferV1Request) (*GetAssetTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssetTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAssetTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int32 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.fromSymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromSymbol", r.fromSymbol, "form", "")
	} else {
		var defaultValue string = ""
		r.fromSymbol = &defaultValue
	}
	if r.toSymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toSymbol", r.toSymbol, "form", "")
	} else {
		var defaultValue string = ""
		r.toSymbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetWalletBalanceV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	quoteAsset *string
	recvWindow *int64
}

func (r ApiGetAssetWalletBalanceV1Request) Timestamp(timestamp int64) ApiGetAssetWalletBalanceV1Request {
	r.timestamp = &timestamp
	return r
}

// &#x60;USDT&#x60;, &#x60;ETH&#x60;, &#x60;USDC&#x60;, &#x60;BNB&#x60;, etc. default &#x60;BTC&#x60;
func (r ApiGetAssetWalletBalanceV1Request) QuoteAsset(quoteAsset string) ApiGetAssetWalletBalanceV1Request {
	r.quoteAsset = &quoteAsset
	return r
}

func (r ApiGetAssetWalletBalanceV1Request) RecvWindow(recvWindow int64) ApiGetAssetWalletBalanceV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAssetWalletBalanceV1Request) Execute() ([]GetAssetWalletBalanceV1RespItem, *http.Response, error) {
	return r.ApiService.GetAssetWalletBalanceV1Execute(r)
}

/*
GetAssetWalletBalanceV1 Query User Wallet Balance (USER_DATA)

Query User Wallet Balance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAssetWalletBalanceV1Request
*/
func (a *WalletAPIService) GetAssetWalletBalanceV1(ctx context.Context) ApiGetAssetWalletBalanceV1Request {
	return ApiGetAssetWalletBalanceV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetAssetWalletBalanceV1RespItem
func (a *WalletAPIService) GetAssetWalletBalanceV1Execute(r ApiGetAssetWalletBalanceV1Request) ([]GetAssetWalletBalanceV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetAssetWalletBalanceV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetAssetWalletBalanceV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/wallet/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.quoteAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quoteAsset", r.quoteAsset, "form", "")
	} else {
		var defaultValue string = ""
		r.quoteAsset = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCapitalConfigGetallV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetCapitalConfigGetallV1Request) Timestamp(timestamp int64) ApiGetCapitalConfigGetallV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetCapitalConfigGetallV1Request) RecvWindow(recvWindow int64) ApiGetCapitalConfigGetallV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetCapitalConfigGetallV1Request) Execute() ([]GetCapitalConfigGetallV1RespItem, *http.Response, error) {
	return r.ApiService.GetCapitalConfigGetallV1Execute(r)
}

/*
GetCapitalConfigGetallV1 All Coins' Information (USER_DATA)

Get information of coins (available for deposit and withdraw) for user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCapitalConfigGetallV1Request
*/
func (a *WalletAPIService) GetCapitalConfigGetallV1(ctx context.Context) ApiGetCapitalConfigGetallV1Request {
	return ApiGetCapitalConfigGetallV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetCapitalConfigGetallV1RespItem
func (a *WalletAPIService) GetCapitalConfigGetallV1Execute(r ApiGetCapitalConfigGetallV1Request) ([]GetCapitalConfigGetallV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetCapitalConfigGetallV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetCapitalConfigGetallV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/config/getall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCapitalDepositAddressListV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	coin *string
	timestamp *int64
	network *string
}

// &#x60;coin&#x60; refers to the parent network address format that the address is using
func (r ApiGetCapitalDepositAddressListV1Request) Coin(coin string) ApiGetCapitalDepositAddressListV1Request {
	r.coin = &coin
	return r
}

func (r ApiGetCapitalDepositAddressListV1Request) Timestamp(timestamp int64) ApiGetCapitalDepositAddressListV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetCapitalDepositAddressListV1Request) Network(network string) ApiGetCapitalDepositAddressListV1Request {
	r.network = &network
	return r
}

func (r ApiGetCapitalDepositAddressListV1Request) Execute() ([]GetCapitalDepositAddressListV1RespItem, *http.Response, error) {
	return r.ApiService.GetCapitalDepositAddressListV1Execute(r)
}

/*
GetCapitalDepositAddressListV1 Fetch deposit address list with network(USER_DATA)

Fetch deposit address list with network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCapitalDepositAddressListV1Request
*/
func (a *WalletAPIService) GetCapitalDepositAddressListV1(ctx context.Context) ApiGetCapitalDepositAddressListV1Request {
	return ApiGetCapitalDepositAddressListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetCapitalDepositAddressListV1RespItem
func (a *WalletAPIService) GetCapitalDepositAddressListV1Execute(r ApiGetCapitalDepositAddressListV1Request) ([]GetCapitalDepositAddressListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetCapitalDepositAddressListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetCapitalDepositAddressListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/address/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCapitalDepositAddressV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	coin *string
	timestamp *int64
	network *string
	amount *string
	recvWindow *int64
}

func (r ApiGetCapitalDepositAddressV1Request) Coin(coin string) ApiGetCapitalDepositAddressV1Request {
	r.coin = &coin
	return r
}

func (r ApiGetCapitalDepositAddressV1Request) Timestamp(timestamp int64) ApiGetCapitalDepositAddressV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetCapitalDepositAddressV1Request) Network(network string) ApiGetCapitalDepositAddressV1Request {
	r.network = &network
	return r
}

func (r ApiGetCapitalDepositAddressV1Request) Amount(amount string) ApiGetCapitalDepositAddressV1Request {
	r.amount = &amount
	return r
}

func (r ApiGetCapitalDepositAddressV1Request) RecvWindow(recvWindow int64) ApiGetCapitalDepositAddressV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetCapitalDepositAddressV1Request) Execute() (*GetCapitalDepositAddressV1Resp, *http.Response, error) {
	return r.ApiService.GetCapitalDepositAddressV1Execute(r)
}

/*
GetCapitalDepositAddressV1 Deposit Address(supporting network) (USER_DATA)

Fetch deposit address with network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCapitalDepositAddressV1Request
*/
func (a *WalletAPIService) GetCapitalDepositAddressV1(ctx context.Context) ApiGetCapitalDepositAddressV1Request {
	return ApiGetCapitalDepositAddressV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCapitalDepositAddressV1Resp
func (a *WalletAPIService) GetCapitalDepositAddressV1Execute(r ApiGetCapitalDepositAddressV1Request) (*GetCapitalDepositAddressV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCapitalDepositAddressV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetCapitalDepositAddressV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	} else {
		var defaultValue string = ""
		r.amount = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCapitalDepositHisrecV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	includeSource *bool
	coin *string
	status *int32
	startTime *int64
	endTime *int64
	offset *int32
	limit *int32
	recvWindow *int64
	txId *string
}

func (r ApiGetCapitalDepositHisrecV1Request) Timestamp(timestamp int64) ApiGetCapitalDepositHisrecV1Request {
	r.timestamp = &timestamp
	return r
}

// Default: &#x60;false&#x60;, return &#x60;sourceAddress&#x60;field when set to &#x60;true&#x60;
func (r ApiGetCapitalDepositHisrecV1Request) IncludeSource(includeSource bool) ApiGetCapitalDepositHisrecV1Request {
	r.includeSource = &includeSource
	return r
}

func (r ApiGetCapitalDepositHisrecV1Request) Coin(coin string) ApiGetCapitalDepositHisrecV1Request {
	r.coin = &coin
	return r
}

// 0(0:pending, 6:credited but cannot withdraw, 7:Wrong Deposit, 8:Waiting User confirm, 1:success, 2:rejected)
func (r ApiGetCapitalDepositHisrecV1Request) Status(status int32) ApiGetCapitalDepositHisrecV1Request {
	r.status = &status
	return r
}

// Default: 90 days from current timestamp
func (r ApiGetCapitalDepositHisrecV1Request) StartTime(startTime int64) ApiGetCapitalDepositHisrecV1Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r ApiGetCapitalDepositHisrecV1Request) EndTime(endTime int64) ApiGetCapitalDepositHisrecV1Request {
	r.endTime = &endTime
	return r
}

// Default:0
func (r ApiGetCapitalDepositHisrecV1Request) Offset(offset int32) ApiGetCapitalDepositHisrecV1Request {
	r.offset = &offset
	return r
}

// Default:1000, Max:1000
func (r ApiGetCapitalDepositHisrecV1Request) Limit(limit int32) ApiGetCapitalDepositHisrecV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetCapitalDepositHisrecV1Request) RecvWindow(recvWindow int64) ApiGetCapitalDepositHisrecV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetCapitalDepositHisrecV1Request) TxId(txId string) ApiGetCapitalDepositHisrecV1Request {
	r.txId = &txId
	return r
}

func (r ApiGetCapitalDepositHisrecV1Request) Execute() ([]GetCapitalDepositHisrecV1RespItem, *http.Response, error) {
	return r.ApiService.GetCapitalDepositHisrecV1Execute(r)
}

/*
GetCapitalDepositHisrecV1 Deposit History (supporting network) (USER_DATA)

Fetch deposit history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCapitalDepositHisrecV1Request
*/
func (a *WalletAPIService) GetCapitalDepositHisrecV1(ctx context.Context) ApiGetCapitalDepositHisrecV1Request {
	return ApiGetCapitalDepositHisrecV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetCapitalDepositHisrecV1RespItem
func (a *WalletAPIService) GetCapitalDepositHisrecV1Execute(r ApiGetCapitalDepositHisrecV1Request) ([]GetCapitalDepositHisrecV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetCapitalDepositHisrecV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetCapitalDepositHisrecV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/hisrec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.includeSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSource", r.includeSource, "form", "")
	} else {
		var defaultValue bool = false
		r.includeSource = &defaultValue
	}
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCapitalWithdrawAddressListV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
}

func (r ApiGetCapitalWithdrawAddressListV1Request) Execute() ([]GetCapitalWithdrawAddressListV1RespItem, *http.Response, error) {
	return r.ApiService.GetCapitalWithdrawAddressListV1Execute(r)
}

/*
GetCapitalWithdrawAddressListV1 Fetch withdraw address list (USER_DATA)

Fetch withdraw address list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCapitalWithdrawAddressListV1Request
*/
func (a *WalletAPIService) GetCapitalWithdrawAddressListV1(ctx context.Context) ApiGetCapitalWithdrawAddressListV1Request {
	return ApiGetCapitalWithdrawAddressListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetCapitalWithdrawAddressListV1RespItem
func (a *WalletAPIService) GetCapitalWithdrawAddressListV1Execute(r ApiGetCapitalWithdrawAddressListV1Request) ([]GetCapitalWithdrawAddressListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetCapitalWithdrawAddressListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetCapitalWithdrawAddressListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/withdraw/address/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCapitalWithdrawHistoryV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	coin *string
	withdrawOrderId *string
	status *int32
	offset *int32
	limit *int32
	idList *string
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r ApiGetCapitalWithdrawHistoryV1Request) Timestamp(timestamp int64) ApiGetCapitalWithdrawHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetCapitalWithdrawHistoryV1Request) Coin(coin string) ApiGetCapitalWithdrawHistoryV1Request {
	r.coin = &coin
	return r
}

func (r ApiGetCapitalWithdrawHistoryV1Request) WithdrawOrderId(withdrawOrderId string) ApiGetCapitalWithdrawHistoryV1Request {
	r.withdrawOrderId = &withdrawOrderId
	return r
}

// 0(0:Email Sent, 2:Awaiting Approval 3:Rejected 4:Processing 6:Completed)
func (r ApiGetCapitalWithdrawHistoryV1Request) Status(status int32) ApiGetCapitalWithdrawHistoryV1Request {
	r.status = &status
	return r
}

func (r ApiGetCapitalWithdrawHistoryV1Request) Offset(offset int32) ApiGetCapitalWithdrawHistoryV1Request {
	r.offset = &offset
	return r
}

// Default: 1000, Max: 1000
func (r ApiGetCapitalWithdrawHistoryV1Request) Limit(limit int32) ApiGetCapitalWithdrawHistoryV1Request {
	r.limit = &limit
	return r
}

// id list returned in the response of POST &#x60;/sapi/v1/capital/withdraw/apply&#x60;, separated by &#x60;,&#x60;
func (r ApiGetCapitalWithdrawHistoryV1Request) IdList(idList string) ApiGetCapitalWithdrawHistoryV1Request {
	r.idList = &idList
	return r
}

// Default: 90 days from current timestamp
func (r ApiGetCapitalWithdrawHistoryV1Request) StartTime(startTime int64) ApiGetCapitalWithdrawHistoryV1Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r ApiGetCapitalWithdrawHistoryV1Request) EndTime(endTime int64) ApiGetCapitalWithdrawHistoryV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetCapitalWithdrawHistoryV1Request) RecvWindow(recvWindow int64) ApiGetCapitalWithdrawHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetCapitalWithdrawHistoryV1Request) Execute() ([]GetCapitalWithdrawHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.GetCapitalWithdrawHistoryV1Execute(r)
}

/*
GetCapitalWithdrawHistoryV1 Withdraw History (supporting network) (USER_DATA)

Fetch withdraw history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCapitalWithdrawHistoryV1Request
*/
func (a *WalletAPIService) GetCapitalWithdrawHistoryV1(ctx context.Context) ApiGetCapitalWithdrawHistoryV1Request {
	return ApiGetCapitalWithdrawHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetCapitalWithdrawHistoryV1RespItem
func (a *WalletAPIService) GetCapitalWithdrawHistoryV1Execute(r ApiGetCapitalWithdrawHistoryV1Request) ([]GetCapitalWithdrawHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetCapitalWithdrawHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetCapitalWithdrawHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/withdraw/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.withdrawOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withdrawOrderId", r.withdrawOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.withdrawOrderId = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 1000
		r.limit = &defaultValue
	}
	if r.idList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idList", r.idList, "form", "")
	} else {
		var defaultValue string = ""
		r.idList = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLocalentityDepositHistoryV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	trId *string
	txId *string
	tranId *string
	network *string
	coin *string
	travelRuleStatus *int32
	pendingQuestionnaire *bool
	startTime *int64
	endTime *int64
	offset *int32
	limit *int32
}

func (r ApiGetLocalentityDepositHistoryV1Request) Timestamp(timestamp int64) ApiGetLocalentityDepositHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// Comma(,) separated list of travel rule record Ids.
func (r ApiGetLocalentityDepositHistoryV1Request) TrId(trId string) ApiGetLocalentityDepositHistoryV1Request {
	r.trId = &trId
	return r
}

// Comma(,) separated list of transaction Ids.
func (r ApiGetLocalentityDepositHistoryV1Request) TxId(txId string) ApiGetLocalentityDepositHistoryV1Request {
	r.txId = &txId
	return r
}

// Comma(,) separated list of wallet tran Ids.
func (r ApiGetLocalentityDepositHistoryV1Request) TranId(tranId string) ApiGetLocalentityDepositHistoryV1Request {
	r.tranId = &tranId
	return r
}

func (r ApiGetLocalentityDepositHistoryV1Request) Network(network string) ApiGetLocalentityDepositHistoryV1Request {
	r.network = &network
	return r
}

func (r ApiGetLocalentityDepositHistoryV1Request) Coin(coin string) ApiGetLocalentityDepositHistoryV1Request {
	r.coin = &coin
	return r
}

// 0:Completed,1:Pending,2:Failed
func (r ApiGetLocalentityDepositHistoryV1Request) TravelRuleStatus(travelRuleStatus int32) ApiGetLocalentityDepositHistoryV1Request {
	r.travelRuleStatus = &travelRuleStatus
	return r
}

// true: Only return records that pending deposit questionnaire. false/not provided: return all records.
func (r ApiGetLocalentityDepositHistoryV1Request) PendingQuestionnaire(pendingQuestionnaire bool) ApiGetLocalentityDepositHistoryV1Request {
	r.pendingQuestionnaire = &pendingQuestionnaire
	return r
}

// Default: 90 days from current timestamp
func (r ApiGetLocalentityDepositHistoryV1Request) StartTime(startTime int64) ApiGetLocalentityDepositHistoryV1Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r ApiGetLocalentityDepositHistoryV1Request) EndTime(endTime int64) ApiGetLocalentityDepositHistoryV1Request {
	r.endTime = &endTime
	return r
}

// Default:0
func (r ApiGetLocalentityDepositHistoryV1Request) Offset(offset int32) ApiGetLocalentityDepositHistoryV1Request {
	r.offset = &offset
	return r
}

// Default:1000, Max:1000
func (r ApiGetLocalentityDepositHistoryV1Request) Limit(limit int32) ApiGetLocalentityDepositHistoryV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetLocalentityDepositHistoryV1Request) Execute() ([]GetLocalentityDepositHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.GetLocalentityDepositHistoryV1Execute(r)
}

/*
GetLocalentityDepositHistoryV1 Deposit History (for local entities that required travel rule) (supporting network) (USER_DATA)

Fetch deposit history for local entities that required travel rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLocalentityDepositHistoryV1Request
*/
func (a *WalletAPIService) GetLocalentityDepositHistoryV1(ctx context.Context) ApiGetLocalentityDepositHistoryV1Request {
	return ApiGetLocalentityDepositHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetLocalentityDepositHistoryV1RespItem
func (a *WalletAPIService) GetLocalentityDepositHistoryV1Execute(r ApiGetLocalentityDepositHistoryV1Request) ([]GetLocalentityDepositHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetLocalentityDepositHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetLocalentityDepositHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/localentity/deposit/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.trId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trId", r.trId, "form", "")
	} else {
		var defaultValue string = ""
		r.trId = &defaultValue
	}
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	if r.tranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tranId", r.tranId, "form", "")
	} else {
		var defaultValue string = ""
		r.tranId = &defaultValue
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.travelRuleStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "travelRuleStatus", r.travelRuleStatus, "form", "")
	}
	if r.pendingQuestionnaire != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pendingQuestionnaire", r.pendingQuestionnaire, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLocalentityVaspV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
}

func (r ApiGetLocalentityVaspV1Request) Execute() ([]GetLocalentityVaspV1RespItem, *http.Response, error) {
	return r.ApiService.GetLocalentityVaspV1Execute(r)
}

/*
GetLocalentityVaspV1 Onboarded VASP list (for local entities that require travel rule) (supporting network) (USER_DATA)

Fetch the onboarded VASP list for local entities that required travel rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLocalentityVaspV1Request
*/
func (a *WalletAPIService) GetLocalentityVaspV1(ctx context.Context) ApiGetLocalentityVaspV1Request {
	return ApiGetLocalentityVaspV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetLocalentityVaspV1RespItem
func (a *WalletAPIService) GetLocalentityVaspV1Execute(r ApiGetLocalentityVaspV1Request) ([]GetLocalentityVaspV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetLocalentityVaspV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetLocalentityVaspV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/localentity/vasp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLocalentityWithdrawHistoryV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	trId *string
	txId *string
	withdrawOrderId *string
	network *string
	coin *string
	travelRuleStatus *int32
	offset *int32
	limit *int32
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r ApiGetLocalentityWithdrawHistoryV1Request) Timestamp(timestamp int64) ApiGetLocalentityWithdrawHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// Comma(,) separated list of travel rule record Ids.
func (r ApiGetLocalentityWithdrawHistoryV1Request) TrId(trId string) ApiGetLocalentityWithdrawHistoryV1Request {
	r.trId = &trId
	return r
}

// Comma(,) separated list of transaction Ids.
func (r ApiGetLocalentityWithdrawHistoryV1Request) TxId(txId string) ApiGetLocalentityWithdrawHistoryV1Request {
	r.txId = &txId
	return r
}

// Comma(,) separated list of withdrawID defined by the client (i.e. client&amp;#39;s internal withdrawID).
func (r ApiGetLocalentityWithdrawHistoryV1Request) WithdrawOrderId(withdrawOrderId string) ApiGetLocalentityWithdrawHistoryV1Request {
	r.withdrawOrderId = &withdrawOrderId
	return r
}

func (r ApiGetLocalentityWithdrawHistoryV1Request) Network(network string) ApiGetLocalentityWithdrawHistoryV1Request {
	r.network = &network
	return r
}

func (r ApiGetLocalentityWithdrawHistoryV1Request) Coin(coin string) ApiGetLocalentityWithdrawHistoryV1Request {
	r.coin = &coin
	return r
}

// 0:Completed,1:Pending,2:Failed
func (r ApiGetLocalentityWithdrawHistoryV1Request) TravelRuleStatus(travelRuleStatus int32) ApiGetLocalentityWithdrawHistoryV1Request {
	r.travelRuleStatus = &travelRuleStatus
	return r
}

// Default: 0
func (r ApiGetLocalentityWithdrawHistoryV1Request) Offset(offset int32) ApiGetLocalentityWithdrawHistoryV1Request {
	r.offset = &offset
	return r
}

// Default: 1000, Max: 1000
func (r ApiGetLocalentityWithdrawHistoryV1Request) Limit(limit int32) ApiGetLocalentityWithdrawHistoryV1Request {
	r.limit = &limit
	return r
}

// Default: 90 days from current timestamp
func (r ApiGetLocalentityWithdrawHistoryV1Request) StartTime(startTime int64) ApiGetLocalentityWithdrawHistoryV1Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r ApiGetLocalentityWithdrawHistoryV1Request) EndTime(endTime int64) ApiGetLocalentityWithdrawHistoryV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetLocalentityWithdrawHistoryV1Request) RecvWindow(recvWindow int64) ApiGetLocalentityWithdrawHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetLocalentityWithdrawHistoryV1Request) Execute() ([]GetLocalentityWithdrawHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.GetLocalentityWithdrawHistoryV1Execute(r)
}

/*
GetLocalentityWithdrawHistoryV1 Withdraw History (for local entities that require travel rule) (supporting network) (USER_DATA)

Fetch withdraw history for local entities that required travel rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLocalentityWithdrawHistoryV1Request
*/
func (a *WalletAPIService) GetLocalentityWithdrawHistoryV1(ctx context.Context) ApiGetLocalentityWithdrawHistoryV1Request {
	return ApiGetLocalentityWithdrawHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetLocalentityWithdrawHistoryV1RespItem
func (a *WalletAPIService) GetLocalentityWithdrawHistoryV1Execute(r ApiGetLocalentityWithdrawHistoryV1Request) ([]GetLocalentityWithdrawHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetLocalentityWithdrawHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetLocalentityWithdrawHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/localentity/withdraw/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.trId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trId", r.trId, "form", "")
	} else {
		var defaultValue string = ""
		r.trId = &defaultValue
	}
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	if r.withdrawOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withdrawOrderId", r.withdrawOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.withdrawOrderId = &defaultValue
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.travelRuleStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "travelRuleStatus", r.travelRuleStatus, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 1000
		r.limit = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLocalentityWithdrawHistoryV2Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	trId *string
	txId *string
	withdrawOrderId *string
	network *string
	coin *string
	travelRuleStatus *int32
	offset *int32
	limit *int32
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r ApiGetLocalentityWithdrawHistoryV2Request) Timestamp(timestamp int64) ApiGetLocalentityWithdrawHistoryV2Request {
	r.timestamp = &timestamp
	return r
}

// Comma(,) separated list of travel rule record Ids.
func (r ApiGetLocalentityWithdrawHistoryV2Request) TrId(trId string) ApiGetLocalentityWithdrawHistoryV2Request {
	r.trId = &trId
	return r
}

// Comma(,) separated list of transaction Ids.
func (r ApiGetLocalentityWithdrawHistoryV2Request) TxId(txId string) ApiGetLocalentityWithdrawHistoryV2Request {
	r.txId = &txId
	return r
}

// Withdraw ID defined by the client (i.e. client&amp;#39;s internal withdrawID).
func (r ApiGetLocalentityWithdrawHistoryV2Request) WithdrawOrderId(withdrawOrderId string) ApiGetLocalentityWithdrawHistoryV2Request {
	r.withdrawOrderId = &withdrawOrderId
	return r
}

func (r ApiGetLocalentityWithdrawHistoryV2Request) Network(network string) ApiGetLocalentityWithdrawHistoryV2Request {
	r.network = &network
	return r
}

func (r ApiGetLocalentityWithdrawHistoryV2Request) Coin(coin string) ApiGetLocalentityWithdrawHistoryV2Request {
	r.coin = &coin
	return r
}

// 0:Completed,1:Pending,2:Failed
func (r ApiGetLocalentityWithdrawHistoryV2Request) TravelRuleStatus(travelRuleStatus int32) ApiGetLocalentityWithdrawHistoryV2Request {
	r.travelRuleStatus = &travelRuleStatus
	return r
}

// Default: 0
func (r ApiGetLocalentityWithdrawHistoryV2Request) Offset(offset int32) ApiGetLocalentityWithdrawHistoryV2Request {
	r.offset = &offset
	return r
}

// Default: 1000, Max: 1000
func (r ApiGetLocalentityWithdrawHistoryV2Request) Limit(limit int32) ApiGetLocalentityWithdrawHistoryV2Request {
	r.limit = &limit
	return r
}

// Default: 90 days from current timestamp
func (r ApiGetLocalentityWithdrawHistoryV2Request) StartTime(startTime int64) ApiGetLocalentityWithdrawHistoryV2Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r ApiGetLocalentityWithdrawHistoryV2Request) EndTime(endTime int64) ApiGetLocalentityWithdrawHistoryV2Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetLocalentityWithdrawHistoryV2Request) RecvWindow(recvWindow int64) ApiGetLocalentityWithdrawHistoryV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetLocalentityWithdrawHistoryV2Request) Execute() ([]GetLocalentityWithdrawHistoryV2RespItem, *http.Response, error) {
	return r.ApiService.GetLocalentityWithdrawHistoryV2Execute(r)
}

/*
GetLocalentityWithdrawHistoryV2 Withdraw History V2 (for local entities that require travel rule) (supporting network) (USER_DATA)

Fetch withdraw history for local entities that required travel rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLocalentityWithdrawHistoryV2Request
*/
func (a *WalletAPIService) GetLocalentityWithdrawHistoryV2(ctx context.Context) ApiGetLocalentityWithdrawHistoryV2Request {
	return ApiGetLocalentityWithdrawHistoryV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetLocalentityWithdrawHistoryV2RespItem
func (a *WalletAPIService) GetLocalentityWithdrawHistoryV2Execute(r ApiGetLocalentityWithdrawHistoryV2Request) ([]GetLocalentityWithdrawHistoryV2RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetLocalentityWithdrawHistoryV2RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetLocalentityWithdrawHistoryV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/localentity/withdraw/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.trId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trId", r.trId, "form", "")
	} else {
		var defaultValue string = ""
		r.trId = &defaultValue
	}
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	if r.withdrawOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withdrawOrderId", r.withdrawOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.withdrawOrderId = &defaultValue
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.travelRuleStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "travelRuleStatus", r.travelRuleStatus, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 1000
		r.limit = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpotDelistScheduleV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetSpotDelistScheduleV1Request) Timestamp(timestamp int64) ApiGetSpotDelistScheduleV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetSpotDelistScheduleV1Request) RecvWindow(recvWindow int64) ApiGetSpotDelistScheduleV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSpotDelistScheduleV1Request) Execute() ([]GetSpotDelistScheduleV1RespItem, *http.Response, error) {
	return r.ApiService.GetSpotDelistScheduleV1Execute(r)
}

/*
GetSpotDelistScheduleV1 Get Spot Delist Schedule (MARKET_DATA)

Get symbols delist schedule for spot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSpotDelistScheduleV1Request
*/
func (a *WalletAPIService) GetSpotDelistScheduleV1(ctx context.Context) ApiGetSpotDelistScheduleV1Request {
	return ApiGetSpotDelistScheduleV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetSpotDelistScheduleV1RespItem
func (a *WalletAPIService) GetSpotDelistScheduleV1Execute(r ApiGetSpotDelistScheduleV1Request) ([]GetSpotDelistScheduleV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetSpotDelistScheduleV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetSpotDelistScheduleV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/spot/delist-schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpotOpenSymbolListV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
}

func (r ApiGetSpotOpenSymbolListV1Request) Execute() ([]GetSpotOpenSymbolListV1RespItem, *http.Response, error) {
	return r.ApiService.GetSpotOpenSymbolListV1Execute(r)
}

/*
GetSpotOpenSymbolListV1 Get Open Symbol List (MARKET_DATA)

Get the list of symbols that are scheduled to be opened for trading in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSpotOpenSymbolListV1Request
*/
func (a *WalletAPIService) GetSpotOpenSymbolListV1(ctx context.Context) ApiGetSpotOpenSymbolListV1Request {
	return ApiGetSpotOpenSymbolListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetSpotOpenSymbolListV1RespItem
func (a *WalletAPIService) GetSpotOpenSymbolListV1Execute(r ApiGetSpotOpenSymbolListV1Request) ([]GetSpotOpenSymbolListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetSpotOpenSymbolListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetSpotOpenSymbolListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/spot/open-symbol-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSystemStatusV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
}

func (r ApiGetSystemStatusV1Request) Execute() (*GetSystemStatusV1Resp, *http.Response, error) {
	return r.ApiService.GetSystemStatusV1Execute(r)
}

/*
GetSystemStatusV1 System Status (System)

Fetch system status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSystemStatusV1Request
*/
func (a *WalletAPIService) GetSystemStatusV1(ctx context.Context) ApiGetSystemStatusV1Request {
	return ApiGetSystemStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSystemStatusV1Resp
func (a *WalletAPIService) GetSystemStatusV1Execute(r ApiGetSystemStatusV1Request) (*GetSystemStatusV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSystemStatusV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.GetSystemStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/system/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLocalentityBrokerDepositProvideInfoV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	beneficiaryPii *string
	depositId *string
	questionnaire *string
	signature *string
	subAccountId *string
	timestamp *int64
	address *string
	addressTag *string
	amount *string
	coin *string
	network *string
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) BeneficiaryPii(beneficiaryPii string) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.beneficiaryPii = &beneficiaryPii
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) DepositId(depositId string) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.depositId = &depositId
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) Questionnaire(questionnaire string) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.questionnaire = &questionnaire
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) Signature(signature string) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.signature = &signature
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) SubAccountId(subAccountId string) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) Timestamp(timestamp int64) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) Address(address string) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.address = &address
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) AddressTag(addressTag string) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.addressTag = &addressTag
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) Amount(amount string) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.amount = &amount
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) Coin(coin string) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.coin = &coin
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) Network(network string) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	r.network = &network
	return r
}

func (r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) Execute() (*UpdateLocalentityBrokerDepositProvideInfoV1Resp, *http.Response, error) {
	return r.ApiService.UpdateLocalentityBrokerDepositProvideInfoV1Execute(r)
}

/*
UpdateLocalentityBrokerDepositProvideInfoV1 Submit Deposit Questionnaire (For local entities that require travel rule) (supporting network) (USER_DATA)

Submit questionnaire for brokers of local entities that require travel rule.
The questionnaire is only applies to transactions from un-hosted wallets or VASPs that are not
yet onboarded with GTR.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateLocalentityBrokerDepositProvideInfoV1Request
*/
func (a *WalletAPIService) UpdateLocalentityBrokerDepositProvideInfoV1(ctx context.Context) ApiUpdateLocalentityBrokerDepositProvideInfoV1Request {
	return ApiUpdateLocalentityBrokerDepositProvideInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateLocalentityBrokerDepositProvideInfoV1Resp
func (a *WalletAPIService) UpdateLocalentityBrokerDepositProvideInfoV1Execute(r ApiUpdateLocalentityBrokerDepositProvideInfoV1Request) (*UpdateLocalentityBrokerDepositProvideInfoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateLocalentityBrokerDepositProvideInfoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.UpdateLocalentityBrokerDepositProvideInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/localentity/broker/deposit/provide-info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.beneficiaryPii == nil {
		return localVarReturnValue, nil, reportError("beneficiaryPii is required and must be specified")
	}
	if r.depositId == nil {
		return localVarReturnValue, nil, reportError("depositId is required and must be specified")
	}
	if r.questionnaire == nil {
		return localVarReturnValue, nil, reportError("questionnaire is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "address", r.address, "", "")
	}
	if r.addressTag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "addressTag", r.addressTag, "", "")
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "beneficiaryPii", r.beneficiaryPii, "", "")
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "coin", r.coin, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "depositId", r.depositId, "", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "network", r.network, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "questionnaire", r.questionnaire, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "signature", r.signature, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLocalentityDepositProvideInfoV1Request struct {
	ctx context.Context
	ApiService *WalletAPIService
	questionnaire *string
	timestamp *int64
	tranId *int64
}

func (r ApiUpdateLocalentityDepositProvideInfoV1Request) Questionnaire(questionnaire string) ApiUpdateLocalentityDepositProvideInfoV1Request {
	r.questionnaire = &questionnaire
	return r
}

func (r ApiUpdateLocalentityDepositProvideInfoV1Request) Timestamp(timestamp int64) ApiUpdateLocalentityDepositProvideInfoV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiUpdateLocalentityDepositProvideInfoV1Request) TranId(tranId int64) ApiUpdateLocalentityDepositProvideInfoV1Request {
	r.tranId = &tranId
	return r
}

func (r ApiUpdateLocalentityDepositProvideInfoV1Request) Execute() (*UpdateLocalentityDepositProvideInfoV1Resp, *http.Response, error) {
	return r.ApiService.UpdateLocalentityDepositProvideInfoV1Execute(r)
}

/*
UpdateLocalentityDepositProvideInfoV1 Submit Deposit Questionnaire (For local entities that require travel rule) (supporting network) (USER_DATA)

Submit questionnaire for local entities that require travel rule.
The questionnaire is only applies to transactions from unhosted wallets or VASPs that are not
yet onboarded with GTR.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateLocalentityDepositProvideInfoV1Request
*/
func (a *WalletAPIService) UpdateLocalentityDepositProvideInfoV1(ctx context.Context) ApiUpdateLocalentityDepositProvideInfoV1Request {
	return ApiUpdateLocalentityDepositProvideInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateLocalentityDepositProvideInfoV1Resp
func (a *WalletAPIService) UpdateLocalentityDepositProvideInfoV1Execute(r ApiUpdateLocalentityDepositProvideInfoV1Request) (*UpdateLocalentityDepositProvideInfoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateLocalentityDepositProvideInfoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletAPIService.UpdateLocalentityDepositProvideInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/localentity/deposit/provide-info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.questionnaire == nil {
		return localVarReturnValue, nil, reportError("questionnaire is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.tranId == nil {
		return localVarReturnValue, nil, reportError("tranId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "questionnaire", r.questionnaire, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "tranId", r.tranId, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

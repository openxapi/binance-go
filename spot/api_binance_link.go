/*
Binance Spot API

OpenAPI specification for Binance exchange - Spot API

API version: 0.3.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// BinanceLinkAPIService BinanceLinkAPI service
type BinanceLinkAPIService service

type ApiCreateApiReferralCustomizationV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	customerId *string
	email *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateApiReferralCustomizationV1Request) CustomerId(customerId string) ApiCreateApiReferralCustomizationV1Request {
	r.customerId = &customerId
	return r
}

func (r ApiCreateApiReferralCustomizationV1Request) Email(email string) ApiCreateApiReferralCustomizationV1Request {
	r.email = &email
	return r
}

func (r ApiCreateApiReferralCustomizationV1Request) Timestamp(timestamp int64) ApiCreateApiReferralCustomizationV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateApiReferralCustomizationV1Request) RecvWindow(recvWindow int64) ApiCreateApiReferralCustomizationV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateApiReferralCustomizationV1Request) Execute() (*CreateApiReferralCustomizationV1Resp, *http.Response, error) {
	return r.ApiService.CreateApiReferralCustomizationV1Execute(r)
}

/*
CreateApiReferralCustomizationV1 Customize Id For Client (USER DATA) （For Partner）

- CustomerId must be unique
- For the same email, the customerId will be modified in real time

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateApiReferralCustomizationV1Request
*/
func (a *BinanceLinkAPIService) CreateApiReferralCustomizationV1(ctx context.Context) ApiCreateApiReferralCustomizationV1Request {
	return ApiCreateApiReferralCustomizationV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateApiReferralCustomizationV1Resp
func (a *BinanceLinkAPIService) CreateApiReferralCustomizationV1Execute(r ApiCreateApiReferralCustomizationV1Request) (*CreateApiReferralCustomizationV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateApiReferralCustomizationV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateApiReferralCustomizationV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/apiReferral/customization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.customerId == nil {
		return localVarReturnValue, nil, reportError("customerId is required and must be specified")
	}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "customerId", r.customerId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApiReferralUserCustomizationV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	apiAgentCode *string
	customerId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateApiReferralUserCustomizationV1Request) ApiAgentCode(apiAgentCode string) ApiCreateApiReferralUserCustomizationV1Request {
	r.apiAgentCode = &apiAgentCode
	return r
}

func (r ApiCreateApiReferralUserCustomizationV1Request) CustomerId(customerId string) ApiCreateApiReferralUserCustomizationV1Request {
	r.customerId = &customerId
	return r
}

func (r ApiCreateApiReferralUserCustomizationV1Request) Timestamp(timestamp int64) ApiCreateApiReferralUserCustomizationV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateApiReferralUserCustomizationV1Request) RecvWindow(recvWindow int64) ApiCreateApiReferralUserCustomizationV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateApiReferralUserCustomizationV1Request) Execute() (*CreateApiReferralUserCustomizationV1Resp, *http.Response, error) {
	return r.ApiService.CreateApiReferralUserCustomizationV1Execute(r)
}

/*
CreateApiReferralUserCustomizationV1 Customize Id For Client  (USER DATA)(For client)

- CustomerId must be unique for each apiAgent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateApiReferralUserCustomizationV1Request
*/
func (a *BinanceLinkAPIService) CreateApiReferralUserCustomizationV1(ctx context.Context) ApiCreateApiReferralUserCustomizationV1Request {
	return ApiCreateApiReferralUserCustomizationV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateApiReferralUserCustomizationV1Resp
func (a *BinanceLinkAPIService) CreateApiReferralUserCustomizationV1Execute(r ApiCreateApiReferralUserCustomizationV1Request) (*CreateApiReferralUserCustomizationV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateApiReferralUserCustomizationV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateApiReferralUserCustomizationV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/apiReferral/userCustomization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiAgentCode == nil {
		return localVarReturnValue, nil, reportError("apiAgentCode is required and must be specified")
	}
	if r.customerId == nil {
		return localVarReturnValue, nil, reportError("customerId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "apiAgentCode", r.apiAgentCode, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "customerId", r.customerId, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	makerAdjustment *int32
	pair *string
	subAccountId *string
	takerAdjustment *int32
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request) MakerAdjustment(makerAdjustment int32) ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request {
	r.makerAdjustment = &makerAdjustment
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request) Pair(pair string) ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request {
	r.pair = &pair
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request) SubAccountId(subAccountId string) ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request) TakerAdjustment(takerAdjustment int32) ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request {
	r.takerAdjustment = &takerAdjustment
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request) Execute() (*CreateBrokerSubAccountApiCommissionCoinFuturesV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountApiCommissionCoinFuturesV1Execute(r)
}

/*
CreateBrokerSubAccountApiCommissionCoinFuturesV1 Change Sub Account COIN-Ⓜ Futures Commission Adjustment

This request will change the COIN-Ⓜ futures commission for a sub account.
You need to enable "trade" option for the api key which requests this endpoint.
The sub-account's COIN-Ⓜ futures commission of a symbol equals to the base commission of the symbol on the sub-account's fee tier plus the commission adjustment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiCommissionCoinFuturesV1(ctx context.Context) ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request {
	return ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountApiCommissionCoinFuturesV1Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiCommissionCoinFuturesV1Execute(r ApiCreateBrokerSubAccountApiCommissionCoinFuturesV1Request) (*CreateBrokerSubAccountApiCommissionCoinFuturesV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountApiCommissionCoinFuturesV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountApiCommissionCoinFuturesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi/commission/coinFutures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.makerAdjustment == nil {
		return localVarReturnValue, nil, reportError("makerAdjustment is required and must be specified")
	}
	if r.pair == nil {
		return localVarReturnValue, nil, reportError("pair is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.takerAdjustment == nil {
		return localVarReturnValue, nil, reportError("takerAdjustment is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "makerAdjustment", r.makerAdjustment, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pair", r.pair, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "takerAdjustment", r.takerAdjustment, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountApiCommissionFuturesV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	makerAdjustment *int32
	subAccountId *string
	symbol *string
	takerAdjustment *int32
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateBrokerSubAccountApiCommissionFuturesV1Request) MakerAdjustment(makerAdjustment int32) ApiCreateBrokerSubAccountApiCommissionFuturesV1Request {
	r.makerAdjustment = &makerAdjustment
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionFuturesV1Request) SubAccountId(subAccountId string) ApiCreateBrokerSubAccountApiCommissionFuturesV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionFuturesV1Request) Symbol(symbol string) ApiCreateBrokerSubAccountApiCommissionFuturesV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionFuturesV1Request) TakerAdjustment(takerAdjustment int32) ApiCreateBrokerSubAccountApiCommissionFuturesV1Request {
	r.takerAdjustment = &takerAdjustment
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionFuturesV1Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountApiCommissionFuturesV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionFuturesV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountApiCommissionFuturesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionFuturesV1Request) Execute() (*CreateBrokerSubAccountApiCommissionFuturesV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountApiCommissionFuturesV1Execute(r)
}

/*
CreateBrokerSubAccountApiCommissionFuturesV1 Change Sub Account USDT-Ⓜ Futures Commission Adjustment

This request will change the USDT-Ⓜ futures commission for a sub account.
You need to enable "trade" option for the api key which requests this endpoint.
The sub-account's USDT-Ⓜ futures commission of a symbol equals to the base commission of the symbol on the sub-account's fee tier plus the commission adjustment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountApiCommissionFuturesV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiCommissionFuturesV1(ctx context.Context) ApiCreateBrokerSubAccountApiCommissionFuturesV1Request {
	return ApiCreateBrokerSubAccountApiCommissionFuturesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountApiCommissionFuturesV1Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiCommissionFuturesV1Execute(r ApiCreateBrokerSubAccountApiCommissionFuturesV1Request) (*CreateBrokerSubAccountApiCommissionFuturesV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountApiCommissionFuturesV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountApiCommissionFuturesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi/commission/futures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.makerAdjustment == nil {
		return localVarReturnValue, nil, reportError("makerAdjustment is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.takerAdjustment == nil {
		return localVarReturnValue, nil, reportError("takerAdjustment is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "makerAdjustment", r.makerAdjustment, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "takerAdjustment", r.takerAdjustment, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountApiCommissionV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	makerCommission *float32
	subAccountId *string
	takerCommission *float32
	timestamp *int64
	marginMakerCommission *float32
	marginTakerCommission *float32
	recvWindow *int64
}

func (r ApiCreateBrokerSubAccountApiCommissionV1Request) MakerCommission(makerCommission float32) ApiCreateBrokerSubAccountApiCommissionV1Request {
	r.makerCommission = &makerCommission
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionV1Request) SubAccountId(subAccountId string) ApiCreateBrokerSubAccountApiCommissionV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionV1Request) TakerCommission(takerCommission float32) ApiCreateBrokerSubAccountApiCommissionV1Request {
	r.takerCommission = &takerCommission
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionV1Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountApiCommissionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionV1Request) MarginMakerCommission(marginMakerCommission float32) ApiCreateBrokerSubAccountApiCommissionV1Request {
	r.marginMakerCommission = &marginMakerCommission
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionV1Request) MarginTakerCommission(marginTakerCommission float32) ApiCreateBrokerSubAccountApiCommissionV1Request {
	r.marginTakerCommission = &marginTakerCommission
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountApiCommissionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountApiCommissionV1Request) Execute() (*CreateBrokerSubAccountApiCommissionV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountApiCommissionV1Execute(r)
}

/*
CreateBrokerSubAccountApiCommissionV1 Change Sub Account Commission

This request will change the commission for a sub account.
You need to enable "trade" option for the api key which requests this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountApiCommissionV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiCommissionV1(ctx context.Context) ApiCreateBrokerSubAccountApiCommissionV1Request {
	return ApiCreateBrokerSubAccountApiCommissionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountApiCommissionV1Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiCommissionV1Execute(r ApiCreateBrokerSubAccountApiCommissionV1Request) (*CreateBrokerSubAccountApiCommissionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountApiCommissionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountApiCommissionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi/commission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.makerCommission == nil {
		return localVarReturnValue, nil, reportError("makerCommission is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.takerCommission == nil {
		return localVarReturnValue, nil, reportError("takerCommission is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "makerCommission", r.makerCommission, "", "")
	if r.marginMakerCommission != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "marginMakerCommission", r.marginMakerCommission, "", "")
	}
	if r.marginTakerCommission != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "marginTakerCommission", r.marginTakerCommission, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "takerCommission", r.takerCommission, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountApiIpRestrictionV2Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	status *string
	subAccountApiKey *string
	subAccountId *string
	timestamp *int64
	ipAddress *string
	recvWindow *int64
}

func (r ApiCreateBrokerSubAccountApiIpRestrictionV2Request) Status(status string) ApiCreateBrokerSubAccountApiIpRestrictionV2Request {
	r.status = &status
	return r
}

func (r ApiCreateBrokerSubAccountApiIpRestrictionV2Request) SubAccountApiKey(subAccountApiKey string) ApiCreateBrokerSubAccountApiIpRestrictionV2Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r ApiCreateBrokerSubAccountApiIpRestrictionV2Request) SubAccountId(subAccountId string) ApiCreateBrokerSubAccountApiIpRestrictionV2Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateBrokerSubAccountApiIpRestrictionV2Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountApiIpRestrictionV2Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountApiIpRestrictionV2Request) IpAddress(ipAddress string) ApiCreateBrokerSubAccountApiIpRestrictionV2Request {
	r.ipAddress = &ipAddress
	return r
}

func (r ApiCreateBrokerSubAccountApiIpRestrictionV2Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountApiIpRestrictionV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountApiIpRestrictionV2Request) Execute() (*CreateBrokerSubAccountApiIpRestrictionV2Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountApiIpRestrictionV2Execute(r)
}

/*
CreateBrokerSubAccountApiIpRestrictionV2 Update IP Restriction for Sub-Account API key (For Master Account)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountApiIpRestrictionV2Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiIpRestrictionV2(ctx context.Context) ApiCreateBrokerSubAccountApiIpRestrictionV2Request {
	return ApiCreateBrokerSubAccountApiIpRestrictionV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountApiIpRestrictionV2Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiIpRestrictionV2Execute(r ApiCreateBrokerSubAccountApiIpRestrictionV2Request) (*CreateBrokerSubAccountApiIpRestrictionV2Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountApiIpRestrictionV2Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountApiIpRestrictionV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/broker/subAccountApi/ipRestriction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ipAddress", r.ipAddress, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "status", r.status, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountApiKey", r.subAccountApiKey, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	canUniversalTransfer *string
	subAccountApiKey *string
	subAccountId *int64
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request) CanUniversalTransfer(canUniversalTransfer string) ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request {
	r.canUniversalTransfer = &canUniversalTransfer
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request) SubAccountApiKey(subAccountApiKey string) ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request) SubAccountId(subAccountId int64) ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request) Execute() (*CreateBrokerSubAccountApiPermissionUniversalTransferV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountApiPermissionUniversalTransferV1Execute(r)
}

/*
CreateBrokerSubAccountApiPermissionUniversalTransferV1 Enable Universal Transfer Permission For Sub Account Api Key

Caution:
- This request will enable the api permission for a sub account to use POST /sapi/v1/asset/transferendpoint.
- You need to enable "trade" option for the api key which requests this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiPermissionUniversalTransferV1(ctx context.Context) ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request {
	return ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountApiPermissionUniversalTransferV1Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiPermissionUniversalTransferV1Execute(r ApiCreateBrokerSubAccountApiPermissionUniversalTransferV1Request) (*CreateBrokerSubAccountApiPermissionUniversalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountApiPermissionUniversalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountApiPermissionUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi/permission/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.canUniversalTransfer == nil {
		return localVarReturnValue, nil, reportError("canUniversalTransfer is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "canUniversalTransfer", r.canUniversalTransfer, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountApiKey", r.subAccountApiKey, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountApiPermissionV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	canTrade *string
	futuresTrade *string
	marginTrade *string
	subAccountApiKey *string
	subAccountId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateBrokerSubAccountApiPermissionV1Request) CanTrade(canTrade string) ApiCreateBrokerSubAccountApiPermissionV1Request {
	r.canTrade = &canTrade
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionV1Request) FuturesTrade(futuresTrade string) ApiCreateBrokerSubAccountApiPermissionV1Request {
	r.futuresTrade = &futuresTrade
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionV1Request) MarginTrade(marginTrade string) ApiCreateBrokerSubAccountApiPermissionV1Request {
	r.marginTrade = &marginTrade
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionV1Request) SubAccountApiKey(subAccountApiKey string) ApiCreateBrokerSubAccountApiPermissionV1Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionV1Request) SubAccountId(subAccountId string) ApiCreateBrokerSubAccountApiPermissionV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionV1Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountApiPermissionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountApiPermissionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountApiPermissionV1Request) Execute() (*CreateBrokerSubAccountApiPermissionV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountApiPermissionV1Execute(r)
}

/*
CreateBrokerSubAccountApiPermissionV1 Change Sub Account Api Permission

Caution:
- This request will change the api permission for a sub account.
- You need to enable "trade" option for the api key which requests this endpoint.
- Sub account should be enable margin before its api-key's marginTrade being enabled.
- Sub account should be enable futures before its api-key's futuresTrade being enabled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountApiPermissionV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiPermissionV1(ctx context.Context) ApiCreateBrokerSubAccountApiPermissionV1Request {
	return ApiCreateBrokerSubAccountApiPermissionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountApiPermissionV1Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiPermissionV1Execute(r ApiCreateBrokerSubAccountApiPermissionV1Request) (*CreateBrokerSubAccountApiPermissionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountApiPermissionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountApiPermissionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi/permission"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.canTrade == nil {
		return localVarReturnValue, nil, reportError("canTrade is required and must be specified")
	}
	if r.futuresTrade == nil {
		return localVarReturnValue, nil, reportError("futuresTrade is required and must be specified")
	}
	if r.marginTrade == nil {
		return localVarReturnValue, nil, reportError("marginTrade is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "canTrade", r.canTrade, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "futuresTrade", r.futuresTrade, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "marginTrade", r.marginTrade, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountApiKey", r.subAccountApiKey, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountApiV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	canTrade *string
	subAccountId *string
	timestamp *int64
	futuresTrade *string
	marginTrade *string
	publicKey *string
	recvWindow *int64
}

func (r ApiCreateBrokerSubAccountApiV1Request) CanTrade(canTrade string) ApiCreateBrokerSubAccountApiV1Request {
	r.canTrade = &canTrade
	return r
}

func (r ApiCreateBrokerSubAccountApiV1Request) SubAccountId(subAccountId string) ApiCreateBrokerSubAccountApiV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateBrokerSubAccountApiV1Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountApiV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountApiV1Request) FuturesTrade(futuresTrade string) ApiCreateBrokerSubAccountApiV1Request {
	r.futuresTrade = &futuresTrade
	return r
}

func (r ApiCreateBrokerSubAccountApiV1Request) MarginTrade(marginTrade string) ApiCreateBrokerSubAccountApiV1Request {
	r.marginTrade = &marginTrade
	return r
}

func (r ApiCreateBrokerSubAccountApiV1Request) PublicKey(publicKey string) ApiCreateBrokerSubAccountApiV1Request {
	r.publicKey = &publicKey
	return r
}

func (r ApiCreateBrokerSubAccountApiV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountApiV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountApiV1Request) Execute() (*CreateBrokerSubAccountApiV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountApiV1Execute(r)
}

/*
CreateBrokerSubAccountApiV1 Create Api Key for Sub Account

Caution:
- This request will generate a api key for a sub account.
- You need to enable "trade" option for the api key which requests this endpoint
- Sub account should be enable margin before its api-key's marginTrade being enabled
- Sub account should be enable futures before its api-key's futuresTrade being enabled
- You can only create 1 api key for each sub account per second

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountApiV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiV1(ctx context.Context) ApiCreateBrokerSubAccountApiV1Request {
	return ApiCreateBrokerSubAccountApiV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountApiV1Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountApiV1Execute(r ApiCreateBrokerSubAccountApiV1Request) (*CreateBrokerSubAccountApiV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountApiV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountApiV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.canTrade == nil {
		return localVarReturnValue, nil, reportError("canTrade is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "canTrade", r.canTrade, "", "")
	if r.futuresTrade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "futuresTrade", r.futuresTrade, "", "")
	}
	if r.marginTrade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "marginTrade", r.marginTrade, "", "")
	}
	if r.publicKey != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "publicKey", r.publicKey, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	interestBNBBurn *string
	subAccountId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request) InterestBNBBurn(interestBNBBurn string) ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request {
	r.interestBNBBurn = &interestBNBBurn
	return r
}

func (r ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request) SubAccountId(subAccountId string) ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request) Execute() (*CreateBrokerSubAccountBnbBurnMarginInterestV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountBnbBurnMarginInterestV1Execute(r)
}

/*
CreateBrokerSubAccountBnbBurnMarginInterestV1 Enable Or Disable BNB Burn for Sub Account Margin Interest

- Subaccount must be enabled margin before using this switch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountBnbBurnMarginInterestV1(ctx context.Context) ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request {
	return ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountBnbBurnMarginInterestV1Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountBnbBurnMarginInterestV1Execute(r ApiCreateBrokerSubAccountBnbBurnMarginInterestV1Request) (*CreateBrokerSubAccountBnbBurnMarginInterestV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountBnbBurnMarginInterestV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountBnbBurnMarginInterestV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccount/bnbBurn/marginInterest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.interestBNBBurn == nil {
		return localVarReturnValue, nil, reportError("interestBNBBurn is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "interestBNBBurn", r.interestBNBBurn, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountBnbBurnSpotV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	spotBNBBurn *string
	subAccountId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateBrokerSubAccountBnbBurnSpotV1Request) SpotBNBBurn(spotBNBBurn string) ApiCreateBrokerSubAccountBnbBurnSpotV1Request {
	r.spotBNBBurn = &spotBNBBurn
	return r
}

func (r ApiCreateBrokerSubAccountBnbBurnSpotV1Request) SubAccountId(subAccountId string) ApiCreateBrokerSubAccountBnbBurnSpotV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateBrokerSubAccountBnbBurnSpotV1Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountBnbBurnSpotV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountBnbBurnSpotV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountBnbBurnSpotV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountBnbBurnSpotV1Request) Execute() (*CreateBrokerSubAccountBnbBurnSpotV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountBnbBurnSpotV1Execute(r)
}

/*
CreateBrokerSubAccountBnbBurnSpotV1 Enable Or Disable BNB Burn for Sub Account SPOT and MARGIN

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountBnbBurnSpotV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountBnbBurnSpotV1(ctx context.Context) ApiCreateBrokerSubAccountBnbBurnSpotV1Request {
	return ApiCreateBrokerSubAccountBnbBurnSpotV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountBnbBurnSpotV1Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountBnbBurnSpotV1Execute(r ApiCreateBrokerSubAccountBnbBurnSpotV1Request) (*CreateBrokerSubAccountBnbBurnSpotV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountBnbBurnSpotV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountBnbBurnSpotV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccount/bnbBurn/spot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.spotBNBBurn == nil {
		return localVarReturnValue, nil, reportError("spotBNBBurn is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "spotBNBBurn", r.spotBNBBurn, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountFuturesV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	futures *string
	subAccountId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiCreateBrokerSubAccountFuturesV1Request) Futures(futures string) ApiCreateBrokerSubAccountFuturesV1Request {
	r.futures = &futures
	return r
}

func (r ApiCreateBrokerSubAccountFuturesV1Request) SubAccountId(subAccountId string) ApiCreateBrokerSubAccountFuturesV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiCreateBrokerSubAccountFuturesV1Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountFuturesV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountFuturesV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountFuturesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountFuturesV1Request) Execute() (*CreateBrokerSubAccountFuturesV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountFuturesV1Execute(r)
}

/*
CreateBrokerSubAccountFuturesV1 Enable Futures for Sub Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountFuturesV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountFuturesV1(ctx context.Context) ApiCreateBrokerSubAccountFuturesV1Request {
	return ApiCreateBrokerSubAccountFuturesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountFuturesV1Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountFuturesV1Execute(r ApiCreateBrokerSubAccountFuturesV1Request) (*CreateBrokerSubAccountFuturesV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountFuturesV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountFuturesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccount/futures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.futures == nil {
		return localVarReturnValue, nil, reportError("futures is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "futures", r.futures, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerSubAccountV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	recvWindow *int64
	tag *string
}

func (r ApiCreateBrokerSubAccountV1Request) Timestamp(timestamp int64) ApiCreateBrokerSubAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerSubAccountV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerSubAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerSubAccountV1Request) Tag(tag string) ApiCreateBrokerSubAccountV1Request {
	r.tag = &tag
	return r
}

func (r ApiCreateBrokerSubAccountV1Request) Execute() (*CreateBrokerSubAccountV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerSubAccountV1Execute(r)
}

/*
CreateBrokerSubAccountV1 Create a Sub Account

To create a link sub-account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerSubAccountV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerSubAccountV1(ctx context.Context) ApiCreateBrokerSubAccountV1Request {
	return ApiCreateBrokerSubAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerSubAccountV1Resp
func (a *BinanceLinkAPIService) CreateBrokerSubAccountV1Execute(r ApiCreateBrokerSubAccountV1Request) (*CreateBrokerSubAccountV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerSubAccountV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerSubAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tag", r.tag, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerTransferFuturesV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	amount *string
	asset *string
	futuresType *int64
	timestamp *int64
	clientTranId *string
	fromId *string
	recvWindow *int64
	toId *string
}

func (r ApiCreateBrokerTransferFuturesV1Request) Amount(amount string) ApiCreateBrokerTransferFuturesV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateBrokerTransferFuturesV1Request) Asset(asset string) ApiCreateBrokerTransferFuturesV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateBrokerTransferFuturesV1Request) FuturesType(futuresType int64) ApiCreateBrokerTransferFuturesV1Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiCreateBrokerTransferFuturesV1Request) Timestamp(timestamp int64) ApiCreateBrokerTransferFuturesV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerTransferFuturesV1Request) ClientTranId(clientTranId string) ApiCreateBrokerTransferFuturesV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r ApiCreateBrokerTransferFuturesV1Request) FromId(fromId string) ApiCreateBrokerTransferFuturesV1Request {
	r.fromId = &fromId
	return r
}

func (r ApiCreateBrokerTransferFuturesV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerTransferFuturesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerTransferFuturesV1Request) ToId(toId string) ApiCreateBrokerTransferFuturesV1Request {
	r.toId = &toId
	return r
}

func (r ApiCreateBrokerTransferFuturesV1Request) Execute() (*CreateBrokerTransferFuturesV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerTransferFuturesV1Execute(r)
}

/*
CreateBrokerTransferFuturesV1 Sub Account Transfer（FUTURES）

Caution:
- You need to enable "internal transfer" option for the api key which requests this endpoint.
- Transfer from master account if fromId not sent.
- Transfer to master account if toId not sent.
- Each master account could transfer 5000 times/min

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerTransferFuturesV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerTransferFuturesV1(ctx context.Context) ApiCreateBrokerTransferFuturesV1Request {
	return ApiCreateBrokerTransferFuturesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerTransferFuturesV1Resp
func (a *BinanceLinkAPIService) CreateBrokerTransferFuturesV1Execute(r ApiCreateBrokerTransferFuturesV1Request) (*CreateBrokerTransferFuturesV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerTransferFuturesV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerTransferFuturesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/transfer/futures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "clientTranId", r.clientTranId, "", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromId", r.fromId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "futuresType", r.futuresType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.toId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toId", r.toId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerTransferV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	amount *string
	asset *string
	timestamp *int64
	clientTranId *string
	fromId *string
	recvWindow *int64
	toId *string
}

func (r ApiCreateBrokerTransferV1Request) Amount(amount string) ApiCreateBrokerTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateBrokerTransferV1Request) Asset(asset string) ApiCreateBrokerTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateBrokerTransferV1Request) Timestamp(timestamp int64) ApiCreateBrokerTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerTransferV1Request) ClientTranId(clientTranId string) ApiCreateBrokerTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r ApiCreateBrokerTransferV1Request) FromId(fromId string) ApiCreateBrokerTransferV1Request {
	r.fromId = &fromId
	return r
}

func (r ApiCreateBrokerTransferV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerTransferV1Request) ToId(toId string) ApiCreateBrokerTransferV1Request {
	r.toId = &toId
	return r
}

func (r ApiCreateBrokerTransferV1Request) Execute() (*CreateBrokerTransferV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerTransferV1Execute(r)
}

/*
CreateBrokerTransferV1 Sub Account Transfer（SPOT）

Caution:
- You need to enable "internal transfer" option for the api key which requests this endpoint.
- Transfer from master account if fromId not sent.
- Transfer to master account if toId not sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerTransferV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerTransferV1(ctx context.Context) ApiCreateBrokerTransferV1Request {
	return ApiCreateBrokerTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerTransferV1Resp
func (a *BinanceLinkAPIService) CreateBrokerTransferV1Execute(r ApiCreateBrokerTransferV1Request) (*CreateBrokerTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "clientTranId", r.clientTranId, "", "")
	}
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromId", r.fromId, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.toId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toId", r.toId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrokerUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	amount *string
	asset *string
	fromAccountType *string
	timestamp *int64
	toAccountType *string
	clientTranId *string
	fromId *string
	recvWindow *int64
	toId *string
}

func (r ApiCreateBrokerUniversalTransferV1Request) Amount(amount string) ApiCreateBrokerUniversalTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiCreateBrokerUniversalTransferV1Request) Asset(asset string) ApiCreateBrokerUniversalTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiCreateBrokerUniversalTransferV1Request) FromAccountType(fromAccountType string) ApiCreateBrokerUniversalTransferV1Request {
	r.fromAccountType = &fromAccountType
	return r
}

func (r ApiCreateBrokerUniversalTransferV1Request) Timestamp(timestamp int64) ApiCreateBrokerUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiCreateBrokerUniversalTransferV1Request) ToAccountType(toAccountType string) ApiCreateBrokerUniversalTransferV1Request {
	r.toAccountType = &toAccountType
	return r
}

func (r ApiCreateBrokerUniversalTransferV1Request) ClientTranId(clientTranId string) ApiCreateBrokerUniversalTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r ApiCreateBrokerUniversalTransferV1Request) FromId(fromId string) ApiCreateBrokerUniversalTransferV1Request {
	r.fromId = &fromId
	return r
}

func (r ApiCreateBrokerUniversalTransferV1Request) RecvWindow(recvWindow int64) ApiCreateBrokerUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateBrokerUniversalTransferV1Request) ToId(toId string) ApiCreateBrokerUniversalTransferV1Request {
	r.toId = &toId
	return r
}

func (r ApiCreateBrokerUniversalTransferV1Request) Execute() (*CreateBrokerUniversalTransferV1Resp, *http.Response, error) {
	return r.ApiService.CreateBrokerUniversalTransferV1Execute(r)
}

/*
CreateBrokerUniversalTransferV1 Universal Transfer

Caution:
- You need to enable "internal transfer" option for the api key which requests this endpoint.
- Transfer from master account if fromId not sent.
- Transfer to master account if toId not sent.
- Transfer between futures acount is not supported.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBrokerUniversalTransferV1Request
*/
func (a *BinanceLinkAPIService) CreateBrokerUniversalTransferV1(ctx context.Context) ApiCreateBrokerUniversalTransferV1Request {
	return ApiCreateBrokerUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBrokerUniversalTransferV1Resp
func (a *BinanceLinkAPIService) CreateBrokerUniversalTransferV1Execute(r ApiCreateBrokerUniversalTransferV1Request) (*CreateBrokerUniversalTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBrokerUniversalTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.CreateBrokerUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.fromAccountType == nil {
		return localVarReturnValue, nil, reportError("fromAccountType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.toAccountType == nil {
		return localVarReturnValue, nil, reportError("toAccountType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "clientTranId", r.clientTranId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "fromAccountType", r.fromAccountType, "", "")
	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromId", r.fromId, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "toAccountType", r.toAccountType, "", "")
	if r.toId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toId", r.toId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	subAccountId *string
	subAccountApiKey *string
	timestamp *int64
	ipAddress *string
	recvWindow *int64
}

func (r ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request) SubAccountId(subAccountId string) ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request) SubAccountApiKey(subAccountApiKey string) ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request) Timestamp(timestamp int64) ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request) IpAddress(ipAddress string) ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request {
	r.ipAddress = &ipAddress
	return r
}

func (r ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request) RecvWindow(recvWindow int64) ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request) Execute() (*DeleteBrokerSubAccountApiIpRestrictionIpListV1Resp, *http.Response, error) {
	return r.ApiService.DeleteBrokerSubAccountApiIpRestrictionIpListV1Execute(r)
}

/*
DeleteBrokerSubAccountApiIpRestrictionIpListV1 Delete IP Restriction for Sub Account Api Key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request
*/
func (a *BinanceLinkAPIService) DeleteBrokerSubAccountApiIpRestrictionIpListV1(ctx context.Context) ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request {
	return ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteBrokerSubAccountApiIpRestrictionIpListV1Resp
func (a *BinanceLinkAPIService) DeleteBrokerSubAccountApiIpRestrictionIpListV1Execute(r ApiDeleteBrokerSubAccountApiIpRestrictionIpListV1Request) (*DeleteBrokerSubAccountApiIpRestrictionIpListV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteBrokerSubAccountApiIpRestrictionIpListV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.DeleteBrokerSubAccountApiIpRestrictionIpListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi/ipRestriction/ipList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountApiKey", r.subAccountApiKey, "form", "")
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ipAddress", r.ipAddress, "form", "")
	} else {
		var defaultValue string = ""
		r.ipAddress = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBrokerSubAccountApiV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	subAccountId *string
	subAccountApiKey *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiDeleteBrokerSubAccountApiV1Request) SubAccountId(subAccountId string) ApiDeleteBrokerSubAccountApiV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiDeleteBrokerSubAccountApiV1Request) SubAccountApiKey(subAccountApiKey string) ApiDeleteBrokerSubAccountApiV1Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r ApiDeleteBrokerSubAccountApiV1Request) Timestamp(timestamp int64) ApiDeleteBrokerSubAccountApiV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiDeleteBrokerSubAccountApiV1Request) RecvWindow(recvWindow int64) ApiDeleteBrokerSubAccountApiV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiDeleteBrokerSubAccountApiV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteBrokerSubAccountApiV1Execute(r)
}

/*
DeleteBrokerSubAccountApiV1 Delete Sub Account Api Key

Caution:
- This request will delete a api key for a sub account
- You need to enable "trade" option for the api key which requests this endpoint
- You can only delete 1 api key for each sub account per second

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBrokerSubAccountApiV1Request
*/
func (a *BinanceLinkAPIService) DeleteBrokerSubAccountApiV1(ctx context.Context) ApiDeleteBrokerSubAccountApiV1Request {
	return ApiDeleteBrokerSubAccountApiV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BinanceLinkAPIService) DeleteBrokerSubAccountApiV1Execute(r ApiDeleteBrokerSubAccountApiV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.DeleteBrokerSubAccountApiV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountApiKey", r.subAccountApiKey, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBrokerSubAccountV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	subAccountId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiDeleteBrokerSubAccountV1Request) SubAccountId(subAccountId string) ApiDeleteBrokerSubAccountV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiDeleteBrokerSubAccountV1Request) Timestamp(timestamp int64) ApiDeleteBrokerSubAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiDeleteBrokerSubAccountV1Request) RecvWindow(recvWindow int64) ApiDeleteBrokerSubAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiDeleteBrokerSubAccountV1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteBrokerSubAccountV1Execute(r)
}

/*
DeleteBrokerSubAccountV1 Delete Sub Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBrokerSubAccountV1Request
*/
func (a *BinanceLinkAPIService) DeleteBrokerSubAccountV1(ctx context.Context) ApiDeleteBrokerSubAccountV1Request {
	return ApiDeleteBrokerSubAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BinanceLinkAPIService) DeleteBrokerSubAccountV1Execute(r ApiDeleteBrokerSubAccountV1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.DeleteBrokerSubAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiReferralCustomizationV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	customerId *string
	email *string
	recvWindow *int64
}

func (r ApiGetApiReferralCustomizationV1Request) Timestamp(timestamp int64) ApiGetApiReferralCustomizationV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetApiReferralCustomizationV1Request) CustomerId(customerId string) ApiGetApiReferralCustomizationV1Request {
	r.customerId = &customerId
	return r
}

func (r ApiGetApiReferralCustomizationV1Request) Email(email string) ApiGetApiReferralCustomizationV1Request {
	r.email = &email
	return r
}

func (r ApiGetApiReferralCustomizationV1Request) RecvWindow(recvWindow int64) ApiGetApiReferralCustomizationV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetApiReferralCustomizationV1Request) Execute() ([]GetApiReferralCustomizationV1RespItem, *http.Response, error) {
	return r.ApiService.GetApiReferralCustomizationV1Execute(r)
}

/*
GetApiReferralCustomizationV1 Get Client Email Customized Id (USER DATA) （For Partner）

- CustomerId and email can not be sent at the same time

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApiReferralCustomizationV1Request
*/
func (a *BinanceLinkAPIService) GetApiReferralCustomizationV1(ctx context.Context) ApiGetApiReferralCustomizationV1Request {
	return ApiGetApiReferralCustomizationV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetApiReferralCustomizationV1RespItem
func (a *BinanceLinkAPIService) GetApiReferralCustomizationV1Execute(r ApiGetApiReferralCustomizationV1Request) ([]GetApiReferralCustomizationV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetApiReferralCustomizationV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetApiReferralCustomizationV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/apiReferral/customization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customerId", r.customerId, "form", "")
	} else {
		var defaultValue string = ""
		r.customerId = &defaultValue
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	} else {
		var defaultValue string = ""
		r.email = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiReferralIfNewUserV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	apiAgentCode *string
	timestamp *int64
	recvWindow *int64
}

// brokerId
func (r ApiGetApiReferralIfNewUserV1Request) ApiAgentCode(apiAgentCode string) ApiGetApiReferralIfNewUserV1Request {
	r.apiAgentCode = &apiAgentCode
	return r
}

func (r ApiGetApiReferralIfNewUserV1Request) Timestamp(timestamp int64) ApiGetApiReferralIfNewUserV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetApiReferralIfNewUserV1Request) RecvWindow(recvWindow int64) ApiGetApiReferralIfNewUserV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetApiReferralIfNewUserV1Request) Execute() (*GetApiReferralIfNewUserV1Resp, *http.Response, error) {
	return r.ApiService.GetApiReferralIfNewUserV1Execute(r)
}

/*
GetApiReferralIfNewUserV1 Query Client If The New User (USER  DATA)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApiReferralIfNewUserV1Request
*/
func (a *BinanceLinkAPIService) GetApiReferralIfNewUserV1(ctx context.Context) ApiGetApiReferralIfNewUserV1Request {
	return ApiGetApiReferralIfNewUserV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetApiReferralIfNewUserV1Resp
func (a *BinanceLinkAPIService) GetApiReferralIfNewUserV1Execute(r ApiGetApiReferralIfNewUserV1Request) (*GetApiReferralIfNewUserV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetApiReferralIfNewUserV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetApiReferralIfNewUserV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/apiReferral/ifNewUser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiAgentCode == nil {
		return localVarReturnValue, nil, reportError("apiAgentCode is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "apiAgentCode", r.apiAgentCode, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiReferralKickbackRecentRecordV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiGetApiReferralKickbackRecentRecordV1Request) Timestamp(timestamp int64) ApiGetApiReferralKickbackRecentRecordV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetApiReferralKickbackRecentRecordV1Request) StartTime(startTime int64) ApiGetApiReferralKickbackRecentRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetApiReferralKickbackRecentRecordV1Request) EndTime(endTime int64) ApiGetApiReferralKickbackRecentRecordV1Request {
	r.endTime = &endTime
	return r
}

// Default 500, max 1000
func (r ApiGetApiReferralKickbackRecentRecordV1Request) Limit(limit int32) ApiGetApiReferralKickbackRecentRecordV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetApiReferralKickbackRecentRecordV1Request) RecvWindow(recvWindow int64) ApiGetApiReferralKickbackRecentRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetApiReferralKickbackRecentRecordV1Request) Execute() ([]GetApiReferralKickbackRecentRecordV1RespItem, *http.Response, error) {
	return r.ApiService.GetApiReferralKickbackRecentRecordV1Execute(r)
}

/*
GetApiReferralKickbackRecentRecordV1 Query Rebate Recent Record(For Client)

- Only get the latest history of past 7 days.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApiReferralKickbackRecentRecordV1Request
*/
func (a *BinanceLinkAPIService) GetApiReferralKickbackRecentRecordV1(ctx context.Context) ApiGetApiReferralKickbackRecentRecordV1Request {
	return ApiGetApiReferralKickbackRecentRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetApiReferralKickbackRecentRecordV1RespItem
func (a *BinanceLinkAPIService) GetApiReferralKickbackRecentRecordV1Execute(r ApiGetApiReferralKickbackRecentRecordV1Request) ([]GetApiReferralKickbackRecentRecordV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetApiReferralKickbackRecentRecordV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetApiReferralKickbackRecentRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/apiReferral/kickback/recentRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiReferralRebateRecentRecordV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	startTime *int64
	endTime *int64
	limit *int32
	timestamp *int64
	customerId *string
	recvWindow *int64
}

func (r ApiGetApiReferralRebateRecentRecordV1Request) StartTime(startTime int64) ApiGetApiReferralRebateRecentRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetApiReferralRebateRecentRecordV1Request) EndTime(endTime int64) ApiGetApiReferralRebateRecentRecordV1Request {
	r.endTime = &endTime
	return r
}

// max 500
func (r ApiGetApiReferralRebateRecentRecordV1Request) Limit(limit int32) ApiGetApiReferralRebateRecentRecordV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetApiReferralRebateRecentRecordV1Request) Timestamp(timestamp int64) ApiGetApiReferralRebateRecentRecordV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetApiReferralRebateRecentRecordV1Request) CustomerId(customerId string) ApiGetApiReferralRebateRecentRecordV1Request {
	r.customerId = &customerId
	return r
}

func (r ApiGetApiReferralRebateRecentRecordV1Request) RecvWindow(recvWindow int64) ApiGetApiReferralRebateRecentRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetApiReferralRebateRecentRecordV1Request) Execute() ([]GetApiReferralRebateRecentRecordV1RespItem, *http.Response, error) {
	return r.ApiService.GetApiReferralRebateRecentRecordV1Execute(r)
}

/*
GetApiReferralRebateRecentRecordV1 Query Rebate Recent Record （USER DATA）(For Partner)

- startTime and endTime must be both specified or both omitted.
- When both omitted it returns last 7 days.
- When both specified the span has to be within 7 days.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApiReferralRebateRecentRecordV1Request
*/
func (a *BinanceLinkAPIService) GetApiReferralRebateRecentRecordV1(ctx context.Context) ApiGetApiReferralRebateRecentRecordV1Request {
	return ApiGetApiReferralRebateRecentRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetApiReferralRebateRecentRecordV1RespItem
func (a *BinanceLinkAPIService) GetApiReferralRebateRecentRecordV1Execute(r ApiGetApiReferralRebateRecentRecordV1Request) ([]GetApiReferralRebateRecentRecordV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetApiReferralRebateRecentRecordV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetApiReferralRebateRecentRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/apiReferral/rebate/recentRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit > 500 {
		return localVarReturnValue, nil, reportError("limit must be less than 500")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customerId", r.customerId, "form", "")
	} else {
		var defaultValue string = ""
		r.customerId = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiReferralUserCustomizationV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	apiAgentCode *string
	timestamp *int64
	recvWindow *int64
}

// brokerId
func (r ApiGetApiReferralUserCustomizationV1Request) ApiAgentCode(apiAgentCode string) ApiGetApiReferralUserCustomizationV1Request {
	r.apiAgentCode = &apiAgentCode
	return r
}

func (r ApiGetApiReferralUserCustomizationV1Request) Timestamp(timestamp int64) ApiGetApiReferralUserCustomizationV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetApiReferralUserCustomizationV1Request) RecvWindow(recvWindow int64) ApiGetApiReferralUserCustomizationV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetApiReferralUserCustomizationV1Request) Execute() (*GetApiReferralUserCustomizationV1Resp, *http.Response, error) {
	return r.ApiService.GetApiReferralUserCustomizationV1Execute(r)
}

/*
GetApiReferralUserCustomizationV1 Get User’s Customize Id (USER DATA)

- CustomerId must be unique

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApiReferralUserCustomizationV1Request
*/
func (a *BinanceLinkAPIService) GetApiReferralUserCustomizationV1(ctx context.Context) ApiGetApiReferralUserCustomizationV1Request {
	return ApiGetApiReferralUserCustomizationV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetApiReferralUserCustomizationV1Resp
func (a *BinanceLinkAPIService) GetApiReferralUserCustomizationV1Execute(r ApiGetApiReferralUserCustomizationV1Request) (*GetApiReferralUserCustomizationV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetApiReferralUserCustomizationV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetApiReferralUserCustomizationV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/apiReferral/userCustomization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiAgentCode == nil {
		return localVarReturnValue, nil, reportError("apiAgentCode is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "apiAgentCode", r.apiAgentCode, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerInfoV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetBrokerInfoV1Request) Timestamp(timestamp int64) ApiGetBrokerInfoV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerInfoV1Request) RecvWindow(recvWindow int64) ApiGetBrokerInfoV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerInfoV1Request) Execute() (*GetBrokerInfoV1Resp, *http.Response, error) {
	return r.ApiService.GetBrokerInfoV1Execute(r)
}

/*
GetBrokerInfoV1 Link Account Information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerInfoV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerInfoV1(ctx context.Context) ApiGetBrokerInfoV1Request {
	return ApiGetBrokerInfoV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBrokerInfoV1Resp
func (a *BinanceLinkAPIService) GetBrokerInfoV1Execute(r ApiGetBrokerInfoV1Request) (*GetBrokerInfoV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBrokerInfoV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerInfoV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerRebateFuturesRecentRecordV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	futuresType *int64
	startTime *int64
	endTime *int64
	timestamp *int64
	page *int64
	size *int64
	filterResult *bool
	recvWindow *int64
}

// 1:USDT Futures, 2: Coin Futures
func (r ApiGetBrokerRebateFuturesRecentRecordV1Request) FuturesType(futuresType int64) ApiGetBrokerRebateFuturesRecentRecordV1Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiGetBrokerRebateFuturesRecentRecordV1Request) StartTime(startTime int64) ApiGetBrokerRebateFuturesRecentRecordV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetBrokerRebateFuturesRecentRecordV1Request) EndTime(endTime int64) ApiGetBrokerRebateFuturesRecentRecordV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetBrokerRebateFuturesRecentRecordV1Request) Timestamp(timestamp int64) ApiGetBrokerRebateFuturesRecentRecordV1Request {
	r.timestamp = &timestamp
	return r
}

// default 1
func (r ApiGetBrokerRebateFuturesRecentRecordV1Request) Page(page int64) ApiGetBrokerRebateFuturesRecentRecordV1Request {
	r.page = &page
	return r
}

// default 10, max 100
func (r ApiGetBrokerRebateFuturesRecentRecordV1Request) Size(size int64) ApiGetBrokerRebateFuturesRecentRecordV1Request {
	r.size = &size
	return r
}

// TRUE or FALSE. Default: FALSE
func (r ApiGetBrokerRebateFuturesRecentRecordV1Request) FilterResult(filterResult bool) ApiGetBrokerRebateFuturesRecentRecordV1Request {
	r.filterResult = &filterResult
	return r
}

func (r ApiGetBrokerRebateFuturesRecentRecordV1Request) RecvWindow(recvWindow int64) ApiGetBrokerRebateFuturesRecentRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerRebateFuturesRecentRecordV1Request) Execute() ([]GetBrokerRebateFuturesRecentRecordV1RespItem, *http.Response, error) {
	return r.ApiService.GetBrokerRebateFuturesRecentRecordV1Execute(r)
}

/*
GetBrokerRebateFuturesRecentRecordV1 Query Broker Futures Commission Rebate Record

- If filterResult = TRUE, rebates not from its own sub accounts will be filtered out in response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerRebateFuturesRecentRecordV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerRebateFuturesRecentRecordV1(ctx context.Context) ApiGetBrokerRebateFuturesRecentRecordV1Request {
	return ApiGetBrokerRebateFuturesRecentRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetBrokerRebateFuturesRecentRecordV1RespItem
func (a *BinanceLinkAPIService) GetBrokerRebateFuturesRecentRecordV1Execute(r ApiGetBrokerRebateFuturesRecentRecordV1Request) ([]GetBrokerRebateFuturesRecentRecordV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetBrokerRebateFuturesRecentRecordV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerRebateFuturesRecentRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/rebate/futures/recentRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.filterResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterResult", r.filterResult, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerRebateRecentRecordV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	subAccountId *string
	startTime *int64
	endTime *int64
	page *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetBrokerRebateRecentRecordV1Request) Timestamp(timestamp int64) ApiGetBrokerRebateRecentRecordV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerRebateRecentRecordV1Request) SubAccountId(subAccountId string) ApiGetBrokerRebateRecentRecordV1Request {
	r.subAccountId = &subAccountId
	return r
}

// Default: 7 days from current timestamp
func (r ApiGetBrokerRebateRecentRecordV1Request) StartTime(startTime int64) ApiGetBrokerRebateRecentRecordV1Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r ApiGetBrokerRebateRecentRecordV1Request) EndTime(endTime int64) ApiGetBrokerRebateRecentRecordV1Request {
	r.endTime = &endTime
	return r
}

// default 1
func (r ApiGetBrokerRebateRecentRecordV1Request) Page(page int64) ApiGetBrokerRebateRecentRecordV1Request {
	r.page = &page
	return r
}

// default 500，max500
func (r ApiGetBrokerRebateRecentRecordV1Request) Size(size int64) ApiGetBrokerRebateRecentRecordV1Request {
	r.size = &size
	return r
}

func (r ApiGetBrokerRebateRecentRecordV1Request) RecvWindow(recvWindow int64) ApiGetBrokerRebateRecentRecordV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerRebateRecentRecordV1Request) Execute() ([]GetBrokerRebateRecentRecordV1RespItem, *http.Response, error) {
	return r.ApiService.GetBrokerRebateRecentRecordV1Execute(r)
}

/*
GetBrokerRebateRecentRecordV1 Query Broker Commission Rebate Recent Record（Spot）

- The query time period must be less than 7 days (default as the recent 7 days).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerRebateRecentRecordV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerRebateRecentRecordV1(ctx context.Context) ApiGetBrokerRebateRecentRecordV1Request {
	return ApiGetBrokerRebateRecentRecordV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetBrokerRebateRecentRecordV1RespItem
func (a *BinanceLinkAPIService) GetBrokerRebateRecentRecordV1Execute(r ApiGetBrokerRebateRecentRecordV1Request) ([]GetBrokerRebateRecentRecordV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetBrokerRebateRecentRecordV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerRebateRecentRecordV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/rebate/recentRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.subAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	} else {
		var defaultValue string = ""
		r.subAccountId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 500
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	subAccountId *string
	timestamp *int64
	pair *string
	recvWindow *int64
}

func (r ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request {
	r.timestamp = &timestamp
	return r
}

// BTCUSD
func (r ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request) Pair(pair string) ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request {
	r.pair = &pair
	return r
}

func (r ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request) Execute() ([]GetBrokerSubAccountApiCommissionCoinFuturesV1RespItem, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountApiCommissionCoinFuturesV1Execute(r)
}

/*
GetBrokerSubAccountApiCommissionCoinFuturesV1 Query Sub Account COIN-Ⓜ Futures Commission Adjustment

- The sub-account's COIN-Ⓜ futures commission of a symbol equals to the base commission of the symbol on the sub-account's fee tier plus the commission adjustment.
- If symbol not sent, commission adjustment of all symbols will be returned.
- If futures disabled, it is not allowed to set subaccount's COIN-Ⓜ futures commission adjustment on any symbol.
- Different symbols have the same commission for the same pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountApiCommissionCoinFuturesV1(ctx context.Context) ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request {
	return ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetBrokerSubAccountApiCommissionCoinFuturesV1RespItem
func (a *BinanceLinkAPIService) GetBrokerSubAccountApiCommissionCoinFuturesV1Execute(r ApiGetBrokerSubAccountApiCommissionCoinFuturesV1Request) ([]GetBrokerSubAccountApiCommissionCoinFuturesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetBrokerSubAccountApiCommissionCoinFuturesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountApiCommissionCoinFuturesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi/commission/coinFutures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	if r.pair != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pair", r.pair, "form", "")
	} else {
		var defaultValue string = ""
		r.pair = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountApiCommissionFuturesV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	subAccountId *string
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiGetBrokerSubAccountApiCommissionFuturesV1Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountApiCommissionFuturesV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiGetBrokerSubAccountApiCommissionFuturesV1Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountApiCommissionFuturesV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerSubAccountApiCommissionFuturesV1Request) Symbol(symbol string) ApiGetBrokerSubAccountApiCommissionFuturesV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiGetBrokerSubAccountApiCommissionFuturesV1Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountApiCommissionFuturesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountApiCommissionFuturesV1Request) Execute() ([]GetBrokerSubAccountApiCommissionFuturesV1RespItem, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountApiCommissionFuturesV1Execute(r)
}

/*
GetBrokerSubAccountApiCommissionFuturesV1 Query Sub Account USDT-Ⓜ Futures Commission Adjustment

The sub-account's USDT-Ⓜ futures commission of a symbol equals to the base commission of the symbol on the sub-account's fee tier plus the commission adjustment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountApiCommissionFuturesV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountApiCommissionFuturesV1(ctx context.Context) ApiGetBrokerSubAccountApiCommissionFuturesV1Request {
	return ApiGetBrokerSubAccountApiCommissionFuturesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetBrokerSubAccountApiCommissionFuturesV1RespItem
func (a *BinanceLinkAPIService) GetBrokerSubAccountApiCommissionFuturesV1Execute(r ApiGetBrokerSubAccountApiCommissionFuturesV1Request) ([]GetBrokerSubAccountApiCommissionFuturesV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetBrokerSubAccountApiCommissionFuturesV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountApiCommissionFuturesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi/commission/futures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountApiIpRestrictionV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	subAccountId *string
	subAccountApiKey *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetBrokerSubAccountApiIpRestrictionV1Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountApiIpRestrictionV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiGetBrokerSubAccountApiIpRestrictionV1Request) SubAccountApiKey(subAccountApiKey string) ApiGetBrokerSubAccountApiIpRestrictionV1Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

func (r ApiGetBrokerSubAccountApiIpRestrictionV1Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountApiIpRestrictionV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerSubAccountApiIpRestrictionV1Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountApiIpRestrictionV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountApiIpRestrictionV1Request) Execute() (*GetBrokerSubAccountApiIpRestrictionV1Resp, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountApiIpRestrictionV1Execute(r)
}

/*
GetBrokerSubAccountApiIpRestrictionV1 Get IP Restriction for Sub Account Api Key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountApiIpRestrictionV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountApiIpRestrictionV1(ctx context.Context) ApiGetBrokerSubAccountApiIpRestrictionV1Request {
	return ApiGetBrokerSubAccountApiIpRestrictionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBrokerSubAccountApiIpRestrictionV1Resp
func (a *BinanceLinkAPIService) GetBrokerSubAccountApiIpRestrictionV1Execute(r ApiGetBrokerSubAccountApiIpRestrictionV1Request) (*GetBrokerSubAccountApiIpRestrictionV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBrokerSubAccountApiIpRestrictionV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountApiIpRestrictionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi/ipRestriction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.subAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("subAccountApiKey is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountApiKey", r.subAccountApiKey, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountApiV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	subAccountId *string
	timestamp *int64
	subAccountApiKey *string
	page *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetBrokerSubAccountApiV1Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountApiV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiGetBrokerSubAccountApiV1Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountApiV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerSubAccountApiV1Request) SubAccountApiKey(subAccountApiKey string) ApiGetBrokerSubAccountApiV1Request {
	r.subAccountApiKey = &subAccountApiKey
	return r
}

// default 1
func (r ApiGetBrokerSubAccountApiV1Request) Page(page int64) ApiGetBrokerSubAccountApiV1Request {
	r.page = &page
	return r
}

// default 500, max 500
func (r ApiGetBrokerSubAccountApiV1Request) Size(size int64) ApiGetBrokerSubAccountApiV1Request {
	r.size = &size
	return r
}

func (r ApiGetBrokerSubAccountApiV1Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountApiV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountApiV1Request) Execute() ([]GetBrokerSubAccountApiV1RespItem, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountApiV1Execute(r)
}

/*
GetBrokerSubAccountApiV1 Query Sub Account Api Key

Caution:
- You need to enable "trade" option for the api key which requests this endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountApiV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountApiV1(ctx context.Context) ApiGetBrokerSubAccountApiV1Request {
	return ApiGetBrokerSubAccountApiV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetBrokerSubAccountApiV1RespItem
func (a *BinanceLinkAPIService) GetBrokerSubAccountApiV1Execute(r ApiGetBrokerSubAccountApiV1Request) ([]GetBrokerSubAccountApiV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetBrokerSubAccountApiV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountApiV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccountApi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	if r.subAccountApiKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountApiKey", r.subAccountApiKey, "form", "")
	} else {
		var defaultValue string = ""
		r.subAccountApiKey = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 500
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountBnbBurnStatusV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	subAccountId *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiGetBrokerSubAccountBnbBurnStatusV1Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountBnbBurnStatusV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiGetBrokerSubAccountBnbBurnStatusV1Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountBnbBurnStatusV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerSubAccountBnbBurnStatusV1Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountBnbBurnStatusV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountBnbBurnStatusV1Request) Execute() (*GetBrokerSubAccountBnbBurnStatusV1Resp, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountBnbBurnStatusV1Execute(r)
}

/*
GetBrokerSubAccountBnbBurnStatusV1 Get BNB Burn Status for Sub Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountBnbBurnStatusV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountBnbBurnStatusV1(ctx context.Context) ApiGetBrokerSubAccountBnbBurnStatusV1Request {
	return ApiGetBrokerSubAccountBnbBurnStatusV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBrokerSubAccountBnbBurnStatusV1Resp
func (a *BinanceLinkAPIService) GetBrokerSubAccountBnbBurnStatusV1Execute(r ApiGetBrokerSubAccountBnbBurnStatusV1Request) (*GetBrokerSubAccountBnbBurnStatusV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBrokerSubAccountBnbBurnStatusV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountBnbBurnStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccount/bnbBurn/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountDepositHistV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	subAccountId *string
	coin *string
	status *int32
	startTime *int64
	endTime *int64
	limit *int32
	offset *int32
	recvWindow *int64
}

func (r ApiGetBrokerSubAccountDepositHistV1Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountDepositHistV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerSubAccountDepositHistV1Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountDepositHistV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiGetBrokerSubAccountDepositHistV1Request) Coin(coin string) ApiGetBrokerSubAccountDepositHistV1Request {
	r.coin = &coin
	return r
}

// 0(0:pending,6: credited but cannot withdraw, 1:success)
func (r ApiGetBrokerSubAccountDepositHistV1Request) Status(status int32) ApiGetBrokerSubAccountDepositHistV1Request {
	r.status = &status
	return r
}

// Default: 7 days from current timestamp
func (r ApiGetBrokerSubAccountDepositHistV1Request) StartTime(startTime int64) ApiGetBrokerSubAccountDepositHistV1Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r ApiGetBrokerSubAccountDepositHistV1Request) EndTime(endTime int64) ApiGetBrokerSubAccountDepositHistV1Request {
	r.endTime = &endTime
	return r
}

// Default：500
func (r ApiGetBrokerSubAccountDepositHistV1Request) Limit(limit int32) ApiGetBrokerSubAccountDepositHistV1Request {
	r.limit = &limit
	return r
}

// Default：0
func (r ApiGetBrokerSubAccountDepositHistV1Request) Offset(offset int32) ApiGetBrokerSubAccountDepositHistV1Request {
	r.offset = &offset
	return r
}

func (r ApiGetBrokerSubAccountDepositHistV1Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountDepositHistV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountDepositHistV1Request) Execute() ([]GetBrokerSubAccountDepositHistV1RespItem, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountDepositHistV1Execute(r)
}

/*
GetBrokerSubAccountDepositHistV1 Get Sub Account Deposit History

- The query time period must be less than 7 days( default as the recent 7 days).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountDepositHistV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountDepositHistV1(ctx context.Context) ApiGetBrokerSubAccountDepositHistV1Request {
	return ApiGetBrokerSubAccountDepositHistV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetBrokerSubAccountDepositHistV1RespItem
func (a *BinanceLinkAPIService) GetBrokerSubAccountDepositHistV1Execute(r ApiGetBrokerSubAccountDepositHistV1Request) ([]GetBrokerSubAccountDepositHistV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetBrokerSubAccountDepositHistV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountDepositHistV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccount/depositHist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.subAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	} else {
		var defaultValue string = ""
		r.subAccountId = &defaultValue
	}
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountDepositHistV2Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	depositId *string
	subAccountId *string
	timestamp *int64
	limit *int32
	offset *int32
	recvWindow *int64
}

func (r ApiGetBrokerSubAccountDepositHistV2Request) DepositId(depositId string) ApiGetBrokerSubAccountDepositHistV2Request {
	r.depositId = &depositId
	return r
}

func (r ApiGetBrokerSubAccountDepositHistV2Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountDepositHistV2Request {
	r.subAccountId = &subAccountId
	return r
}

func (r ApiGetBrokerSubAccountDepositHistV2Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountDepositHistV2Request {
	r.timestamp = &timestamp
	return r
}

// Default：500
func (r ApiGetBrokerSubAccountDepositHistV2Request) Limit(limit int32) ApiGetBrokerSubAccountDepositHistV2Request {
	r.limit = &limit
	return r
}

// Default：0
func (r ApiGetBrokerSubAccountDepositHistV2Request) Offset(offset int32) ApiGetBrokerSubAccountDepositHistV2Request {
	r.offset = &offset
	return r
}

func (r ApiGetBrokerSubAccountDepositHistV2Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountDepositHistV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountDepositHistV2Request) Execute() ([]GetBrokerSubAccountDepositHistV2RespItem, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountDepositHistV2Execute(r)
}

/*
GetBrokerSubAccountDepositHistV2 Get Sub Account Deposit History V2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountDepositHistV2Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountDepositHistV2(ctx context.Context) ApiGetBrokerSubAccountDepositHistV2Request {
	return ApiGetBrokerSubAccountDepositHistV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetBrokerSubAccountDepositHistV2RespItem
func (a *BinanceLinkAPIService) GetBrokerSubAccountDepositHistV2Execute(r ApiGetBrokerSubAccountDepositHistV2Request) ([]GetBrokerSubAccountDepositHistV2RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetBrokerSubAccountDepositHistV2RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountDepositHistV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/broker/subAccount/depositHist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.depositId == nil {
		return localVarReturnValue, nil, reportError("depositId is required and must be specified")
	}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "depositId", r.depositId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountFuturesSummaryV3Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	futuresType *int32
	timestamp *int64
	subAccountId *string
	page *int64
	size *int64
	recvWindow *int64
}

// 1:USD Margined Futures, 2:COIN Margined Futures
func (r ApiGetBrokerSubAccountFuturesSummaryV3Request) FuturesType(futuresType int32) ApiGetBrokerSubAccountFuturesSummaryV3Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiGetBrokerSubAccountFuturesSummaryV3Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountFuturesSummaryV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerSubAccountFuturesSummaryV3Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountFuturesSummaryV3Request {
	r.subAccountId = &subAccountId
	return r
}

// default 1
func (r ApiGetBrokerSubAccountFuturesSummaryV3Request) Page(page int64) ApiGetBrokerSubAccountFuturesSummaryV3Request {
	r.page = &page
	return r
}

// default 10, max 20
func (r ApiGetBrokerSubAccountFuturesSummaryV3Request) Size(size int64) ApiGetBrokerSubAccountFuturesSummaryV3Request {
	r.size = &size
	return r
}

func (r ApiGetBrokerSubAccountFuturesSummaryV3Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountFuturesSummaryV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountFuturesSummaryV3Request) Execute() (*ExchangelinkGetBrokerSubAccountFuturesSummaryV3Resp, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountFuturesSummaryV3Execute(r)
}

/*
GetBrokerSubAccountFuturesSummaryV3 Query Sub Account Futures Asset info (V3)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountFuturesSummaryV3Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountFuturesSummaryV3(ctx context.Context) ApiGetBrokerSubAccountFuturesSummaryV3Request {
	return ApiGetBrokerSubAccountFuturesSummaryV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExchangelinkGetBrokerSubAccountFuturesSummaryV3Resp
func (a *BinanceLinkAPIService) GetBrokerSubAccountFuturesSummaryV3Execute(r ApiGetBrokerSubAccountFuturesSummaryV3Request) (*ExchangelinkGetBrokerSubAccountFuturesSummaryV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExchangelinkGetBrokerSubAccountFuturesSummaryV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountFuturesSummaryV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v3/broker/subAccount/futuresSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.subAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	} else {
		var defaultValue string = ""
		r.subAccountId = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountMarginSummaryV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	subAccountId *string
	page *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetBrokerSubAccountMarginSummaryV1Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountMarginSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerSubAccountMarginSummaryV1Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountMarginSummaryV1Request {
	r.subAccountId = &subAccountId
	return r
}

// default 1
func (r ApiGetBrokerSubAccountMarginSummaryV1Request) Page(page int64) ApiGetBrokerSubAccountMarginSummaryV1Request {
	r.page = &page
	return r
}

// default 10, max 20
func (r ApiGetBrokerSubAccountMarginSummaryV1Request) Size(size int64) ApiGetBrokerSubAccountMarginSummaryV1Request {
	r.size = &size
	return r
}

func (r ApiGetBrokerSubAccountMarginSummaryV1Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountMarginSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountMarginSummaryV1Request) Execute() (*GetBrokerSubAccountMarginSummaryV1Resp, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountMarginSummaryV1Execute(r)
}

/*
GetBrokerSubAccountMarginSummaryV1 Query Sub Account Margin Asset info

- If subaccountId is not sent, the size must be sent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountMarginSummaryV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountMarginSummaryV1(ctx context.Context) ApiGetBrokerSubAccountMarginSummaryV1Request {
	return ApiGetBrokerSubAccountMarginSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBrokerSubAccountMarginSummaryV1Resp
func (a *BinanceLinkAPIService) GetBrokerSubAccountMarginSummaryV1Execute(r ApiGetBrokerSubAccountMarginSummaryV1Request) (*GetBrokerSubAccountMarginSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBrokerSubAccountMarginSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountMarginSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccount/marginSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.subAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	} else {
		var defaultValue string = ""
		r.subAccountId = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountSpotSummaryV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	subAccountId *string
	page *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetBrokerSubAccountSpotSummaryV1Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountSpotSummaryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerSubAccountSpotSummaryV1Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountSpotSummaryV1Request {
	r.subAccountId = &subAccountId
	return r
}

// default 1
func (r ApiGetBrokerSubAccountSpotSummaryV1Request) Page(page int64) ApiGetBrokerSubAccountSpotSummaryV1Request {
	r.page = &page
	return r
}

// default 10, max 20
func (r ApiGetBrokerSubAccountSpotSummaryV1Request) Size(size int64) ApiGetBrokerSubAccountSpotSummaryV1Request {
	r.size = &size
	return r
}

func (r ApiGetBrokerSubAccountSpotSummaryV1Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountSpotSummaryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountSpotSummaryV1Request) Execute() (*GetBrokerSubAccountSpotSummaryV1Resp, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountSpotSummaryV1Execute(r)
}

/*
GetBrokerSubAccountSpotSummaryV1 Query Sub Account Spot Asset info

- If subaccountId is not sent, the size must be sent
- Requests per UID are limited to 60 requests per minute

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountSpotSummaryV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountSpotSummaryV1(ctx context.Context) ApiGetBrokerSubAccountSpotSummaryV1Request {
	return ApiGetBrokerSubAccountSpotSummaryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBrokerSubAccountSpotSummaryV1Resp
func (a *BinanceLinkAPIService) GetBrokerSubAccountSpotSummaryV1Execute(r ApiGetBrokerSubAccountSpotSummaryV1Request) (*GetBrokerSubAccountSpotSummaryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBrokerSubAccountSpotSummaryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountSpotSummaryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccount/spotSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.subAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	} else {
		var defaultValue string = ""
		r.subAccountId = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerSubAccountV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	subAccountId *string
	page *int64
	size *int64
	recvWindow *int64
}

func (r ApiGetBrokerSubAccountV1Request) Timestamp(timestamp int64) ApiGetBrokerSubAccountV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerSubAccountV1Request) SubAccountId(subAccountId string) ApiGetBrokerSubAccountV1Request {
	r.subAccountId = &subAccountId
	return r
}

// default 1
func (r ApiGetBrokerSubAccountV1Request) Page(page int64) ApiGetBrokerSubAccountV1Request {
	r.page = &page
	return r
}

// default 500
func (r ApiGetBrokerSubAccountV1Request) Size(size int64) ApiGetBrokerSubAccountV1Request {
	r.size = &size
	return r
}

func (r ApiGetBrokerSubAccountV1Request) RecvWindow(recvWindow int64) ApiGetBrokerSubAccountV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerSubAccountV1Request) Execute() ([]GetBrokerSubAccountV1RespItem, *http.Response, error) {
	return r.ApiService.GetBrokerSubAccountV1Execute(r)
}

/*
GetBrokerSubAccountV1 Query Sub Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerSubAccountV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerSubAccountV1(ctx context.Context) ApiGetBrokerSubAccountV1Request {
	return ApiGetBrokerSubAccountV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetBrokerSubAccountV1RespItem
func (a *BinanceLinkAPIService) GetBrokerSubAccountV1Execute(r ApiGetBrokerSubAccountV1Request) ([]GetBrokerSubAccountV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetBrokerSubAccountV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerSubAccountV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/subAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.subAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	} else {
		var defaultValue string = ""
		r.subAccountId = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int64 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int64 = 500
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerTransferFuturesV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	subAccountId *string
	futuresType *int64
	timestamp *int64
	clientTranId *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ApiGetBrokerTransferFuturesV1Request) SubAccountId(subAccountId string) ApiGetBrokerTransferFuturesV1Request {
	r.subAccountId = &subAccountId
	return r
}

// 1:USDT Futures,2: COIN Futures
func (r ApiGetBrokerTransferFuturesV1Request) FuturesType(futuresType int64) ApiGetBrokerTransferFuturesV1Request {
	r.futuresType = &futuresType
	return r
}

func (r ApiGetBrokerTransferFuturesV1Request) Timestamp(timestamp int64) ApiGetBrokerTransferFuturesV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerTransferFuturesV1Request) ClientTranId(clientTranId string) ApiGetBrokerTransferFuturesV1Request {
	r.clientTranId = &clientTranId
	return r
}

// default 30 days records
func (r ApiGetBrokerTransferFuturesV1Request) StartTime(startTime int64) ApiGetBrokerTransferFuturesV1Request {
	r.startTime = &startTime
	return r
}

// default 30 days records
func (r ApiGetBrokerTransferFuturesV1Request) EndTime(endTime int64) ApiGetBrokerTransferFuturesV1Request {
	r.endTime = &endTime
	return r
}

// default 1
func (r ApiGetBrokerTransferFuturesV1Request) Page(page int32) ApiGetBrokerTransferFuturesV1Request {
	r.page = &page
	return r
}

// default 50, max 500
func (r ApiGetBrokerTransferFuturesV1Request) Limit(limit int32) ApiGetBrokerTransferFuturesV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetBrokerTransferFuturesV1Request) RecvWindow(recvWindow int64) ApiGetBrokerTransferFuturesV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerTransferFuturesV1Request) Execute() (*GetBrokerTransferFuturesV1Resp, *http.Response, error) {
	return r.ApiService.GetBrokerTransferFuturesV1Execute(r)
}

/*
GetBrokerTransferFuturesV1 Query Sub Account Transfer History（FUTURES）

- Only get the latest history of past 30 days.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerTransferFuturesV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerTransferFuturesV1(ctx context.Context) ApiGetBrokerTransferFuturesV1Request {
	return ApiGetBrokerTransferFuturesV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBrokerTransferFuturesV1Resp
func (a *BinanceLinkAPIService) GetBrokerTransferFuturesV1Execute(r ApiGetBrokerTransferFuturesV1Request) (*GetBrokerTransferFuturesV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBrokerTransferFuturesV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerTransferFuturesV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/transfer/futures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subAccountId == nil {
		return localVarReturnValue, nil, reportError("subAccountId is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subAccountId", r.subAccountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "futuresType", r.futuresType, "form", "")
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientTranId", r.clientTranId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientTranId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerTransferV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	fromId *string
	toId *string
	clientTranId *string
	showAllStatus *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

func (r ApiGetBrokerTransferV1Request) Timestamp(timestamp int64) ApiGetBrokerTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerTransferV1Request) FromId(fromId string) ApiGetBrokerTransferV1Request {
	r.fromId = &fromId
	return r
}

func (r ApiGetBrokerTransferV1Request) ToId(toId string) ApiGetBrokerTransferV1Request {
	r.toId = &toId
	return r
}

// client transfer id
func (r ApiGetBrokerTransferV1Request) ClientTranId(clientTranId string) ApiGetBrokerTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

// true or false, default: false
func (r ApiGetBrokerTransferV1Request) ShowAllStatus(showAllStatus string) ApiGetBrokerTransferV1Request {
	r.showAllStatus = &showAllStatus
	return r
}

func (r ApiGetBrokerTransferV1Request) StartTime(startTime int64) ApiGetBrokerTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetBrokerTransferV1Request) EndTime(endTime int64) ApiGetBrokerTransferV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiGetBrokerTransferV1Request) Page(page int32) ApiGetBrokerTransferV1Request {
	r.page = &page
	return r
}

// default 500, max 500
func (r ApiGetBrokerTransferV1Request) Limit(limit int32) ApiGetBrokerTransferV1Request {
	r.limit = &limit
	return r
}

func (r ApiGetBrokerTransferV1Request) RecvWindow(recvWindow int64) ApiGetBrokerTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerTransferV1Request) Execute() ([]GetBrokerTransferV1RespItem, *http.Response, error) {
	return r.ApiService.GetBrokerTransferV1Execute(r)
}

/*
GetBrokerTransferV1 Query Sub Account Transfer History（SPOT）

Caution:
- If showAllStatus is true, the status in response will show four types: INIT,PROCESS,SUCCESS,FAILURE.
- If showAllStatus is false, the status in response will show three types: INIT,PROCESS,SUCCESS.
- Either fromId or toId must be sent. Return fromId equal master account by default.
Query scope is limited to 100 days:
- Both startTime and endTime are provided: If it exceeds, the endTime will be re-calculated 100 days after the startTime.
- Neither startTime nor endTime are provided: Calculate 100 days before today.
- endTime is not provided: Calculate 100 days after startTime.
- startTime is not provided: Calculate 100 days before endTime.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerTransferV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerTransferV1(ctx context.Context) ApiGetBrokerTransferV1Request {
	return ApiGetBrokerTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetBrokerTransferV1RespItem
func (a *BinanceLinkAPIService) GetBrokerTransferV1Execute(r ApiGetBrokerTransferV1Request) ([]GetBrokerTransferV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetBrokerTransferV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	} else {
		var defaultValue string = ""
		r.fromId = &defaultValue
	}
	if r.toId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toId", r.toId, "form", "")
	} else {
		var defaultValue string = ""
		r.toId = &defaultValue
	}
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientTranId", r.clientTranId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientTranId = &defaultValue
	}
	if r.showAllStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showAllStatus", r.showAllStatus, "form", "")
	} else {
		var defaultValue string = "false"
		r.showAllStatus = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrokerUniversalTransferV1Request struct {
	ctx context.Context
	ApiService *BinanceLinkAPIService
	timestamp *int64
	fromId *string
	toId *string
	clientTranId *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	showAllStatus *bool
	recvWindow *int64
}

func (r ApiGetBrokerUniversalTransferV1Request) Timestamp(timestamp int64) ApiGetBrokerUniversalTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetBrokerUniversalTransferV1Request) FromId(fromId string) ApiGetBrokerUniversalTransferV1Request {
	r.fromId = &fromId
	return r
}

func (r ApiGetBrokerUniversalTransferV1Request) ToId(toId string) ApiGetBrokerUniversalTransferV1Request {
	r.toId = &toId
	return r
}

// client transfer id
func (r ApiGetBrokerUniversalTransferV1Request) ClientTranId(clientTranId string) ApiGetBrokerUniversalTransferV1Request {
	r.clientTranId = &clientTranId
	return r
}

func (r ApiGetBrokerUniversalTransferV1Request) StartTime(startTime int64) ApiGetBrokerUniversalTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiGetBrokerUniversalTransferV1Request) EndTime(endTime int64) ApiGetBrokerUniversalTransferV1Request {
	r.endTime = &endTime
	return r
}

// default 1
func (r ApiGetBrokerUniversalTransferV1Request) Page(page int32) ApiGetBrokerUniversalTransferV1Request {
	r.page = &page
	return r
}

// default 500, max 500
func (r ApiGetBrokerUniversalTransferV1Request) Limit(limit int32) ApiGetBrokerUniversalTransferV1Request {
	r.limit = &limit
	return r
}

// TRUE or FALSE
func (r ApiGetBrokerUniversalTransferV1Request) ShowAllStatus(showAllStatus bool) ApiGetBrokerUniversalTransferV1Request {
	r.showAllStatus = &showAllStatus
	return r
}

func (r ApiGetBrokerUniversalTransferV1Request) RecvWindow(recvWindow int64) ApiGetBrokerUniversalTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBrokerUniversalTransferV1Request) Execute() ([]GetBrokerUniversalTransferV1RespItem, *http.Response, error) {
	return r.ApiService.GetBrokerUniversalTransferV1Execute(r)
}

/*
GetBrokerUniversalTransferV1 Query Universal Transfer History

Caution:
- Either fromId or toId must be sent.
- If either fromId or toId is the master account itself, it will not return in response.
- If showAllStatus is true, the status in response will show four types: INIT,PROCESS,SUCCESS,FAILURE.
Query scope is limited to 100 days:
- Both startTime and endTime are provided: If it exceeds, the endTime will be re-calculated 100 days after the startTime.
- Neither startTime nor endTime are provided: Calculate 30 days before today.
- endTime is not provided: Calculate as Current time.
- startTime is not provided: Calculate 30 days before endTime.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrokerUniversalTransferV1Request
*/
func (a *BinanceLinkAPIService) GetBrokerUniversalTransferV1(ctx context.Context) ApiGetBrokerUniversalTransferV1Request {
	return ApiGetBrokerUniversalTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetBrokerUniversalTransferV1RespItem
func (a *BinanceLinkAPIService) GetBrokerUniversalTransferV1Execute(r ApiGetBrokerUniversalTransferV1Request) ([]GetBrokerUniversalTransferV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetBrokerUniversalTransferV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BinanceLinkAPIService.GetBrokerUniversalTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/broker/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	} else {
		var defaultValue string = ""
		r.fromId = &defaultValue
	}
	if r.toId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toId", r.toId, "form", "")
	} else {
		var defaultValue string = ""
		r.toId = &defaultValue
	}
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientTranId", r.clientTranId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientTranId = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.showAllStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showAllStatus", r.showAllStatus, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

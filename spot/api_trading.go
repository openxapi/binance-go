/*
Binance Spot API

OpenAPI specification for Binance exchange - Spot API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spot

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TradingAPIService TradingAPI service
type TradingAPIService service

type ApiSpotCreateOrderCancelReplaceV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	cancelReplaceMode *string
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	cancelNewClientOrderId *string
	cancelOrderId *int64
	cancelOrigClientOrderId *string
	cancelRestrictions *string
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	orderRateLimitExceededMode *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopPrice *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
	trailingDelta *int64
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) CancelReplaceMode(cancelReplaceMode string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.cancelReplaceMode = &cancelReplaceMode
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) Side(side string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.side = &side
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) Symbol(symbol string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) Timestamp(timestamp int64) ApiSpotCreateOrderCancelReplaceV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) Type_(type_ string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.type_ = &type_
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) CancelNewClientOrderId(cancelNewClientOrderId string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.cancelNewClientOrderId = &cancelNewClientOrderId
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) CancelOrderId(cancelOrderId int64) ApiSpotCreateOrderCancelReplaceV3Request {
	r.cancelOrderId = &cancelOrderId
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) CancelOrigClientOrderId(cancelOrigClientOrderId string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.cancelOrigClientOrderId = &cancelOrigClientOrderId
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) CancelRestrictions(cancelRestrictions string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.cancelRestrictions = &cancelRestrictions
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) IcebergQty(icebergQty string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) NewClientOrderId(newClientOrderId string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) NewOrderRespType(newOrderRespType string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) OrderRateLimitExceededMode(orderRateLimitExceededMode string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.orderRateLimitExceededMode = &orderRateLimitExceededMode
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) Price(price string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.price = &price
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) Quantity(quantity string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) QuoteOrderQty(quoteOrderQty string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) RecvWindow(recvWindow int64) ApiSpotCreateOrderCancelReplaceV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) StopPrice(stopPrice string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) StrategyId(strategyId int64) ApiSpotCreateOrderCancelReplaceV3Request {
	r.strategyId = &strategyId
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) StrategyType(strategyType int32) ApiSpotCreateOrderCancelReplaceV3Request {
	r.strategyType = &strategyType
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) TimeInForce(timeInForce string) ApiSpotCreateOrderCancelReplaceV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) TrailingDelta(trailingDelta int64) ApiSpotCreateOrderCancelReplaceV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r ApiSpotCreateOrderCancelReplaceV3Request) Execute() (*SpotCreateOrderCancelReplaceV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderCancelReplaceV3Execute(r)
}

/*
SpotCreateOrderCancelReplaceV3 Cancel an Existing Order and Send a New Order (TRADE)

Cancels an existing order and places a new order on the same symbol.
Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotCreateOrderCancelReplaceV3Request
*/
func (a *TradingAPIService) SpotCreateOrderCancelReplaceV3(ctx context.Context) ApiSpotCreateOrderCancelReplaceV3Request {
	return ApiSpotCreateOrderCancelReplaceV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderCancelReplaceV3Resp
func (a *TradingAPIService) SpotCreateOrderCancelReplaceV3Execute(r ApiSpotCreateOrderCancelReplaceV3Request) (*SpotCreateOrderCancelReplaceV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderCancelReplaceV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotCreateOrderCancelReplaceV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/cancelReplace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cancelReplaceMode == nil {
		return localVarReturnValue, nil, reportError("cancelReplaceMode is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cancelNewClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelNewClientOrderId", r.cancelNewClientOrderId, "", "")
	}
	if r.cancelOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelOrderId", r.cancelOrderId, "", "")
	}
	if r.cancelOrigClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelOrigClientOrderId", r.cancelOrigClientOrderId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "cancelReplaceMode", r.cancelReplaceMode, "", "")
	if r.cancelRestrictions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cancelRestrictions", r.cancelRestrictions, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.orderRateLimitExceededMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "orderRateLimitExceededMode", r.orderRateLimitExceededMode, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotCreateOrderListOcoV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	aboveType *string
	belowType *string
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	aboveClientOrderId *string
	aboveIcebergQty *int64
	abovePrice *string
	aboveStopPrice *string
	aboveStrategyId *int64
	aboveStrategyType *int32
	aboveTimeInForce *string
	aboveTrailingDelta *int64
	belowClientOrderId *string
	belowIcebergQty *int64
	belowPrice *string
	belowStopPrice *string
	belowStrategyId *int64
	belowStrategyType *int32
	belowTimeInForce *string
	belowTrailingDelta *int64
	listClientOrderId *string
	newOrderRespType *string
	recvWindow *int64
	selfTradePreventionMode *string
}

func (r ApiSpotCreateOrderListOcoV3Request) AboveType(aboveType string) ApiSpotCreateOrderListOcoV3Request {
	r.aboveType = &aboveType
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) BelowType(belowType string) ApiSpotCreateOrderListOcoV3Request {
	r.belowType = &belowType
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) Quantity(quantity string) ApiSpotCreateOrderListOcoV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) Side(side string) ApiSpotCreateOrderListOcoV3Request {
	r.side = &side
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) Symbol(symbol string) ApiSpotCreateOrderListOcoV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) Timestamp(timestamp int64) ApiSpotCreateOrderListOcoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) AboveClientOrderId(aboveClientOrderId string) ApiSpotCreateOrderListOcoV3Request {
	r.aboveClientOrderId = &aboveClientOrderId
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) AboveIcebergQty(aboveIcebergQty int64) ApiSpotCreateOrderListOcoV3Request {
	r.aboveIcebergQty = &aboveIcebergQty
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) AbovePrice(abovePrice string) ApiSpotCreateOrderListOcoV3Request {
	r.abovePrice = &abovePrice
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) AboveStopPrice(aboveStopPrice string) ApiSpotCreateOrderListOcoV3Request {
	r.aboveStopPrice = &aboveStopPrice
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) AboveStrategyId(aboveStrategyId int64) ApiSpotCreateOrderListOcoV3Request {
	r.aboveStrategyId = &aboveStrategyId
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) AboveStrategyType(aboveStrategyType int32) ApiSpotCreateOrderListOcoV3Request {
	r.aboveStrategyType = &aboveStrategyType
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) AboveTimeInForce(aboveTimeInForce string) ApiSpotCreateOrderListOcoV3Request {
	r.aboveTimeInForce = &aboveTimeInForce
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) AboveTrailingDelta(aboveTrailingDelta int64) ApiSpotCreateOrderListOcoV3Request {
	r.aboveTrailingDelta = &aboveTrailingDelta
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) BelowClientOrderId(belowClientOrderId string) ApiSpotCreateOrderListOcoV3Request {
	r.belowClientOrderId = &belowClientOrderId
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) BelowIcebergQty(belowIcebergQty int64) ApiSpotCreateOrderListOcoV3Request {
	r.belowIcebergQty = &belowIcebergQty
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) BelowPrice(belowPrice string) ApiSpotCreateOrderListOcoV3Request {
	r.belowPrice = &belowPrice
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) BelowStopPrice(belowStopPrice string) ApiSpotCreateOrderListOcoV3Request {
	r.belowStopPrice = &belowStopPrice
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) BelowStrategyId(belowStrategyId int64) ApiSpotCreateOrderListOcoV3Request {
	r.belowStrategyId = &belowStrategyId
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) BelowStrategyType(belowStrategyType int32) ApiSpotCreateOrderListOcoV3Request {
	r.belowStrategyType = &belowStrategyType
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) BelowTimeInForce(belowTimeInForce string) ApiSpotCreateOrderListOcoV3Request {
	r.belowTimeInForce = &belowTimeInForce
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) BelowTrailingDelta(belowTrailingDelta int64) ApiSpotCreateOrderListOcoV3Request {
	r.belowTrailingDelta = &belowTrailingDelta
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) ListClientOrderId(listClientOrderId string) ApiSpotCreateOrderListOcoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) NewOrderRespType(newOrderRespType string) ApiSpotCreateOrderListOcoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) RecvWindow(recvWindow int64) ApiSpotCreateOrderListOcoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiSpotCreateOrderListOcoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiSpotCreateOrderListOcoV3Request) Execute() (*SpotCreateOrderListOcoV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderListOcoV3Execute(r)
}

/*
SpotCreateOrderListOcoV3 New Order list - OCO (TRADE)

Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
- An OCO has 2 orders called the above order and below order.
- One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order.
- Price restrictions

If the OCO is on the SELL side:

LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice
TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice


If the OCO is on the BUY side:

LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice
TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice
- OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotCreateOrderListOcoV3Request
*/
func (a *TradingAPIService) SpotCreateOrderListOcoV3(ctx context.Context) ApiSpotCreateOrderListOcoV3Request {
	return ApiSpotCreateOrderListOcoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderListOcoV3Resp
func (a *TradingAPIService) SpotCreateOrderListOcoV3Execute(r ApiSpotCreateOrderListOcoV3Request) (*SpotCreateOrderListOcoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderListOcoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotCreateOrderListOcoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aboveType == nil {
		return localVarReturnValue, nil, reportError("aboveType is required and must be specified")
	}
	if r.belowType == nil {
		return localVarReturnValue, nil, reportError("belowType is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.aboveClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveClientOrderId", r.aboveClientOrderId, "", "")
	}
	if r.aboveIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveIcebergQty", r.aboveIcebergQty, "", "")
	}
	if r.abovePrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "abovePrice", r.abovePrice, "", "")
	}
	if r.aboveStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveStopPrice", r.aboveStopPrice, "", "")
	}
	if r.aboveStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveStrategyId", r.aboveStrategyId, "", "")
	}
	if r.aboveStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveStrategyType", r.aboveStrategyType, "", "")
	}
	if r.aboveTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveTimeInForce", r.aboveTimeInForce, "", "")
	}
	if r.aboveTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "aboveTrailingDelta", r.aboveTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "aboveType", r.aboveType, "", "")
	if r.belowClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowClientOrderId", r.belowClientOrderId, "", "")
	}
	if r.belowIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowIcebergQty", r.belowIcebergQty, "", "")
	}
	if r.belowPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowPrice", r.belowPrice, "", "")
	}
	if r.belowStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowStopPrice", r.belowStopPrice, "", "")
	}
	if r.belowStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowStrategyId", r.belowStrategyId, "", "")
	}
	if r.belowStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowStrategyType", r.belowStrategyType, "", "")
	}
	if r.belowTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowTimeInForce", r.belowTimeInForce, "", "")
	}
	if r.belowTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "belowTrailingDelta", r.belowTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "belowType", r.belowType, "", "")
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotCreateOrderListOtoV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	pendingQuantity *string
	pendingSide *string
	pendingType *string
	symbol *string
	timestamp *int64
	workingPrice *string
	workingQuantity *string
	workingSide *string
	workingType *string
	listClientOrderId *string
	newOrderRespType *string
	pendingClientOrderId *string
	pendingIcebergQty *string
	pendingPrice *string
	pendingStopPrice *string
	pendingStrategyId *int64
	pendingStrategyType *int32
	pendingTimeInForce *string
	pendingTrailingDelta *string
	recvWindow *int64
	selfTradePreventionMode *string
	workingClientOrderId *string
	workingIcebergQty *string
	workingStrategyId *int64
	workingStrategyType *int32
	workingTimeInForce *string
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingQuantity(pendingQuantity string) ApiSpotCreateOrderListOtoV3Request {
	r.pendingQuantity = &pendingQuantity
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingSide(pendingSide string) ApiSpotCreateOrderListOtoV3Request {
	r.pendingSide = &pendingSide
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingType(pendingType string) ApiSpotCreateOrderListOtoV3Request {
	r.pendingType = &pendingType
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) Symbol(symbol string) ApiSpotCreateOrderListOtoV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) Timestamp(timestamp int64) ApiSpotCreateOrderListOtoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) WorkingPrice(workingPrice string) ApiSpotCreateOrderListOtoV3Request {
	r.workingPrice = &workingPrice
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) WorkingQuantity(workingQuantity string) ApiSpotCreateOrderListOtoV3Request {
	r.workingQuantity = &workingQuantity
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) WorkingSide(workingSide string) ApiSpotCreateOrderListOtoV3Request {
	r.workingSide = &workingSide
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) WorkingType(workingType string) ApiSpotCreateOrderListOtoV3Request {
	r.workingType = &workingType
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) ListClientOrderId(listClientOrderId string) ApiSpotCreateOrderListOtoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) NewOrderRespType(newOrderRespType string) ApiSpotCreateOrderListOtoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingClientOrderId(pendingClientOrderId string) ApiSpotCreateOrderListOtoV3Request {
	r.pendingClientOrderId = &pendingClientOrderId
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingIcebergQty(pendingIcebergQty string) ApiSpotCreateOrderListOtoV3Request {
	r.pendingIcebergQty = &pendingIcebergQty
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingPrice(pendingPrice string) ApiSpotCreateOrderListOtoV3Request {
	r.pendingPrice = &pendingPrice
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingStopPrice(pendingStopPrice string) ApiSpotCreateOrderListOtoV3Request {
	r.pendingStopPrice = &pendingStopPrice
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingStrategyId(pendingStrategyId int64) ApiSpotCreateOrderListOtoV3Request {
	r.pendingStrategyId = &pendingStrategyId
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingStrategyType(pendingStrategyType int32) ApiSpotCreateOrderListOtoV3Request {
	r.pendingStrategyType = &pendingStrategyType
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingTimeInForce(pendingTimeInForce string) ApiSpotCreateOrderListOtoV3Request {
	r.pendingTimeInForce = &pendingTimeInForce
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) PendingTrailingDelta(pendingTrailingDelta string) ApiSpotCreateOrderListOtoV3Request {
	r.pendingTrailingDelta = &pendingTrailingDelta
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) RecvWindow(recvWindow int64) ApiSpotCreateOrderListOtoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiSpotCreateOrderListOtoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) WorkingClientOrderId(workingClientOrderId string) ApiSpotCreateOrderListOtoV3Request {
	r.workingClientOrderId = &workingClientOrderId
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) WorkingIcebergQty(workingIcebergQty string) ApiSpotCreateOrderListOtoV3Request {
	r.workingIcebergQty = &workingIcebergQty
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) WorkingStrategyId(workingStrategyId int64) ApiSpotCreateOrderListOtoV3Request {
	r.workingStrategyId = &workingStrategyId
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) WorkingStrategyType(workingStrategyType int32) ApiSpotCreateOrderListOtoV3Request {
	r.workingStrategyType = &workingStrategyType
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) WorkingTimeInForce(workingTimeInForce string) ApiSpotCreateOrderListOtoV3Request {
	r.workingTimeInForce = &workingTimeInForce
	return r
}

func (r ApiSpotCreateOrderListOtoV3Request) Execute() (*SpotCreateOrderListOtoV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderListOtoV3Execute(r)
}

/*
SpotCreateOrderListOtoV3 New Order list - OTO (TRADE)

Places an OTO.
- An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
- The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.
- The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled.
- If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
- When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status.
- OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotCreateOrderListOtoV3Request
*/
func (a *TradingAPIService) SpotCreateOrderListOtoV3(ctx context.Context) ApiSpotCreateOrderListOtoV3Request {
	return ApiSpotCreateOrderListOtoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderListOtoV3Resp
func (a *TradingAPIService) SpotCreateOrderListOtoV3Execute(r ApiSpotCreateOrderListOtoV3Request) (*SpotCreateOrderListOtoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderListOtoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotCreateOrderListOtoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList/oto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pendingQuantity == nil {
		return localVarReturnValue, nil, reportError("pendingQuantity is required and must be specified")
	}
	if r.pendingSide == nil {
		return localVarReturnValue, nil, reportError("pendingSide is required and must be specified")
	}
	if r.pendingType == nil {
		return localVarReturnValue, nil, reportError("pendingType is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.workingPrice == nil {
		return localVarReturnValue, nil, reportError("workingPrice is required and must be specified")
	}
	if r.workingQuantity == nil {
		return localVarReturnValue, nil, reportError("workingQuantity is required and must be specified")
	}
	if r.workingSide == nil {
		return localVarReturnValue, nil, reportError("workingSide is required and must be specified")
	}
	if r.workingType == nil {
		return localVarReturnValue, nil, reportError("workingType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.pendingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingClientOrderId", r.pendingClientOrderId, "", "")
	}
	if r.pendingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingIcebergQty", r.pendingIcebergQty, "", "")
	}
	if r.pendingPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingPrice", r.pendingPrice, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingQuantity", r.pendingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingSide", r.pendingSide, "", "")
	if r.pendingStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStopPrice", r.pendingStopPrice, "", "")
	}
	if r.pendingStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStrategyId", r.pendingStrategyId, "", "")
	}
	if r.pendingStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingStrategyType", r.pendingStrategyType, "", "")
	}
	if r.pendingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingTimeInForce", r.pendingTimeInForce, "", "")
	}
	if r.pendingTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingTrailingDelta", r.pendingTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingType", r.pendingType, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.workingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingClientOrderId", r.workingClientOrderId, "", "")
	}
	if r.workingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingIcebergQty", r.workingIcebergQty, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingPrice", r.workingPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingQuantity", r.workingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingSide", r.workingSide, "", "")
	if r.workingStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyId", r.workingStrategyId, "", "")
	}
	if r.workingStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyType", r.workingStrategyType, "", "")
	}
	if r.workingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingTimeInForce", r.workingTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotCreateOrderListOtocoV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	pendingAboveType *string
	pendingQuantity *string
	pendingSide *string
	symbol *string
	timestamp *int64
	workingPrice *string
	workingQuantity *string
	workingSide *string
	workingType *string
	listClientOrderId *string
	newOrderRespType *string
	pendingAboveClientOrderId *string
	pendingAboveIcebergQty *string
	pendingAbovePrice *string
	pendingAboveStopPrice *string
	pendingAboveStrategyId *int64
	pendingAboveStrategyType *int32
	pendingAboveTimeInForce *string
	pendingAboveTrailingDelta *string
	pendingBelowClientOrderId *string
	pendingBelowIcebergQty *string
	pendingBelowPrice *string
	pendingBelowStopPrice *string
	pendingBelowStrategyId *int64
	pendingBelowStrategyType *int32
	pendingBelowTimeInForce *string
	pendingBelowTrailingDelta *string
	pendingBelowType *string
	recvWindow *int64
	selfTradePreventionMode *string
	workingClientOrderId *string
	workingIcebergQty *string
	workingStrategyId *int64
	workingStrategyType *int32
	workingTimeInForce *string
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingAboveType(pendingAboveType string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingAboveType = &pendingAboveType
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingQuantity(pendingQuantity string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingQuantity = &pendingQuantity
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingSide(pendingSide string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingSide = &pendingSide
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) Symbol(symbol string) ApiSpotCreateOrderListOtocoV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) Timestamp(timestamp int64) ApiSpotCreateOrderListOtocoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) WorkingPrice(workingPrice string) ApiSpotCreateOrderListOtocoV3Request {
	r.workingPrice = &workingPrice
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) WorkingQuantity(workingQuantity string) ApiSpotCreateOrderListOtocoV3Request {
	r.workingQuantity = &workingQuantity
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) WorkingSide(workingSide string) ApiSpotCreateOrderListOtocoV3Request {
	r.workingSide = &workingSide
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) WorkingType(workingType string) ApiSpotCreateOrderListOtocoV3Request {
	r.workingType = &workingType
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) ListClientOrderId(listClientOrderId string) ApiSpotCreateOrderListOtocoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) NewOrderRespType(newOrderRespType string) ApiSpotCreateOrderListOtocoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingAboveClientOrderId(pendingAboveClientOrderId string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingAboveClientOrderId = &pendingAboveClientOrderId
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingAboveIcebergQty(pendingAboveIcebergQty string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingAboveIcebergQty = &pendingAboveIcebergQty
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingAbovePrice(pendingAbovePrice string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingAbovePrice = &pendingAbovePrice
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingAboveStopPrice(pendingAboveStopPrice string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingAboveStopPrice = &pendingAboveStopPrice
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingAboveStrategyId(pendingAboveStrategyId int64) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingAboveStrategyId = &pendingAboveStrategyId
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingAboveStrategyType(pendingAboveStrategyType int32) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingAboveStrategyType = &pendingAboveStrategyType
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingAboveTimeInForce(pendingAboveTimeInForce string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingAboveTimeInForce = &pendingAboveTimeInForce
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingAboveTrailingDelta(pendingAboveTrailingDelta string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingAboveTrailingDelta = &pendingAboveTrailingDelta
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingBelowClientOrderId(pendingBelowClientOrderId string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingBelowClientOrderId = &pendingBelowClientOrderId
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingBelowIcebergQty(pendingBelowIcebergQty string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingBelowIcebergQty = &pendingBelowIcebergQty
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingBelowPrice(pendingBelowPrice string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingBelowPrice = &pendingBelowPrice
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingBelowStopPrice(pendingBelowStopPrice string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingBelowStopPrice = &pendingBelowStopPrice
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingBelowStrategyId(pendingBelowStrategyId int64) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingBelowStrategyId = &pendingBelowStrategyId
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingBelowStrategyType(pendingBelowStrategyType int32) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingBelowStrategyType = &pendingBelowStrategyType
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingBelowTimeInForce(pendingBelowTimeInForce string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingBelowTimeInForce = &pendingBelowTimeInForce
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingBelowTrailingDelta(pendingBelowTrailingDelta string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingBelowTrailingDelta = &pendingBelowTrailingDelta
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) PendingBelowType(pendingBelowType string) ApiSpotCreateOrderListOtocoV3Request {
	r.pendingBelowType = &pendingBelowType
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) RecvWindow(recvWindow int64) ApiSpotCreateOrderListOtocoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiSpotCreateOrderListOtocoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) WorkingClientOrderId(workingClientOrderId string) ApiSpotCreateOrderListOtocoV3Request {
	r.workingClientOrderId = &workingClientOrderId
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) WorkingIcebergQty(workingIcebergQty string) ApiSpotCreateOrderListOtocoV3Request {
	r.workingIcebergQty = &workingIcebergQty
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) WorkingStrategyId(workingStrategyId int64) ApiSpotCreateOrderListOtocoV3Request {
	r.workingStrategyId = &workingStrategyId
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) WorkingStrategyType(workingStrategyType int32) ApiSpotCreateOrderListOtocoV3Request {
	r.workingStrategyType = &workingStrategyType
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) WorkingTimeInForce(workingTimeInForce string) ApiSpotCreateOrderListOtocoV3Request {
	r.workingTimeInForce = &workingTimeInForce
	return r
}

func (r ApiSpotCreateOrderListOtocoV3Request) Execute() (*SpotCreateOrderListOtocoV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderListOtocoV3Execute(r)
}

/*
SpotCreateOrderListOtocoV3 New Order list - OTOCO (TRADE)

Place an OTOCO.
- An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
- The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.

The behavior of the working order is the same as the OTO.
- OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.

The rules of the pending above and pending below follow the same rules as the Order list OCO.
- OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotCreateOrderListOtocoV3Request
*/
func (a *TradingAPIService) SpotCreateOrderListOtocoV3(ctx context.Context) ApiSpotCreateOrderListOtocoV3Request {
	return ApiSpotCreateOrderListOtocoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderListOtocoV3Resp
func (a *TradingAPIService) SpotCreateOrderListOtocoV3Execute(r ApiSpotCreateOrderListOtocoV3Request) (*SpotCreateOrderListOtocoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderListOtocoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotCreateOrderListOtocoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList/otoco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pendingAboveType == nil {
		return localVarReturnValue, nil, reportError("pendingAboveType is required and must be specified")
	}
	if r.pendingQuantity == nil {
		return localVarReturnValue, nil, reportError("pendingQuantity is required and must be specified")
	}
	if r.pendingSide == nil {
		return localVarReturnValue, nil, reportError("pendingSide is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.workingPrice == nil {
		return localVarReturnValue, nil, reportError("workingPrice is required and must be specified")
	}
	if r.workingQuantity == nil {
		return localVarReturnValue, nil, reportError("workingQuantity is required and must be specified")
	}
	if r.workingSide == nil {
		return localVarReturnValue, nil, reportError("workingSide is required and must be specified")
	}
	if r.workingType == nil {
		return localVarReturnValue, nil, reportError("workingType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.pendingAboveClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveClientOrderId", r.pendingAboveClientOrderId, "", "")
	}
	if r.pendingAboveIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveIcebergQty", r.pendingAboveIcebergQty, "", "")
	}
	if r.pendingAbovePrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAbovePrice", r.pendingAbovePrice, "", "")
	}
	if r.pendingAboveStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStopPrice", r.pendingAboveStopPrice, "", "")
	}
	if r.pendingAboveStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStrategyId", r.pendingAboveStrategyId, "", "")
	}
	if r.pendingAboveStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveStrategyType", r.pendingAboveStrategyType, "", "")
	}
	if r.pendingAboveTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveTimeInForce", r.pendingAboveTimeInForce, "", "")
	}
	if r.pendingAboveTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveTrailingDelta", r.pendingAboveTrailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingAboveType", r.pendingAboveType, "", "")
	if r.pendingBelowClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowClientOrderId", r.pendingBelowClientOrderId, "", "")
	}
	if r.pendingBelowIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowIcebergQty", r.pendingBelowIcebergQty, "", "")
	}
	if r.pendingBelowPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowPrice", r.pendingBelowPrice, "", "")
	}
	if r.pendingBelowStopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStopPrice", r.pendingBelowStopPrice, "", "")
	}
	if r.pendingBelowStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStrategyId", r.pendingBelowStrategyId, "", "")
	}
	if r.pendingBelowStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowStrategyType", r.pendingBelowStrategyType, "", "")
	}
	if r.pendingBelowTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowTimeInForce", r.pendingBelowTimeInForce, "", "")
	}
	if r.pendingBelowTrailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowTrailingDelta", r.pendingBelowTrailingDelta, "", "")
	}
	if r.pendingBelowType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pendingBelowType", r.pendingBelowType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingQuantity", r.pendingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "pendingSide", r.pendingSide, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.workingClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingClientOrderId", r.workingClientOrderId, "", "")
	}
	if r.workingIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingIcebergQty", r.workingIcebergQty, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingPrice", r.workingPrice, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingQuantity", r.workingQuantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "workingSide", r.workingSide, "", "")
	if r.workingStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyId", r.workingStrategyId, "", "")
	}
	if r.workingStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingStrategyType", r.workingStrategyType, "", "")
	}
	if r.workingTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "workingTimeInForce", r.workingTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "workingType", r.workingType, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotCreateOrderOcoV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	price *string
	quantity *string
	side *string
	stopPrice *string
	symbol *string
	timestamp *int64
	limitClientOrderId *string
	limitIcebergQty *string
	limitStrategyId *int64
	limitStrategyType *int32
	listClientOrderId *string
	newOrderRespType *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopClientOrderId *string
	stopIcebergQty *string
	stopLimitPrice *string
	stopLimitTimeInForce *string
	stopStrategyId *int64
	stopStrategyType *int32
	trailingDelta *int64
}

func (r ApiSpotCreateOrderOcoV3Request) Price(price string) ApiSpotCreateOrderOcoV3Request {
	r.price = &price
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) Quantity(quantity string) ApiSpotCreateOrderOcoV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) Side(side string) ApiSpotCreateOrderOcoV3Request {
	r.side = &side
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) StopPrice(stopPrice string) ApiSpotCreateOrderOcoV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) Symbol(symbol string) ApiSpotCreateOrderOcoV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) Timestamp(timestamp int64) ApiSpotCreateOrderOcoV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) LimitClientOrderId(limitClientOrderId string) ApiSpotCreateOrderOcoV3Request {
	r.limitClientOrderId = &limitClientOrderId
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) LimitIcebergQty(limitIcebergQty string) ApiSpotCreateOrderOcoV3Request {
	r.limitIcebergQty = &limitIcebergQty
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) LimitStrategyId(limitStrategyId int64) ApiSpotCreateOrderOcoV3Request {
	r.limitStrategyId = &limitStrategyId
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) LimitStrategyType(limitStrategyType int32) ApiSpotCreateOrderOcoV3Request {
	r.limitStrategyType = &limitStrategyType
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) ListClientOrderId(listClientOrderId string) ApiSpotCreateOrderOcoV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) NewOrderRespType(newOrderRespType string) ApiSpotCreateOrderOcoV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) RecvWindow(recvWindow int64) ApiSpotCreateOrderOcoV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiSpotCreateOrderOcoV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) StopClientOrderId(stopClientOrderId string) ApiSpotCreateOrderOcoV3Request {
	r.stopClientOrderId = &stopClientOrderId
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) StopIcebergQty(stopIcebergQty string) ApiSpotCreateOrderOcoV3Request {
	r.stopIcebergQty = &stopIcebergQty
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) StopLimitPrice(stopLimitPrice string) ApiSpotCreateOrderOcoV3Request {
	r.stopLimitPrice = &stopLimitPrice
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) StopLimitTimeInForce(stopLimitTimeInForce string) ApiSpotCreateOrderOcoV3Request {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) StopStrategyId(stopStrategyId int64) ApiSpotCreateOrderOcoV3Request {
	r.stopStrategyId = &stopStrategyId
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) StopStrategyType(stopStrategyType int32) ApiSpotCreateOrderOcoV3Request {
	r.stopStrategyType = &stopStrategyType
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) TrailingDelta(trailingDelta int64) ApiSpotCreateOrderOcoV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r ApiSpotCreateOrderOcoV3Request) Execute() (*SpotCreateOrderOcoV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderOcoV3Execute(r)
}

/*
SpotCreateOrderOcoV3 New OCO - Deprecated (TRADE)

Send in a new OCO.
- Price Restrictions:

SELL: Limit Price > Last Price > Stop Price
BUY: Limit Price < Last Price < Stop Price
- Quantity Restrictions:

Both legs must have the same quantity.
ICEBERG quantities however do not have to be the same
- OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotCreateOrderOcoV3Request
*/
func (a *TradingAPIService) SpotCreateOrderOcoV3(ctx context.Context) ApiSpotCreateOrderOcoV3Request {
	return ApiSpotCreateOrderOcoV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderOcoV3Resp
func (a *TradingAPIService) SpotCreateOrderOcoV3Execute(r ApiSpotCreateOrderOcoV3Request) (*SpotCreateOrderOcoV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderOcoV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotCreateOrderOcoV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.limitClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitClientOrderId", r.limitClientOrderId, "", "")
	}
	if r.limitIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitIcebergQty", r.limitIcebergQty, "", "")
	}
	if r.limitStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitStrategyId", r.limitStrategyId, "", "")
	}
	if r.limitStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limitStrategyType", r.limitStrategyType, "", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "listClientOrderId", r.listClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopClientOrderId", r.stopClientOrderId, "", "")
	}
	if r.stopIcebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopIcebergQty", r.stopIcebergQty, "", "")
	}
	if r.stopLimitPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitPrice", r.stopLimitPrice, "", "")
	}
	if r.stopLimitTimeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopLimitTimeInForce", r.stopLimitTimeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	if r.stopStrategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopStrategyId", r.stopStrategyId, "", "")
	}
	if r.stopStrategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopStrategyType", r.stopStrategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotCreateOrderTestV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	computeCommissionRates *bool
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopPrice *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
	trailingDelta *int64
}

func (r ApiSpotCreateOrderTestV3Request) Side(side string) ApiSpotCreateOrderTestV3Request {
	r.side = &side
	return r
}

func (r ApiSpotCreateOrderTestV3Request) Symbol(symbol string) ApiSpotCreateOrderTestV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotCreateOrderTestV3Request) Timestamp(timestamp int64) ApiSpotCreateOrderTestV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotCreateOrderTestV3Request) Type_(type_ string) ApiSpotCreateOrderTestV3Request {
	r.type_ = &type_
	return r
}

func (r ApiSpotCreateOrderTestV3Request) ComputeCommissionRates(computeCommissionRates bool) ApiSpotCreateOrderTestV3Request {
	r.computeCommissionRates = &computeCommissionRates
	return r
}

func (r ApiSpotCreateOrderTestV3Request) IcebergQty(icebergQty string) ApiSpotCreateOrderTestV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiSpotCreateOrderTestV3Request) NewClientOrderId(newClientOrderId string) ApiSpotCreateOrderTestV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiSpotCreateOrderTestV3Request) NewOrderRespType(newOrderRespType string) ApiSpotCreateOrderTestV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiSpotCreateOrderTestV3Request) Price(price string) ApiSpotCreateOrderTestV3Request {
	r.price = &price
	return r
}

func (r ApiSpotCreateOrderTestV3Request) Quantity(quantity string) ApiSpotCreateOrderTestV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiSpotCreateOrderTestV3Request) QuoteOrderQty(quoteOrderQty string) ApiSpotCreateOrderTestV3Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r ApiSpotCreateOrderTestV3Request) RecvWindow(recvWindow int64) ApiSpotCreateOrderTestV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotCreateOrderTestV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiSpotCreateOrderTestV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiSpotCreateOrderTestV3Request) StopPrice(stopPrice string) ApiSpotCreateOrderTestV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r ApiSpotCreateOrderTestV3Request) StrategyId(strategyId int64) ApiSpotCreateOrderTestV3Request {
	r.strategyId = &strategyId
	return r
}

func (r ApiSpotCreateOrderTestV3Request) StrategyType(strategyType int32) ApiSpotCreateOrderTestV3Request {
	r.strategyType = &strategyType
	return r
}

func (r ApiSpotCreateOrderTestV3Request) TimeInForce(timeInForce string) ApiSpotCreateOrderTestV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiSpotCreateOrderTestV3Request) TrailingDelta(trailingDelta int64) ApiSpotCreateOrderTestV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r ApiSpotCreateOrderTestV3Request) Execute() (*SpotCreateOrderTestV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderTestV3Execute(r)
}

/*
SpotCreateOrderTestV3 Test new order (TRADE)

Test new order creation and signature/recvWindow long.
Creates and validates a new order but does not send it into the matching engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotCreateOrderTestV3Request
*/
func (a *TradingAPIService) SpotCreateOrderTestV3(ctx context.Context) ApiSpotCreateOrderTestV3Request {
	return ApiSpotCreateOrderTestV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderTestV3Resp
func (a *TradingAPIService) SpotCreateOrderTestV3Execute(r ApiSpotCreateOrderTestV3Request) (*SpotCreateOrderTestV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderTestV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotCreateOrderTestV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.computeCommissionRates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "computeCommissionRates", r.computeCommissionRates, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotCreateOrderV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	quantity *string
	quoteOrderQty *string
	recvWindow *int64
	selfTradePreventionMode *string
	stopPrice *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
	trailingDelta *int64
}

func (r ApiSpotCreateOrderV3Request) Side(side string) ApiSpotCreateOrderV3Request {
	r.side = &side
	return r
}

func (r ApiSpotCreateOrderV3Request) Symbol(symbol string) ApiSpotCreateOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotCreateOrderV3Request) Timestamp(timestamp int64) ApiSpotCreateOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotCreateOrderV3Request) Type_(type_ string) ApiSpotCreateOrderV3Request {
	r.type_ = &type_
	return r
}

func (r ApiSpotCreateOrderV3Request) IcebergQty(icebergQty string) ApiSpotCreateOrderV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiSpotCreateOrderV3Request) NewClientOrderId(newClientOrderId string) ApiSpotCreateOrderV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiSpotCreateOrderV3Request) NewOrderRespType(newOrderRespType string) ApiSpotCreateOrderV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiSpotCreateOrderV3Request) Price(price string) ApiSpotCreateOrderV3Request {
	r.price = &price
	return r
}

func (r ApiSpotCreateOrderV3Request) Quantity(quantity string) ApiSpotCreateOrderV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiSpotCreateOrderV3Request) QuoteOrderQty(quoteOrderQty string) ApiSpotCreateOrderV3Request {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

func (r ApiSpotCreateOrderV3Request) RecvWindow(recvWindow int64) ApiSpotCreateOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotCreateOrderV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiSpotCreateOrderV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiSpotCreateOrderV3Request) StopPrice(stopPrice string) ApiSpotCreateOrderV3Request {
	r.stopPrice = &stopPrice
	return r
}

func (r ApiSpotCreateOrderV3Request) StrategyId(strategyId int64) ApiSpotCreateOrderV3Request {
	r.strategyId = &strategyId
	return r
}

func (r ApiSpotCreateOrderV3Request) StrategyType(strategyType int32) ApiSpotCreateOrderV3Request {
	r.strategyType = &strategyType
	return r
}

func (r ApiSpotCreateOrderV3Request) TimeInForce(timeInForce string) ApiSpotCreateOrderV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiSpotCreateOrderV3Request) TrailingDelta(trailingDelta int64) ApiSpotCreateOrderV3Request {
	r.trailingDelta = &trailingDelta
	return r
}

func (r ApiSpotCreateOrderV3Request) Execute() (*SpotCreateOrderV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateOrderV3Execute(r)
}

/*
SpotCreateOrderV3 New order (TRADE)

Send in a new order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotCreateOrderV3Request
*/
func (a *TradingAPIService) SpotCreateOrderV3(ctx context.Context) ApiSpotCreateOrderV3Request {
	return ApiSpotCreateOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateOrderV3Resp
func (a *TradingAPIService) SpotCreateOrderV3Execute(r ApiSpotCreateOrderV3Request) (*SpotCreateOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotCreateOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	}
	if r.quoteOrderQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "quoteOrderQty", r.quoteOrderQty, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.stopPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "stopPrice", r.stopPrice, "", "")
	}
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.trailingDelta != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "trailingDelta", r.trailingDelta, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotCreateSorOrderTestV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	computeCommissionRates *bool
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	recvWindow *int64
	selfTradePreventionMode *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
}

func (r ApiSpotCreateSorOrderTestV3Request) Quantity(quantity string) ApiSpotCreateSorOrderTestV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) Side(side string) ApiSpotCreateSorOrderTestV3Request {
	r.side = &side
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) Symbol(symbol string) ApiSpotCreateSorOrderTestV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) Timestamp(timestamp int64) ApiSpotCreateSorOrderTestV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) Type_(type_ string) ApiSpotCreateSorOrderTestV3Request {
	r.type_ = &type_
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) ComputeCommissionRates(computeCommissionRates bool) ApiSpotCreateSorOrderTestV3Request {
	r.computeCommissionRates = &computeCommissionRates
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) IcebergQty(icebergQty string) ApiSpotCreateSorOrderTestV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) NewClientOrderId(newClientOrderId string) ApiSpotCreateSorOrderTestV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) NewOrderRespType(newOrderRespType string) ApiSpotCreateSorOrderTestV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) Price(price string) ApiSpotCreateSorOrderTestV3Request {
	r.price = &price
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) RecvWindow(recvWindow int64) ApiSpotCreateSorOrderTestV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiSpotCreateSorOrderTestV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) StrategyId(strategyId int64) ApiSpotCreateSorOrderTestV3Request {
	r.strategyId = &strategyId
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) StrategyType(strategyType int32) ApiSpotCreateSorOrderTestV3Request {
	r.strategyType = &strategyType
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) TimeInForce(timeInForce string) ApiSpotCreateSorOrderTestV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiSpotCreateSorOrderTestV3Request) Execute() (*SpotCreateSorOrderTestV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateSorOrderTestV3Execute(r)
}

/*
SpotCreateSorOrderTestV3 Test new order using SOR (TRADE)

Test new order creation and signature/recvWindow using smart order routing (SOR).
Creates and validates a new order but does not send it into the matching engine.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotCreateSorOrderTestV3Request
*/
func (a *TradingAPIService) SpotCreateSorOrderTestV3(ctx context.Context) ApiSpotCreateSorOrderTestV3Request {
	return ApiSpotCreateSorOrderTestV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateSorOrderTestV3Resp
func (a *TradingAPIService) SpotCreateSorOrderTestV3Execute(r ApiSpotCreateSorOrderTestV3Request) (*SpotCreateSorOrderTestV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateSorOrderTestV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotCreateSorOrderTestV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sor/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.computeCommissionRates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "computeCommissionRates", r.computeCommissionRates, "", "")
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotCreateSorOrderV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	quantity *string
	side *string
	symbol *string
	timestamp *int64
	type_ *string
	icebergQty *string
	newClientOrderId *string
	newOrderRespType *string
	price *string
	recvWindow *int64
	selfTradePreventionMode *string
	strategyId *int64
	strategyType *int32
	timeInForce *string
}

func (r ApiSpotCreateSorOrderV3Request) Quantity(quantity string) ApiSpotCreateSorOrderV3Request {
	r.quantity = &quantity
	return r
}

func (r ApiSpotCreateSorOrderV3Request) Side(side string) ApiSpotCreateSorOrderV3Request {
	r.side = &side
	return r
}

func (r ApiSpotCreateSorOrderV3Request) Symbol(symbol string) ApiSpotCreateSorOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotCreateSorOrderV3Request) Timestamp(timestamp int64) ApiSpotCreateSorOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotCreateSorOrderV3Request) Type_(type_ string) ApiSpotCreateSorOrderV3Request {
	r.type_ = &type_
	return r
}

func (r ApiSpotCreateSorOrderV3Request) IcebergQty(icebergQty string) ApiSpotCreateSorOrderV3Request {
	r.icebergQty = &icebergQty
	return r
}

func (r ApiSpotCreateSorOrderV3Request) NewClientOrderId(newClientOrderId string) ApiSpotCreateSorOrderV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

func (r ApiSpotCreateSorOrderV3Request) NewOrderRespType(newOrderRespType string) ApiSpotCreateSorOrderV3Request {
	r.newOrderRespType = &newOrderRespType
	return r
}

func (r ApiSpotCreateSorOrderV3Request) Price(price string) ApiSpotCreateSorOrderV3Request {
	r.price = &price
	return r
}

func (r ApiSpotCreateSorOrderV3Request) RecvWindow(recvWindow int64) ApiSpotCreateSorOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotCreateSorOrderV3Request) SelfTradePreventionMode(selfTradePreventionMode string) ApiSpotCreateSorOrderV3Request {
	r.selfTradePreventionMode = &selfTradePreventionMode
	return r
}

func (r ApiSpotCreateSorOrderV3Request) StrategyId(strategyId int64) ApiSpotCreateSorOrderV3Request {
	r.strategyId = &strategyId
	return r
}

func (r ApiSpotCreateSorOrderV3Request) StrategyType(strategyType int32) ApiSpotCreateSorOrderV3Request {
	r.strategyType = &strategyType
	return r
}

func (r ApiSpotCreateSorOrderV3Request) TimeInForce(timeInForce string) ApiSpotCreateSorOrderV3Request {
	r.timeInForce = &timeInForce
	return r
}

func (r ApiSpotCreateSorOrderV3Request) Execute() (*SpotCreateSorOrderV3Resp, *http.Response, error) {
	return r.ApiService.SpotCreateSorOrderV3Execute(r)
}

/*
SpotCreateSorOrderV3 New order using SOR (TRADE)

Places an order using smart order routing (SOR).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotCreateSorOrderV3Request
*/
func (a *TradingAPIService) SpotCreateSorOrderV3(ctx context.Context) ApiSpotCreateSorOrderV3Request {
	return ApiSpotCreateSorOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotCreateSorOrderV3Resp
func (a *TradingAPIService) SpotCreateSorOrderV3Execute(r ApiSpotCreateSorOrderV3Request) (*SpotCreateSorOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotCreateSorOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotCreateSorOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/sor/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.icebergQty != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icebergQty", r.icebergQty, "", "")
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newClientOrderId", r.newClientOrderId, "", "")
	}
	if r.newOrderRespType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "newOrderRespType", r.newOrderRespType, "", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.selfTradePreventionMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "selfTradePreventionMode", r.selfTradePreventionMode, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "side", r.side, "", "")
	if r.strategyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyId", r.strategyId, "", "")
	}
	if r.strategyType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "strategyType", r.strategyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "symbol", r.symbol, "", "")
	if r.timeInForce != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeInForce", r.timeInForce, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotDeleteOpenOrdersV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	symbol *string
	timestamp *int64
	recvWindow *int64
}

func (r ApiSpotDeleteOpenOrdersV3Request) Symbol(symbol string) ApiSpotDeleteOpenOrdersV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotDeleteOpenOrdersV3Request) Timestamp(timestamp int64) ApiSpotDeleteOpenOrdersV3Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiSpotDeleteOpenOrdersV3Request) RecvWindow(recvWindow int64) ApiSpotDeleteOpenOrdersV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotDeleteOpenOrdersV3Request) Execute() ([][]SpotDeleteOpenOrdersV3RespInner, *http.Response, error) {
	return r.ApiService.SpotDeleteOpenOrdersV3Execute(r)
}

/*
SpotDeleteOpenOrdersV3 Cancel All Open Orders on a Symbol (TRADE)

Cancels all active orders on a symbol.
This includes orders that are part of an order list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotDeleteOpenOrdersV3Request
*/
func (a *TradingAPIService) SpotDeleteOpenOrdersV3(ctx context.Context) ApiSpotDeleteOpenOrdersV3Request {
	return ApiSpotDeleteOpenOrdersV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return [][]SpotDeleteOpenOrdersV3RespInner
func (a *TradingAPIService) SpotDeleteOpenOrdersV3Execute(r ApiSpotDeleteOpenOrdersV3Request) ([][]SpotDeleteOpenOrdersV3RespInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]SpotDeleteOpenOrdersV3RespInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotDeleteOpenOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotDeleteOrderListV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	symbol *string
	timestamp *int64
	orderListId *int64
	listClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

func (r ApiSpotDeleteOrderListV3Request) Symbol(symbol string) ApiSpotDeleteOrderListV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotDeleteOrderListV3Request) Timestamp(timestamp int64) ApiSpotDeleteOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r ApiSpotDeleteOrderListV3Request) OrderListId(orderListId int64) ApiSpotDeleteOrderListV3Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r ApiSpotDeleteOrderListV3Request) ListClientOrderId(listClientOrderId string) ApiSpotDeleteOrderListV3Request {
	r.listClientOrderId = &listClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiSpotDeleteOrderListV3Request) NewClientOrderId(newClientOrderId string) ApiSpotDeleteOrderListV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiSpotDeleteOrderListV3Request) RecvWindow(recvWindow int64) ApiSpotDeleteOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotDeleteOrderListV3Request) Execute() (*SpotDeleteOrderListV3Resp, *http.Response, error) {
	return r.ApiService.SpotDeleteOrderListV3Execute(r)
}

/*
SpotDeleteOrderListV3 Cancel Order list (TRADE)

Cancel an entire Order list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotDeleteOrderListV3Request
*/
func (a *TradingAPIService) SpotDeleteOrderListV3(ctx context.Context) ApiSpotDeleteOrderListV3Request {
	return ApiSpotDeleteOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotDeleteOrderListV3Resp
func (a *TradingAPIService) SpotDeleteOrderListV3Execute(r ApiSpotDeleteOrderListV3Request) (*SpotDeleteOrderListV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotDeleteOrderListV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotDeleteOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.listClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listClientOrderId", r.listClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.listClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotDeleteOrderV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	newClientOrderId *string
	cancelRestrictions *string
	recvWindow *int64
}

func (r ApiSpotDeleteOrderV3Request) Symbol(symbol string) ApiSpotDeleteOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotDeleteOrderV3Request) Timestamp(timestamp int64) ApiSpotDeleteOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotDeleteOrderV3Request) OrderId(orderId int64) ApiSpotDeleteOrderV3Request {
	r.orderId = &orderId
	return r
}

func (r ApiSpotDeleteOrderV3Request) OrigClientOrderId(origClientOrderId string) ApiSpotDeleteOrderV3Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default.
func (r ApiSpotDeleteOrderV3Request) NewClientOrderId(newClientOrderId string) ApiSpotDeleteOrderV3Request {
	r.newClientOrderId = &newClientOrderId
	return r
}

// Supported values: &lt;br/&gt;&#x60;ONLY_NEW&#x60; - Cancel will succeed if the order status is &#x60;NEW&#x60;.&lt;br/&gt; &#x60;ONLY_PARTIALLY_FILLED &#x60; - Cancel will succeed if order status is &#x60;PARTIALLY_FILLED&#x60;.
func (r ApiSpotDeleteOrderV3Request) CancelRestrictions(cancelRestrictions string) ApiSpotDeleteOrderV3Request {
	r.cancelRestrictions = &cancelRestrictions
	return r
}

// The value cannot be greater than &#x60;60000&#x60;.
func (r ApiSpotDeleteOrderV3Request) RecvWindow(recvWindow int64) ApiSpotDeleteOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotDeleteOrderV3Request) Execute() (*SpotDeleteOrderV3Resp, *http.Response, error) {
	return r.ApiService.SpotDeleteOrderV3Execute(r)
}

/*
SpotDeleteOrderV3 Cancel order (TRADE)

Cancel an active order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotDeleteOrderV3Request
*/
func (a *TradingAPIService) SpotDeleteOrderV3(ctx context.Context) ApiSpotDeleteOrderV3Request {
	return ApiSpotDeleteOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotDeleteOrderV3Resp
func (a *TradingAPIService) SpotDeleteOrderV3Execute(r ApiSpotDeleteOrderV3Request) (*SpotDeleteOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotDeleteOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotDeleteOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.newClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newClientOrderId", r.newClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.newClientOrderId = &defaultValue
	}
	if r.cancelRestrictions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancelRestrictions", r.cancelRestrictions, "form", "")
	} else {
		var defaultValue string = ""
		r.cancelRestrictions = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotGetAllOrderListV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	timestamp *int64
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiSpotGetAllOrderListV3Request) Timestamp(timestamp int64) ApiSpotGetAllOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
func (r ApiSpotGetAllOrderListV3Request) FromId(fromId int64) ApiSpotGetAllOrderListV3Request {
	r.fromId = &fromId
	return r
}

func (r ApiSpotGetAllOrderListV3Request) StartTime(startTime int64) ApiSpotGetAllOrderListV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiSpotGetAllOrderListV3Request) EndTime(endTime int64) ApiSpotGetAllOrderListV3Request {
	r.endTime = &endTime
	return r
}

// Default Value: 500; Max Value: 1000
func (r ApiSpotGetAllOrderListV3Request) Limit(limit int32) ApiSpotGetAllOrderListV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiSpotGetAllOrderListV3Request) RecvWindow(recvWindow int64) ApiSpotGetAllOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotGetAllOrderListV3Request) Execute() ([]SpotGetAllOrderListV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetAllOrderListV3Execute(r)
}

/*
SpotGetAllOrderListV3 Query all Order lists (USER_DATA)

Retrieves all order lists based on provided optional parameters.
Note that the time between startTime and endTime can't be longer than 24 hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotGetAllOrderListV3Request
*/
func (a *TradingAPIService) SpotGetAllOrderListV3(ctx context.Context) ApiSpotGetAllOrderListV3Request {
	return ApiSpotGetAllOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetAllOrderListV3RespItem
func (a *TradingAPIService) SpotGetAllOrderListV3Execute(r ApiSpotGetAllOrderListV3Request) ([]SpotGetAllOrderListV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetAllOrderListV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotGetAllOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.fromId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromId", r.fromId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotGetAllOrdersV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiSpotGetAllOrdersV3Request) Symbol(symbol string) ApiSpotGetAllOrdersV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotGetAllOrdersV3Request) Timestamp(timestamp int64) ApiSpotGetAllOrdersV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotGetAllOrdersV3Request) OrderId(orderId int64) ApiSpotGetAllOrdersV3Request {
	r.orderId = &orderId
	return r
}

func (r ApiSpotGetAllOrdersV3Request) StartTime(startTime int64) ApiSpotGetAllOrdersV3Request {
	r.startTime = &startTime
	return r
}

func (r ApiSpotGetAllOrdersV3Request) EndTime(endTime int64) ApiSpotGetAllOrdersV3Request {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r ApiSpotGetAllOrdersV3Request) Limit(limit int32) ApiSpotGetAllOrdersV3Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiSpotGetAllOrdersV3Request) RecvWindow(recvWindow int64) ApiSpotGetAllOrdersV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotGetAllOrdersV3Request) Execute() ([]SpotGetAllOrdersV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetAllOrdersV3Execute(r)
}

/*
SpotGetAllOrdersV3 All orders (USER_DATA)

Get all account orders; active, canceled, or filled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotGetAllOrdersV3Request
*/
func (a *TradingAPIService) SpotGetAllOrdersV3(ctx context.Context) ApiSpotGetAllOrdersV3Request {
	return ApiSpotGetAllOrdersV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetAllOrdersV3RespItem
func (a *TradingAPIService) SpotGetAllOrdersV3Execute(r ApiSpotGetAllOrdersV3Request) ([]SpotGetAllOrdersV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetAllOrdersV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotGetAllOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 500
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotGetOpenOrderListV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiSpotGetOpenOrderListV3Request) Timestamp(timestamp int64) ApiSpotGetOpenOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiSpotGetOpenOrderListV3Request) RecvWindow(recvWindow int64) ApiSpotGetOpenOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotGetOpenOrderListV3Request) Execute() ([]SpotGetOpenOrderListV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetOpenOrderListV3Execute(r)
}

/*
SpotGetOpenOrderListV3 Query Open Order lists (USER_DATA)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotGetOpenOrderListV3Request
*/
func (a *TradingAPIService) SpotGetOpenOrderListV3(ctx context.Context) ApiSpotGetOpenOrderListV3Request {
	return ApiSpotGetOpenOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetOpenOrderListV3RespItem
func (a *TradingAPIService) SpotGetOpenOrderListV3Execute(r ApiSpotGetOpenOrderListV3Request) ([]SpotGetOpenOrderListV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetOpenOrderListV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotGetOpenOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotGetOpenOrdersV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiSpotGetOpenOrdersV3Request) Timestamp(timestamp int64) ApiSpotGetOpenOrdersV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotGetOpenOrdersV3Request) Symbol(symbol string) ApiSpotGetOpenOrdersV3Request {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiSpotGetOpenOrdersV3Request) RecvWindow(recvWindow int64) ApiSpotGetOpenOrdersV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotGetOpenOrdersV3Request) Execute() ([]SpotGetOpenOrdersV3RespItem, *http.Response, error) {
	return r.ApiService.SpotGetOpenOrdersV3Execute(r)
}

/*
SpotGetOpenOrdersV3 Current open orders (USER_DATA)

Get all open orders on a symbol. Careful when accessing this with no symbol.
Weight:
6 for a single symbol; 80 when the symbol parameter is omitted

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotGetOpenOrdersV3Request
*/
func (a *TradingAPIService) SpotGetOpenOrdersV3(ctx context.Context) ApiSpotGetOpenOrdersV3Request {
	return ApiSpotGetOpenOrdersV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SpotGetOpenOrdersV3RespItem
func (a *TradingAPIService) SpotGetOpenOrdersV3Execute(r ApiSpotGetOpenOrdersV3Request) ([]SpotGetOpenOrdersV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SpotGetOpenOrdersV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotGetOpenOrdersV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotGetOrderListV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	timestamp *int64
	orderListId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r ApiSpotGetOrderListV3Request) Timestamp(timestamp int64) ApiSpotGetOrderListV3Request {
	r.timestamp = &timestamp
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r ApiSpotGetOrderListV3Request) OrderListId(orderListId int64) ApiSpotGetOrderListV3Request {
	r.orderListId = &orderListId
	return r
}

// Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided
func (r ApiSpotGetOrderListV3Request) OrigClientOrderId(origClientOrderId string) ApiSpotGetOrderListV3Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiSpotGetOrderListV3Request) RecvWindow(recvWindow int64) ApiSpotGetOrderListV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotGetOrderListV3Request) Execute() (*SpotGetOrderListV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetOrderListV3Execute(r)
}

/*
SpotGetOrderListV3 Query Order list (USER_DATA)

Retrieves a specific order list based on provided optional parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotGetOrderListV3Request
*/
func (a *TradingAPIService) SpotGetOrderListV3(ctx context.Context) ApiSpotGetOrderListV3Request {
	return ApiSpotGetOrderListV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetOrderListV3Resp
func (a *TradingAPIService) SpotGetOrderListV3Execute(r ApiSpotGetOrderListV3Request) (*SpotGetOrderListV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetOrderListV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotGetOrderListV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.orderListId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderListId", r.orderListId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpotGetOrderV3Request struct {
	ctx context.Context
	ApiService *TradingAPIService
	symbol *string
	timestamp *int64
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

func (r ApiSpotGetOrderV3Request) Symbol(symbol string) ApiSpotGetOrderV3Request {
	r.symbol = &symbol
	return r
}

func (r ApiSpotGetOrderV3Request) Timestamp(timestamp int64) ApiSpotGetOrderV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiSpotGetOrderV3Request) OrderId(orderId int64) ApiSpotGetOrderV3Request {
	r.orderId = &orderId
	return r
}

func (r ApiSpotGetOrderV3Request) OrigClientOrderId(origClientOrderId string) ApiSpotGetOrderV3Request {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than &#x60;60000&#x60;
func (r ApiSpotGetOrderV3Request) RecvWindow(recvWindow int64) ApiSpotGetOrderV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSpotGetOrderV3Request) Execute() (*SpotGetOrderV3Resp, *http.Response, error) {
	return r.ApiService.SpotGetOrderV3Execute(r)
}

/*
SpotGetOrderV3 Query order (USER_DATA)

Check an order's status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpotGetOrderV3Request
*/
func (a *TradingAPIService) SpotGetOrderV3(ctx context.Context) ApiSpotGetOrderV3Request {
	return ApiSpotGetOrderV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpotGetOrderV3Resp
func (a *TradingAPIService) SpotGetOrderV3Execute(r ApiSpotGetOrderV3Request) (*SpotGetOrderV3Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpotGetOrderV3Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingAPIService.SpotGetOrderV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderId", r.orderId, "form", "")
	}
	if r.origClientOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origClientOrderId", r.origClientOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.origClientOrderId = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

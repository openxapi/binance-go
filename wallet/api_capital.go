/*
Binance Wallet API

OpenAPI specification for Binance exchange - Wallet API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package wallet

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// CapitalAPIService CapitalAPI service
type CapitalAPIService service

type CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request struct {
	ctx context.Context
	ApiService *CapitalAPIService
	depositId *int64
	subAccountId *int64
	subUserId *int64
	txId *string
}

func (r CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request) DepositId(depositId int64) CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request {
	r.depositId = &depositId
	return r
}

func (r CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request) SubAccountId(subAccountId int64) CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request {
	r.subAccountId = &subAccountId
	return r
}

func (r CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request) SubUserId(subUserId int64) CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request {
	r.subUserId = &subUserId
	return r
}

func (r CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request) TxId(txId string) CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request {
	r.txId = &txId
	return r
}

func (r CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request) Execute() (*WalletCreateCapitalDepositCreditApplyV1Resp, *http.Response, error) {
	return r.ApiService.WalletCreateCapitalDepositCreditApplyV1Execute(r)
}

/*
WalletCreateCapitalDepositCreditApplyV1 One click arrival deposit apply (for expired address deposit) (USER_DATA)

Apply deposit credit for expired address (One click arrival)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request
*/
func (a *CapitalAPIService) WalletCreateCapitalDepositCreditApplyV1(ctx context.Context) CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request {
	return CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletCreateCapitalDepositCreditApplyV1Resp
func (a *CapitalAPIService) WalletCreateCapitalDepositCreditApplyV1Execute(r CapitalAPIWalletCreateCapitalDepositCreditApplyV1Request) (*WalletCreateCapitalDepositCreditApplyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletCreateCapitalDepositCreditApplyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapitalAPIService.WalletCreateCapitalDepositCreditApplyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/credit-apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.depositId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "depositId", r.depositId, "", "")
	}
	if r.subAccountId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "subAccountId", r.subAccountId, "", "")
	}
	if r.subUserId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "subUserId", r.subUserId, "", "")
	}
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "txId", r.txId, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapitalAPIWalletCreateCapitalWithdrawApplyV1Request struct {
	ctx context.Context
	ApiService *CapitalAPIService
	address *string
	amount *string
	coin *string
	timestamp *int64
	addressTag *string
	name *string
	network *string
	recvWindow *int64
	transactionFeeFlag *bool
	walletType *int32
	withdrawOrderId *string
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) Address(address string) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.address = &address
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) Amount(amount string) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.amount = &amount
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) Coin(coin string) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.coin = &coin
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) Timestamp(timestamp int64) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.timestamp = &timestamp
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) AddressTag(addressTag string) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.addressTag = &addressTag
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) Name(name string) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.name = &name
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) Network(network string) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.network = &network
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) RecvWindow(recvWindow int64) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) TransactionFeeFlag(transactionFeeFlag bool) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.transactionFeeFlag = &transactionFeeFlag
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) WalletType(walletType int32) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.walletType = &walletType
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) WithdrawOrderId(withdrawOrderId string) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	r.withdrawOrderId = &withdrawOrderId
	return r
}

func (r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) Execute() (*WalletCreateCapitalWithdrawApplyV1Resp, *http.Response, error) {
	return r.ApiService.WalletCreateCapitalWithdrawApplyV1Execute(r)
}

/*
WalletCreateCapitalWithdrawApplyV1 Withdraw(USER_DATA)

Submit a withdraw request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CapitalAPIWalletCreateCapitalWithdrawApplyV1Request
*/
func (a *CapitalAPIService) WalletCreateCapitalWithdrawApplyV1(ctx context.Context) CapitalAPIWalletCreateCapitalWithdrawApplyV1Request {
	return CapitalAPIWalletCreateCapitalWithdrawApplyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletCreateCapitalWithdrawApplyV1Resp
func (a *CapitalAPIService) WalletCreateCapitalWithdrawApplyV1Execute(r CapitalAPIWalletCreateCapitalWithdrawApplyV1Request) (*WalletCreateCapitalWithdrawApplyV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletCreateCapitalWithdrawApplyV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapitalAPIService.WalletCreateCapitalWithdrawApplyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/withdraw/apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.address == nil {
		return localVarReturnValue, nil, reportError("address is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "address", r.address, "", "")
	if r.addressTag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "addressTag", r.addressTag, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "coin", r.coin, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "network", r.network, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.transactionFeeFlag != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transactionFeeFlag", r.transactionFeeFlag, "", "")
	}
	if r.walletType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "walletType", r.walletType, "", "")
	}
	if r.withdrawOrderId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "withdrawOrderId", r.withdrawOrderId, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapitalAPIWalletGetCapitalConfigGetallV1Request struct {
	ctx context.Context
	ApiService *CapitalAPIService
	timestamp *int64
	recvWindow *int64
}

func (r CapitalAPIWalletGetCapitalConfigGetallV1Request) Timestamp(timestamp int64) CapitalAPIWalletGetCapitalConfigGetallV1Request {
	r.timestamp = &timestamp
	return r
}

func (r CapitalAPIWalletGetCapitalConfigGetallV1Request) RecvWindow(recvWindow int64) CapitalAPIWalletGetCapitalConfigGetallV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r CapitalAPIWalletGetCapitalConfigGetallV1Request) Execute() ([]WalletGetCapitalConfigGetallV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetCapitalConfigGetallV1Execute(r)
}

/*
WalletGetCapitalConfigGetallV1 All Coins' Information (USER_DATA)

Get information of coins (available for deposit and withdraw) for user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CapitalAPIWalletGetCapitalConfigGetallV1Request
*/
func (a *CapitalAPIService) WalletGetCapitalConfigGetallV1(ctx context.Context) CapitalAPIWalletGetCapitalConfigGetallV1Request {
	return CapitalAPIWalletGetCapitalConfigGetallV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetCapitalConfigGetallV1RespItem
func (a *CapitalAPIService) WalletGetCapitalConfigGetallV1Execute(r CapitalAPIWalletGetCapitalConfigGetallV1Request) ([]WalletGetCapitalConfigGetallV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetCapitalConfigGetallV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapitalAPIService.WalletGetCapitalConfigGetallV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/config/getall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapitalAPIWalletGetCapitalDepositAddressListV1Request struct {
	ctx context.Context
	ApiService *CapitalAPIService
	coin *string
	timestamp *int64
	network *string
}

// &#x60;coin&#x60; refers to the parent network address format that the address is using
func (r CapitalAPIWalletGetCapitalDepositAddressListV1Request) Coin(coin string) CapitalAPIWalletGetCapitalDepositAddressListV1Request {
	r.coin = &coin
	return r
}

func (r CapitalAPIWalletGetCapitalDepositAddressListV1Request) Timestamp(timestamp int64) CapitalAPIWalletGetCapitalDepositAddressListV1Request {
	r.timestamp = &timestamp
	return r
}

func (r CapitalAPIWalletGetCapitalDepositAddressListV1Request) Network(network string) CapitalAPIWalletGetCapitalDepositAddressListV1Request {
	r.network = &network
	return r
}

func (r CapitalAPIWalletGetCapitalDepositAddressListV1Request) Execute() ([]WalletGetCapitalDepositAddressListV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetCapitalDepositAddressListV1Execute(r)
}

/*
WalletGetCapitalDepositAddressListV1 Fetch deposit address list with network(USER_DATA)

Fetch deposit address list with network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CapitalAPIWalletGetCapitalDepositAddressListV1Request
*/
func (a *CapitalAPIService) WalletGetCapitalDepositAddressListV1(ctx context.Context) CapitalAPIWalletGetCapitalDepositAddressListV1Request {
	return CapitalAPIWalletGetCapitalDepositAddressListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetCapitalDepositAddressListV1RespItem
func (a *CapitalAPIService) WalletGetCapitalDepositAddressListV1Execute(r CapitalAPIWalletGetCapitalDepositAddressListV1Request) ([]WalletGetCapitalDepositAddressListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetCapitalDepositAddressListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapitalAPIService.WalletGetCapitalDepositAddressListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/address/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapitalAPIWalletGetCapitalDepositAddressV1Request struct {
	ctx context.Context
	ApiService *CapitalAPIService
	coin *string
	timestamp *int64
	network *string
	amount *string
	recvWindow *int64
}

func (r CapitalAPIWalletGetCapitalDepositAddressV1Request) Coin(coin string) CapitalAPIWalletGetCapitalDepositAddressV1Request {
	r.coin = &coin
	return r
}

func (r CapitalAPIWalletGetCapitalDepositAddressV1Request) Timestamp(timestamp int64) CapitalAPIWalletGetCapitalDepositAddressV1Request {
	r.timestamp = &timestamp
	return r
}

func (r CapitalAPIWalletGetCapitalDepositAddressV1Request) Network(network string) CapitalAPIWalletGetCapitalDepositAddressV1Request {
	r.network = &network
	return r
}

func (r CapitalAPIWalletGetCapitalDepositAddressV1Request) Amount(amount string) CapitalAPIWalletGetCapitalDepositAddressV1Request {
	r.amount = &amount
	return r
}

func (r CapitalAPIWalletGetCapitalDepositAddressV1Request) RecvWindow(recvWindow int64) CapitalAPIWalletGetCapitalDepositAddressV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r CapitalAPIWalletGetCapitalDepositAddressV1Request) Execute() (*WalletGetCapitalDepositAddressV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetCapitalDepositAddressV1Execute(r)
}

/*
WalletGetCapitalDepositAddressV1 Deposit Address(supporting network) (USER_DATA)

Fetch deposit address with network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CapitalAPIWalletGetCapitalDepositAddressV1Request
*/
func (a *CapitalAPIService) WalletGetCapitalDepositAddressV1(ctx context.Context) CapitalAPIWalletGetCapitalDepositAddressV1Request {
	return CapitalAPIWalletGetCapitalDepositAddressV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetCapitalDepositAddressV1Resp
func (a *CapitalAPIService) WalletGetCapitalDepositAddressV1Execute(r CapitalAPIWalletGetCapitalDepositAddressV1Request) (*WalletGetCapitalDepositAddressV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetCapitalDepositAddressV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapitalAPIService.WalletGetCapitalDepositAddressV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "form", "")
	} else {
		var defaultValue string = ""
		r.network = &defaultValue
	}
	if r.amount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	} else {
		var defaultValue string = ""
		r.amount = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapitalAPIWalletGetCapitalDepositHisrecV1Request struct {
	ctx context.Context
	ApiService *CapitalAPIService
	timestamp *int64
	includeSource *bool
	coin *string
	status *int32
	startTime *int64
	endTime *int64
	offset *int32
	limit *int32
	recvWindow *int64
	txId *string
}

func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) Timestamp(timestamp int64) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	r.timestamp = &timestamp
	return r
}

// Default: &#x60;false&#x60;, return &#x60;sourceAddress&#x60;field when set to &#x60;true&#x60;
func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) IncludeSource(includeSource bool) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	r.includeSource = &includeSource
	return r
}

func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) Coin(coin string) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	r.coin = &coin
	return r
}

// 0(0:pending, 6:credited but cannot withdraw, 7:Wrong Deposit, 8:Waiting User confirm, 1:success, 2:rejected)
func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) Status(status int32) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	r.status = &status
	return r
}

// Default: 90 days from current timestamp
func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) StartTime(startTime int64) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) EndTime(endTime int64) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	r.endTime = &endTime
	return r
}

// Default:0
func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) Offset(offset int32) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	r.offset = &offset
	return r
}

// Default:1000, Max:1000
func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) Limit(limit int32) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	r.limit = &limit
	return r
}

func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) RecvWindow(recvWindow int64) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) TxId(txId string) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	r.txId = &txId
	return r
}

func (r CapitalAPIWalletGetCapitalDepositHisrecV1Request) Execute() ([]WalletGetCapitalDepositHisrecV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetCapitalDepositHisrecV1Execute(r)
}

/*
WalletGetCapitalDepositHisrecV1 Deposit History (supporting network) (USER_DATA)

Fetch deposit history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CapitalAPIWalletGetCapitalDepositHisrecV1Request
*/
func (a *CapitalAPIService) WalletGetCapitalDepositHisrecV1(ctx context.Context) CapitalAPIWalletGetCapitalDepositHisrecV1Request {
	return CapitalAPIWalletGetCapitalDepositHisrecV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetCapitalDepositHisrecV1RespItem
func (a *CapitalAPIService) WalletGetCapitalDepositHisrecV1Execute(r CapitalAPIWalletGetCapitalDepositHisrecV1Request) ([]WalletGetCapitalDepositHisrecV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetCapitalDepositHisrecV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapitalAPIService.WalletGetCapitalDepositHisrecV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/hisrec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.includeSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSource", r.includeSource, "form", "")
	} else {
		var defaultValue bool = false
		r.includeSource = &defaultValue
	}
	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "txId", r.txId, "form", "")
	} else {
		var defaultValue string = ""
		r.txId = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapitalAPIWalletGetCapitalWithdrawAddressListV1Request struct {
	ctx context.Context
	ApiService *CapitalAPIService
}

func (r CapitalAPIWalletGetCapitalWithdrawAddressListV1Request) Execute() ([]WalletGetCapitalWithdrawAddressListV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetCapitalWithdrawAddressListV1Execute(r)
}

/*
WalletGetCapitalWithdrawAddressListV1 Fetch withdraw address list (USER_DATA)

Fetch withdraw address list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CapitalAPIWalletGetCapitalWithdrawAddressListV1Request
*/
func (a *CapitalAPIService) WalletGetCapitalWithdrawAddressListV1(ctx context.Context) CapitalAPIWalletGetCapitalWithdrawAddressListV1Request {
	return CapitalAPIWalletGetCapitalWithdrawAddressListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetCapitalWithdrawAddressListV1RespItem
func (a *CapitalAPIService) WalletGetCapitalWithdrawAddressListV1Execute(r CapitalAPIWalletGetCapitalWithdrawAddressListV1Request) ([]WalletGetCapitalWithdrawAddressListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetCapitalWithdrawAddressListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapitalAPIService.WalletGetCapitalWithdrawAddressListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/withdraw/address/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapitalAPIWalletGetCapitalWithdrawHistoryV1Request struct {
	ctx context.Context
	ApiService *CapitalAPIService
	timestamp *int64
	coin *string
	withdrawOrderId *string
	status *int32
	offset *int32
	limit *int32
	idList *string
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) Timestamp(timestamp int64) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) Coin(coin string) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	r.coin = &coin
	return r
}

func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) WithdrawOrderId(withdrawOrderId string) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	r.withdrawOrderId = &withdrawOrderId
	return r
}

// 0(0:Email Sent, 2:Awaiting Approval 3:Rejected 4:Processing 6:Completed)
func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) Status(status int32) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	r.status = &status
	return r
}

func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) Offset(offset int32) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	r.offset = &offset
	return r
}

// Default: 1000, Max: 1000
func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) Limit(limit int32) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	r.limit = &limit
	return r
}

// id list returned in the response of POST &#x60;/sapi/v1/capital/withdraw/apply&#x60;, separated by &#x60;,&#x60;
func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) IdList(idList string) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	r.idList = &idList
	return r
}

// Default: 90 days from current timestamp
func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) StartTime(startTime int64) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	r.startTime = &startTime
	return r
}

// Default: present timestamp
func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) EndTime(endTime int64) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	r.endTime = &endTime
	return r
}

func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) RecvWindow(recvWindow int64) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) Execute() ([]WalletGetCapitalWithdrawHistoryV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetCapitalWithdrawHistoryV1Execute(r)
}

/*
WalletGetCapitalWithdrawHistoryV1 Withdraw History (supporting network) (USER_DATA)

Fetch withdraw history.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CapitalAPIWalletGetCapitalWithdrawHistoryV1Request
*/
func (a *CapitalAPIService) WalletGetCapitalWithdrawHistoryV1(ctx context.Context) CapitalAPIWalletGetCapitalWithdrawHistoryV1Request {
	return CapitalAPIWalletGetCapitalWithdrawHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetCapitalWithdrawHistoryV1RespItem
func (a *CapitalAPIService) WalletGetCapitalWithdrawHistoryV1Execute(r CapitalAPIWalletGetCapitalWithdrawHistoryV1Request) ([]WalletGetCapitalWithdrawHistoryV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetCapitalWithdrawHistoryV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapitalAPIService.WalletGetCapitalWithdrawHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/withdraw/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.coin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coin", r.coin, "form", "")
	} else {
		var defaultValue string = ""
		r.coin = &defaultValue
	}
	if r.withdrawOrderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withdrawOrderId", r.withdrawOrderId, "form", "")
	} else {
		var defaultValue string = ""
		r.withdrawOrderId = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 1000
		r.limit = &defaultValue
	}
	if r.idList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idList", r.idList, "form", "")
	} else {
		var defaultValue string = ""
		r.idList = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

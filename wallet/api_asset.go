/*
Binance Wallet API

OpenAPI specification for Binance exchange - Wallet API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package wallet

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AssetAPIService AssetAPI service
type AssetAPIService service

type AssetAPIWalletCreateAssetDustBtcV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	accountType *string
	recvWindow *int64
}

func (r AssetAPIWalletCreateAssetDustBtcV1Request) Timestamp(timestamp int64) AssetAPIWalletCreateAssetDustBtcV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletCreateAssetDustBtcV1Request) AccountType(accountType string) AssetAPIWalletCreateAssetDustBtcV1Request {
	r.accountType = &accountType
	return r
}

func (r AssetAPIWalletCreateAssetDustBtcV1Request) RecvWindow(recvWindow int64) AssetAPIWalletCreateAssetDustBtcV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletCreateAssetDustBtcV1Request) Execute() (*WalletCreateAssetDustBtcV1Resp, *http.Response, error) {
	return r.ApiService.WalletCreateAssetDustBtcV1Execute(r)
}

/*
WalletCreateAssetDustBtcV1 Get Assets That Can Be Converted Into BNB (USER_DATA)

Get Assets That Can Be Converted Into BNB

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletCreateAssetDustBtcV1Request
*/
func (a *AssetAPIService) WalletCreateAssetDustBtcV1(ctx context.Context) AssetAPIWalletCreateAssetDustBtcV1Request {
	return AssetAPIWalletCreateAssetDustBtcV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletCreateAssetDustBtcV1Resp
func (a *AssetAPIService) WalletCreateAssetDustBtcV1Execute(r AssetAPIWalletCreateAssetDustBtcV1Request) (*WalletCreateAssetDustBtcV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletCreateAssetDustBtcV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateAssetDustBtcV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dust-btc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "accountType", r.accountType, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletCreateAssetDustV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	asset *[]string
	timestamp *int64
	accountType *string
	recvWindow *int64
}

func (r AssetAPIWalletCreateAssetDustV1Request) Asset(asset []string) AssetAPIWalletCreateAssetDustV1Request {
	r.asset = &asset
	return r
}

func (r AssetAPIWalletCreateAssetDustV1Request) Timestamp(timestamp int64) AssetAPIWalletCreateAssetDustV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletCreateAssetDustV1Request) AccountType(accountType string) AssetAPIWalletCreateAssetDustV1Request {
	r.accountType = &accountType
	return r
}

func (r AssetAPIWalletCreateAssetDustV1Request) RecvWindow(recvWindow int64) AssetAPIWalletCreateAssetDustV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletCreateAssetDustV1Request) Execute() (*WalletCreateAssetDustV1Resp, *http.Response, error) {
	return r.ApiService.WalletCreateAssetDustV1Execute(r)
}

/*
WalletCreateAssetDustV1 Dust Transfer (USER_DATA)

Convert dust assets to BNB.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletCreateAssetDustV1Request
*/
func (a *AssetAPIService) WalletCreateAssetDustV1(ctx context.Context) AssetAPIWalletCreateAssetDustV1Request {
	return AssetAPIWalletCreateAssetDustV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletCreateAssetDustV1Resp
func (a *AssetAPIService) WalletCreateAssetDustV1Execute(r AssetAPIWalletCreateAssetDustV1Request) (*WalletCreateAssetDustV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletCreateAssetDustV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateAssetDustV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dust"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "accountType", r.accountType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "csv")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletCreateAssetGetFundingAssetV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	asset *string
	needBtcValuation *string
	recvWindow *int64
}

func (r AssetAPIWalletCreateAssetGetFundingAssetV1Request) Timestamp(timestamp int64) AssetAPIWalletCreateAssetGetFundingAssetV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletCreateAssetGetFundingAssetV1Request) Asset(asset string) AssetAPIWalletCreateAssetGetFundingAssetV1Request {
	r.asset = &asset
	return r
}

func (r AssetAPIWalletCreateAssetGetFundingAssetV1Request) NeedBtcValuation(needBtcValuation string) AssetAPIWalletCreateAssetGetFundingAssetV1Request {
	r.needBtcValuation = &needBtcValuation
	return r
}

func (r AssetAPIWalletCreateAssetGetFundingAssetV1Request) RecvWindow(recvWindow int64) AssetAPIWalletCreateAssetGetFundingAssetV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletCreateAssetGetFundingAssetV1Request) Execute() ([]WalletCreateAssetGetFundingAssetV1RespItem, *http.Response, error) {
	return r.ApiService.WalletCreateAssetGetFundingAssetV1Execute(r)
}

/*
WalletCreateAssetGetFundingAssetV1 Funding Wallet (USER_DATA)

Query Funding Wallet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletCreateAssetGetFundingAssetV1Request
*/
func (a *AssetAPIService) WalletCreateAssetGetFundingAssetV1(ctx context.Context) AssetAPIWalletCreateAssetGetFundingAssetV1Request {
	return AssetAPIWalletCreateAssetGetFundingAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletCreateAssetGetFundingAssetV1RespItem
func (a *AssetAPIService) WalletCreateAssetGetFundingAssetV1Execute(r AssetAPIWalletCreateAssetGetFundingAssetV1Request) ([]WalletCreateAssetGetFundingAssetV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletCreateAssetGetFundingAssetV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateAssetGetFundingAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/get-funding-asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	}
	if r.needBtcValuation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "needBtcValuation", r.needBtcValuation, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletCreateAssetGetUserAssetV3Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	asset *string
	needBtcValuation *bool
	recvWindow *int64
}

func (r AssetAPIWalletCreateAssetGetUserAssetV3Request) Timestamp(timestamp int64) AssetAPIWalletCreateAssetGetUserAssetV3Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletCreateAssetGetUserAssetV3Request) Asset(asset string) AssetAPIWalletCreateAssetGetUserAssetV3Request {
	r.asset = &asset
	return r
}

func (r AssetAPIWalletCreateAssetGetUserAssetV3Request) NeedBtcValuation(needBtcValuation bool) AssetAPIWalletCreateAssetGetUserAssetV3Request {
	r.needBtcValuation = &needBtcValuation
	return r
}

func (r AssetAPIWalletCreateAssetGetUserAssetV3Request) RecvWindow(recvWindow int64) AssetAPIWalletCreateAssetGetUserAssetV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletCreateAssetGetUserAssetV3Request) Execute() ([]WalletCreateAssetGetUserAssetV3RespItem, *http.Response, error) {
	return r.ApiService.WalletCreateAssetGetUserAssetV3Execute(r)
}

/*
WalletCreateAssetGetUserAssetV3 User Asset (USER_DATA)

Get user assets, just for positive data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletCreateAssetGetUserAssetV3Request
*/
func (a *AssetAPIService) WalletCreateAssetGetUserAssetV3(ctx context.Context) AssetAPIWalletCreateAssetGetUserAssetV3Request {
	return AssetAPIWalletCreateAssetGetUserAssetV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletCreateAssetGetUserAssetV3RespItem
func (a *AssetAPIService) WalletCreateAssetGetUserAssetV3Execute(r AssetAPIWalletCreateAssetGetUserAssetV3Request) ([]WalletCreateAssetGetUserAssetV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletCreateAssetGetUserAssetV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateAssetGetUserAssetV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v3/asset/getUserAsset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	}
	if r.needBtcValuation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "needBtcValuation", r.needBtcValuation, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletCreateAssetTransferV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	amount *string
	asset *string
	timestamp *int64
	type_ *string
	fromSymbol *string
	recvWindow *int64
	toSymbol *string
}

func (r AssetAPIWalletCreateAssetTransferV1Request) Amount(amount string) AssetAPIWalletCreateAssetTransferV1Request {
	r.amount = &amount
	return r
}

func (r AssetAPIWalletCreateAssetTransferV1Request) Asset(asset string) AssetAPIWalletCreateAssetTransferV1Request {
	r.asset = &asset
	return r
}

func (r AssetAPIWalletCreateAssetTransferV1Request) Timestamp(timestamp int64) AssetAPIWalletCreateAssetTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletCreateAssetTransferV1Request) Type_(type_ string) AssetAPIWalletCreateAssetTransferV1Request {
	r.type_ = &type_
	return r
}

func (r AssetAPIWalletCreateAssetTransferV1Request) FromSymbol(fromSymbol string) AssetAPIWalletCreateAssetTransferV1Request {
	r.fromSymbol = &fromSymbol
	return r
}

func (r AssetAPIWalletCreateAssetTransferV1Request) RecvWindow(recvWindow int64) AssetAPIWalletCreateAssetTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletCreateAssetTransferV1Request) ToSymbol(toSymbol string) AssetAPIWalletCreateAssetTransferV1Request {
	r.toSymbol = &toSymbol
	return r
}

func (r AssetAPIWalletCreateAssetTransferV1Request) Execute() (*WalletCreateAssetTransferV1Resp, *http.Response, error) {
	return r.ApiService.WalletCreateAssetTransferV1Execute(r)
}

/*
WalletCreateAssetTransferV1 User Universal Transfer (USER_DATA)

user universal transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletCreateAssetTransferV1Request
*/
func (a *AssetAPIService) WalletCreateAssetTransferV1(ctx context.Context) AssetAPIWalletCreateAssetTransferV1Request {
	return AssetAPIWalletCreateAssetTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletCreateAssetTransferV1Resp
func (a *AssetAPIService) WalletCreateAssetTransferV1Execute(r AssetAPIWalletCreateAssetTransferV1Request) (*WalletCreateAssetTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletCreateAssetTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateAssetTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.fromSymbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromSymbol", r.fromSymbol, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.toSymbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toSymbol", r.toSymbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletCreateBnbBurnV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	interestBNBBurn *string
	recvWindow *int64
	spotBNBBurn *string
}

func (r AssetAPIWalletCreateBnbBurnV1Request) Timestamp(timestamp int64) AssetAPIWalletCreateBnbBurnV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletCreateBnbBurnV1Request) InterestBNBBurn(interestBNBBurn string) AssetAPIWalletCreateBnbBurnV1Request {
	r.interestBNBBurn = &interestBNBBurn
	return r
}

func (r AssetAPIWalletCreateBnbBurnV1Request) RecvWindow(recvWindow int64) AssetAPIWalletCreateBnbBurnV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletCreateBnbBurnV1Request) SpotBNBBurn(spotBNBBurn string) AssetAPIWalletCreateBnbBurnV1Request {
	r.spotBNBBurn = &spotBNBBurn
	return r
}

func (r AssetAPIWalletCreateBnbBurnV1Request) Execute() (*WalletCreateBnbBurnV1Resp, *http.Response, error) {
	return r.ApiService.WalletCreateBnbBurnV1Execute(r)
}

/*
WalletCreateBnbBurnV1 Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)

Toggle BNB Burn On Spot Trade And Margin Interest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletCreateBnbBurnV1Request
*/
func (a *AssetAPIService) WalletCreateBnbBurnV1(ctx context.Context) AssetAPIWalletCreateBnbBurnV1Request {
	return AssetAPIWalletCreateBnbBurnV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletCreateBnbBurnV1Resp
func (a *AssetAPIService) WalletCreateBnbBurnV1Execute(r AssetAPIWalletCreateBnbBurnV1Request) (*WalletCreateBnbBurnV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletCreateBnbBurnV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateBnbBurnV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bnbBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.interestBNBBurn != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "interestBNBBurn", r.interestBNBBurn, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.spotBNBBurn != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "spotBNBBurn", r.spotBNBBurn, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletGetAssetAssetDetailV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	recvWindow *int64
}

func (r AssetAPIWalletGetAssetAssetDetailV1Request) Timestamp(timestamp int64) AssetAPIWalletGetAssetAssetDetailV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletGetAssetAssetDetailV1Request) RecvWindow(recvWindow int64) AssetAPIWalletGetAssetAssetDetailV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletGetAssetAssetDetailV1Request) Execute() (*map[string]WalletGetAssetAssetDetailV1RespValue, *http.Response, error) {
	return r.ApiService.WalletGetAssetAssetDetailV1Execute(r)
}

/*
WalletGetAssetAssetDetailV1 Asset Detail (USER_DATA)

Fetch details of assets supported on Binance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletGetAssetAssetDetailV1Request
*/
func (a *AssetAPIService) WalletGetAssetAssetDetailV1(ctx context.Context) AssetAPIWalletGetAssetAssetDetailV1Request {
	return AssetAPIWalletGetAssetAssetDetailV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]WalletGetAssetAssetDetailV1RespValue
func (a *AssetAPIService) WalletGetAssetAssetDetailV1Execute(r AssetAPIWalletGetAssetAssetDetailV1Request) (*map[string]WalletGetAssetAssetDetailV1RespValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]WalletGetAssetAssetDetailV1RespValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetAssetDetailV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/assetDetail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletGetAssetAssetDividendV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	asset *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r AssetAPIWalletGetAssetAssetDividendV1Request) Timestamp(timestamp int64) AssetAPIWalletGetAssetAssetDividendV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletGetAssetAssetDividendV1Request) Asset(asset string) AssetAPIWalletGetAssetAssetDividendV1Request {
	r.asset = &asset
	return r
}

func (r AssetAPIWalletGetAssetAssetDividendV1Request) StartTime(startTime int64) AssetAPIWalletGetAssetAssetDividendV1Request {
	r.startTime = &startTime
	return r
}

func (r AssetAPIWalletGetAssetAssetDividendV1Request) EndTime(endTime int64) AssetAPIWalletGetAssetAssetDividendV1Request {
	r.endTime = &endTime
	return r
}

// Default 20, max 500
func (r AssetAPIWalletGetAssetAssetDividendV1Request) Limit(limit int32) AssetAPIWalletGetAssetAssetDividendV1Request {
	r.limit = &limit
	return r
}

func (r AssetAPIWalletGetAssetAssetDividendV1Request) RecvWindow(recvWindow int64) AssetAPIWalletGetAssetAssetDividendV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletGetAssetAssetDividendV1Request) Execute() (*WalletGetAssetAssetDividendV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetAssetAssetDividendV1Execute(r)
}

/*
WalletGetAssetAssetDividendV1 Asset Dividend Record (USER_DATA)

Query asset dividend record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletGetAssetAssetDividendV1Request
*/
func (a *AssetAPIService) WalletGetAssetAssetDividendV1(ctx context.Context) AssetAPIWalletGetAssetAssetDividendV1Request {
	return AssetAPIWalletGetAssetAssetDividendV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetAssetAssetDividendV1Resp
func (a *AssetAPIService) WalletGetAssetAssetDividendV1Execute(r AssetAPIWalletGetAssetAssetDividendV1Request) (*WalletGetAssetAssetDividendV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetAssetAssetDividendV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetAssetDividendV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/assetDividend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletGetAssetCustodyTransferHistoryV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	email *string
	startTime *int64
	endTime *int64
	timestamp *int64
	type_ *string
	asset *string
	current *int32
	size *int32
	recvWindow *int64
}

func (r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) Email(email string) AssetAPIWalletGetAssetCustodyTransferHistoryV1Request {
	r.email = &email
	return r
}

func (r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) StartTime(startTime int64) AssetAPIWalletGetAssetCustodyTransferHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) EndTime(endTime int64) AssetAPIWalletGetAssetCustodyTransferHistoryV1Request {
	r.endTime = &endTime
	return r
}

func (r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) Timestamp(timestamp int64) AssetAPIWalletGetAssetCustodyTransferHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// Delegate/Undelegate
func (r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) Type_(type_ string) AssetAPIWalletGetAssetCustodyTransferHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) Asset(asset string) AssetAPIWalletGetAssetCustodyTransferHistoryV1Request {
	r.asset = &asset
	return r
}

// default 1
func (r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) Current(current int32) AssetAPIWalletGetAssetCustodyTransferHistoryV1Request {
	r.current = &current
	return r
}

// default 10, max 100
func (r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) Size(size int32) AssetAPIWalletGetAssetCustodyTransferHistoryV1Request {
	r.size = &size
	return r
}

func (r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) RecvWindow(recvWindow int64) AssetAPIWalletGetAssetCustodyTransferHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) Execute() (*WalletGetAssetCustodyTransferHistoryV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetAssetCustodyTransferHistoryV1Execute(r)
}

/*
WalletGetAssetCustodyTransferHistoryV1 Query User Delegation History(For Master Account)(USER_DATA)

Query User Delegation History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletGetAssetCustodyTransferHistoryV1Request
*/
func (a *AssetAPIService) WalletGetAssetCustodyTransferHistoryV1(ctx context.Context) AssetAPIWalletGetAssetCustodyTransferHistoryV1Request {
	return AssetAPIWalletGetAssetCustodyTransferHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetAssetCustodyTransferHistoryV1Resp
func (a *AssetAPIService) WalletGetAssetCustodyTransferHistoryV1Execute(r AssetAPIWalletGetAssetCustodyTransferHistoryV1Request) (*WalletGetAssetCustodyTransferHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetAssetCustodyTransferHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetCustodyTransferHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/custody/transfer-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int32 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletGetAssetDribbletV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r AssetAPIWalletGetAssetDribbletV1Request) Timestamp(timestamp int64) AssetAPIWalletGetAssetDribbletV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletGetAssetDribbletV1Request) StartTime(startTime int64) AssetAPIWalletGetAssetDribbletV1Request {
	r.startTime = &startTime
	return r
}

func (r AssetAPIWalletGetAssetDribbletV1Request) EndTime(endTime int64) AssetAPIWalletGetAssetDribbletV1Request {
	r.endTime = &endTime
	return r
}

func (r AssetAPIWalletGetAssetDribbletV1Request) RecvWindow(recvWindow int64) AssetAPIWalletGetAssetDribbletV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletGetAssetDribbletV1Request) Execute() (*WalletGetAssetDribbletV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetAssetDribbletV1Execute(r)
}

/*
WalletGetAssetDribbletV1 DustLog(USER_DATA)

Dustlog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletGetAssetDribbletV1Request
*/
func (a *AssetAPIService) WalletGetAssetDribbletV1(ctx context.Context) AssetAPIWalletGetAssetDribbletV1Request {
	return AssetAPIWalletGetAssetDribbletV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetAssetDribbletV1Resp
func (a *AssetAPIService) WalletGetAssetDribbletV1Execute(r AssetAPIWalletGetAssetDribbletV1Request) (*WalletGetAssetDribbletV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetAssetDribbletV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetDribbletV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dribblet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	startTime *int64
	endTime *int64
	tranId *int64
	clientTranId *string
	asset *string
	current *int32
	size *int32
}

// inclusive, unit: ms
func (r AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) StartTime(startTime int64) AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.startTime = &startTime
	return r
}

// exclusive, unit: ms
func (r AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) EndTime(endTime int64) AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.endTime = &endTime
	return r
}

// The transaction id
func (r AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) TranId(tranId int64) AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.tranId = &tranId
	return r
}

// The unique flag
func (r AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) ClientTranId(clientTranId string) AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.clientTranId = &clientTranId
	return r
}

// If it is blank, we will query all assets
func (r AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Asset(asset string) AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.asset = &asset
	return r
}

// current page, default 1, the min value is 1
func (r AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Current(current int32) AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.current = &current
	return r
}

// page size, default 10, the max value is 100
func (r AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Size(size int32) AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.size = &size
	return r
}

func (r AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Execute() (*WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Execute(r)
}

/*
WalletGetAssetLedgerTransferCloudMiningQueryByPageV1 Get Cloud-Mining payment and refund history (USER_DATA)

The query of Cloud-Mining payment and refund history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request
*/
func (a *AssetAPIService) WalletGetAssetLedgerTransferCloudMiningQueryByPageV1(ctx context.Context) AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	return AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Resp
func (a *AssetAPIService) WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Execute(r AssetAPIWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) (*WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetLedgerTransferCloudMiningQueryByPageV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}

	if r.tranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tranId", r.tranId, "form", "")
	}
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientTranId", r.clientTranId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientTranId = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int32 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletGetAssetTradeFeeV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r AssetAPIWalletGetAssetTradeFeeV1Request) Timestamp(timestamp int64) AssetAPIWalletGetAssetTradeFeeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletGetAssetTradeFeeV1Request) Symbol(symbol string) AssetAPIWalletGetAssetTradeFeeV1Request {
	r.symbol = &symbol
	return r
}

func (r AssetAPIWalletGetAssetTradeFeeV1Request) RecvWindow(recvWindow int64) AssetAPIWalletGetAssetTradeFeeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletGetAssetTradeFeeV1Request) Execute() ([]WalletGetAssetTradeFeeV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetAssetTradeFeeV1Execute(r)
}

/*
WalletGetAssetTradeFeeV1 Trade Fee (USER_DATA)

Fetch trade fee

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletGetAssetTradeFeeV1Request
*/
func (a *AssetAPIService) WalletGetAssetTradeFeeV1(ctx context.Context) AssetAPIWalletGetAssetTradeFeeV1Request {
	return AssetAPIWalletGetAssetTradeFeeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetAssetTradeFeeV1RespItem
func (a *AssetAPIService) WalletGetAssetTradeFeeV1Execute(r AssetAPIWalletGetAssetTradeFeeV1Request) ([]WalletGetAssetTradeFeeV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetAssetTradeFeeV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetTradeFeeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/tradeFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletGetAssetTransferV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	type_ *string
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	fromSymbol *string
	toSymbol *string
	recvWindow *int64
}

func (r AssetAPIWalletGetAssetTransferV1Request) Type_(type_ string) AssetAPIWalletGetAssetTransferV1Request {
	r.type_ = &type_
	return r
}

func (r AssetAPIWalletGetAssetTransferV1Request) Timestamp(timestamp int64) AssetAPIWalletGetAssetTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletGetAssetTransferV1Request) StartTime(startTime int64) AssetAPIWalletGetAssetTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r AssetAPIWalletGetAssetTransferV1Request) EndTime(endTime int64) AssetAPIWalletGetAssetTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default 1
func (r AssetAPIWalletGetAssetTransferV1Request) Current(current int32) AssetAPIWalletGetAssetTransferV1Request {
	r.current = &current
	return r
}

// Default 10, Max 100
func (r AssetAPIWalletGetAssetTransferV1Request) Size(size int32) AssetAPIWalletGetAssetTransferV1Request {
	r.size = &size
	return r
}

func (r AssetAPIWalletGetAssetTransferV1Request) FromSymbol(fromSymbol string) AssetAPIWalletGetAssetTransferV1Request {
	r.fromSymbol = &fromSymbol
	return r
}

func (r AssetAPIWalletGetAssetTransferV1Request) ToSymbol(toSymbol string) AssetAPIWalletGetAssetTransferV1Request {
	r.toSymbol = &toSymbol
	return r
}

func (r AssetAPIWalletGetAssetTransferV1Request) RecvWindow(recvWindow int64) AssetAPIWalletGetAssetTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletGetAssetTransferV1Request) Execute() (*WalletGetAssetTransferV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetAssetTransferV1Execute(r)
}

/*
WalletGetAssetTransferV1 Query User Universal Transfer History(USER_DATA)

Query User Universal Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletGetAssetTransferV1Request
*/
func (a *AssetAPIService) WalletGetAssetTransferV1(ctx context.Context) AssetAPIWalletGetAssetTransferV1Request {
	return AssetAPIWalletGetAssetTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetAssetTransferV1Resp
func (a *AssetAPIService) WalletGetAssetTransferV1Execute(r AssetAPIWalletGetAssetTransferV1Request) (*WalletGetAssetTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetAssetTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int32 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.fromSymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromSymbol", r.fromSymbol, "form", "")
	} else {
		var defaultValue string = ""
		r.fromSymbol = &defaultValue
	}
	if r.toSymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toSymbol", r.toSymbol, "form", "")
	} else {
		var defaultValue string = ""
		r.toSymbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletGetAssetWalletBalanceV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	quoteAsset *string
	recvWindow *int64
}

func (r AssetAPIWalletGetAssetWalletBalanceV1Request) Timestamp(timestamp int64) AssetAPIWalletGetAssetWalletBalanceV1Request {
	r.timestamp = &timestamp
	return r
}

// &#x60;USDT&#x60;, &#x60;ETH&#x60;, &#x60;USDC&#x60;, &#x60;BNB&#x60;, etc. default &#x60;BTC&#x60;
func (r AssetAPIWalletGetAssetWalletBalanceV1Request) QuoteAsset(quoteAsset string) AssetAPIWalletGetAssetWalletBalanceV1Request {
	r.quoteAsset = &quoteAsset
	return r
}

func (r AssetAPIWalletGetAssetWalletBalanceV1Request) RecvWindow(recvWindow int64) AssetAPIWalletGetAssetWalletBalanceV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletGetAssetWalletBalanceV1Request) Execute() ([]WalletGetAssetWalletBalanceV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetAssetWalletBalanceV1Execute(r)
}

/*
WalletGetAssetWalletBalanceV1 Query User Wallet Balance (USER_DATA)

Query User Wallet Balance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletGetAssetWalletBalanceV1Request
*/
func (a *AssetAPIService) WalletGetAssetWalletBalanceV1(ctx context.Context) AssetAPIWalletGetAssetWalletBalanceV1Request {
	return AssetAPIWalletGetAssetWalletBalanceV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetAssetWalletBalanceV1RespItem
func (a *AssetAPIService) WalletGetAssetWalletBalanceV1Execute(r AssetAPIWalletGetAssetWalletBalanceV1Request) ([]WalletGetAssetWalletBalanceV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetAssetWalletBalanceV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetWalletBalanceV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/wallet/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.quoteAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quoteAsset", r.quoteAsset, "form", "")
	} else {
		var defaultValue string = ""
		r.quoteAsset = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletGetSpotDelistScheduleV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	recvWindow *int64
}

func (r AssetAPIWalletGetSpotDelistScheduleV1Request) Timestamp(timestamp int64) AssetAPIWalletGetSpotDelistScheduleV1Request {
	r.timestamp = &timestamp
	return r
}

func (r AssetAPIWalletGetSpotDelistScheduleV1Request) RecvWindow(recvWindow int64) AssetAPIWalletGetSpotDelistScheduleV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r AssetAPIWalletGetSpotDelistScheduleV1Request) Execute() ([]WalletGetSpotDelistScheduleV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetSpotDelistScheduleV1Execute(r)
}

/*
WalletGetSpotDelistScheduleV1 Get Spot Delist Schedule (MARKET_DATA)

Get symbols delist schedule for spot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletGetSpotDelistScheduleV1Request
*/
func (a *AssetAPIService) WalletGetSpotDelistScheduleV1(ctx context.Context) AssetAPIWalletGetSpotDelistScheduleV1Request {
	return AssetAPIWalletGetSpotDelistScheduleV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetSpotDelistScheduleV1RespItem
func (a *AssetAPIService) WalletGetSpotDelistScheduleV1Execute(r AssetAPIWalletGetSpotDelistScheduleV1Request) ([]WalletGetSpotDelistScheduleV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetSpotDelistScheduleV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetSpotDelistScheduleV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/spot/delist-schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AssetAPIWalletGetSpotOpenSymbolListV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
}

func (r AssetAPIWalletGetSpotOpenSymbolListV1Request) Execute() ([]WalletGetSpotOpenSymbolListV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetSpotOpenSymbolListV1Execute(r)
}

/*
WalletGetSpotOpenSymbolListV1 Get Open Symbol List (MARKET_DATA)

Get the list of symbols that are scheduled to be opened for trading in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AssetAPIWalletGetSpotOpenSymbolListV1Request
*/
func (a *AssetAPIService) WalletGetSpotOpenSymbolListV1(ctx context.Context) AssetAPIWalletGetSpotOpenSymbolListV1Request {
	return AssetAPIWalletGetSpotOpenSymbolListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetSpotOpenSymbolListV1RespItem
func (a *AssetAPIService) WalletGetSpotOpenSymbolListV1Execute(r AssetAPIWalletGetSpotOpenSymbolListV1Request) ([]WalletGetSpotOpenSymbolListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetSpotOpenSymbolListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetSpotOpenSymbolListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/spot/open-symbol-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

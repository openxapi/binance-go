/*
Binance Wallet API

OpenAPI specification for Binance exchange - Wallet API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package wallet

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AssetAPIService AssetAPI service
type AssetAPIService service

type ApiWalletCreateAssetDustBtcV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	accountType *string
	recvWindow *int64
}

func (r ApiWalletCreateAssetDustBtcV1Request) Timestamp(timestamp int64) ApiWalletCreateAssetDustBtcV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletCreateAssetDustBtcV1Request) AccountType(accountType string) ApiWalletCreateAssetDustBtcV1Request {
	r.accountType = &accountType
	return r
}

func (r ApiWalletCreateAssetDustBtcV1Request) RecvWindow(recvWindow int64) ApiWalletCreateAssetDustBtcV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletCreateAssetDustBtcV1Request) Execute() (*WalletCreateAssetDustBtcV1Resp, *http.Response, error) {
	return r.ApiService.WalletCreateAssetDustBtcV1Execute(r)
}

/*
WalletCreateAssetDustBtcV1 Get Assets That Can Be Converted Into BNB (USER_DATA)

Get Assets That Can Be Converted Into BNB

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletCreateAssetDustBtcV1Request
*/
func (a *AssetAPIService) WalletCreateAssetDustBtcV1(ctx context.Context) ApiWalletCreateAssetDustBtcV1Request {
	return ApiWalletCreateAssetDustBtcV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletCreateAssetDustBtcV1Resp
func (a *AssetAPIService) WalletCreateAssetDustBtcV1Execute(r ApiWalletCreateAssetDustBtcV1Request) (*WalletCreateAssetDustBtcV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletCreateAssetDustBtcV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateAssetDustBtcV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dust-btc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "accountType", r.accountType, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletCreateAssetDustV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	asset *[]string
	timestamp *int64
	accountType *string
	recvWindow *int64
}

func (r ApiWalletCreateAssetDustV1Request) Asset(asset []string) ApiWalletCreateAssetDustV1Request {
	r.asset = &asset
	return r
}

func (r ApiWalletCreateAssetDustV1Request) Timestamp(timestamp int64) ApiWalletCreateAssetDustV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletCreateAssetDustV1Request) AccountType(accountType string) ApiWalletCreateAssetDustV1Request {
	r.accountType = &accountType
	return r
}

func (r ApiWalletCreateAssetDustV1Request) RecvWindow(recvWindow int64) ApiWalletCreateAssetDustV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletCreateAssetDustV1Request) Execute() (*WalletCreateAssetDustV1Resp, *http.Response, error) {
	return r.ApiService.WalletCreateAssetDustV1Execute(r)
}

/*
WalletCreateAssetDustV1 Dust Transfer (USER_DATA)

Convert dust assets to BNB.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletCreateAssetDustV1Request
*/
func (a *AssetAPIService) WalletCreateAssetDustV1(ctx context.Context) ApiWalletCreateAssetDustV1Request {
	return ApiWalletCreateAssetDustV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletCreateAssetDustV1Resp
func (a *AssetAPIService) WalletCreateAssetDustV1Execute(r ApiWalletCreateAssetDustV1Request) (*WalletCreateAssetDustV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletCreateAssetDustV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateAssetDustV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dust"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "accountType", r.accountType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "csv")
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletCreateAssetGetFundingAssetV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	asset *string
	needBtcValuation *string
	recvWindow *int64
}

func (r ApiWalletCreateAssetGetFundingAssetV1Request) Timestamp(timestamp int64) ApiWalletCreateAssetGetFundingAssetV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletCreateAssetGetFundingAssetV1Request) Asset(asset string) ApiWalletCreateAssetGetFundingAssetV1Request {
	r.asset = &asset
	return r
}

func (r ApiWalletCreateAssetGetFundingAssetV1Request) NeedBtcValuation(needBtcValuation string) ApiWalletCreateAssetGetFundingAssetV1Request {
	r.needBtcValuation = &needBtcValuation
	return r
}

func (r ApiWalletCreateAssetGetFundingAssetV1Request) RecvWindow(recvWindow int64) ApiWalletCreateAssetGetFundingAssetV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletCreateAssetGetFundingAssetV1Request) Execute() ([]WalletCreateAssetGetFundingAssetV1RespItem, *http.Response, error) {
	return r.ApiService.WalletCreateAssetGetFundingAssetV1Execute(r)
}

/*
WalletCreateAssetGetFundingAssetV1 Funding Wallet (USER_DATA)

Query Funding Wallet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletCreateAssetGetFundingAssetV1Request
*/
func (a *AssetAPIService) WalletCreateAssetGetFundingAssetV1(ctx context.Context) ApiWalletCreateAssetGetFundingAssetV1Request {
	return ApiWalletCreateAssetGetFundingAssetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletCreateAssetGetFundingAssetV1RespItem
func (a *AssetAPIService) WalletCreateAssetGetFundingAssetV1Execute(r ApiWalletCreateAssetGetFundingAssetV1Request) ([]WalletCreateAssetGetFundingAssetV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletCreateAssetGetFundingAssetV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateAssetGetFundingAssetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/get-funding-asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	}
	if r.needBtcValuation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "needBtcValuation", r.needBtcValuation, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletCreateAssetGetUserAssetV3Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	asset *string
	needBtcValuation *bool
	recvWindow *int64
}

func (r ApiWalletCreateAssetGetUserAssetV3Request) Timestamp(timestamp int64) ApiWalletCreateAssetGetUserAssetV3Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletCreateAssetGetUserAssetV3Request) Asset(asset string) ApiWalletCreateAssetGetUserAssetV3Request {
	r.asset = &asset
	return r
}

func (r ApiWalletCreateAssetGetUserAssetV3Request) NeedBtcValuation(needBtcValuation bool) ApiWalletCreateAssetGetUserAssetV3Request {
	r.needBtcValuation = &needBtcValuation
	return r
}

func (r ApiWalletCreateAssetGetUserAssetV3Request) RecvWindow(recvWindow int64) ApiWalletCreateAssetGetUserAssetV3Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletCreateAssetGetUserAssetV3Request) Execute() ([]WalletCreateAssetGetUserAssetV3RespItem, *http.Response, error) {
	return r.ApiService.WalletCreateAssetGetUserAssetV3Execute(r)
}

/*
WalletCreateAssetGetUserAssetV3 User Asset (USER_DATA)

Get user assets, just for positive data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletCreateAssetGetUserAssetV3Request
*/
func (a *AssetAPIService) WalletCreateAssetGetUserAssetV3(ctx context.Context) ApiWalletCreateAssetGetUserAssetV3Request {
	return ApiWalletCreateAssetGetUserAssetV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletCreateAssetGetUserAssetV3RespItem
func (a *AssetAPIService) WalletCreateAssetGetUserAssetV3Execute(r ApiWalletCreateAssetGetUserAssetV3Request) ([]WalletCreateAssetGetUserAssetV3RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletCreateAssetGetUserAssetV3RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateAssetGetUserAssetV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v3/asset/getUserAsset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	}
	if r.needBtcValuation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "needBtcValuation", r.needBtcValuation, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletCreateAssetTransferV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	amount *string
	asset *string
	timestamp *int64
	type_ *string
	fromSymbol *string
	recvWindow *int64
	toSymbol *string
}

func (r ApiWalletCreateAssetTransferV1Request) Amount(amount string) ApiWalletCreateAssetTransferV1Request {
	r.amount = &amount
	return r
}

func (r ApiWalletCreateAssetTransferV1Request) Asset(asset string) ApiWalletCreateAssetTransferV1Request {
	r.asset = &asset
	return r
}

func (r ApiWalletCreateAssetTransferV1Request) Timestamp(timestamp int64) ApiWalletCreateAssetTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletCreateAssetTransferV1Request) Type_(type_ string) ApiWalletCreateAssetTransferV1Request {
	r.type_ = &type_
	return r
}

func (r ApiWalletCreateAssetTransferV1Request) FromSymbol(fromSymbol string) ApiWalletCreateAssetTransferV1Request {
	r.fromSymbol = &fromSymbol
	return r
}

func (r ApiWalletCreateAssetTransferV1Request) RecvWindow(recvWindow int64) ApiWalletCreateAssetTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletCreateAssetTransferV1Request) ToSymbol(toSymbol string) ApiWalletCreateAssetTransferV1Request {
	r.toSymbol = &toSymbol
	return r
}

func (r ApiWalletCreateAssetTransferV1Request) Execute() (*WalletCreateAssetTransferV1Resp, *http.Response, error) {
	return r.ApiService.WalletCreateAssetTransferV1Execute(r)
}

/*
WalletCreateAssetTransferV1 User Universal Transfer (USER_DATA)

user universal transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletCreateAssetTransferV1Request
*/
func (a *AssetAPIService) WalletCreateAssetTransferV1(ctx context.Context) ApiWalletCreateAssetTransferV1Request {
	return ApiWalletCreateAssetTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletCreateAssetTransferV1Resp
func (a *AssetAPIService) WalletCreateAssetTransferV1Execute(r ApiWalletCreateAssetTransferV1Request) (*WalletCreateAssetTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletCreateAssetTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateAssetTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "asset", r.asset, "", "")
	if r.fromSymbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "fromSymbol", r.fromSymbol, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.toSymbol != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "toSymbol", r.toSymbol, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletCreateBnbBurnV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	interestBNBBurn *string
	recvWindow *int64
	spotBNBBurn *string
}

func (r ApiWalletCreateBnbBurnV1Request) Timestamp(timestamp int64) ApiWalletCreateBnbBurnV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletCreateBnbBurnV1Request) InterestBNBBurn(interestBNBBurn string) ApiWalletCreateBnbBurnV1Request {
	r.interestBNBBurn = &interestBNBBurn
	return r
}

func (r ApiWalletCreateBnbBurnV1Request) RecvWindow(recvWindow int64) ApiWalletCreateBnbBurnV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletCreateBnbBurnV1Request) SpotBNBBurn(spotBNBBurn string) ApiWalletCreateBnbBurnV1Request {
	r.spotBNBBurn = &spotBNBBurn
	return r
}

func (r ApiWalletCreateBnbBurnV1Request) Execute() (*WalletCreateBnbBurnV1Resp, *http.Response, error) {
	return r.ApiService.WalletCreateBnbBurnV1Execute(r)
}

/*
WalletCreateBnbBurnV1 Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)

Toggle BNB Burn On Spot Trade And Margin Interest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletCreateBnbBurnV1Request
*/
func (a *AssetAPIService) WalletCreateBnbBurnV1(ctx context.Context) ApiWalletCreateBnbBurnV1Request {
	return ApiWalletCreateBnbBurnV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletCreateBnbBurnV1Resp
func (a *AssetAPIService) WalletCreateBnbBurnV1Execute(r ApiWalletCreateBnbBurnV1Request) (*WalletCreateBnbBurnV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletCreateBnbBurnV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletCreateBnbBurnV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bnbBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.interestBNBBurn != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "interestBNBBurn", r.interestBNBBurn, "", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "recvWindow", r.recvWindow, "", "")
	}
	if r.spotBNBBurn != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "spotBNBBurn", r.spotBNBBurn, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "timestamp", r.timestamp, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletGetAssetAssetDetailV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiWalletGetAssetAssetDetailV1Request) Timestamp(timestamp int64) ApiWalletGetAssetAssetDetailV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletGetAssetAssetDetailV1Request) RecvWindow(recvWindow int64) ApiWalletGetAssetAssetDetailV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletGetAssetAssetDetailV1Request) Execute() (*map[string]WalletGetAssetAssetDetailV1RespValue, *http.Response, error) {
	return r.ApiService.WalletGetAssetAssetDetailV1Execute(r)
}

/*
WalletGetAssetAssetDetailV1 Asset Detail (USER_DATA)

Fetch details of assets supported on Binance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletGetAssetAssetDetailV1Request
*/
func (a *AssetAPIService) WalletGetAssetAssetDetailV1(ctx context.Context) ApiWalletGetAssetAssetDetailV1Request {
	return ApiWalletGetAssetAssetDetailV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]WalletGetAssetAssetDetailV1RespValue
func (a *AssetAPIService) WalletGetAssetAssetDetailV1Execute(r ApiWalletGetAssetAssetDetailV1Request) (*map[string]WalletGetAssetAssetDetailV1RespValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]WalletGetAssetAssetDetailV1RespValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetAssetDetailV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/assetDetail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletGetAssetAssetDividendV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	asset *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiWalletGetAssetAssetDividendV1Request) Timestamp(timestamp int64) ApiWalletGetAssetAssetDividendV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletGetAssetAssetDividendV1Request) Asset(asset string) ApiWalletGetAssetAssetDividendV1Request {
	r.asset = &asset
	return r
}

func (r ApiWalletGetAssetAssetDividendV1Request) StartTime(startTime int64) ApiWalletGetAssetAssetDividendV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiWalletGetAssetAssetDividendV1Request) EndTime(endTime int64) ApiWalletGetAssetAssetDividendV1Request {
	r.endTime = &endTime
	return r
}

// Default 20, max 500
func (r ApiWalletGetAssetAssetDividendV1Request) Limit(limit int32) ApiWalletGetAssetAssetDividendV1Request {
	r.limit = &limit
	return r
}

func (r ApiWalletGetAssetAssetDividendV1Request) RecvWindow(recvWindow int64) ApiWalletGetAssetAssetDividendV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletGetAssetAssetDividendV1Request) Execute() (*WalletGetAssetAssetDividendV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetAssetAssetDividendV1Execute(r)
}

/*
WalletGetAssetAssetDividendV1 Asset Dividend Record (USER_DATA)

Query asset dividend record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletGetAssetAssetDividendV1Request
*/
func (a *AssetAPIService) WalletGetAssetAssetDividendV1(ctx context.Context) ApiWalletGetAssetAssetDividendV1Request {
	return ApiWalletGetAssetAssetDividendV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetAssetAssetDividendV1Resp
func (a *AssetAPIService) WalletGetAssetAssetDividendV1Execute(r ApiWalletGetAssetAssetDividendV1Request) (*WalletGetAssetAssetDividendV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetAssetAssetDividendV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetAssetDividendV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/assetDividend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletGetAssetCustodyTransferHistoryV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	email *string
	startTime *int64
	endTime *int64
	timestamp *int64
	type_ *string
	asset *string
	current *int32
	size *int32
	recvWindow *int64
}

func (r ApiWalletGetAssetCustodyTransferHistoryV1Request) Email(email string) ApiWalletGetAssetCustodyTransferHistoryV1Request {
	r.email = &email
	return r
}

func (r ApiWalletGetAssetCustodyTransferHistoryV1Request) StartTime(startTime int64) ApiWalletGetAssetCustodyTransferHistoryV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiWalletGetAssetCustodyTransferHistoryV1Request) EndTime(endTime int64) ApiWalletGetAssetCustodyTransferHistoryV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiWalletGetAssetCustodyTransferHistoryV1Request) Timestamp(timestamp int64) ApiWalletGetAssetCustodyTransferHistoryV1Request {
	r.timestamp = &timestamp
	return r
}

// Delegate/Undelegate
func (r ApiWalletGetAssetCustodyTransferHistoryV1Request) Type_(type_ string) ApiWalletGetAssetCustodyTransferHistoryV1Request {
	r.type_ = &type_
	return r
}

func (r ApiWalletGetAssetCustodyTransferHistoryV1Request) Asset(asset string) ApiWalletGetAssetCustodyTransferHistoryV1Request {
	r.asset = &asset
	return r
}

// default 1
func (r ApiWalletGetAssetCustodyTransferHistoryV1Request) Current(current int32) ApiWalletGetAssetCustodyTransferHistoryV1Request {
	r.current = &current
	return r
}

// default 10, max 100
func (r ApiWalletGetAssetCustodyTransferHistoryV1Request) Size(size int32) ApiWalletGetAssetCustodyTransferHistoryV1Request {
	r.size = &size
	return r
}

func (r ApiWalletGetAssetCustodyTransferHistoryV1Request) RecvWindow(recvWindow int64) ApiWalletGetAssetCustodyTransferHistoryV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletGetAssetCustodyTransferHistoryV1Request) Execute() (*WalletGetAssetCustodyTransferHistoryV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetAssetCustodyTransferHistoryV1Execute(r)
}

/*
WalletGetAssetCustodyTransferHistoryV1 Query User Delegation History(For Master Account)(USER_DATA)

Query User Delegation History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletGetAssetCustodyTransferHistoryV1Request
*/
func (a *AssetAPIService) WalletGetAssetCustodyTransferHistoryV1(ctx context.Context) ApiWalletGetAssetCustodyTransferHistoryV1Request {
	return ApiWalletGetAssetCustodyTransferHistoryV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetAssetCustodyTransferHistoryV1Resp
func (a *AssetAPIService) WalletGetAssetCustodyTransferHistoryV1Execute(r ApiWalletGetAssetCustodyTransferHistoryV1Request) (*WalletGetAssetCustodyTransferHistoryV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetAssetCustodyTransferHistoryV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetCustodyTransferHistoryV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/custody/transfer-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = ""
		r.type_ = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int32 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletGetAssetDribbletV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r ApiWalletGetAssetDribbletV1Request) Timestamp(timestamp int64) ApiWalletGetAssetDribbletV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletGetAssetDribbletV1Request) StartTime(startTime int64) ApiWalletGetAssetDribbletV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiWalletGetAssetDribbletV1Request) EndTime(endTime int64) ApiWalletGetAssetDribbletV1Request {
	r.endTime = &endTime
	return r
}

func (r ApiWalletGetAssetDribbletV1Request) RecvWindow(recvWindow int64) ApiWalletGetAssetDribbletV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletGetAssetDribbletV1Request) Execute() (*WalletGetAssetDribbletV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetAssetDribbletV1Execute(r)
}

/*
WalletGetAssetDribbletV1 DustLog(USER_DATA)

Dustlog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletGetAssetDribbletV1Request
*/
func (a *AssetAPIService) WalletGetAssetDribbletV1(ctx context.Context) ApiWalletGetAssetDribbletV1Request {
	return ApiWalletGetAssetDribbletV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetAssetDribbletV1Resp
func (a *AssetAPIService) WalletGetAssetDribbletV1Execute(r ApiWalletGetAssetDribbletV1Request) (*WalletGetAssetDribbletV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetAssetDribbletV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetDribbletV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dribblet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	startTime *int64
	endTime *int64
	tranId *int64
	clientTranId *string
	asset *string
	current *int32
	size *int32
}

// inclusive, unit: ms
func (r ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) StartTime(startTime int64) ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.startTime = &startTime
	return r
}

// exclusive, unit: ms
func (r ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) EndTime(endTime int64) ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.endTime = &endTime
	return r
}

// The transaction id
func (r ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) TranId(tranId int64) ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.tranId = &tranId
	return r
}

// The unique flag
func (r ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) ClientTranId(clientTranId string) ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.clientTranId = &clientTranId
	return r
}

// If it is blank, we will query all assets
func (r ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Asset(asset string) ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.asset = &asset
	return r
}

// current page, default 1, the min value is 1
func (r ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Current(current int32) ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.current = &current
	return r
}

// page size, default 10, the max value is 100
func (r ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Size(size int32) ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	r.size = &size
	return r
}

func (r ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) Execute() (*WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Execute(r)
}

/*
WalletGetAssetLedgerTransferCloudMiningQueryByPageV1 Get Cloud-Mining payment and refund history (USER_DATA)

The query of Cloud-Mining payment and refund history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request
*/
func (a *AssetAPIService) WalletGetAssetLedgerTransferCloudMiningQueryByPageV1(ctx context.Context) ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request {
	return ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Resp
func (a *AssetAPIService) WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Execute(r ApiWalletGetAssetLedgerTransferCloudMiningQueryByPageV1Request) (*WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetAssetLedgerTransferCloudMiningQueryByPageV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetLedgerTransferCloudMiningQueryByPageV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.endTime == nil {
		return localVarReturnValue, nil, reportError("endTime is required and must be specified")
	}

	if r.tranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tranId", r.tranId, "form", "")
	}
	if r.clientTranId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientTranId", r.clientTranId, "form", "")
	} else {
		var defaultValue string = ""
		r.clientTranId = &defaultValue
	}
	if r.asset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset", r.asset, "form", "")
	} else {
		var defaultValue string = ""
		r.asset = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int32 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletGetAssetTradeFeeV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	symbol *string
	recvWindow *int64
}

func (r ApiWalletGetAssetTradeFeeV1Request) Timestamp(timestamp int64) ApiWalletGetAssetTradeFeeV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletGetAssetTradeFeeV1Request) Symbol(symbol string) ApiWalletGetAssetTradeFeeV1Request {
	r.symbol = &symbol
	return r
}

func (r ApiWalletGetAssetTradeFeeV1Request) RecvWindow(recvWindow int64) ApiWalletGetAssetTradeFeeV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletGetAssetTradeFeeV1Request) Execute() ([]WalletGetAssetTradeFeeV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetAssetTradeFeeV1Execute(r)
}

/*
WalletGetAssetTradeFeeV1 Trade Fee (USER_DATA)

Fetch trade fee

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletGetAssetTradeFeeV1Request
*/
func (a *AssetAPIService) WalletGetAssetTradeFeeV1(ctx context.Context) ApiWalletGetAssetTradeFeeV1Request {
	return ApiWalletGetAssetTradeFeeV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetAssetTradeFeeV1RespItem
func (a *AssetAPIService) WalletGetAssetTradeFeeV1Execute(r ApiWalletGetAssetTradeFeeV1Request) ([]WalletGetAssetTradeFeeV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetAssetTradeFeeV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetTradeFeeV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/tradeFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "form", "")
	} else {
		var defaultValue string = ""
		r.symbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletGetAssetTransferV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	type_ *string
	timestamp *int64
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	fromSymbol *string
	toSymbol *string
	recvWindow *int64
}

func (r ApiWalletGetAssetTransferV1Request) Type_(type_ string) ApiWalletGetAssetTransferV1Request {
	r.type_ = &type_
	return r
}

func (r ApiWalletGetAssetTransferV1Request) Timestamp(timestamp int64) ApiWalletGetAssetTransferV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletGetAssetTransferV1Request) StartTime(startTime int64) ApiWalletGetAssetTransferV1Request {
	r.startTime = &startTime
	return r
}

func (r ApiWalletGetAssetTransferV1Request) EndTime(endTime int64) ApiWalletGetAssetTransferV1Request {
	r.endTime = &endTime
	return r
}

// Default 1
func (r ApiWalletGetAssetTransferV1Request) Current(current int32) ApiWalletGetAssetTransferV1Request {
	r.current = &current
	return r
}

// Default 10, Max 100
func (r ApiWalletGetAssetTransferV1Request) Size(size int32) ApiWalletGetAssetTransferV1Request {
	r.size = &size
	return r
}

func (r ApiWalletGetAssetTransferV1Request) FromSymbol(fromSymbol string) ApiWalletGetAssetTransferV1Request {
	r.fromSymbol = &fromSymbol
	return r
}

func (r ApiWalletGetAssetTransferV1Request) ToSymbol(toSymbol string) ApiWalletGetAssetTransferV1Request {
	r.toSymbol = &toSymbol
	return r
}

func (r ApiWalletGetAssetTransferV1Request) RecvWindow(recvWindow int64) ApiWalletGetAssetTransferV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletGetAssetTransferV1Request) Execute() (*WalletGetAssetTransferV1Resp, *http.Response, error) {
	return r.ApiService.WalletGetAssetTransferV1Execute(r)
}

/*
WalletGetAssetTransferV1 Query User Universal Transfer History(USER_DATA)

Query User Universal Transfer History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletGetAssetTransferV1Request
*/
func (a *AssetAPIService) WalletGetAssetTransferV1(ctx context.Context) ApiWalletGetAssetTransferV1Request {
	return ApiWalletGetAssetTransferV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WalletGetAssetTransferV1Resp
func (a *AssetAPIService) WalletGetAssetTransferV1Execute(r ApiWalletGetAssetTransferV1Request) (*WalletGetAssetTransferV1Resp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WalletGetAssetTransferV1Resp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetTransferV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "form", "")
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	} else {
		var defaultValue int32 = 1
		r.current = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		r.size = &defaultValue
	}
	if r.fromSymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromSymbol", r.fromSymbol, "form", "")
	} else {
		var defaultValue string = ""
		r.fromSymbol = &defaultValue
	}
	if r.toSymbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toSymbol", r.toSymbol, "form", "")
	} else {
		var defaultValue string = ""
		r.toSymbol = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletGetAssetWalletBalanceV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	quoteAsset *string
	recvWindow *int64
}

func (r ApiWalletGetAssetWalletBalanceV1Request) Timestamp(timestamp int64) ApiWalletGetAssetWalletBalanceV1Request {
	r.timestamp = &timestamp
	return r
}

// &#x60;USDT&#x60;, &#x60;ETH&#x60;, &#x60;USDC&#x60;, &#x60;BNB&#x60;, etc. default &#x60;BTC&#x60;
func (r ApiWalletGetAssetWalletBalanceV1Request) QuoteAsset(quoteAsset string) ApiWalletGetAssetWalletBalanceV1Request {
	r.quoteAsset = &quoteAsset
	return r
}

func (r ApiWalletGetAssetWalletBalanceV1Request) RecvWindow(recvWindow int64) ApiWalletGetAssetWalletBalanceV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletGetAssetWalletBalanceV1Request) Execute() ([]WalletGetAssetWalletBalanceV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetAssetWalletBalanceV1Execute(r)
}

/*
WalletGetAssetWalletBalanceV1 Query User Wallet Balance (USER_DATA)

Query User Wallet Balance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletGetAssetWalletBalanceV1Request
*/
func (a *AssetAPIService) WalletGetAssetWalletBalanceV1(ctx context.Context) ApiWalletGetAssetWalletBalanceV1Request {
	return ApiWalletGetAssetWalletBalanceV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetAssetWalletBalanceV1RespItem
func (a *AssetAPIService) WalletGetAssetWalletBalanceV1Execute(r ApiWalletGetAssetWalletBalanceV1Request) ([]WalletGetAssetWalletBalanceV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetAssetWalletBalanceV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetAssetWalletBalanceV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/wallet/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.quoteAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quoteAsset", r.quoteAsset, "form", "")
	} else {
		var defaultValue string = ""
		r.quoteAsset = &defaultValue
	}
	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextBinanceAuth).(Auth); ok {
			localVarHeaderParams["X-MBX-APIKEY"] = auth.APIKey
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletGetSpotDelistScheduleV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
	timestamp *int64
	recvWindow *int64
}

func (r ApiWalletGetSpotDelistScheduleV1Request) Timestamp(timestamp int64) ApiWalletGetSpotDelistScheduleV1Request {
	r.timestamp = &timestamp
	return r
}

func (r ApiWalletGetSpotDelistScheduleV1Request) RecvWindow(recvWindow int64) ApiWalletGetSpotDelistScheduleV1Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiWalletGetSpotDelistScheduleV1Request) Execute() ([]WalletGetSpotDelistScheduleV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetSpotDelistScheduleV1Execute(r)
}

/*
WalletGetSpotDelistScheduleV1 Get Spot Delist Schedule (MARKET_DATA)

Get symbols delist schedule for spot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletGetSpotDelistScheduleV1Request
*/
func (a *AssetAPIService) WalletGetSpotDelistScheduleV1(ctx context.Context) ApiWalletGetSpotDelistScheduleV1Request {
	return ApiWalletGetSpotDelistScheduleV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetSpotDelistScheduleV1RespItem
func (a *AssetAPIService) WalletGetSpotDelistScheduleV1Execute(r ApiWalletGetSpotDelistScheduleV1Request) ([]WalletGetSpotDelistScheduleV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetSpotDelistScheduleV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetSpotDelistScheduleV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/spot/delist-schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	if r.recvWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recvWindow", r.recvWindow, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletGetSpotOpenSymbolListV1Request struct {
	ctx context.Context
	ApiService *AssetAPIService
}

func (r ApiWalletGetSpotOpenSymbolListV1Request) Execute() ([]WalletGetSpotOpenSymbolListV1RespItem, *http.Response, error) {
	return r.ApiService.WalletGetSpotOpenSymbolListV1Execute(r)
}

/*
WalletGetSpotOpenSymbolListV1 Get Open Symbol List (MARKET_DATA)

Get the list of symbols that are scheduled to be opened for trading in the market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletGetSpotOpenSymbolListV1Request
*/
func (a *AssetAPIService) WalletGetSpotOpenSymbolListV1(ctx context.Context) ApiWalletGetSpotOpenSymbolListV1Request {
	return ApiWalletGetSpotOpenSymbolListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []WalletGetSpotOpenSymbolListV1RespItem
func (a *AssetAPIService) WalletGetSpotOpenSymbolListV1Execute(r ApiWalletGetSpotOpenSymbolListV1Request) ([]WalletGetSpotOpenSymbolListV1RespItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WalletGetSpotOpenSymbolListV1RespItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAPIService.WalletGetSpotOpenSymbolListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/spot/open-symbol-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

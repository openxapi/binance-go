# Go WebSocket API client for Binance

[![Go Reference](https://pkg.go.dev/badge/github.com/openxapi/binance-go/ws.svg)](https://pkg.go.dev/github.com/openxapi/binance-go/ws)

AsyncAPI specification for Binance cryptocurrency exchange WebSocket API.

## Overview

This WebSocket API client was automatically generated by [OpenXAPI](https://github.com/openxapi/openxapi).

**Please do not edit the generated code manually.**

If you need to update the API client, please submit an issue or a PR to [OpenXAPI](https://github.com/openxapi/openxapi) to update the [AsyncAPI specification](https://github.com/openxapi/openxapi/tree/main/specs/binance/asyncapi) or the [Go client templates](https://github.com/openxapi/openxapi/tree/main/templates/binance/asyncapi/go), and regenerate the API client.

## Supported Products

| Category | Product | Package | Description |
|:---------:|:---------:|---------|-------------|
| WebSocket API | Spot | `github.com/openxapi/binance-go/ws/spot` | ✅ [Spot WebSocket API](https://developers.binance.com/docs/binance-spot-api-docs/websocket-api) |
| WebSocket Market Streams | Spot | `github.com/openxapi/binance-go/ws/spot-streams` | ✅ [Spot WebSocket Streams](https://developers.binance.com/docs/binance-spot-api-docs/websocket-streams) |
| WebSocket API | USDS-M Futures | `github.com/openxapi/binance-go/ws/umfutures` | ✅ [USDS-M Futures WebSocket API](https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-api) |
| WebSocket Market Streams | USDS-M Futures | `github.com/openxapi/binance-go/ws/umfutures-streams` | ✅ [USDS-M Futures WebSocket Streams](https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-streams) |
| WebSocket API | COIN-M Futures | `github.com/openxapi/binance-go/ws/cmfutures` | ✅ [COIN-M Futures WebSocket API](https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-api) |
| WebSocket Market Streams | COIN-M Futures | `github.com/openxapi/binance-go/ws/cmfutures-streams` | ✅ [COIN-M Futures WebSocket Streams](https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-streams) |
| WebSocket API | Options | `github.com/openxapi/binance-go/ws/options` | ✅ [Options WebSocket API](https://developers.binance.com/docs/derivatives/option/websocket-api) |
| WebSocket Market Streams | Options | `github.com/openxapi/binance-go/ws/options-streams` | ✅ [Options WebSocket Streams](https://developers.binance.com/docs/derivatives/option/websocket-streams) |
| WebSocket API | Portfolio Margin | `github.com/openxapi/binance-go/ws/pmargin` | ✅ [Portfolio Margin WebSocket API](https://developers.binance.com/docs/derivatives/portfolio-margin/websocket-api) |

Feel free to contribute to this project by adding support for other products.

With [OpenXAPI](https://github.com/openxapi/openxapi), you can add support for other products and generate API clients in different languages in a breeze.

## WebSocket API vs WebSocket Market Streams

- **WebSocket API**: Provides request-response functionality similar to REST API but over WebSocket connections. Supports account operations, order management, market data queries, and user data streams.
- **WebSocket Market Streams**: Provides real-time market data streams only. Optimized for high-frequency market data updates.

## Import

```go
import (
    spotws "github.com/openxapi/binance-go/ws/spot"
    spotstreams "github.com/openxapi/binance-go/ws/spot-streams"
    umfutures "github.com/openxapi/binance-go/ws/umfutures"
    umfuturesstreams "github.com/openxapi/binance-go/ws/umfutures-streams"
    cmfutures "github.com/openxapi/binance-go/ws/cmfutures"
    cmfuturesstreams "github.com/openxapi/binance-go/ws/cmfutures-streams"
    options "github.com/openxapi/binance-go/ws/options"
    optionsstreams "github.com/openxapi/binance-go/ws/options-streams"
    pmargin "github.com/openxapi/binance-go/ws/pmargin"
)
```

## Usage

### WebSocket API Example (Spot)

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "time"

    spotws "github.com/openxapi/binance-go/ws/spot"
    "github.com/openxapi/binance-go/ws/spot/models"
)

func main() {
    // Create client
    client := spotws.NewClient()
    
    // Set to testnet for testing (optional)
    err := client.SetActiveServer("testnet1")
    if err != nil {
        log.Fatal(err)
    }
    
    // Authentication for account operations
    apiKey := os.Getenv("BINANCE_API_KEY")
    secretKey := os.Getenv("BINANCE_SECRET_KEY")
    
    if apiKey != "" && secretKey != "" {
        auth := &spotws.Auth{
            APIKey: apiKey,
        }
        auth.SetSecretKey(secretKey)
        client.SetAuth(auth)
    }

    // Register event handlers for user data streams
    client.HandleExecutionReportEvent(func(event *models.ExecutionReportEvent) error {
        fmt.Printf("Execution Report: %+v\n", event)
        return nil
    })

    client.HandleBalanceUpdateEvent(func(event *models.BalanceUpdateEvent) error {
        fmt.Printf("Balance Update: %+v\n", event)
        return nil
    })

    client.HandleOutboundAccountPositionEvent(func(event *models.OutboundAccountPositionEvent) error {
        fmt.Printf("Account Position: %+v\n", event)
        return nil
    })

    client.HandleListStatusEvent(func(event *models.ListStatusEvent) error {
        fmt.Printf("List Status: %+v\n", event)
        return nil
    })

    // Connect to WebSocket
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    err = client.Connect(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect()

    // Get server time (public endpoint)
    timeResp, err := client.SendTime(ctx, 
        models.NewTimeRequest(),
        func(response *models.TimeResponse, err error) error {
            if err != nil {
                log.Printf("Time request failed: %v", err)
                return err
            }
            fmt.Printf("Server time: %d\n", response.Result.ServerTime)
            return nil
        })
    if err != nil {
        log.Fatal(err)
    }

    // Get account information (requires authentication)
    if apiKey != "" && secretKey != "" {
        accountResp, err := client.SendAccount(ctx,
            models.NewAccountStatusRequest(),
            func(response *models.AccountStatusResponse, err error) error {
                if err != nil {
                    log.Printf("Account request failed: %v", err)
                    return err
                }
                fmt.Printf("Account: %+v\n", response.Result)
                return nil
            })
        if err != nil {
            log.Fatal(err)
        }
    }

    // Keep connection alive for user data events
    time.Sleep(30 * time.Second)
}
```

### WebSocket Market Streams Example (Spot)

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"

    spotstreams "github.com/openxapi/binance-go/ws/spot-streams"
    "github.com/openxapi/binance-go/ws/spot-streams/models"
)

func main() {
    // Create client
    client := spotstreams.NewClient()
    
    // Set to testnet for testing (optional)
    err := client.SetActiveServer("testnet1")
    if err != nil {
        log.Fatal(err)
    }

    // Register event handlers
    client.OnTradeEvent(func(event *models.TradeEvent) error {
        fmt.Printf("Trade: %s Price: %s Quantity: %s\n", 
            event.Symbol, event.Price, event.Quantity)
        return nil
    })

    client.OnAggregateTradeEvent(func(event *models.AggregateTradeEvent) error {
        fmt.Printf("Agg Trade: %s Price: %s Quantity: %s\n", 
            event.Symbol, event.Price, event.Quantity)
        return nil
    })

    client.OnKlineEvent(func(event *models.KlineEvent) error {
        fmt.Printf("Kline: %s Open: %s High: %s Low: %s Close: %s\n", 
            event.Symbol, event.Kline.OpenPrice, event.Kline.HighPrice, 
            event.Kline.LowPrice, event.Kline.ClosePrice)
        return nil
    })

    client.OnTickerEvent(func(event *models.TickerEvent) error {
        fmt.Printf("Ticker: %s Price: %s Change: %s%%\n", 
            event.Symbol, event.CurrentClosePrice, event.PriceChangePercent)
        return nil
    })

    client.OnBookTickerEvent(func(event *models.BookTickerEvent) error {
        fmt.Printf("Book Ticker: %s Bid: %s Ask: %s\n", 
            event.Symbol, event.BidPrice, event.AskPrice)
        return nil
    })

    client.OnMiniTickerEvent(func(event *models.MiniTickerEvent) error {
        fmt.Printf("Mini Ticker: %s Price: %s\n", 
            event.Symbol, event.ClosePrice)
        return nil
    })

    client.OnStreamError(func(event *models.ErrorResponse) error {
        log.Printf("Stream error: %+v", event)
        return nil
    })

    // Connect to WebSocket
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    err = client.Connect(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect()

    // Subscribe to streams
    streams := []string{
        "btcusdt@trade",
        "btcusdt@aggTrade",
        "btcusdt@kline_1m",
        "btcusdt@ticker",
        "btcusdt@bookTicker",
        "btcusdt@miniTicker",
    }

    err = client.Subscribe(ctx, streams)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Subscribed to streams: %v\n", streams)

    // Keep the connection alive to receive events
    time.Sleep(30 * time.Second)

    // Unsubscribe from streams
    err = client.Unsubscribe(ctx, streams)
    if err != nil {
        log.Printf("Failed to unsubscribe: %v", err)
    } else {
        fmt.Printf("Unsubscribed from streams: %v\n", streams)
    }
}
```

### USDS-M Futures WebSocket API Example

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "time"

    umfutures "github.com/openxapi/binance-go/ws/umfutures"
    "github.com/openxapi/binance-go/ws/umfutures/models"
)

func main() {
    // Create client
    client := umfutures.NewClient()
    
    // Set to testnet for testing (optional)
    err := client.SetActiveServer("testnet1")
    if err != nil {
        log.Fatal(err)
    }

    // Authentication
    apiKey := os.Getenv("BINANCE_API_KEY")
    secretKey := os.Getenv("BINANCE_SECRET_KEY")
    
    if apiKey != "" && secretKey != "" {
        auth := &umfutures.Auth{
            APIKey: apiKey,
        }
        auth.SetSecretKey(secretKey)
        client.SetAuth(auth)
    }

    // Register event handlers for user data streams
    client.HandleAccountUpdateEvent(func(event *models.AccountUpdateEvent) error {
        fmt.Printf("Account Update: %+v\n", event)
        return nil
    })

    client.HandleOrderTradeUpdateEvent(func(event *models.OrderTradeUpdateEvent) error {
        fmt.Printf("Order Update: %+v\n", event)
        return nil
    })

    client.HandleMarginCallEvent(func(event *models.MarginCallEvent) error {
        fmt.Printf("Margin Call: %+v\n", event)
        return nil
    })

    client.HandleAccountConfigUpdateEvent(func(event *models.AccountConfigUpdateEvent) error {
        fmt.Printf("Account Config Update: %+v\n", event)
        return nil
    })

    // Connect to WebSocket
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    err = client.Connect(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect()

    // Get account balance (requires authentication)
    if apiKey != "" && secretKey != "" {
        err = client.SendAccountBalance(ctx,
            models.NewAccountBalanceRequest(),
            func(response *models.AccountBalanceResponse, err error) error {
                if err != nil {
                    log.Printf("Account balance request failed: %v", err)
                    return err
                }
                fmt.Printf("Account balance: %+v\n", response.Result)
                return nil
            })
        if err != nil {
            log.Fatal(err)
        }
    }

    // Get ticker price (public endpoint)
    err = client.SendTickerPrice(ctx,
        models.NewTickerPriceRequest().SetSymbol("BTCUSDT"),
        func(response *models.TickerPriceResponse, err error) error {
            if err != nil {
                log.Printf("Ticker price request failed: %v", err)
                return err
            }
            fmt.Printf("BTCUSDT price: %s\n", response.Result.Price)
            return nil
        })
    if err != nil {
        log.Fatal(err)
    }

    // Keep connection alive for user data events
    time.Sleep(30 * time.Second)
}
```

### USDS-M Futures Market Streams Example

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"

    umfuturesstreams "github.com/openxapi/binance-go/ws/umfutures-streams"
    "github.com/openxapi/binance-go/ws/umfutures-streams/models"
)

func main() {
    // Create client
    client := umfuturesstreams.NewClient()
    
    // Set to testnet for testing (optional)
    err := client.SetActiveServer("testnet1")
    if err != nil {
        log.Fatal(err)
    }

    // Register event handlers
    client.OnAggregateTradeEvent(func(event *models.AggregateTradeEvent) error {
        fmt.Printf("Futures Agg Trade: %s Price: %s Quantity: %s\n", 
            event.Symbol, event.Price, event.Quantity)
        return nil
    })

    client.OnKlineEvent(func(event *models.KlineEvent) error {
        fmt.Printf("Futures Kline: %s Open: %s Close: %s Volume: %s\n", 
            event.Symbol, event.Kline.OpenPrice, event.Kline.ClosePrice, event.Kline.Volume)
        return nil
    })

    client.OnMarkPriceEvent(func(event *models.MarkPriceEvent) error {
        fmt.Printf("Mark Price: %s Price: %s FundingRate: %s\n", 
            event.Symbol, event.MarkPrice, event.FundingRate)
        return nil
    })

    client.OnLiquidationEvent(func(event *models.LiquidationEvent) error {
        fmt.Printf("Liquidation: %s Side: %s Price: %s Quantity: %s\n", 
            event.Symbol, event.Side, event.Price, event.Quantity)
        return nil
    })

    client.OnTickerEvent(func(event *models.TickerEvent) error {
        fmt.Printf("Ticker: %s Price: %s Change: %s%%\n", 
            event.Symbol, event.LastPrice, event.PriceChangePercent)
        return nil
    })

    client.OnBookTickerEvent(func(event *models.BookTickerEvent) error {
        fmt.Printf("Book Ticker: %s Bid: %s Ask: %s\n", 
            event.Symbol, event.BidPrice, event.AskPrice)
        return nil
    })

    client.OnStreamError(func(event *models.ErrorResponse) error {
        log.Printf("Stream error: %+v", event)
        return nil
    })

    // Connect to WebSocket
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    err = client.Connect(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect()

    // Subscribe to futures streams
    streams := []string{
        "btcusdt@aggTrade",
        "btcusdt@kline_1m",
        "btcusdt@markPrice",
        "btcusdt@ticker",
        "btcusdt@bookTicker",
        "!forceOrder@arr",    // All liquidation orders
    }

    err = client.Subscribe(ctx, streams)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Subscribed to futures streams: %v\n", streams)

    // Keep the connection alive to receive events
    time.Sleep(30 * time.Second)

    // Unsubscribe from streams
    err = client.Unsubscribe(ctx, streams)
    if err != nil {
        log.Printf("Failed to unsubscribe: %v", err)
    } else {
        fmt.Printf("Unsubscribed from streams: %v\n", streams)
    }
}
```

### Options WebSocket API Example

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "time"

    options "github.com/openxapi/binance-go/ws/options"
    "github.com/openxapi/binance-go/ws/options/models"
)

func main() {
    // Create client with authentication
    apiKey := os.Getenv("BINANCE_API_KEY")
    secretKey := os.Getenv("BINANCE_SECRET_KEY")
    
    var client *options.Client
    if apiKey != "" && secretKey != "" {
        auth := options.NewAuth(apiKey)
        auth.SetSecretKey(secretKey)
        client = options.NewClientWithAuth(auth)
    } else {
        client = options.NewClient()
    }

    // Register event handlers for user data
    client.OnAccountUpdate(func(event *models.AccountUpdate) error {
        fmt.Printf("Options Account Update: %+v\n", event)
        return nil
    })

    client.OnOrderTradeUpdate(func(event *models.OrderTradeUpdate) error {
        fmt.Printf("Options Order Update: %+v\n", event)
        return nil
    })

    client.OnRiskLevelChange(func(event *models.RiskLevelChange) error {
        fmt.Printf("Options Risk Level Change: %+v\n", event)
        return nil
    })

    // Note: Options WebSocket requires a listen key from REST API
    // This example shows the connection pattern
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    // Connection requires a valid listen key
    // err := client.ConnectWithListenKey(ctx, "your_listen_key_here")
    // For demonstration, we'll show connection attempt
    err := client.Connect(ctx)
    if err != nil {
        log.Printf("Connection failed (expected without listen key): %v", err)
    }
    defer client.Disconnect()

    fmt.Println("Options WebSocket client configured successfully")
    fmt.Println("To connect, provide a valid listen key from the REST API")
}
```

### Portfolio Margin WebSocket API Example

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "time"

    pmargin "github.com/openxapi/binance-go/ws/pmargin"
    "github.com/openxapi/binance-go/ws/pmargin/models"
)

func main() {
    // Create client with authentication
    apiKey := os.Getenv("BINANCE_API_KEY")
    secretKey := os.Getenv("BINANCE_SECRET_KEY")
    
    var client *pmargin.Client
    if apiKey != "" && secretKey != "" {
        auth := pmargin.NewAuth(apiKey)
        auth.SetSecretKey(secretKey)
        client = pmargin.NewClientWithAuth(auth)
    } else {
        client = pmargin.NewClient()
    }

    // Register event handlers for portfolio margin events
    client.OnMarginAccountUpdate(func(event *models.MarginAccountUpdate) error {
        fmt.Printf("Margin Account Update: %+v\n", event)
        return nil
    })

    client.OnFuturesOrderUpdate(func(event *models.FuturesOrderUpdate) error {
        fmt.Printf("Futures Order Update: %+v\n", event)
        return nil
    })

    client.OnFuturesBalancePositionUpdate(func(event *models.FuturesBalancePositionUpdate) error {
        fmt.Printf("Futures Balance/Position Update: %+v\n", event)
        return nil
    })

    client.OnMarginOrderUpdate(func(event *models.MarginOrderUpdate) error {
        fmt.Printf("Margin Order Update: %+v\n", event)
        return nil
    })

    client.OnRiskLevelChange(func(event *models.RiskLevelChange) error {
        fmt.Printf("Risk Level Change: %+v\n", event)
        return nil
    })

    client.OnLiabilityUpdate(func(event *models.LiabilityUpdate) error {
        fmt.Printf("Liability Update: %+v\n", event)
        return nil
    })

    client.OnUserDataStreamExpired(func(event *models.UserDataStreamExpired) error {
        fmt.Printf("User Data Stream Expired: %+v\n", event)
        return nil
    })

    // Note: Portfolio Margin WebSocket requires a listen key from REST API
    // This example shows the connection pattern
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    // Connection requires a valid listen key
    // err := client.ConnectWithListenKey(ctx, "your_listen_key_here")
    // For demonstration, we'll show connection attempt
    err := client.Connect(ctx)
    if err != nil {
        log.Printf("Connection failed (expected without listen key): %v", err)
    }
    defer client.Disconnect()

    fmt.Println("Portfolio Margin WebSocket client configured successfully")
    fmt.Println("To connect, provide a valid listen key from the REST API")
}
```

## Authentication

### HMAC Authentication

The WebSocket API clients support HMAC-SHA256 authentication for account operations.

```go
auth := &spotws.Auth{
    APIKey: apiKey,
}
auth.SetSecretKey(secretKey)
client.SetAuth(auth)
```

### RSA Authentication

For RSA authentication, you can set the private key path:

```go
auth := &spotws.Auth{
    APIKey: apiKey,
    PrivateKeyPath: "/path/to/private_key.pem",
}
client.SetAuth(auth)
```

### Ed25519 Authentication

For Ed25519 authentication:

```go
auth := &spotws.Auth{
    APIKey: apiKey,
    PrivateKeyPath: "/path/to/ed25519_private_key.pem",
}
client.SetAuth(auth)
```

## Event Handling

All WebSocket clients provide event handling mechanisms for real-time data:

```go
// Handle execution reports for order updates
client.HandleExecutionReport(func(event *models.ExecutionReport) error {
    fmt.Printf("Order Update: %+v\n", event)
    return nil
})

// Handle balance updates
client.HandleBalanceUpdate(func(event *models.BalanceUpdate) error {
    fmt.Printf("Balance Update: %+v\n", event)
    return nil
})

// Handle account position updates
client.HandleOutboundAccountPosition(func(event *models.OutboundAccountPosition) error {
    fmt.Printf("Position Update: %+v\n", event)
    return nil
})
```

## Error Handling

Handle connection errors and API errors:

```go
// Handle connection errors
client.HandleError(func(err error) {
    log.Printf("WebSocket error: %v", err)
})

// Handle API errors in streams
client.HandleErrorResponse(func(event *models.ErrorResponse) error {
    log.Printf("API error: %+v", event)
    return nil
})
```

## Configuration

### Connection Timeouts

```go
// Set connection timeout
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

err := client.Connect(ctx)
```

### Server Selection

```go
// Use production server (default)
client.SetActiveServer("production")

// Use testnet server for testing
client.SetActiveServer("testnet1")
```

### Proxy Support

To use a proxy, set the environment variable `HTTP_PROXY`:

```go
os.Setenv("HTTP_PROXY", "http://proxy_name:proxy_port")
```

## Rate Limits

Please refer to the official Binance API documentation for rate limits:

- [Spot WebSocket API Rate Limits](https://developers.binance.com/docs/binance-spot-api-docs/websocket-api#rate-limits)
- [USDS-M Futures WebSocket API Rate Limits](https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-api#rate-limits)
- [COIN-M Futures WebSocket API Rate Limits](https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-api#rate-limits)

## WebSocket Endpoints

### Production

- **Spot WebSocket API**: `wss://ws-api.binance.com/ws-api/v3`
- **Spot WebSocket Streams**: `wss://stream.binance.com/ws`
- **USDS-M Futures WebSocket API**: `wss://fstream.binance.com/ws-fapi/v1`
- **USDS-M Futures WebSocket Streams**: `wss://fstream.binance.com/ws`
- **COIN-M Futures WebSocket API**: `wss://dstream.binance.com/ws-dapi/v1`

### Testnet

- **Spot WebSocket API**: `wss://ws-api.testnet.binance.vision/ws-api/v3`
- **Spot WebSocket Streams**: `wss://stream.testnet.binance.vision/ws`
- **USDS-M Futures WebSocket API**: `wss://fstream.binance.com/ws-fapi/v1`
- **USDS-M Futures WebSocket Streams**: `wss://fstream.binance.com/ws`

## Stream Types

### Spot Streams

- **Trade Streams**: `<symbol>@trade`
- **Aggregate Trade Streams**: `<symbol>@aggTrade`
- **Kline Streams**: `<symbol>@kline_<interval>`
- **Mini Ticker Streams**: `<symbol>@miniTicker`
- **Ticker Streams**: `<symbol>@ticker`
- **Book Ticker Streams**: `<symbol>@bookTicker`
- **Depth Streams**: `<symbol>@depth`
- **Partial Depth Streams**: `<symbol>@depth5`, `<symbol>@depth10`, `<symbol>@depth20`

### Futures Streams

- **Aggregate Trade Streams**: `<symbol>@aggTrade`
- **Kline Streams**: `<symbol>@kline_<interval>`
- **Mark Price Streams**: `<symbol>@markPrice`
- **Liquidation Order Streams**: `!forceOrder@arr`
- **Book Ticker Streams**: `<symbol>@bookTicker`
- **Composite Index Streams**: `<symbol>@compositeIndex`

## Testing

Each WebSocket client includes comprehensive integration tests. You can run them with:

```bash
# Set environment variables for authentication
export BINANCE_API_KEY="your_api_key"
export BINANCE_SECRET_KEY="your_secret_key"

# Run tests for spot WebSocket API
cd ws/spot
go test -v

# Run tests for spot streams
cd ws/spot-streams
go test -v

# Run tests for USDS-M futures WebSocket API
cd ws/umfutures
go test -v

# Run tests for USDS-M futures streams
cd ws/umfutures-streams
go test -v

# Run tests for options WebSocket API
cd ws/options
go test -v

# Run tests for options streams
cd ws/options-streams
go test -v

# Run tests for portfolio margin WebSocket API
cd ws/pmargin
go test -v
```

## Contributing

Feel free to contribute to this project by:

1. Reporting bugs or issues
2. Suggesting new features
3. Submitting pull requests to improve the codebase
4. Adding support for additional Binance products

## License

This project is licensed under the same terms as the parent repository.

## Support

For support and questions:

1. Check the [official Binance API documentation](https://developers.binance.com/)
2. Review the [OpenXAPI project](https://github.com/openxapi/openxapi)
3. Open an issue in this repository

## Disclaimer

This is an unofficial client library. Use at your own risk. Always refer to the official Binance API documentation for the most up-to-date information.

## Integration Tests

The integration tests demonstrate real-world usage patterns and can be found in the `integration-tests` directory. These tests cover:

- Connection management
- Authentication with different key types (HMAC, RSA, Ed25519)
- Event handling
- Stream subscriptions
- Error handling
- Rate limiting

Run the integration tests to see comprehensive examples of how to use the WebSocket clients effectively.
# Go WebSocket API client for Binance

[![Go Reference](https://pkg.go.dev/badge/github.com/openxapi/binance-go/ws.svg)](https://pkg.go.dev/github.com/openxapi/binance-go/ws)

AsyncAPI specification for Binance cryptocurrency exchange WebSocket API.

## Overview

This WebSocket API client was automatically generated by [OpenXAPI](https://github.com/openxapi/openxapi).

**Please do not edit the generated code manually.**

If you need to update the API client, please submit an issue or a PR to [OpenXAPI](https://github.com/openxapi/openxapi) to update the [AsyncAPI specification](https://github.com/openxapi/openxapi/tree/main/specs/binance/asyncapi) or the [Go client templates](https://github.com/openxapi/openxapi/tree/main/templates/binance/asyncapi/go), and regenerate the API client.

## Supported Products

| Category | Product | Package | Description |
|:---------:|:---------:|---------|-------------|
| WebSocket API | Spot | `github.com/openxapi/binance-go/ws/spot` | ✅ [Spot WebSocket API](https://developers.binance.com/docs/binance-spot-api-docs/websocket-api) |
| WebSocket Streams | Spot Streams | `github.com/openxapi/binance-go/ws/spot-streams` | ✅ [Spot WebSocket Streams](https://developers.binance.com/docs/binance-spot-api-docs/websocket-streams) |
| WebSocket API | USDS-M Futures | `github.com/openxapi/binance-go/ws/umfutures` | ✅ [USDS-M Futures WebSocket API](https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-api) |
| WebSocket Streams | USDS-M Futures Streams | `github.com/openxapi/binance-go/ws/umfutures-streams` | ✅ [USDS-M Futures WebSocket Streams](https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-streams) |
| WebSocket API | COIN-M Futures | `github.com/openxapi/binance-go/ws/cmfutures` | ✅ [COIN-M Futures WebSocket API](https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-api) |

Feel free to contribute to this project by adding support for other products.

With [OpenXAPI](https://github.com/openxapi/openxapi), you can add support for other products and generate API clients in different languages in a breeze.

## WebSocket API vs WebSocket Streams

- **WebSocket API**: Provides request-response functionality similar to REST API but over WebSocket connections. Supports account operations, order management, and market data queries.
- **WebSocket Streams**: Provides real-time market data streams and user data streams. Optimized for high-frequency data updates.

## Import

```go
import (
    spotws "github.com/openxapi/binance-go/ws/spot"
    spotstreams "github.com/openxapi/binance-go/ws/spot-streams"
    umfutures "github.com/openxapi/binance-go/ws/umfutures"
    umfuturesstreams "github.com/openxapi/binance-go/ws/umfutures-streams"
    cmfutures "github.com/openxapi/binance-go/ws/cmfutures"
)
```

## Usage

### WebSocket API Example (Spot)

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "time"

    spotws "github.com/openxapi/binance-go/ws/spot"
    "github.com/openxapi/binance-go/ws/spot/models"
)

func main() {
    // Create client
    client := spotws.NewClient()
    
    // Set to testnet for testing (optional)
    err := client.SetActiveServer("testnet1")
    if err != nil {
        log.Fatal(err)
    }
    
    // Authentication for account operations
    apiKey := os.Getenv("BINANCE_API_KEY")
    secretKey := os.Getenv("BINANCE_SECRET_KEY")
    
    if apiKey != "" && secretKey != "" {
        auth := &spotws.Auth{
            APIKey: apiKey,
        }
        auth.SetSecretKey(secretKey)
        client.SetAuth(auth)
    }

    // Register event handlers
    client.HandleExecutionReport(func(event *models.ExecutionReport) error {
        fmt.Printf("Execution Report: %+v\n", event)
        return nil
    })

    client.HandleBalanceUpdate(func(event *models.BalanceUpdate) error {
        fmt.Printf("Balance Update: %+v\n", event)
        return nil
    })

    // Connect to WebSocket
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    err = client.Connect(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect()

    // Get server time
    timeResp, err := client.Time(ctx)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Server time: %d\n", timeResp.ServerTime)

    // Get account information (requires authentication)
    if apiKey != "" && secretKey != "" {
        accountResp, err := client.Account(ctx)
        if err != nil {
            log.Fatal(err)
        }
        fmt.Printf("Account: %+v\n", accountResp)
    }
}
```

### WebSocket Streams Example (Spot)

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"

    spotstreams "github.com/openxapi/binance-go/ws/spot-streams"
    "github.com/openxapi/binance-go/ws/spot-streams/models"
)

func main() {
    // Create client
    client := spotstreams.NewClient()
    
    // Set to testnet for testing (optional)
    err := client.SetActiveServer("testnet1")
    if err != nil {
        log.Fatal(err)
    }

    // Register event handlers
    client.HandleTradeEvent(func(event *models.TradeEvent) error {
        fmt.Printf("Trade: %s Price: %s Quantity: %s\n", 
            event.Symbol, event.Price, event.Quantity)
        return nil
    })

    client.HandleAggregateTradeEvent(func(event *models.AggregateTradeEvent) error {
        fmt.Printf("Agg Trade: %s Price: %s Quantity: %s\n", 
            event.Symbol, event.Price, event.Quantity)
        return nil
    })

    client.HandleKlineEvent(func(event *models.KlineEvent) error {
        fmt.Printf("Kline: %s Open: %s High: %s Low: %s Close: %s\n", 
            event.Symbol, event.Kline.OpenPrice, event.Kline.HighPrice, 
            event.Kline.LowPrice, event.Kline.ClosePrice)
        return nil
    })

    client.HandleTickerEvent(func(event *models.TickerEvent) error {
        fmt.Printf("Ticker: %s Price: %s Change: %s%%\n", 
            event.Symbol, event.CurrentClosePrice, event.PriceChangePercent)
        return nil
    })

    client.HandleBookTickerEvent(func(event *models.BookTickerEvent) error {
        fmt.Printf("Book Ticker: %s Bid: %s Ask: %s\n", 
            event.Symbol, event.BidPrice, event.AskPrice)
        return nil
    })

    // Connect to WebSocket
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    err = client.Connect(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect()

    // Subscribe to streams
    streams := []string{
        "btcusdt@trade",
        "btcusdt@aggTrade",
        "btcusdt@kline_1m",
        "btcusdt@ticker",
        "btcusdt@bookTicker",
    }

    subscribeResp, err := client.Subscribe(ctx, streams)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Subscribed to streams: %+v\n", subscribeResp)

    // Keep the connection alive
    time.Sleep(30 * time.Second)

    // Unsubscribe from streams
    unsubscribeResp, err := client.Unsubscribe(ctx, streams)
    if err != nil {
        log.Printf("Failed to unsubscribe: %v", err)
    } else {
        fmt.Printf("Unsubscribed from streams: %+v\n", unsubscribeResp)
    }
}
```

### USDS-M Futures WebSocket API Example

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "time"

    umfutures "github.com/openxapi/binance-go/ws/umfutures"
    "github.com/openxapi/binance-go/ws/umfutures/models"
)

func main() {
    // Create client
    client := umfutures.NewClient()
    
    // Set to testnet for testing (optional)
    err := client.SetActiveServer("testnet1")
    if err != nil {
        log.Fatal(err)
    }

    // Authentication
    apiKey := os.Getenv("BINANCE_API_KEY")
    secretKey := os.Getenv("BINANCE_SECRET_KEY")
    
    if apiKey != "" && secretKey != "" {
        auth := &umfutures.Auth{
            APIKey: apiKey,
        }
        auth.SetSecretKey(secretKey)
        client.SetAuth(auth)
    }

    // Connect to WebSocket
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    err = client.Connect(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect()

    // Get account balance
    if apiKey != "" && secretKey != "" {
        balanceResp, err := client.AccountBalance(ctx)
        if err != nil {
            log.Fatal(err)
        }
        fmt.Printf("Account balance: %+v\n", balanceResp)
    }
}
```

### USDS-M Futures Streams Example

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"

    umfuturesstreams "github.com/openxapi/binance-go/ws/umfutures-streams"
    "github.com/openxapi/binance-go/ws/umfutures-streams/models"
)

func main() {
    // Create client
    client := umfuturesstreams.NewClient()
    
    // Set to testnet for testing (optional)
    err := client.SetActiveServer("testnet1")
    if err != nil {
        log.Fatal(err)
    }

    // Register event handlers
    client.HandleAggregateTradeEvent(func(event *models.AggregateTradeEvent) error {
        fmt.Printf("Futures Agg Trade: %s Price: %s Quantity: %s\n", 
            event.Symbol, event.Price, event.Quantity)
        return nil
    })

    client.HandleKlineEvent(func(event *models.KlineEvent) error {
        fmt.Printf("Futures Kline: %s Open: %s Close: %s Volume: %s\n", 
            event.Symbol, event.Kline.OpenPrice, event.Kline.ClosePrice, event.Kline.Volume)
        return nil
    })

    client.HandleMarkPriceEvent(func(event *models.MarkPriceEvent) error {
        fmt.Printf("Mark Price: %s Price: %s FundingRate: %s\n", 
            event.Symbol, event.MarkPrice, event.FundingRate)
        return nil
    })

    client.HandleLiquidationEvent(func(event *models.LiquidationEvent) error {
        fmt.Printf("Liquidation: %s Side: %s Price: %s Quantity: %s\n", 
            event.Symbol, event.Side, event.Price, event.Quantity)
        return nil
    })

    // Connect to WebSocket
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    err = client.Connect(ctx)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect()

    // Subscribe to futures streams
    streams := []string{
        "btcusdt@aggTrade",
        "btcusdt@kline_1m",
        "btcusdt@markPrice",
        "!forceOrder@arr",    // All liquidation orders
    }

    subscribeResp, err := client.Subscribe(ctx, streams)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Subscribed to futures streams: %+v\n", subscribeResp)

    // Keep the connection alive
    time.Sleep(30 * time.Second)
}
```

## Authentication

### HMAC Authentication

The WebSocket API clients support HMAC-SHA256 authentication for account operations.

```go
auth := &spotws.Auth{
    APIKey: apiKey,
}
auth.SetSecretKey(secretKey)
client.SetAuth(auth)
```

### RSA Authentication

For RSA authentication, you can set the private key path:

```go
auth := &spotws.Auth{
    APIKey: apiKey,
    PrivateKeyPath: "/path/to/private_key.pem",
}
client.SetAuth(auth)
```

### Ed25519 Authentication

For Ed25519 authentication:

```go
auth := &spotws.Auth{
    APIKey: apiKey,
    PrivateKeyPath: "/path/to/ed25519_private_key.pem",
}
client.SetAuth(auth)
```

## Event Handling

All WebSocket clients provide event handling mechanisms for real-time data:

```go
// Handle execution reports for order updates
client.HandleExecutionReport(func(event *models.ExecutionReport) error {
    fmt.Printf("Order Update: %+v\n", event)
    return nil
})

// Handle balance updates
client.HandleBalanceUpdate(func(event *models.BalanceUpdate) error {
    fmt.Printf("Balance Update: %+v\n", event)
    return nil
})

// Handle account position updates
client.HandleOutboundAccountPosition(func(event *models.OutboundAccountPosition) error {
    fmt.Printf("Position Update: %+v\n", event)
    return nil
})
```

## Error Handling

Handle connection errors and API errors:

```go
// Handle connection errors
client.HandleError(func(err error) {
    log.Printf("WebSocket error: %v", err)
})

// Handle API errors in streams
client.HandleErrorResponse(func(event *models.ErrorResponse) error {
    log.Printf("API error: %+v", event)
    return nil
})
```

## Configuration

### Connection Timeouts

```go
// Set connection timeout
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

err := client.Connect(ctx)
```

### Server Selection

```go
// Use production server (default)
client.SetActiveServer("production")

// Use testnet server for testing
client.SetActiveServer("testnet1")
```

### Proxy Support

To use a proxy, set the environment variable `HTTP_PROXY`:

```go
os.Setenv("HTTP_PROXY", "http://proxy_name:proxy_port")
```

## Rate Limits

Please refer to the official Binance API documentation for rate limits:

- [Spot WebSocket API Rate Limits](https://developers.binance.com/docs/binance-spot-api-docs/websocket-api#rate-limits)
- [USDS-M Futures WebSocket API Rate Limits](https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-api#rate-limits)
- [COIN-M Futures WebSocket API Rate Limits](https://developers.binance.com/docs/derivatives/coin-margined-futures/websocket-api#rate-limits)

## WebSocket Endpoints

### Production

- **Spot WebSocket API**: `wss://ws-api.binance.com/ws-api/v3`
- **Spot WebSocket Streams**: `wss://stream.binance.com/ws`
- **USDS-M Futures WebSocket API**: `wss://fstream.binance.com/ws-fapi/v1`
- **USDS-M Futures WebSocket Streams**: `wss://fstream.binance.com/ws`
- **COIN-M Futures WebSocket API**: `wss://dstream.binance.com/ws-dapi/v1`

### Testnet

- **Spot WebSocket API**: `wss://ws-api.testnet.binance.vision/ws-api/v3`
- **Spot WebSocket Streams**: `wss://stream.testnet.binance.vision/ws`
- **USDS-M Futures WebSocket API**: `wss://fstream.binance.com/ws-fapi/v1`
- **USDS-M Futures WebSocket Streams**: `wss://fstream.binance.com/ws`

## Stream Types

### Spot Streams

- **Trade Streams**: `<symbol>@trade`
- **Aggregate Trade Streams**: `<symbol>@aggTrade`
- **Kline Streams**: `<symbol>@kline_<interval>`
- **Mini Ticker Streams**: `<symbol>@miniTicker`
- **Ticker Streams**: `<symbol>@ticker`
- **Book Ticker Streams**: `<symbol>@bookTicker`
- **Depth Streams**: `<symbol>@depth`
- **Partial Depth Streams**: `<symbol>@depth5`, `<symbol>@depth10`, `<symbol>@depth20`

### Futures Streams

- **Aggregate Trade Streams**: `<symbol>@aggTrade`
- **Kline Streams**: `<symbol>@kline_<interval>`
- **Mark Price Streams**: `<symbol>@markPrice`
- **Liquidation Order Streams**: `!forceOrder@arr`
- **Book Ticker Streams**: `<symbol>@bookTicker`
- **Composite Index Streams**: `<symbol>@compositeIndex`

## Testing

Each WebSocket client includes comprehensive integration tests. You can run them with:

```bash
# Set environment variables for authentication
export BINANCE_API_KEY="your_api_key"
export BINANCE_SECRET_KEY="your_secret_key"

# Run tests for spot WebSocket API
cd ws/spot
go test -v

# Run tests for spot streams
cd ws/spot-streams
go test -v

# Run tests for USDS-M futures WebSocket API
cd ws/umfutures
go test -v

# Run tests for USDS-M futures streams
cd ws/umfutures-streams
go test -v
```

## Contributing

Feel free to contribute to this project by:

1. Reporting bugs or issues
2. Suggesting new features
3. Submitting pull requests to improve the codebase
4. Adding support for additional Binance products

## License

This project is licensed under the same terms as the parent repository.

## Support

For support and questions:

1. Check the [official Binance API documentation](https://developers.binance.com/)
2. Review the [OpenXAPI project](https://github.com/openxapi/openxapi)
3. Open an issue in this repository

## Disclaimer

This is an unofficial client library. Use at your own risk. Always refer to the official Binance API documentation for the most up-to-date information.

## Integration Tests

The integration tests demonstrate real-world usage patterns and can be found in the `integration-tests` directory. These tests cover:

- Connection management
- Authentication with different key types (HMAC, RSA, Ed25519)
- Event handling
- Stream subscriptions
- Error handling
- Rate limiting

Run the integration tests to see comprehensive examples of how to use the WebSocket clients effectively.